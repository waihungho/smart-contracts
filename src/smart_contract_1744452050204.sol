```solidity
pragma solidity ^0.8.0;

/**
 * @title Decentralized Autonomous Organization for Collaborative Content Creation (DAO4CCC)
 * @author Bard (Generated by a Large Language Model)
 * @dev This contract implements a DAO focused on collaborative content creation.
 * It features advanced concepts like reputation-based voting, dynamic role management,
 * content proposals, revenue sharing, and on-chain moderation, aiming for a novel and
 * engaging decentralized platform for creators and community members.
 *
 * Function Summary:
 * -----------------
 * **Membership & Roles:**
 * 1. joinDAO(): Allows users to become members of the DAO.
 * 2. leaveDAO(): Allows members to leave the DAO.
 * 3. assignRole(address _member, Role _role): Assigns a specific role to a member (Admin-only).
 * 4. removeRole(address _member, Role _role): Removes a specific role from a member (Admin-only).
 * 5. getMemberRole(address _member): Retrieves the role of a member.
 *
 * **Content Proposals & Creation:**
 * 6. submitContentProposal(string memory _title, string memory _description, string memory _contentURI): Members propose content for creation.
 * 7. voteOnProposal(uint256 _proposalId, bool _vote): Members vote on content proposals.
 * 8. finalizeProposal(uint256 _proposalId): Finalizes a proposal if it reaches quorum and positive votes (Admin-only).
 * 9. getContentProposalDetails(uint256 _proposalId): Retrieves details of a specific content proposal.
 * 10. mintContentItem(uint256 _proposalId): Mints a ContentNFT upon successful proposal finalization (Internal, called by finalizeProposal).
 * 11. getContentItemDetails(uint256 _contentItemId): Retrieves details of a specific content item.
 * 12. setContentMetadataURI(uint256 _contentItemId, string memory _metadataURI): Updates the metadata URI of a ContentNFT (Creator role or Admin).
 *
 * **Governance & Reputation:**
 * 13. createGovernanceProposal(string memory _title, string memory _description, bytes memory _data): Members propose governance changes.
 * 14. voteOnGovernanceProposal(uint256 _proposalId, bool _vote): Members vote on governance proposals.
 * 15. finalizeGovernanceProposal(uint256 _proposalId): Finalizes a governance proposal if it reaches quorum and positive votes (Admin-only).
 * 16. getGovernanceProposalDetails(uint256 _proposalId): Retrieves details of a specific governance proposal.
 * 17. awardReputationPoints(address _member, uint256 _points, string memory _reason): Awards reputation points to members (Admin or Moderator role).
 * 18. deductReputationPoints(address _member, uint256 _points, string memory _reason): Deducts reputation points from members (Admin or Moderator role).
 * 19. getMemberReputation(address _member): Retrieves the reputation points of a member.
 *
 * **Treasury & Revenue Sharing (Conceptual - Basic Implementation):**
 * 20. depositFunds(): Allows anyone to deposit funds into the DAO treasury.
 * 21. distributeRevenueShare(uint256 _contentItemId): Distributes revenue share to content creators and voters (Conceptual - triggers manually by Admin).
 *
 * **Utility & Admin Functions:**
 * 22. pauseContract(): Pauses core functionalities of the contract (Admin-only).
 * 23. unpauseContract(): Resumes core functionalities of the contract (Admin-only).
 * 24. setQuorum(uint256 _newQuorum): Sets the quorum percentage for proposals (Admin-only).
 * 25. setVotingDuration(uint256 _newDuration): Sets the voting duration for proposals in blocks (Admin-only).
 */
contract DAO4CCC {
    // Enums
    enum Role {
        Member,
        Creator,
        Moderator,
        Admin
    }

    enum ProposalStatus {
        Pending,
        Active,
        Rejected,
        Accepted,
        Finalized
    }

    // Structs
    struct Member {
        Role role;
        uint256 reputationPoints;
        bool isActive;
    }

    struct ContentProposal {
        uint256 proposalId;
        address proposer;
        string title;
        string description;
        string contentURI;
        ProposalStatus status;
        uint256 voteCountPositive;
        uint256 voteCountNegative;
        uint256 startTime;
        uint256 endTime;
    }

    struct GovernanceProposal {
        uint256 proposalId;
        address proposer;
        string title;
        string description;
        bytes data; // For arbitrary governance actions
        ProposalStatus status;
        uint256 voteCountPositive;
        uint256 voteCountNegative;
        uint256 startTime;
        uint256 endTime;
    }

    struct ContentItem {
        uint256 contentItemId;
        uint256 proposalId;
        address creator;
        string metadataURI;
        uint256 mintTimestamp;
    }

    // State Variables
    address public admin;
    mapping(address => Member) public members;
    mapping(uint256 => ContentProposal) public contentProposals;
    uint256 public contentProposalCounter;
    mapping(uint256 => GovernanceProposal) public governanceProposals;
    uint256 public governanceProposalCounter;
    mapping(uint256 => ContentItem) public contentItems;
    uint256 public contentItemCounter;
    uint256 public quorumPercentage = 50; // Minimum percentage of votes needed to pass a proposal
    uint256 public votingDuration = 7 days; // Default voting duration in blocks (adjust as needed)
    bool public paused = false;
    uint256 public treasuryBalance;

    // Events
    event MemberJoined(address indexed memberAddress);
    event MemberLeft(address indexed memberAddress);
    event RoleAssigned(address indexed memberAddress, Role role);
    event RoleRemoved(address indexed memberAddress, Role role);
    event ContentProposalSubmitted(uint256 proposalId, address proposer, string title);
    event ProposalVoted(uint256 proposalId, address voter, bool vote);
    event ProposalFinalized(uint256 proposalId, ProposalStatus status);
    event ContentItemMinted(uint256 contentItemId, uint256 proposalId, address creator);
    event ContentMetadataURISet(uint256 contentItemId, string metadataURI);
    event GovernanceProposalSubmitted(uint256 proposalId, address proposer, string title);
    event GovernanceProposalVoted(uint256 proposalId, address voter, bool vote);
    event GovernanceProposalFinalized(uint256 proposalId, ProposalStatus status);
    event ReputationPointsAwarded(address indexed memberAddress, uint256 points, string reason);
    event ReputationPointsDeducted(address indexed memberAddress, uint256 points, string reason);
    event ContractPaused();
    event ContractUnpaused();
    event QuorumSet(uint256 newQuorum);
    event VotingDurationSet(uint256 newDuration);
    event FundsDeposited(uint256 amount);
    event RevenueDistributed(uint256 contentItemId, uint256 amount);


    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    modifier onlyRole(Role _role) {
        require(members[msg.sender].role >= _role && members[msg.sender].isActive, "Insufficient role or inactive member");
        _;
    }

    modifier onlyMember() {
        require(members[msg.sender].isActive, "Must be an active DAO member");
        _;
    }

    modifier notPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    modifier proposalExists(uint256 _proposalId) {
        require(_proposalId > 0 && (_proposalId <= contentProposalCounter || _proposalId <= governanceProposalCounter), "Proposal does not exist");
        _;
    }

    modifier contentItemExists(uint256 _contentItemId) {
        require(_contentItemId > 0 && _contentItemId <= contentItemCounter, "Content item does not exist");
        _;
    }


    // Constructor
    constructor() {
        admin = msg.sender;
        _assignInitialRoles(msg.sender); // Admin is initially all roles for setup
    }

    function _assignInitialRoles(address _admin) private {
        members[_admin] = Member({
            role: Role.Admin,
            reputationPoints: 1000, // Initial reputation for admin
            isActive: true
        });
        emit MemberJoined(_admin);
        emit RoleAssigned(_admin, Role.Admin);
    }

    // ------------------------------------------------------------------------
    // Membership & Roles
    // ------------------------------------------------------------------------

    function joinDAO() external notPaused {
        require(!members[msg.sender].isActive, "Already a member");
        members[msg.sender] = Member({
            role: Role.Member,
            reputationPoints: 100, // Initial reputation for new members
            isActive: true
        });
        emit MemberJoined(msg.sender);
    }

    function leaveDAO() external onlyMember notPaused {
        members[msg.sender].isActive = false;
        emit MemberLeft(msg.sender);
    }

    function assignRole(address _member, Role _role) external onlyAdmin notPaused {
        require(members[_member].isActive, "Member must be active");
        members[_member].role = _role;
        emit RoleAssigned(_member, _role);
    }

    function removeRole(address _member, Role _role) external onlyAdmin notPaused {
        require(members[_member].isActive, "Member must be active");
        require(members[_member].role >= _role, "Member does not have this role"); // Ensure role is actually assigned
        if (_role == Role.Admin) {
            require(msg.sender == admin && _member != admin, "Cannot remove Admin role from the current admin"); // Prevent accidental admin removal
        }
        if (_role == Role.Admin) {
             // Find another admin if removing the current admin role
            address nextAdmin = _findNextAdmin();
            require(nextAdmin != address(0), "Cannot remove the last Admin role without another Admin available.");
            admin = nextAdmin; // Transfer admin role to another admin.
        }

        if (_role == Role.Admin) { // If removing admin, downgrade to moderator (or lower if needed)
            members[_member].role = Role.Moderator; // Downgrade to Moderator as a default, adjust as needed
        } else if (members[_member].role == _role) { // If removing non-admin role, downgrade to Member
            members[_member].role = Role.Member;
        } else if (members[_member].role > _role) {
            // If removing a role that is "lower" than current role, no change needed, just emit event.
        }

        emit RoleRemoved(_member, _role);
    }

    function getMemberRole(address _member) external view returns (Role) {
        return members[_member].role;
    }

    function _findNextAdmin() private view returns (address) {
        for (uint256 i = 0; i < contentProposalCounter; i++) { // Iterate through proposals (or any member list, more efficient way needed for large DAOs)
            if (members[contentProposals[i+1].proposer].role == Role.Admin) {
                return contentProposals[i+1].proposer;
            }
        }
        return address(0); // No other admin found.
    }

    // ------------------------------------------------------------------------
    // Content Proposals & Creation
    // ------------------------------------------------------------------------

    function submitContentProposal(string memory _title, string memory _description, string memory _contentURI) external onlyMember notPaused {
        contentProposalCounter++;
        contentProposals[contentProposalCounter] = ContentProposal({
            proposalId: contentProposalCounter,
            proposer: msg.sender,
            title: _title,
            description: _description,
            contentURI: _contentURI,
            status: ProposalStatus.Pending,
            voteCountPositive: 0,
            voteCountNegative: 0,
            startTime: block.timestamp,
            endTime: block.timestamp + votingDuration
        });
        emit ContentProposalSubmitted(contentProposalCounter, msg.sender, _title);
    }

    function voteOnProposal(uint256 _proposalId, bool _vote) external onlyMember notPaused proposalExists(_proposalId) {
        ContentProposal storage proposal = contentProposals[_proposalId];
        require(proposal.status == ProposalStatus.Pending, "Proposal voting is not active");
        require(block.timestamp < proposal.endTime, "Voting period has ended");

        // Simple voting logic - no duplicate voting implemented here for simplicity, can be added with mapping
        if (_vote) {
            proposal.voteCountPositive++;
        } else {
            proposal.voteCountNegative++;
        }
        emit ProposalVoted(_proposalId, msg.sender, _vote);
    }

    function finalizeProposal(uint256 _proposalId) external onlyAdmin notPaused proposalExists(_proposalId) {
        ContentProposal storage proposal = contentProposals[_proposalId];
        require(proposal.status == ProposalStatus.Pending, "Proposal is not pending");
        require(block.timestamp >= proposal.endTime, "Voting period has not ended");

        uint256 totalVotes = proposal.voteCountPositive + proposal.voteCountNegative;
        uint256 quorum = (totalVotes * quorumPercentage) / 100;

        if (totalVotes >= quorum && proposal.voteCountPositive > proposal.voteCountNegative) {
            proposal.status = ProposalStatus.Accepted;
            mintContentItem(_proposalId); // Mint content item on acceptance
        } else {
            proposal.status = ProposalStatus.Rejected;
        }
        emit ProposalFinalized(_proposalId, proposal.status);
    }

    function getContentProposalDetails(uint256 _proposalId) external view proposalExists(_proposalId) returns (ContentProposal memory) {
        return contentProposals[_proposalId];
    }

    function mintContentItem(uint256 _proposalId) private {
        ContentProposal storage proposal = contentProposals[_proposalId];
        require(proposal.status == ProposalStatus.Accepted, "Proposal must be accepted to mint content");
        contentItemCounter++;
        contentItems[contentItemCounter] = ContentItem({
            contentItemId: contentItemCounter,
            proposalId: _proposalId,
            creator: proposal.proposer,
            metadataURI: proposal.contentURI,
            mintTimestamp: block.timestamp
        });
        emit ContentItemMinted(contentItemCounter, _proposalId, proposal.proposer);
    }

    function getContentItemDetails(uint256 _contentItemId) external view contentItemExists(_contentItemId) returns (ContentItem memory) {
        return contentItems[_contentItemId];
    }

    function setContentMetadataURI(uint256 _contentItemId, string memory _metadataURI) external onlyRole(Role.Creator) notPaused contentItemExists(_contentItemId) {
        ContentItem storage item = contentItems[_contentItemId];
        require(item.creator == msg.sender || members[msg.sender].role == Role.Admin, "Only creator or admin can set metadata URI"); // Creator or Admin can set metadata
        item.metadataURI = _metadataURI;
        emit ContentMetadataURISet(_contentItemId, _metadataURI);
    }

    // ------------------------------------------------------------------------
    // Governance & Reputation
    // ------------------------------------------------------------------------

    function createGovernanceProposal(string memory _title, string memory _description, bytes memory _data) external onlyRole(Role.Moderator) notPaused {
        governanceProposalCounter++;
        governanceProposals[governanceProposalCounter] = GovernanceProposal({
            proposalId: governanceProposalCounter,
            proposer: msg.sender,
            title: _title,
            description: _description,
            data: _data, // Data for governance actions, could be function signatures and parameters
            status: ProposalStatus.Pending,
            voteCountPositive: 0,
            voteCountNegative: 0,
            startTime: block.timestamp,
            endTime: block.timestamp + votingDuration
        });
        emit GovernanceProposalSubmitted(governanceProposalCounter, msg.sender, _title);
    }

    function voteOnGovernanceProposal(uint256 _proposalId, bool _vote) external onlyMember notPaused proposalExists(_proposalId) {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(proposal.status == ProposalStatus.Pending, "Governance proposal voting is not active");
        require(block.timestamp < proposal.endTime, "Voting period has ended");

        if (_vote) {
            proposal.voteCountPositive++;
        } else {
            proposal.voteCountNegative++;
        }
        emit GovernanceProposalVoted(_proposalId, msg.sender, _vote);
    }

    function finalizeGovernanceProposal(uint256 _proposalId) external onlyAdmin notPaused proposalExists(_proposalId) {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(proposal.status == ProposalStatus.Pending, "Governance proposal is not pending");
        require(block.timestamp >= proposal.endTime, "Voting period has ended");

        uint256 totalVotes = proposal.voteCountPositive + proposal.voteCountNegative;
        uint256 quorum = (totalVotes * quorumPercentage) / 100;

        if (totalVotes >= quorum && proposal.voteCountPositive > proposal.voteCountNegative) {
            proposal.status = ProposalStatus.Accepted;
            // Execute governance action based on proposal.data (complex, needs careful implementation)
            _executeGovernanceAction(proposal.data);
        } else {
            proposal.status = ProposalStatus.Rejected;
        }
        emit GovernanceProposalFinalized(_proposalId, proposal.status);
    }

    function getGovernanceProposalDetails(uint256 _proposalId) external view proposalExists(_proposalId) returns (GovernanceProposal memory) {
        return governanceProposals[_proposalId];
    }

    function _executeGovernanceAction(bytes memory _data) private {
        // Placeholder for governance action execution logic.
        // In a real implementation, this would parse _data to determine
        // the action to take and parameters. This is a complex area
        // and requires careful security considerations.
        // For example, using delegatecall carefully, or limiting actions to
        // predefined functions in this contract.
        // For simplicity, this is left as a placeholder.
        // Example: (very basic and insecure example - DO NOT USE IN PRODUCTION)
        // (bool success, bytes memory returnData) = address(this).delegatecall(_data);
        // require(success, "Governance action execution failed");
        (void)_data; // To avoid unused variable warning in placeholder
        // In a secure real-world implementation, you'd decode _data based on a predefined format
        // and perform specific allowed actions within the contract.
    }


    function awardReputationPoints(address _member, uint256 _points, string memory _reason) external onlyRole(Role.Moderator) notPaused {
        require(members[_member].isActive, "Member must be active");
        members[_member].reputationPoints += _points;
        emit ReputationPointsAwarded(_member, _points, _reason);
    }

    function deductReputationPoints(address _member, uint256 _points, string memory _reason) external onlyRole(Role.Moderator) notPaused {
        require(members[_member].isActive, "Member must be active");
        require(members[_member].reputationPoints >= _points, "Insufficient reputation points");
        members[_member].reputationPoints -= _points;
        emit ReputationPointsDeducted(_member, _points, _reason);
    }

    function getMemberReputation(address _member) external view returns (uint256) {
        return members[_member].reputationPoints;
    }


    // ------------------------------------------------------------------------
    // Treasury & Revenue Sharing (Conceptual - Basic Implementation)
    // ------------------------------------------------------------------------

    function depositFunds() external payable notPaused {
        treasuryBalance += msg.value;
        emit FundsDeposited(msg.value);
    }

    function distributeRevenueShare(uint256 _contentItemId) external onlyAdmin notPaused contentItemExists(_contentItemId) {
        // Conceptual - Basic example, needs more sophisticated revenue models
        ContentItem storage item = contentItems[_contentItemId];
        require(treasuryBalance > 0, "Treasury balance is zero");

        uint256 rewardAmount = treasuryBalance / 10; // Example: 10% of treasury for content reward
        require(rewardAmount > 0, "Reward amount is zero");

        treasuryBalance -= rewardAmount;

        // Distribute to creator (and potentially voters - complex logic not implemented here for brevity)
        (bool success, ) = payable(item.creator).call{value: rewardAmount}("");
        require(success, "Transfer failed");

        emit RevenueDistributed(_contentItemId, rewardAmount);
    }

    // ------------------------------------------------------------------------
    // Utility & Admin Functions
    // ------------------------------------------------------------------------

    function pauseContract() external onlyAdmin {
        paused = true;
        emit ContractPaused();
    }

    function unpauseContract() external onlyAdmin {
        paused = false;
        emit ContractUnpaused();
    }

    function setQuorum(uint256 _newQuorum) external onlyAdmin {
        require(_newQuorum <= 100, "Quorum percentage cannot exceed 100");
        quorumPercentage = _newQuorum;
        emit QuorumSet(_newQuorum);
    }

    function setVotingDuration(uint256 _newDuration) external onlyAdmin {
        votingDuration = _newDuration;
        emit VotingDurationSet(_newDuration);
    }

    // Fallback function to receive Ether
    receive() external payable {
        emit FundsDeposited(msg.value);
        treasuryBalance += msg.value;
    }
}
```