This smart contract, named **"ChronoGenesis Protocol"**, envisions a decentralized, evolving ecosystem where users manage dynamic digital organisms (NFTs) that interact with an adaptive economy, governed by a reputation-weighted system influenced by simulated environmental conditions. It blends concepts from Dynamic NFTs, Gamified DeFi, Reputation Systems, Oracle-driven adaptability, and even touches upon Regenerative Finance (ReFi) principles.

---

## ChronoGenesis Protocol: Outline & Function Summary

The ChronoGenesis Protocol creates a dynamic, on-chain ecosystem. Users cultivate "Digital Organisms" (Dynamic NFTs) which generate resources. The ecosystem's health and resource generation adapt to simulated environmental conditions (via oracle interaction). Governance is driven by "Adaptation Score" (a form of Soul-Bound Token/Reputation score), enabling users to propose and vote on evolutionary pathways and ecological restoration projects.

### I. Contract Overview
*   **Name:** ChronoGenesisProtocol
*   **Purpose:** Manages a dynamic, self-evolving digital ecosystem driven by user interaction, resource management, and decentralized governance.
*   **Key Concepts:** Dynamic NFTs, Adaptive Yield, Reputation-weighted Governance (Quadratic Voting), Simulated Oracle Integration, Ecosystem Health, Resource Economy, Soul-Bound Achievements.
*   **Inherits:** `Ownable`, `Pausable`
*   **External Dependencies:** Assumes existing ERC20 tokens for `Resources` and `BioPoints`, and ERC721 tokens for `DigitalOrganisms` and `Achievements`.

### II. Core Data Structures
*   `Organism`: Represents a unique Dynamic NFT with evolving traits.
*   `Proposal`: Details a governance proposal.
*   `EcosystemProject`: Represents a community-driven ecological restoration initiative.
*   `Achievement`: Represents a non-transferable, soul-bound achievement.

### III. Function Summary (Total: 25 Functions)

#### A. Digital Organism Management (Dynamic NFTs & Evolution)
1.  `spawnDigitalOrganism(address _owner, string memory _initialMetadataURI)`: Mints a new Digital Organism NFT for `_owner` with initial characteristics.
2.  `mutateOrganism(uint256 _organismId, string memory _newMetadataURI, uint256 _resourceCost)`: Allows the owner to trigger a mutation for their organism, updating its metadata and consuming resources.
3.  `trainOrganismAttribute(uint256 _organismId, uint8 _attributeIndex, uint256 _resourceCost)`: Improves a specific attribute of an organism by consuming resources, potentially affecting its resource generation.
4.  `getOrganismDetails(uint256 _organismId)`: Retrieves all current details and attributes of a specific Digital Organism.
5.  `_calculateOrganismResourceGeneration(uint256 _organismId)`: (Internal) Calculates the resource generation rate of an organism based on its attributes and current environmental conditions.

#### B. Adaptive Resource Economy & Staking
6.  `harvestResources(uint256 _organismId)`: Allows an organism owner to claim accumulated resources generated by their organism.
7.  `stakeResourcesForBioPoints(uint256 _amount)`: Users stake `ResourceToken` to earn `BioPointToken` (the governance/utility token).
8.  `redeemStakedResources(uint256 _amount)`: Allows users to unstake their `ResourceToken` and claim earned `BioPointToken`.
9.  `_calculateAdaptiveYield()`: (Internal) Dynamically calculates the `BioPoint` yield based on `_ecosystemHealthScore` and total staked resources.
10. `donateToEcosystemFund(uint256 _amount)`: Allows users to donate `ResourceToken` directly to a shared ecosystem fund for projects.

#### C. Gamified Governance & Proposals
11. `submitEvolutionPathwayProposal(string memory _description, bytes memory _calldata, address _targetContract)`: Users with sufficient `AdaptationScore` can submit proposals for ecosystem changes.
12. `voteOnProposal(uint256 _proposalId, bool _support)`: Casts a vote on a proposal, using a quadratic voting mechanism weighted by `AdaptationScore`.
13. `delegateAdaptationScore(address _delegatee)`: Allows users to delegate their `AdaptationScore` voting power to another address.
14. `revokeAdaptationScoreDelegation()`: Revokes any existing `AdaptationScore` delegation.
15. `executeApprovedProposal(uint256 _proposalId)`: Allows a designated role (e.g., a multisig or admin) to execute a passed proposal's actions.

#### D. Reputation & Soul-Bound Achievements
16. `awardAdaptationAchievement(address _user, uint8 _achievementType, string memory _metadataURI)`: Awards a non-transferable "Adaptation Achievement" NFT to a user for specific on-chain actions/milestones.
17. `calculateUserAdaptationScore(address _user)`: Calculates a user's cumulative "Adaptation Score" based on their achievements, participation, and resource contributions.
18. `getAchievementDetails(uint256 _achievementId)`: Retrieves details of a specific awarded achievement.

#### E. Oracle & Environmental Adaptation
19. `updateEnvironmentalCondition(uint8 _newConditionIndex, int256 _impactModifier)`: (Admin/Oracle) Updates the global environmental conditions, which can impact organism generation and staking yield.
20. `getEnvironmentalCondition()`: Retrieves the current global environmental condition.
21. `_updateEcosystemHealthScore()`: (Internal) Periodically adjusts the overall `_ecosystemHealthScore` based on environmental conditions, resource fund, and active projects.

#### F. Ecosystem Projects (ReFi & Community Initiatives)
22. `proposeEcologicalRestorationProject(string memory _description, uint256 _resourceBudget)`: Users can propose projects aimed at improving ecosystem health, requiring resource funding.
23. `fundApprovedProject(uint256 _projectId)`: (Admin/Multisig) Allocates `ResourceToken` from the `ecosystemFund` to an approved project.
24. `reportProjectCompletion(uint256 _projectId)`: Marks a project as completed, potentially boosting `_ecosystemHealthScore`.

#### G. System Administration & Configuration
25. `setTokenAddresses(address _resourceAddr, address _bioPointAddr, address _organismNFTAddr, address _achievementNFTAddr)`: (Admin) Sets the addresses of the required external ERC20 and ERC721 tokens.
26. `pauseEcosystemActions()`: (Admin) Pauses critical user-facing functions in case of emergency.
27. `unpauseEcosystemActions()`: (Admin) Unpauses the ecosystem.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol"; // To hold NFTs if needed for staking/locking

// Custom errors for better UX and gas efficiency
error InvalidOrganismOwner();
error NotEnoughResources();
error ProposalNotFound();
error AlreadyVoted();
error NotEnoughAdaptationScore();
error ProposalNotExecutable();
error DelegationMismatch();
error ProjectNotFound();
error ProjectNotApproved();
error ProjectAlreadyCompleted();
error InvalidTokenAddress();
error CannotHarvestYet();

/**
 * @title ChronoGenesisProtocol
 * @dev A decentralized, evolving ecosystem protocol managing dynamic digital organisms (NFTs),
 *      an adaptive resource economy, and reputation-weighted governance influenced by simulated
 *      environmental conditions. It incorporates concepts of Dynamic NFTs, Gamified DeFi,
 *      Reputation Systems, Oracle-driven adaptability, and Regenerative Finance (ReFi) principles.
 *
 * Outline:
 *   I. Core Data Structures: Organism, Proposal, EcosystemProject, Achievement
 *  II. Token & NFT Interfaces: IERC20, IERC721 references
 * III. State Variables & Mappings
 *  IV. Events
 *   V. Constructor & Admin Functions
 *  VI. Digital Organism Management (Dynamic NFTs & Evolution)
 * VII. Adaptive Resource Economy & Staking
 *VIII. Gamified Governance & Proposals
 *  IX. Reputation & Soul-Bound Achievements
 *   X. Oracle & Environmental Adaptation
 *  XI. Ecosystem Projects (ReFi & Community Initiatives)
 * XII. System Administration & Configuration
 */
contract ChronoGenesisProtocol is Ownable, Pausable, ERC721Holder { // ERC721Holder for potential future NFT staking/locking
    // --- I. Core Data Structures ---

    // Represents a unique Dynamic NFT (Digital Organism)
    struct Organism {
        uint256 id;
        address owner;
        string metadataURI;
        uint256 spawnTime;
        uint256 lastHarvestTime;
        uint16[] attributes; // e.g., [strength, agility, intelligence, resilience]
        bool isEvolving; // True if an evolution path is active for this organism
    }

    // Details a governance proposal
    struct Proposal {
        uint256 id;
        string description;
        address proposer;
        uint256 submissionTime;
        uint256 votingEndTime;
        uint256 totalVotesFor; // Represents the sum of square roots of adaptation scores for 'for' votes
        uint256 totalVotesAgainst; // Represents the sum of square roots of adaptation scores for 'against' votes
        address targetContract; // Contract to call if proposal passes
        bytes calldataPayload; // Data to send with the call
        bool executed;
        bool passed;
    }

    // Represents a community-driven ecological restoration initiative
    struct EcosystemProject {
        uint256 id;
        string description;
        address proposer;
        uint256 budget; // In ResourceToken units
        uint256 startTime;
        uint256 completionTime; // 0 if not completed
        bool approved;
        bool funded;
        bool completed;
    }

    // Represents a non-transferable, soul-bound achievement (SBT-like)
    struct Achievement {
        uint256 id;
        address owner;
        uint8 achievementType; // Enum or specific ID for different achievements
        string metadataURI;
        uint256 timestamp;
    }

    // --- II. Token & NFT Interfaces ---
    IERC20 public _resourceToken;     // The main resource token of the ecosystem
    IERC20 public _bioPointToken;     // The governance/utility token, earned via staking
    IERC721 public _digitalOrganismNFT; // The dynamic NFT representing organisms
    IERC721 public _achievementNFT;    // The SBT-like achievement NFT

    // --- III. State Variables & Mappings ---

    // Organism Management
    uint256 private _nextOrganismId;
    mapping(uint256 => Organism) public organisms;
    mapping(address => uint256[]) public userOrganisms; // Tracks organisms owned by an address

    // Resource Economy
    mapping(address => uint256) public stakedResources; // User address => amount of ResourceToken staked
    mapping(address => uint256) public _lastBioPointClaimTime; // For tracking BioPoint accrual
    uint256 public ecosystemFund; // Pool of resources for projects

    // Governance
    uint256 private _nextProposalId;
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted; // proposalId => voterAddress => voted
    mapping(address => address) public adaptationScoreDelegates; // user => delegatee

    // Reputation & Achievements
    uint256 private _nextAchievementId;
    mapping(uint256 => Achievement) public achievements;
    mapping(address => uint256[]) public userAchievements; // Tracks achievements awarded to an address
    mapping(address => uint256) public userAdaptationScores; // Cached Adaptation Score for quick lookup

    // Oracle & Environmental Adaptation
    // Represents an index for different environmental conditions (e.g., 0=Normal, 1=Drought, 2=Abundant)
    uint8 public _environmentalCondition;
    // Modifier that impacts resource generation and yield, based on _environmentalCondition
    int256 public _environmentalImpactModifier;
    uint256 public _ecosystemHealthScore; // A general score reflecting ecosystem health, influencing adaptive yield

    // Ecosystem Projects
    uint256 private _nextProjectId;
    mapping(uint256 => EcosystemProject) public ecosystemProjects;
    mapping(uint256 => address) public projectApprovalAuthority; // Who approved the project if not protocol itself

    // Configuration
    uint255 public constant RESOURCE_GENERATION_BASE = 100; // Base resources per tick for an organism
    uint256 public constant MIN_ADAPTATION_SCORE_TO_PROPOSE = 500;
    uint256 public constant PROPOSAL_VOTING_PERIOD = 7 days;
    uint256 public constant BASE_ADAPTIVE_YIELD_FACTOR = 100; // Multiplier for BioPoint yield calculation
    uint255 public constant MAX_ATTRIBUTES = 4; // Max attributes for an organism (e.g., strength, agility, etc.)
    uint256 public constant HARVEST_COOLDOWN = 1 hours; // Minimum time between harvests for an organism

    // --- IV. Events ---
    event OrganismSpawned(uint256 indexed organismId, address indexed owner, string metadataURI);
    event OrganismMutated(uint256 indexed organismId, string newMetadataURI, uint256 resourceCost);
    event OrganismAttributeTrained(uint256 indexed organismId, uint8 attributeIndex, uint256 resourceCost);
    event ResourcesHarvested(uint256 indexed organismId, address indexed owner, uint256 amount);
    event ResourcesStaked(address indexed user, uint256 amount);
    event ResourcesRedeemed(address indexed user, uint256 amount);
    event BioPointsEarned(address indexed user, uint256 amount);
    event ResourcesDonated(address indexed donor, uint256 amount);
    event ProposalSubmitted(uint256 indexed proposalId, address indexed proposer, string description);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 adaptationScore);
    event AdaptationScoreDelegated(address indexed delegator, address indexed delegatee);
    event AdaptationScoreRevoked(address indexed delegator);
    event ProposalExecuted(uint256 indexed proposalId, bool passed);
    event AchievementAwarded(uint256 indexed achievementId, address indexed owner, uint8 achievementType);
    event EnvironmentalConditionUpdated(uint8 newConditionIndex, int256 impactModifier);
    event EcosystemHealthUpdated(uint256 newHealthScore);
    event EcosystemProjectProposed(uint256 indexed projectId, address indexed proposer, uint256 budget);
    event EcosystemProjectFunded(uint256 indexed projectId, uint256 amount);
    event EcosystemProjectCompleted(uint256 indexed projectId);
    event TokenAddressesSet(address resource, address bioPoint, address organismNFT, address achievementNFT);

    // --- V. Constructor & Admin Functions ---

    constructor(address _initialResourceToken, address _initialBioPointToken, address _initialOrganismNFT, address _initialAchievementNFT) Ownable(msg.sender) Pausable() {
        if (_initialResourceToken == address(0) || _initialBioPointToken == address(0) ||
            _initialOrganismNFT == address(0) || _initialAchievementNFT == address(0)) {
            revert InvalidTokenAddress();
        }
        _resourceToken = IERC20(_initialResourceToken);
        _bioPointToken = IERC20(_initialBioPointToken);
        _digitalOrganismNFT = IERC721(_initialOrganismNFT);
        _achievementNFT = IERC721(_initialAchievementNFT);

        _nextOrganismId = 1;
        _nextProposalId = 1;
        _nextAchievementId = 1;
        _nextProjectId = 1;
        _environmentalCondition = 0; // Default to a neutral condition
        _environmentalImpactModifier = 0; // Neutral impact
        _ecosystemHealthScore = 1000; // Initial healthy score
    }

    /**
     * @dev Allows the owner to set the addresses of the required external ERC20 and ERC721 tokens.
     * @param _resourceAddr Address of the Resource ERC20 token.
     * @param _bioPointAddr Address of the BioPoint ERC20 token.
     * @param _organismNFTAddr Address of the DigitalOrganism ERC721 NFT.
     * @param _achievementNFTAddr Address of the Achievement ERC721 NFT.
     */
    function setTokenAddresses(address _resourceAddr, address _bioPointAddr, address _organismNFTAddr, address _achievementNFTAddr) external onlyOwner {
        if (_resourceAddr == address(0) || _bioPointAddr == address(0) ||
            _organismNFTAddr == address(0) || _achievementNFTAddr == address(0)) {
            revert InvalidTokenAddress();
        }
        _resourceToken = IERC20(_resourceAddr);
        _bioPointToken = IERC20(_bioPointAddr);
        _digitalOrganismNFT = IERC721(_organismNFTAddr);
        _achievementNFT = IERC721(_achievementNFTAddr);
        emit TokenAddressesSet(_resourceAddr, _bioPointAddr, _organismNFTAddr, _achievementNFTAddr);
    }

    // --- VI. Digital Organism Management (Dynamic NFTs & Evolution) ---

    /**
     * @dev Mints a new Digital Organism NFT for `_owner` with initial characteristics.
     *      Initial attributes are randomly assigned or based on a predefined set.
     * @param _owner The address to mint the organism for.
     * @param _initialMetadataURI The initial metadata URI for the organism.
     */
    function spawnDigitalOrganism(address _owner, string memory _initialMetadataURI) external onlyOwner whenNotPaused {
        uint256 newOrganismId = _nextOrganismId++;
        // Simulate initial attributes (e.g., random or base values)
        uint16[] memory initialAttributes = new uint16[](MAX_ATTRIBUTES);
        for (uint8 i = 0; i < MAX_ATTRIBUTES; i++) {
            initialAttributes[i] = uint16(50 + (uint256(keccak256(abi.encodePacked(block.timestamp, newOrganismId, i))) % 50)); // Base 50-99
        }

        organisms[newOrganismId] = Organism({
            id: newOrganismId,
            owner: _owner,
            metadataURI: _initialMetadataURI,
            spawnTime: block.timestamp,
            lastHarvestTime: block.timestamp,
            attributes: initialAttributes,
            isEvolving: false
        });

        userOrganisms[_owner].push(newOrganismId);
        _digitalOrganismNFT.safeMint(_owner, newOrganismId); // Assumes IERC721 supports safeMint extension
        emit OrganismSpawned(newOrganismId, _owner, _initialMetadataURI);
    }

    /**
     * @dev Allows the owner to trigger a mutation for their organism, updating its metadata and consuming resources.
     *      This is a core "evolution" mechanic for Dynamic NFTs.
     * @param _organismId The ID of the organism to mutate.
     * @param _newMetadataURI The new metadata URI reflecting the mutation.
     * @param _resourceCost The amount of ResourceToken required for this mutation.
     */
    function mutateOrganism(uint256 _organismId, string memory _newMetadataURI, uint256 _resourceCost) external whenNotPaused {
        Organism storage organism = organisms[_organismId];
        if (organism.owner != msg.sender) revert InvalidOrganismOwner();
        if (_resourceToken.balanceOf(msg.sender) < _resourceCost) revert NotEnoughResources();

        // Transfer resources to the contract's fund
        _resourceToken.transferFrom(msg.sender, address(this), _resourceCost);
        ecosystemFund += _resourceCost; // Add to ecosystem fund

        organism.metadataURI = _newMetadataURI;
        organism.isEvolving = true; // Mark as evolving, potentially for a cool-down or future mechanics

        // Simulate some attribute change due to mutation
        organism.attributes[uint8(keccak256(abi.encodePacked(block.timestamp, _organismId))) % MAX_ATTRIBUTES] += 5;

        // Optionally, update the NFT's metadata URI directly if the NFT contract supports it
        // _digitalOrganismNFT.setTokenURI(_organismId, _newMetadataURI); // Requires specific ERC721 extension

        emit OrganismMutated(_organismId, _newMetadataURI, _resourceCost);
    }

    /**
     * @dev Improves a specific attribute of an organism by consuming resources.
     *      Further enhances the Dynamic NFT aspect.
     * @param _organismId The ID of the organism.
     * @param _attributeIndex The index of the attribute to train (0 to MAX_ATTRIBUTES-1).
     * @param _resourceCost The amount of ResourceToken required for training.
     */
    function trainOrganismAttribute(uint256 _organismId, uint8 _attributeIndex, uint256 _resourceCost) external whenNotPaused {
        Organism storage organism = organisms[_organismId];
        if (organism.owner != msg.sender) revert InvalidOrganismOwner();
        if (_attributeIndex >= MAX_ATTRIBUTES) revert("Invalid attribute index");
        if (_resourceToken.balanceOf(msg.sender) < _resourceCost) revert NotEnoughResources();

        _resourceToken.transferFrom(msg.sender, address(this), _resourceCost);
        ecosystemFund += _resourceCost;

        organism.attributes[_attributeIndex] += uint16(1 + (uint256(keccak256(abi.encodePacked(block.timestamp, _organismId, _attributeIndex))) % 3)); // Increment by 1-3

        emit OrganismAttributeTrained(_organismId, _attributeIndex, _resourceCost);
    }

    /**
     * @dev Retrieves all current details and attributes of a specific Digital Organism.
     * @param _organismId The ID of the organism.
     * @return All organism data.
     */
    function getOrganismDetails(uint256 _organismId) external view returns (Organism memory) {
        return organisms[_organismId];
    }

    /**
     * @dev Internal function to calculate the resource generation rate of an organism.
     *      Affected by organism attributes and current environmental conditions.
     * @param _organismId The ID of the organism.
     * @return The calculated resources generated per unit of time.
     */
    function _calculateOrganismResourceGeneration(uint256 _organismId) internal view returns (uint256) {
        Organism storage organism = organisms[_organismId];
        uint256 totalAttributeScore = 0;
        for (uint8 i = 0; i < organism.attributes.length; i++) {
            totalAttributeScore += organism.attributes[i];
        }
        // Base generation + (Attribute bonus * Environmental impact)
        // Assume environmental impact modifier is percentage-based (e.g., -100 to +100 means -100% to +100%)
        uint256 generationRate = (RESOURCE_GENERATION_BASE * totalAttributeScore) / 100;
        if (_environmentalImpactModifier < 0) {
            generationRate = (generationRate * uint256(100 + _environmentalImpactModifier)) / 100; // Reduce
        } else {
            generationRate = (generationRate * uint256(100 + _environmentalImpactModifier)) / 100; // Increase
        }
        return generationRate;
    }

    // --- VII. Adaptive Resource Economy & Staking ---

    /**
     * @dev Allows an organism owner to claim accumulated resources generated by their organism.
     *      Resources accrue over time based on the organism's attributes and environment.
     * @param _organismId The ID of the organism to harvest from.
     */
    function harvestResources(uint256 _organismId) external whenNotPaused {
        Organism storage organism = organisms[_organismId];
        if (organism.owner != msg.sender) revert InvalidOrganismOwner();
        if (block.timestamp < organism.lastHarvestTime + HARVEST_COOLDOWN) revert CannotHarvestYet();

        uint256 timeElapsed = block.timestamp - organism.lastHarvestTime;
        uint256 generatedResources = (_calculateOrganismResourceGeneration(_organismId) * timeElapsed) / (1 days); // Normalize to daily rate

        organism.lastHarvestTime = block.timestamp;
        if (generatedResources > 0) {
            _resourceToken.transfer(msg.sender, generatedResources);
            emit ResourcesHarvested(_organismId, msg.sender, generatedResources);
        }
    }

    /**
     * @dev Users stake `ResourceToken` to earn `BioPointToken` (the governance/utility token).
     *      The yield is adaptive based on ecosystem health.
     * @param _amount The amount of ResourceToken to stake.
     */
    function stakeResourcesForBioPoints(uint256 _amount) external whenNotPaused {
        if (_amount == 0) revert("Cannot stake 0");
        _resourceToken.transferFrom(msg.sender, address(this), _amount);
        stakedResources[msg.sender] += _amount;
        // Also claim any accrued BioPoints before new stake
        _claimBioPoints();
        emit ResourcesStaked(msg.sender, _amount);
    }

    /**
     * @dev Allows users to unstake their `ResourceToken` and claim earned `BioPointToken`.
     * @param _amount The amount of ResourceToken to unstake.
     */
    function redeemStakedResources(uint256 _amount) external whenNotPaused {
        if (_amount == 0) revert("Cannot redeem 0");
        if (stakedResources[msg.sender] < _amount) revert("Not enough staked resources");

        _claimBioPoints(); // Claim accrued BioPoints first
        stakedResources[msg.sender] -= _amount;
        _resourceToken.transfer(msg.sender, _amount);
        emit ResourcesRedeemed(msg.sender, _amount);
    }

    /**
     * @dev Internal function to claim accrued BioPoints based on staking duration and adaptive yield.
     */
    function _claimBioPoints() internal {
        uint256 timeElapsed = block.timestamp - _lastBioPointClaimTime[msg.sender];
        if (timeElapsed == 0 || stakedResources[msg.sender] == 0) return;

        uint256 earnedBioPoints = (stakedResources[msg.sender] * _calculateAdaptiveYield() * timeElapsed) / (1 days * BASE_ADAPTIVE_YIELD_FACTOR);
        if (earnedBioPoints > 0) {
            _bioPointToken.transfer(msg.sender, earnedBioPoints);
            emit BioPointsEarned(msg.sender, earnedBioPoints);
        }
        _lastBioPointClaimTime[msg.sender] = block.timestamp;
    }

    /**
     * @dev Dynamically calculates the `BioPoint` yield based on `_ecosystemHealthScore` and total staked resources.
     *      Higher ecosystem health and lower total staked resources (simulated scarcity) could mean higher yield.
     * @return The adaptive yield factor.
     */
    function _calculateAdaptiveYield() internal view returns (uint256) {
        // Simple adaptive yield: higher health = higher yield, more staked resources = lower yield
        uint256 totalStaked = _resourceToken.balanceOf(address(this)); // approximation of total staked
        if (totalStaked == 0) return BASE_ADAPTIVE_YIELD_FACTOR;

        uint256 healthFactor = _ecosystemHealthScore / 100; // e.g., 1000 health = 10 factor
        uint256 stakedFactor = totalStaked / 10000; // e.g., 100,000 staked = 10 factor

        if (stakedFactor == 0) stakedFactor = 1; // Avoid division by zero

        uint256 yieldFactor = (BASE_ADAPTIVE_YIELD_FACTOR * healthFactor) / stakedFactor;
        return yieldFactor > 0 ? yieldFactor : 1; // Ensure at least 1
    }

    /**
     * @dev Allows users to donate `ResourceToken` directly to a shared ecosystem fund for projects.
     * @param _amount The amount of ResourceToken to donate.
     */
    function donateToEcosystemFund(uint256 _amount) external whenNotPaused {
        if (_amount == 0) revert("Cannot donate 0");
        _resourceToken.transferFrom(msg.sender, address(this), _amount);
        ecosystemFund += _amount;
        emit ResourcesDonated(msg.sender, _amount);
    }

    // --- VIII. Gamified Governance & Proposals ---

    /**
     * @dev Users with sufficient `AdaptationScore` can submit proposals for ecosystem changes.
     *      These can range from new mutation rules to resource distribution changes.
     * @param _description A description of the proposal.
     * @param _calldata The calldata to be executed if the proposal passes.
     * @param _targetContract The target contract address for execution.
     */
    function submitEvolutionPathwayProposal(string memory _description, bytes memory _calldata, address _targetContract) external whenNotPaused {
        if (calculateUserAdaptationScore(msg.sender) < MIN_ADAPTATION_SCORE_TO_PROPOSE) {
            revert NotEnoughAdaptationScore();
        }

        uint256 newProposalId = _nextProposalId++;
        proposals[newProposalId] = Proposal({
            id: newProposalId,
            description: _description,
            proposer: msg.sender,
            submissionTime: block.timestamp,
            votingEndTime: block.timestamp + PROPOSAL_VOTING_PERIOD,
            totalVotesFor: 0,
            totalVotesAgainst: 0,
            targetContract: _targetContract,
            calldataPayload: _calldata,
            executed: false,
            passed: false
        });
        emit ProposalSubmitted(newProposalId, msg.sender, _description);
    }

    /**
     * @dev Casts a vote on a proposal, using a quadratic voting mechanism weighted by `AdaptationScore`.
     *      The square root of the Adaptation Score is used for voting power.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _support True for 'yes', false for 'no'.
     */
    function voteOnProposal(uint256 _proposalId, bool _support) external whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.id == 0) revert ProposalNotFound();
        if (block.timestamp >= proposal.votingEndTime) revert("Voting period ended");
        if (hasVoted[_proposalId][msg.sender]) revert AlreadyVoted();

        address voter = adaptationScoreDelegates[msg.sender] != address(0) ? adaptationScoreDelegates[msg.sender] : msg.sender;
        uint256 adaptationScore = calculateUserAdaptationScore(voter);
        if (adaptationScore == 0) revert NotEnoughAdaptationScore();

        // Quadratic Voting: voting power is sqrt(adaptationScore)
        uint256 votingPower = sqrt(adaptationScore);

        if (_support) {
            proposal.totalVotesFor += votingPower;
        } else {
            proposal.totalVotesAgainst += votingPower;
        }

        hasVoted[_proposalId][msg.sender] = true;
        emit VoteCast(_proposalId, msg.sender, _support, adaptationScore);
    }

    /**
     * @dev Allows users to delegate their `AdaptationScore` voting power to another address.
     * @param _delegatee The address to delegate voting power to.
     */
    function delegateAdaptationScore(address _delegatee) external {
        if (_delegatee == msg.sender) revert DelegationMismatch();
        adaptationScoreDelegates[msg.sender] = _delegatee;
        emit AdaptationScoreDelegated(msg.sender, _delegatee);
    }

    /**
     * @dev Revokes any existing `AdaptationScore` delegation.
     */
    function revokeAdaptationScoreDelegation() external {
        if (adaptationScoreDelegates[msg.sender] == address(0)) revert("No active delegation");
        delete adaptationScoreDelegates[msg.sender];
        emit AdaptationScoreRevoked(msg.sender);
    }

    /**
     * @dev Allows a designated role (e.g., a multisig or admin) to execute a passed proposal's actions.
     *      Requires proposal to have ended and passed the majority threshold.
     * @param _proposalId The ID of the proposal to execute.
     */
    function executeApprovedProposal(uint256 _proposalId) external onlyOwner whenNotPaused { // For simplicity, only owner can execute
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.id == 0) revert ProposalNotFound();
        if (block.timestamp < proposal.votingEndTime) revert("Voting still active");
        if (proposal.executed) revert("Proposal already executed");

        // Simple majority threshold based on quadratic voting sums
        bool passed = proposal.totalVotesFor > proposal.totalVotesAgainst;
        proposal.passed = passed;
        proposal.executed = true;

        if (passed) {
            // Execute the proposed calldata on the target contract
            (bool success, ) = proposal.targetContract.call(proposal.calldataPayload);
            if (!success) {
                // Handle failed execution (e.g., log, re-evaluate, don't revert to allow marking as executed)
                emit ProposalExecuted(_proposalId, false); // Mark as failed execution
                revert("Proposal execution failed");
            }
        }
        emit ProposalExecuted(_proposalId, passed);
    }

    // --- IX. Reputation & Soul-Bound Achievements ---

    /**
     * @dev Awards a non-transferable "Adaptation Achievement" NFT to a user for specific on-chain actions/milestones.
     *      These achievements contribute to the user's overall Adaptation Score.
     * @param _user The address to award the achievement to.
     * @param _achievementType An identifier for the type of achievement (e.g., 1 for "First Mutation", 2 for "Staked X Resources").
     * @param _metadataURI Metadata URI for the achievement NFT.
     */
    function awardAdaptationAchievement(address _user, uint8 _achievementType, string memory _metadataURI) external onlyOwner whenNotPaused {
        uint256 newAchievementId = _nextAchievementId++;
        achievements[newAchievementId] = Achievement({
            id: newAchievementId,
            owner: _user,
            achievementType: _achievementType,
            metadataURI: _metadataURI,
            timestamp: block.timestamp
        });
        userAchievements[_user].push(newAchievementId);
        _achievementNFT.safeMint(_user, newAchievementId); // Assumes safeMint is available for SBT-like NFT
        userAdaptationScores[_user] = calculateUserAdaptationScore(_user); // Recalculate score
        emit AchievementAwarded(newAchievementId, _user, _achievementType);
    }

    /**
     * @dev Calculates a user's cumulative "Adaptation Score" based on their achievements, participation, and resource contributions.
     *      This function aggregates various on-chain metrics to form a holistic reputation score.
     * @param _user The address of the user.
     * @return The calculated Adaptation Score.
     */
    function calculateUserAdaptationScore(address _user) public view returns (uint256) {
        uint256 score = 0;
        // 1. Score from Achievements (each achievement type can have a different weight)
        for (uint256 i = 0; i < userAchievements[_user].length; i++) {
            uint8 typeId = achievements[userAchievements[_user][i]].achievementType;
            // Example weights:
            if (typeId == 1) score += 50;  // First Mutation
            if (typeId == 2) score += 100; // Major Contributor
            if (typeId == 3) score += 75;  // Active Voter
            // Add more achievement types and their scores
            score += 20; // Base score for any achievement
        }

        // 2. Score from Staked Resources (proportional to amount staked)
        score += stakedResources[_user] / 1000; // 1 point per 1000 resources staked

        // 3. Score from Ecosystem Fund Donations
        // (This would require tracking individual donations, or sum them in a separate mapping)
        // For simplicity, let's assume a rough estimate based on total donated or a specific donation award.
        // Or award a specific "Philanthropist" achievement.

        // 4. Score from Active Participation (e.g., number of proposals submitted, votes cast)
        // This would require more detailed mappings, e.g., mapping(address => uint256) numProposalsSubmitted;
        // For this example, let's keep it abstract or assume it's covered by achievements.

        return score;
    }

    /**
     * @dev Retrieves details of a specific awarded achievement.
     * @param _achievementId The ID of the achievement.
     * @return All achievement data.
     */
    function getAchievementDetails(uint256 _achievementId) external view returns (Achievement memory) {
        return achievements[_achievementId];
    }

    // --- X. Oracle & Environmental Adaptation ---

    /**
     * @dev Updates the global environmental conditions, which can impact organism generation and staking yield.
     *      This function would ideally be called by a decentralized oracle network.
     * @param _newConditionIndex An index representing the new environmental condition (e.g., 0=Neutral, 1=Drought, 2=Rainy).
     * @param _impactModifier A percentage-based modifier (e.g., -100 to +100) on resource generation.
     */
    function updateEnvironmentalCondition(uint8 _newConditionIndex, int256 _impactModifier) external onlyOwner whenNotPaused { // For demo, onlyOwner
        _environmentalCondition = _newConditionIndex;
        _environmentalImpactModifier = _impactModifier;
        _updateEcosystemHealthScore(); // Update health score based on new conditions
        emit EnvironmentalConditionUpdated(_newConditionIndex, _impactModifier);
    }

    /**
     * @dev Retrieves the current global environmental condition.
     * @return The index of the current environmental condition.
     */
    function getEnvironmentalCondition() external view returns (uint8) {
        return _environmentalCondition;
    }

    /**
     * @dev Internal function to periodically adjust the overall `_ecosystemHealthScore`.
     *      Influenced by environmental conditions, the size of the `ecosystemFund`, and active projects.
     */
    function _updateEcosystemHealthScore() internal {
        uint256 newScore = 0;
        // Base score
        newScore += 500;

        // Factor in environmental condition (e.g., higher score for favorable conditions)
        if (_environmentalImpactModifier > 0) newScore += uint256(_environmentalImpactModifier);
        else newScore = newScore > uint256(-_environmentalImpactModifier) ? newScore - uint256(-_environmentalImpactModifier) : 0;

        // Factor in ecosystem fund size (larger fund = healthier)
        newScore += ecosystemFund / 10000;

        // Factor in number of active/completed projects (more completed projects = healthier)
        uint256 completedProjectsCount = 0;
        for (uint256 i = 1; i < _nextProjectId; i++) {
            if (ecosystemProjects[i].completed) {
                completedProjectsCount++;
            }
        }
        newScore += completedProjectsCount * 50;

        _ecosystemHealthScore = newScore;
        emit EcosystemHealthUpdated(_ecosystemHealthScore);
    }

    // --- XI. Ecosystem Projects (ReFi & Community Initiatives) ---

    /**
     * @dev Users can propose projects aimed at improving ecosystem health, requiring resource funding from the `ecosystemFund`.
     *      These projects align with Regenerative Finance (ReFi) principles.
     * @param _description Description of the proposed project.
     * @param _resourceBudget The amount of ResourceToken requested from the ecosystem fund.
     */
    function proposeEcologicalRestorationProject(string memory _description, uint256 _resourceBudget) external whenNotPaused {
        uint256 newProjectId = _nextProjectId++;
        ecosystemProjects[newProjectId] = EcosystemProject({
            id: newProjectId,
            description: _description,
            proposer: msg.sender,
            budget: _resourceBudget,
            startTime: block.timestamp,
            completionTime: 0,
            approved: false, // Requires separate approval (e.g., via governance proposal)
            funded: false,
            completed: false
        });
        // A project might need to be approved via a governance proposal before it can be funded.
        // For simplicity, this example just registers it.
        emit EcosystemProjectProposed(newProjectId, msg.sender, _resourceBudget);
    }

    /**
     * @dev (Admin/Multisig) Allocates `ResourceToken` from the `ecosystemFund` to an approved project.
     *      This would typically follow a successful governance vote to approve the project.
     * @param _projectId The ID of the project to fund.
     */
    function fundApprovedProject(uint256 _projectId) external onlyOwner whenNotPaused { // For demo, onlyOwner
        EcosystemProject storage project = ecosystemProjects[_projectId];
        if (project.id == 0) revert ProjectNotFound();
        // In a real scenario, this would check if a governance proposal for this project passed.
        // For this example, we'll mark it as "approved" manually if the owner calls it.
        project.approved = true; // Simulating approval
        if (!project.approved) revert ProjectNotApproved();
        if (project.funded) revert("Project already funded");
        if (ecosystemFund < project.budget) revert NotEnoughResources();

        // Transfer funds from the contract's ecosystem fund (its own balance)
        _resourceToken.transfer(project.proposer, project.budget); // Or a multisig managing the project
        ecosystemFund -= project.budget;
        project.funded = true;
        emit EcosystemProjectFunded(_projectId, project.budget);
    }

    /**
     * @dev Marks a project as completed, potentially boosting `_ecosystemHealthScore`.
     *      Requires the project to be funded.
     * @param _projectId The ID of the project to mark as completed.
     */
    function reportProjectCompletion(uint256 _projectId) external onlyOwner whenNotPaused { // For demo, onlyOwner
        EcosystemProject storage project = ecosystemProjects[_projectId];
        if (project.id == 0) revert ProjectNotFound();
        if (!project.funded) revert("Project not yet funded");
        if (project.completed) revert ProjectAlreadyCompleted();

        project.completionTime = block.timestamp;
        project.completed = true;
        _updateEcosystemHealthScore(); // Reflect positive impact on ecosystem health
        emit EcosystemProjectCompleted(_projectId);
    }

    // --- XII. System Administration & Configuration ---

    /**
     * @dev Pauses all user-facing actions in case of emergency.
     */
    function pauseEcosystemActions() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the ecosystem, allowing users to resume actions.
     */
    function unpauseEcosystemActions() external onlyOwner {
        _unpause();
    }

    // --- Helper for Quadratic Voting (simplified sqrt) ---
    // From OpenZeppelin's Math library (replicated here to avoid importing entire library)
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
        // else z = 0 (default value)
    }

    // Fallback function for receiving tokens (optional, but good practice for ERC721Holder)
    // function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4) {
    //     return this.onERC721Received.selector;
    // }
}
```