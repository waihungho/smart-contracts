Okay, let's create a smart contract concept called "ChronoArtifacts" - a system for generating, evolving, and interacting with unique, dynamic digital assets that change based on time, user actions, simulated external data, and community influence. This goes beyond simple ERC721 by adding complex, time-sensitive, and interactive state changes.

It leverages concepts like:
1.  **Dynamic Metadata/State:** Artifacts have changing attributes (level, energy, traits).
2.  **Time-Based Evolution:** Artifacts passively evolve over time, influenced by parameters.
3.  **User Interaction:** Users can actively influence artifact state (feeding, boosting, mutating).
4.  **Simulated Oracle Integration:** Global parameters can be affected by external "data" (simulated here).
5.  **Community Influence:** Users can collectively influence global evolution parameters for future epochs.
6.  **Epoch System:** Time is divided into epochs, which affect evolution rules and reward distribution.
7.  **Asset Mutation:** A novel function allowing combination/transformation of assets.
8.  **Reward Distribution:** Artifact state influences passive reward generation.

This contract is complex and would likely interact with off-chain services (like metadata servers) in a real-world scenario, but the core logic for state changes, evolution, and interaction lives on-chain.

**Outline & Function Summary:**

**Contract:** `ChronoArtifacts`

This contract manages unique digital assets ("ChronoArtifacts") that evolve over time based on various factors.

**I. State Variables:**
    *   `artifactState`: Mapping from `tokenId` to `ArtifactState` struct.
    *   `epochs`: Mapping from `epochId` to `EpochInfo` struct.
    *   `globalParameters`: Mapping from `parameterId` to `int256` value.
    *   `epochInfluence`: Mapping from `epochId` -> `parameterId` -> `influenceAmount`.
    *   Counters, Admin addresses, Paused state, etc.

**II. Structs:**
    *   `ArtifactState`: Represents the state of a single artifact (level, energy, traits, timestamps).
    *   `EpochInfo`: Represents global data for a specific epoch (start time, calculated parameters, oracle data, accumulated influence).

**III. Events:**
    *   `ArtifactMinted`: New artifact created.
    *   `ArtifactEvolved`: Artifact state updated via evolution.
    *   `ArtifactFed`: Artifact energy increased via feeding.
    *   `ArtifactBoosted`: Artifact received a boost.
    *   `ArtifactMutated`: Artifacts combined/transformed.
    *   `RewardsClaimed`: Rewards distributed for an artifact.
    *   `EpochProcessed`: System moved to a new epoch.
    *   `ParameterInfluenced`: User added influence to a parameter.
    *   `GlobalParameterChanged`: A global parameter was updated.
    *   `Paused`, `Unpaused`.

**IV. Modifiers:**
    *   `onlyAdmin`: Restricts access to the contract admin.
    *   `whenNotPaused`: Prevents execution when paused.
    *   `whenPaused`: Allows execution only when paused (e.g., `unpauseContract`).
    *   `artifactExists`: Checks if a given token ID is a valid artifact.

**V. Core ERC721-like Functionality (Conceptual - assumes inheritance or minimal implementation for state tracking):**
    *   (We will track ownership conceptually alongside custom state for this example, but in a real contract, you'd inherit from OpenZeppelin's ERC721Enumerable or similar).
    *   `getTotalArtifactSupply()`: Returns the total number of artifacts minted.

**VI. Artifact Management & State (Custom Logic):**
    1.  `mintArtifact(address recipient)`: Mints a new artifact for `recipient`, initializes its state.
    2.  `getArtifactState(uint256 tokenId)`: Retrieves the full dynamic state of an artifact.
    3.  `getArtifactDynamicMetadata(uint256 tokenId)`: Generates/returns key data points for off-chain metadata.
    4.  `evolveArtifact(uint256 tokenId)`: Triggers the core evolution logic for a single artifact based on time, global params, etc.
    5.  `feedArtifact(uint256 tokenId)`: Allows an owner to spend resources (e.g., ETH/native token) to increase artifact energy.
    6.  `boostArtifact(uint256 tokenId, uint256 boostType)`: Allows an owner to apply a specific boost (could require payment/items).
    7.  `mutateArtifact(uint256 tokenIdA, uint256 tokenIdB)`: Allows combining/transforming two artifacts, potentially consuming one.
    8.  `claimEpochRewards(uint256 tokenId)`: Allows an owner to claim passive rewards generated by the artifact based on its state and current epoch.
    9.  `getRequiredFeedAmount(uint256 tokenId)`: Calculates the resource cost to feed an artifact currently.
    10. `canMutate(uint256 tokenIdA, uint256 tokenIdB)`: Checks if two artifacts meet the criteria for mutation.

**VII. System Mechanics (Epochs, Oracles, Parameters):**
    11. `getCurrentEpoch()`: Returns the ID of the current global epoch.
    12. `getEpochInfo(uint256 epochId)`: Retrieves information about a specific epoch.
    13. `simulateOracleUpdate(uint256 oracleData)`: Admin function to simulate external data influencing future parameters.
    14. `getGlobalParameter(uint256 parameterId)`: Retrieves the current value of a global evolution parameter.
    15. `influenceGlobalParameter(uint256 parameterId)`: Allows users to spend resources to influence the target value of a parameter for the *next* epoch.
    16. `processEpochEvolution()`: Function (callable by admin or keeper) that finalizes the current epoch, calculates new global parameters based on influence and oracle data, and starts a new epoch.

**VIII. Admin & Control Functions:**
    17. `setEvolutionParameter(uint256 parameterId, int256 newValue)`: Admin function to directly set a global parameter (can be used for overrides or initialization).
    18. `setBaseEvolutionRate(uint256 newRate)`: Admin function to set a core rate factor for evolution.
    19. `pauseContract()`: Admin function to pause critical user interactions.
    20. `unpauseContract()`: Admin function to unpause the contract.
    21. `withdrawAdminFunds(uint256 amount)`: Admin function to withdraw collected native tokens (e.g., from feeding fees).
    22. `setAdmin(address newAdmin)`: Admin function to transfer administrative privileges.

*(Note: We'll implement the core custom logic. A full ERC721 implementation adds ~10 standard functions like `transferFrom`, `ownerOf`, etc. which would easily push the count over 20, but are standard and not "creative". The 22 functions listed above focus on the unique aspects.)*

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // Using Ownable for Admin
import "@openzeppelin/contracts/utils/Pausable.sol"; // Using Pausable for control
// In a full implementation, you'd likely import ERC721Enumerable or similar
// import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

/**
 * @title ChronoArtifacts
 * @dev A contract managing dynamic, evolving digital assets.
 *      Artifacts change state based on time, user interaction, simulated external data,
 *      and community influence across global epochs.
 *
 * Outline:
 * I. State Variables (artifactState, epochs, globalParameters, etc.)
 * II. Structs (ArtifactState, EpochInfo)
 * III. Events (ArtifactMinted, ArtifactEvolved, EpochProcessed, etc.)
 * IV. Modifiers (onlyAdmin, whenNotPaused, etc.)
 * V. Core Asset State & Management (minting, getting state, metadata)
 * VI. Evolution & Interaction (evolving, feeding, boosting, mutating, claiming rewards)
 * VII. System Mechanics (epochs, oracles, parameter influence)
 * VIII. Admin & Control Functions (setting parameters, pausing, withdrawing)
 */
contract ChronoArtifacts is Ownable, Pausable {

    // --- I. State Variables ---

    // Stores the dynamic state for each artifact (beyond basic ERC721 data)
    struct ArtifactState {
        uint256 level;
        uint256 energy; // Resource artifacts consume or gain
        uint256[] traits; // Dynamic array of trait IDs/values
        uint256 creationTime;
        uint256 lastEvolvedTime;
        uint256 lastClaimedEpoch; // Tracks epoch for reward claiming
        // Assuming owner is tracked by ERC721 base, but including for clarity
        address owner; // Store owner here for simplicity in this example
    }

    // Global state for each epoch affecting all artifacts
    struct EpochInfo {
        uint256 startTime;
        uint256 endTime; // 0 until epoch is processed
        uint256 oracleDataSnapshot; // External data snapshot for this epoch
        // Global parameters *calculated* for this epoch based on influence/oracle
        mapping(uint256 => int256) effectiveGlobalParameters;
        // Total influence accumulated for the *next* epoch's parameters
        mapping(uint256 => uint256) accumulatedInfluence;
    }

    mapping(uint256 => ArtifactState) public artifactState;
    mapping(uint256 => EpochInfo) public epochs;

    // Base global parameters, can be adjusted by admin or epoch process
    mapping(uint256 => int256) private _globalParameters;

    uint256 private _currentTokenId; // Counter for minting
    uint256 public currentEpochId;

    // Enum-like constants for global parameters
    uint256 public constant PARAM_BASE_EVOLUTION_RATE = 1;
    uint256 public constant PARAM_ENERGY_DECAY_RATE = 2;
    uint256 public constant PARAM_ORACLE_INFLUENCE_FACTOR = 3;
    uint256 public constant PARAM_INFLUENCE_DECAY = 4;
    uint256 public constant PARAM_REWARD_MULTIPLIER = 5;
    // ... more parameters can be added

    // --- II. Structs (Defined above) ---

    // --- III. Events ---

    event ArtifactMinted(address indexed owner, uint256 indexed tokenId, uint256 creationTime);
    event ArtifactEvolved(uint256 indexed tokenId, uint256 newLevel, uint256 newEnergy);
    event ArtifactFed(uint256 indexed tokenId, address indexed feeder, uint256 energyAdded);
    event ArtifactBoosted(uint256 indexed tokenId, address indexed booster, uint256 boostType);
    event ArtifactMutated(uint256 indexed tokenIdA, uint256 indexed tokenIdB, uint256 resultingTokenId); // resultingTokenId could be A, B, or new
    event RewardsClaimed(uint256 indexed tokenId, address indexed owner, uint256 epochId, uint256 amount);
    event EpochProcessed(uint256 indexed epochId, uint256 nextEpochId, uint256 processedTime);
    event ParameterInfluenced(uint256 indexed epochId, uint256 indexed parameterId, address indexed user, uint256 influenceAmount);
    event GlobalParameterChanged(uint256 indexed parameterId, int256 oldValue, int256 newValue);
    // Paused/Unpaused events inherited from Pausable

    // --- IV. Modifiers ---

    modifier artifactExists(uint256 tokenId) {
        require(artifactState[tokenId].creationTime != 0, "Artifact does not exist");
        _;
    }

    // Using Ownable for onlyAdmin functionality

    // --- Constructor ---

    constructor() Ownable(msg.sender) {
        _currentTokenId = 0;
        currentEpochId = 1; // Start with epoch 1
        epochs[currentEpochId].startTime = block.timestamp;

        // Set initial global parameters
        _globalParameters[PARAM_BASE_EVOLUTION_RATE] = 100; // Example base rate
        _globalParameters[PARAM_ENERGY_DECAY_RATE] = -5; // Example decay
        _globalParameters[PARAM_ORACLE_INFLUENCE_FACTOR] = 1; // Example factor
        _globalParameters[PARAM_INFLUENCE_DECAY] = 0; // Example decay for influence
        _globalParameters[PARAM_REWARD_MULTIPLIER] = 1; // Example multiplier
        // Initialize effective parameters for the first epoch (or calculate in processEpochEvolution)
        epochs[currentEpochId].effectiveGlobalParameters[PARAM_BASE_EVOLUTION_RATE] = _globalParameters[PARAM_BASE_EVOLUTION_RATE];
        epochs[currentEpochId].effectiveGlobalParameters[PARAM_ENERGY_DECAY_RATE] = _globalParameters[PARAM_ENERGY_DECAY_RATE];
        epochs[currentEpochId].effectiveGlobalParameters[PARAM_ORACLE_INFLUENCE_FACTOR] = _globalParameters[PARAM_ORACLE_INFLUENCE_FACTOR];
        epochs[currentEpochId].effectiveGlobalParameters[PARAM_INFLUENCE_DECAY] = _globalParameters[PARAM_INFLUENCE_DECAY];
        epochs[currentEpochId].effectiveGlobalParameters[PARAM_REWARD_MULTIPLIER] = _globalParameters[PARAM_REWARD_MULTIPLIER];

    }

    // --- V. Core Asset State & Management ---

    /**
     * @dev Mints a new ChronoArtifact and initializes its state.
     * @param recipient The address to mint the artifact to.
     * @return The ID of the newly minted artifact.
     */
    function mintArtifact(address recipient) public onlyOwner whenNotPaused returns (uint256) {
        // In a real ERC721, you'd call _mint(recipient, newTokenId);
        uint256 newTokenId = _currentTokenId++;
        uint256 currentTime = block.timestamp;

        artifactState[newTokenId] = ArtifactState({
            level: 1,
            energy: 100, // Initial energy
            traits: _generateInitialTraits(), // Generate some initial traits
            creationTime: currentTime,
            lastEvolvedTime: currentTime,
            lastClaimedEpoch: currentEpochId -1, // Can claim from current epoch onwards
            owner: recipient // Storing owner here for example simplicity
        });

        emit ArtifactMinted(recipient, newTokenId, currentTime);

        return newTokenId;
    }

    /**
     * @dev Retrieves the current dynamic state of an artifact.
     * @param tokenId The ID of the artifact.
     * @return The ArtifactState struct.
     */
    function getArtifactState(uint256 tokenId) public view artifactExists(tokenId) returns (ArtifactState memory) {
        // Note: This returns a copy, state must be modified via other functions.
        // In a real ERC721, you'd also check ownerOf(tokenId) == msg.sender if needed.
        return artifactState[tokenId];
    }

    /**
     * @dev Simulates generating dynamic metadata URI based on artifact state.
     *      In a real application, this would often be a separate off-chain service
     *      reading the on-chain state and serving JSON metadata.
     * @param tokenId The ID of the artifact.
     * @return A string representing key dynamic metadata (simplified).
     */
    function getArtifactDynamicMetadata(uint256 tokenId) public view artifactExists(tokenId) returns (string memory) {
        ArtifactState storage artifact = artifactState[tokenId];
        // Example: return a simple string representation of key attributes
        bytes memory metadata = abi.encodePacked(
            '{"level":', Strings.toString(artifact.level),
            ',"energy":', Strings.toString(artifact.energy),
            // Add traits, timestamps etc.
            '}'
        );
        return string(metadata);
    }

    /**
     * @dev Returns the total number of artifacts minted.
     */
    function getTotalArtifactSupply() public view returns (uint256) {
        return _currentTokenId;
    }

    // --- VI. Evolution & Interaction ---

    /**
     * @dev Triggers the evolution process for a specific artifact.
     *      Artifact state (level, energy, traits) updates based on time elapsed
     *      and the effective global parameters of the current epoch.
     * @param tokenId The ID of the artifact to evolve.
     */
    function evolveArtifact(uint256 tokenId) public whenNotPaused artifactExists(tokenId) {
         require(msg.sender == artifactState[tokenId].owner, "Not artifact owner"); // Or allow anyone to trigger? Let's restrict for now.

        ArtifactState storage artifact = artifactState[tokenId];
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - artifact.lastEvolvedTime;

        // Prevent evolving too frequently (optional)
        // require(timeElapsed >= 60, "Evolution cooldown"); // Example: min 1 minute

        // Get effective parameters for the current epoch
        EpochInfo storage currentEpoch = epochs[currentEpochId];
        int256 baseRate = currentEpoch.effectiveGlobalParameters[PARAM_BASE_EVOLUTION_RATE];
        int256 energyDecay = currentEpoch.effectiveGlobalParameters[PARAM_ENERGY_DECAY_RATE];

        // --- Apply Evolution Logic ---

        // Energy change based on time and decay rate
        // Energy can decay or regenerate depending on the sign of energyDecay
        int256 energyChange = timeElapsed * energyDecay / 3600; // Example: per hour decay/regen

        if (energyChange < 0) {
             if (artifact.energy < uint256(-energyChange)) {
                 artifact.energy = 0;
             } else {
                 artifact.energy = artifact.energy - uint256(-energyChange);
             }
        } else {
            artifact.energy = artifact.energy + uint256(energyChange);
        }
        // Clamp energy to a reasonable range (e.g., 0-1000)
        artifact.energy = artifact.energy > 1000 ? 1000 : artifact.energy;


        // Level increases based on energy, time, and base rate
        uint256 levelIncrease = (timeElapsed * uint256(baseRate > 0 ? baseRate : 0) / 86400) // Example: per day level increase
                                + (artifact.energy / 100); // Example: energy contributes to level

        artifact.level = artifact.level + levelIncrease;

        // Traits could also evolve based on level, energy, or random factors (need randomness source)
        // _evolveTraits(artifact); // Placeholder function

        artifact.lastEvolvedTime = currentTime;

        emit ArtifactEvolved(tokenId, artifact.level, artifact.energy);
    }

     /**
      * @dev Allows an artifact owner to spend native token (ETH) to increase its energy.
      *      Requires a certain amount of ETH based on artifact state.
      * @param tokenId The ID of the artifact to feed.
      */
    function feedArtifact(uint256 tokenId) public payable whenNotPaused artifactExists(tokenId) {
        require(msg.sender == artifactState[tokenId].owner, "Not artifact owner");

        uint256 requiredAmount = getRequiredFeedAmount(tokenId);
        require(msg.value >= requiredAmount, "Insufficient funds to feed");

        ArtifactState storage artifact = artifactState[tokenId];
        uint256 energyAdded = msg.value / (requiredAmount / 100); // Example: Every X wei gives 100 energy

        artifact.energy = artifact.energy + energyAdded;
        // Clamp energy
        artifact.energy = artifact.energy > 1000 ? 1000 : artifact.energy;

        // Refund excess Ether
        if (msg.value > requiredAmount) {
            payable(msg.sender).transfer(msg.value - requiredAmount);
        }

        emit ArtifactFed(tokenId, msg.sender, energyAdded);
    }

    /**
     * @dev Allows an artifact owner to apply a specific boost to an artifact.
     *      Boosts could be temporary stat increases, trait changes, etc.
     *      (Implementation requires defining different boost types and effects).
     * @param tokenId The ID of the artifact to boost.
     * @param boostType The type of boost to apply (e.g., 1 for Energy Boost, 2 for XP Boost).
     */
    function boostArtifact(uint256 tokenId, uint256 boostType) public whenNotPaused artifactExists(tokenId) {
        require(msg.sender == artifactState[tokenId].owner, "Not artifact owner");
        // Require payment or burning of another token/NFT here if needed
        // require(IERC20(BOOST_TOKEN_ADDRESS).transferFrom(msg.sender, address(this), BOOST_COST), "Token transfer failed");

        ArtifactState storage artifact = artifactState[tokenId];

        if (boostType == 1) { // Example: Energy Boost
            artifact.energy += 200;
             artifact.energy = artifact.energy > 1000 ? 1000 : artifact.energy;
        } else if (boostType == 2) { // Example: Level Boost (smaller)
            artifact.level += 5;
        }
        // ... implement more boost types

        emit ArtifactBoosted(tokenId, msg.sender, boostType);
    }

    /**
     * @dev Allows an owner to attempt to mutate two artifacts.
     *      Requires specific conditions (`canMutate`).
     *      Example logic: Combines traits and level of B into A, consumes B.
     * @param tokenIdA The ID of the primary artifact (will be modified).
     * @param tokenIdB The ID of the secondary artifact (will potentially be consumed).
     * @return The ID of the resulting artifact (could be tokenIdA or a new one).
     */
    function mutateArtifact(uint256 tokenIdA, uint256 tokenIdB) public whenNotPaused artifactExists(tokenIdA) artifactExists(tokenIdB) returns (uint256 resultingTokenId) {
        require(tokenIdA != tokenIdB, "Cannot mutate an artifact with itself");
        require(msg.sender == artifactState[tokenIdA].owner, "Not owner of artifact A");
        require(msg.sender == artifactState[tokenIdB].owner, "Not owner of artifact B");
        require(canMutate(tokenIdA, tokenIdB), "Artifacts do not meet mutation criteria");

        ArtifactState storage artifactA = artifactState[tokenIdA];
        ArtifactState storage artifactB = artifactState[tokenIdB];

        // --- Mutation Logic (Example) ---
        // Combine traits (simple concatenation for demo)
        for(uint i = 0; i < artifactB.traits.length; i++) {
            artifactA.traits.push(artifactB.traits[i]);
        }

        // Increase level of A based on B's level
        artifactA.level += artifactB.level / 2; // Example: 50% of B's level added to A

        // Increase energy of A based on B's energy
        artifactA.energy += artifactB.energy / 5; // Example: 20% of B's energy added to A
        artifactA.energy = artifactA.energy > 1000 ? 1000 : artifactA.energy;

        // Consume artifact B (remove its state and ownership)
        // In a full ERC721, you'd call _burn(tokenIdB);
        delete artifactState[tokenIdB];
        // Note: If using ERC721Enumerable, _burn handles token supply/ownership.
        // Without it, you'd need manual tracking/removal of tokenIdB from supply/owner list.

        resultingTokenId = tokenIdA; // In this example, A is modified, B is consumed. Could mint a new one.

        emit ArtifactMutated(tokenIdA, tokenIdB, resultingTokenId);
    }


    /**
     * @dev Allows an artifact owner to claim passive rewards generated per epoch.
     *      Reward amount depends on artifact state (e.g., level, traits) and epoch parameters.
     * @param tokenId The ID of the artifact.
     */
    function claimEpochRewards(uint256 tokenId) public whenNotPaused artifactExists(tokenId) {
        require(msg.sender == artifactState[tokenId].owner, "Not artifact owner");

        ArtifactState storage artifact = artifactState[tokenId];
        uint256 lastClaimed = artifact.lastClaimedEpoch;
        uint256 current = currentEpochId;

        require(current > lastClaimed, "Rewards already claimed for current or future epochs");

        uint256 totalRewards = 0;
        // Claim rewards for all epochs since last claimed
        for (uint256 epochToClaim = lastClaimed + 1; epochToClaim <= current; epochToClaim++) {
             // Ensure epoch data exists (might not for very early epochs if not processed)
             // In a real system, processEpochEvolution would ensure this.
             if (epochs[epochToClaim].startTime == 0) continue;

             // Calculate rewards for this specific epoch based on artifact state *at the time evolution was last processed for this artifact*
             // A more complex system might snapshot state per epoch.
             // For simplicity, use current state + epoch parameters.
             uint252 effectiveRewardMultiplier = uint256(epochs[epochToClaim].effectiveGlobalParameters[PARAM_REWARD_MULTIPLIER]);
             uint256 epochRewards = (artifact.level * 10) + (artifact.energy / 10); // Example: Base on level and energy
             epochRewards = epochRewards * effectiveRewardMultiplier / 100; // Apply epoch multiplier (scaled by 100)

             totalRewards += epochRewards;
        }

        require(totalRewards > 0, "No rewards available to claim");

        // Transfer rewards (Example: Transfer native token)
        // In a real system, this might be a separate reward token or staked balance
        // require(address(this).balance >= totalRewards, "Contract balance too low for rewards");
        // payable(msg.sender).transfer(totalRewards); // Be careful with re-entrancy!

        // For this example, let's just update state and emit event, assuming rewards are handled differently
        artifact.lastClaimedEpoch = current; // Mark as claimed up to current epoch

        emit RewardsClaimed(tokenId, msg.sender, current, totalRewards);
    }

    /**
     * @dev Calculates the required native token amount to feed an artifact.
     *      Cost increases with level or energy.
     * @param tokenId The ID of the artifact.
     * @return The amount of native token (wei) required.
     */
    function getRequiredFeedAmount(uint256 tokenId) public view artifactExists(tokenId) returns (uint256) {
        ArtifactState storage artifact = artifactState[tokenId];
        // Example formula: Cost scales with level and current energy
        return (artifact.level * 1 ether / 100) + ((1000 - artifact.energy) * 1 ether / 500); // More expensive if energy is low, and scales with level
    }

    /**
     * @dev Checks if two artifacts meet the criteria for mutation.
     *      Example criteria: Minimum levels, specific traits.
     * @param tokenIdA The ID of the first artifact.
     * @param tokenIdB The ID of the second artifact.
     * @return True if mutation is possible, false otherwise.
     */
    function canMutate(uint256 tokenIdA, uint256 tokenIdB) public view artifactExists(tokenIdA) artifactExists(tokenIdB) returns (bool) {
        ArtifactState storage artifactA = artifactState[tokenIdA];
        ArtifactState storage artifactB = artifactState[tokenIdB];

        // Example criteria:
        // - Both artifacts must be at least level 10
        // - Artifact A must have trait 5, Artifact B must have trait 7
        bool hasTrait5A = false;
        for(uint i=0; i<artifactA.traits.length; i++) { if (artifactA.traits[i] == 5) hasTrait5A = true; }
        bool hasTrait7B = false;
         for(uint i=0; i<artifactB.traits.length; i++) { if (artifactB.traits[i] == 7) hasTrait7B = true; }


        return artifactA.level >= 10 && artifactB.level >= 10 && hasTrait5A && hasTrait7B;
    }

    // --- VII. System Mechanics ---

    /**
     * @dev Returns the ID of the current active epoch.
     */
    function getCurrentEpoch() public view returns (uint256) {
        return currentEpochId;
    }

    /**
     * @dev Retrieves information about a specific epoch.
     * @param epochId The ID of the epoch.
     * @return The EpochInfo struct for the epoch.
     */
    function getEpochInfo(uint256 epochId) public view returns (EpochInfo memory) {
        // Note: This returns a copy of the struct, mapping members are not returned directly.
        // If you need effective parameters or influence, query them specifically.
        return epochs[epochId];
    }

    /**
     * @dev Admin function to simulate external data (e.g., from an oracle).
     *      This data will influence global parameters in the *next* epoch.
     * @param oracleData The simulated external data value.
     */
    function simulateOracleUpdate(uint256 oracleData) public onlyOwner {
        // Store oracle data to be processed for the *next* epoch
        epochs[currentEpochId + 1].oracleDataSnapshot = oracleData;
        // Note: A real oracle integration would use Chainlink or similar.
    }

    /**
     * @dev Retrieves the current effective value of a global evolution parameter for the *current* epoch.
     * @param parameterId The ID of the parameter.
     * @return The effective value of the parameter.
     */
    function getGlobalParameter(uint256 parameterId) public view returns (int256) {
        // Return the parameter value effective for the *current* epoch
        return epochs[currentEpochId].effectiveGlobalParameters[parameterId];
    }


    /**
     * @dev Allows users to spend native token (ETH) to influence a global parameter
     *      for the *next* epoch. Influence accumulates per parameter per epoch.
     * @param parameterId The ID of the parameter to influence.
     */
    function influenceGlobalParameter(uint256 parameterId) public payable whenNotPaused {
        require(parameterId > 0, "Invalid parameter ID");
        require(msg.value > 0, "Must send value to influence");

        uint256 influenceAmount = msg.value; // 1 wei sent gives 1 influence point (example)
        // Could add logic where higher level artifacts give more influence per wei

        // Accumulate influence for the *next* epoch
        epochs[currentEpochId + 1].accumulatedInfluence[parameterId] += influenceAmount;

        emit ParameterInfluenced(currentEpochId + 1, parameterId, msg.sender, influenceAmount);
    }

    /**
     * @dev Callable by admin or keeper. Finalizes the current epoch, calculates
     *      the new effective global parameters for the next epoch based on
     *      accumulated influence and oracle data, and increments the epoch counter.
     *      This function should ideally be called periodically (e.g., daily).
     */
    function processEpochEvolution() public onlyOwner { // Restricted to owner for simplicity
        // Could add logic to allow anyone to call after a delay if rewards are offered for keepers

        uint256 previousEpochId = currentEpochId;
        uint256 nextEpochId = currentEpochId + 1;

        EpochInfo storage currentEpoch = epochs[previousEpochId];
        EpochInfo storage nextEpoch = epochs[nextEpochId];

        currentEpoch.endTime = block.timestamp; // Mark current epoch as ended
        nextEpoch.startTime = block.timestamp; // Mark next epoch as started

        // --- Calculate next epoch's effective parameters ---
        // Logic here is key: how influence and oracle data modify base parameters
        // Example:
        // new_param_value = base_param_value + (accumulated_influence * influence_factor) + (oracle_data * oracle_factor)

        // Carry over base parameters first
        nextEpoch.effectiveGlobalParameters[PARAM_BASE_EVOLUTION_RATE] = _globalParameters[PARAM_BASE_EVOLUTION_RATE];
        nextEpoch.effectiveGlobalParameters[PARAM_ENERGY_DECAY_RATE] = _globalParameters[PARAM_ENERGY_DECAY_RATE];
        nextEpoch.effectiveGlobalParameters[PARAM_ORACLE_INFLUENCE_FACTOR] = _globalParameters[PARAM_ORACLE_INFLUENCE_FACTOR];
        nextEpoch.effectiveGlobalParameters[PARAM_INFLUENCE_DECAY] = _globalParameters[PARAM_INFLUENCE_DECAY];
        nextEpoch.effectiveGlobalParameters[PARAM_REWARD_MULTIPLIER] = _globalParameters[PARAM_REWARD_MULTIPLIER];
        // ... handle all base parameters

        // Apply influence from the *previous* epoch's accumulation to the *next* epoch's parameters
        // (Influence is accumulated for the epoch *after* the current one)
        // This requires looking at epochs[currentEpochId].accumulatedInfluence, which was for NEXT epoch
        // Correction: Influence is accumulated for epoch `currentEpochId + 1`. So process it for `nextEpochId`.
        // We need to get the influence accumulated *during* previousEpochId for *this* nextEpochId
        EpochInfo storage influenceSourceEpoch = epochs[previousEpochId]; // Influence collected *during* previous epoch

        nextEpoch.effectiveGlobalParameters[PARAM_BASE_EVOLUTION_RATE] += int256(influenceSourceEpoch.accumulatedInfluence[PARAM_BASE_EVOLUTION_RATE] / 1 ether); // Example: 1 ETH influence = +1 to base rate
        // Apply oracle data snapshot from nextEpoch (where it was stored)
         nextEpoch.effectiveGlobalParameters[PARAM_BASE_EVOLUTION_RATE] += int256(nextEpoch.oracleDataSnapshot * nextEpoch.effectiveGlobalParameters[PARAM_ORACLE_INFLUENCE_FACTOR]);


        // Apply influence and oracle data to other parameters similarly...
        // nextEpoch.effectiveGlobalParameters[PARAM_ENERGY_DECAY_RATE] += ...

        // Reset influence accumulation for the *next* next epoch (currentEpochId + 2)
        // This is already handled by the mapping structure, as new influence goes into epochs[nextEpochId + 1].accumulatedInfluence


        currentEpochId = nextEpochId; // Advance epoch counter

        emit EpochProcessed(previousEpochId, currentEpochId, block.timestamp);
    }

    // --- VIII. Admin & Control Functions ---

    /**
     * @dev Admin function to directly set the value of a global evolution parameter.
     *      This bypasses the influence/oracle system for direct tuning.
     * @param parameterId The ID of the parameter to set.
     * @param newValue The new value for the parameter.
     */
    function setEvolutionParameter(uint256 parameterId, int256 newValue) public onlyOwner {
        require(parameterId > 0, "Invalid parameter ID");
        int256 oldValue = _globalParameters[parameterId];
        _globalParameters[parameterId] = newValue;
        // Also update the *current* epoch's effective parameter if this is meant to be immediate
        epochs[currentEpochId].effectiveGlobalParameters[parameterId] = newValue;
        emit GlobalParameterChanged(parameterId, oldValue, newValue);
    }

    /**
     * @dev Admin function to set the base rate factor for evolution.
     * @param newRate The new base evolution rate.
     */
    function setBaseEvolutionRate(uint256 newRate) public onlyOwner {
         setEvolutionParameter(PARAM_BASE_EVOLUTION_RATE, int256(newRate));
    }


    /**
     * @dev Pauses the contract, preventing most interactions.
     */
    function pauseContract() public onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the contract, allowing interactions.
     */
    function unpauseContract() public onlyOwner {
        _unpause();
    }

    /**
     * @dev Allows the admin to withdraw accumulated native token (ETH).
     *      E.g., from feeding fees.
     * @param amount The amount to withdraw.
     */
    function withdrawAdminFunds(uint256 amount) public onlyOwner {
        require(amount <= address(this).balance, "Insufficient contract balance");
        payable(owner()).transfer(amount);
    }

    // Override the default transferOwnership from Ownable if needed
    // function transferOwnership(address newOwner) public override onlyOwner {
    //    // Add custom logic if necessary
    //    super.transferOwnership(newOwner);
    // }


    // --- Internal Helper Functions ---

    /**
     * @dev Generates initial traits for a new artifact. (Placeholder)
     * @return An array of trait IDs/values.
     */
    function _generateInitialTraits() internal pure returns (uint256[] memory) {
        // In a real implementation, this could involve:
        // - Using Chainlink VRF for randomness
        // - Deterministic generation based on block hash, timestamp, or minter address
        // - Simple fixed traits for now
        uint256[] memory traits = new uint256[](2);
        traits[0] = 1; // Example Trait 1
        traits[1] = 10; // Example Trait 2
        return traits;
    }

    /**
     * @dev Placeholder for trait evolution logic. (Internal)
     * @param artifact The artifact state to evolve traits for.
     */
    function _evolveTraits(ArtifactState storage artifact) internal {
        // Logic to add, remove, or change trait values based on level, energy, etc.
        // Example: If level > 50, add trait 3
        bool hasTrait3 = false;
        for(uint i=0; i<artifact.traits.length; i++) { if (artifact.traits[i] == 3) hasTrait3 = true; }

        if (artifact.level > 50 && !hasTrait3) {
            artifact.traits.push(3);
        }
        // More complex trait evolution rules...
    }

    // --- Required for Pausable ---
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {
        // This function would be implemented if inheriting from ERC721
        // You would add require(whenNotPaused) here in a full ERC721 contract
    }

    // --- Required for String Conversion (for metadata, etc.) ---
    // Minimal integer to string conversion
    library Strings {
        function toString(uint256 value) internal pure returns (string memory) {
            if (value == 0) {
                return "0";
            }
            uint256 temp = value;
            uint256 digits;
            while (temp != 0) {
                digits++;
                temp /= 10;
            }
            bytes memory buffer = new bytes(digits);
            while (value != 0) {
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + value % 10));
                value /= 10;
            }
            return string(buffer);
        }
        // Add int256 toString if needed
        // function toString(int256 value) internal pure returns (string memory) { ... }
    }
}
```

**Explanation of Advanced Concepts & Creativity:**

1.  **Dynamic State & Metadata:** Artifacts aren't static NFTs. Their `level`, `energy`, and `traits` change over time and through interaction. The `getArtifactDynamicMetadata` function hints at how this on-chain state would feed into off-chain services to provide dynamic visuals or descriptions.
2.  **Epoch-Based System:** Dividing time into `epochs` with specific `EpochInfo` structs creates discrete periods where rules or parameters can change. This is common in games or economic simulations.
3.  **Time-Based Passive Evolution (`evolveArtifact`):** Artifacts automatically change state based on the time elapsed since their last evolution. This requires tracking time and applying formulas based on global parameters.
4.  **Resource Management (`feedArtifact`):** Introduces a basic resource (`energy`) that needs management, potentially consuming native tokens, adding an economic sink.
5.  **Asset Mutation (`mutateArtifact`, `canMutate`):** A creative concept where two assets can interact to change one or both of them, potentially consuming one of the inputs. This adds strategic depth.
6.  **Simulated Oracle Influence (`simulateOracleUpdate`, `EpochInfo.oracleDataSnapshot`):** Demonstrates how external data could be fed into the system to influence global rules. In a real dApp, this would use Chainlink or a custom oracle solution.
7.  **Community Parameter Influence (`influenceGlobalParameter`, `EpochInfo.accumulatedInfluence`, `processEpochEvolution`):** Allows users to spend resources to vote or exert influence on how the *next* epoch's global parameters are calculated. This is a simplified on-chain governance/influence mechanism. `processEpochEvolution` is the core logic that aggregates this influence and the oracle data.
8.  **Layered Parameters:** Having base parameters (`_globalParameters`) that are then modified by epoch-specific factors (influence, oracle data) to create `effectiveGlobalParameters` adds complexity and points for tuning.
9.  **Passive Rewards (`claimEpochRewards`):** Artifacts generate rewards based on their state and the parameters of past epochs, claimable by the owner.
10. **Pausable and Ownable:** Standard but essential patterns for managing complex contracts, allowing for upgrades, bug fixes, or emergency stops.

This contract provides a blueprint for a sophisticated system where digital assets are living, interacting entities governed by dynamic on-chain rules and influenced by both user actions and external factors. It contains 22 custom functions beyond basic ERC721 methods, fulfilling the requirement. (Note: A full ERC721 implementation would add standard functions like `transferFrom`, `ownerOf`, `balanceOf`, `approve`, `getApproved`, `setApprovalForAll`, `isApprovedForAll`, `tokenByIndex`, `tokenOfOwnerByIndex` - at least 10 more, easily exceeding 30 functions in total).