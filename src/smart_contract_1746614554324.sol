Okay, here is a Solidity smart contract concept called "CryptoNexus". It blends elements of dynamic NFTs, resource management, reputation, conditional logic, and node-based interactions, going beyond standard token or simple NFT contracts. It aims for interesting, advanced, and creative functionalities.

---

**Smart Contract: CryptoNexus**

**Outline and Function Summary:**

This contract is an extension of ERC721, representing unique digital entities called "Nodes". Nodes have dynamic attributes, belong to specific types, and can interact with each other and their owners in complex ways based on reputation, resources, and predefined conditions.

1.  **Core ERC721 Functionality:** Standard NFT ownership, transfer, approval.
2.  **Node State & Attributes:** Define and manage Node types, dynamic attributes (e.g., power, decayRate, resourceGeneration), and associated metadata.
3.  **Reputation System:** Track reputation for users based on their interactions within the Nexus. Reputation can unlock capabilities.
4.  **Resource System (Internal):** Manage abstract resources required for or generated by Node interactions.
5.  **Node Interactions:**
    *   **Creation:** Minting new Nodes, potentially based on user reputation or resources.
    *   **Attribute Management:** Updating attributes, triggering decay, claiming generated resources.
    *   **Linking:** Creating logical links between owned Nodes based on conditions.
    *   **Combination/Splitting:** More complex operations where Nodes are burned to create new ones or resources, based on specific rules and attribute calculations.
    *   **Conditional Actions:** A generic function to execute various state changes on Nodes or users, contingent upon multiple dynamic conditions (node state, reputation, resources, time).
6.  **Delegation:** Allow users to delegate specific *action permissions* for their Nodes to other addresses, providing granular control beyond standard ERC721 approval.
7.  **Configuration:** Owner-controlled functions to set parameters, formulas, and thresholds governing node behavior, interactions, and reputation/resource dynamics.
8.  **Utility & System:** Standard Ownable, Pausable, and withdrawal functions, plus helper views.

**Total Public/External/View Functions (approx. 40+):** Includes inherited ERC721 functions and custom functions listed below.

**Key Custom Functions:**

1.  `createNode`: Mint a new node instance with initial attributes.
2.  `updateNodeAttributes`: Directly modify specific attributes of a node (owner/delegate controlled).
3.  `triggerNodeDecay`: Manually or programmatically trigger attribute decay for a node based on time elapsed.
4.  `claimGeneratedResources`: Collect resources passively generated by a node since the last claim.
5.  `getReputation`: Retrieve a user's current reputation score.
6.  `getUserResourceBalance`: Retrieve a user's balance of the internal resource.
7.  `linkNodes`: Create a directional link between two owned nodes, subject to type/attribute/reputation/resource constraints.
8.  `unlinkNodes`: Remove an existing link between nodes.
9.  `getNodesLinkedTo`: Get the list of nodes linked *from* a specific node.
10. `combineNodes`: Burn a set of owned nodes and mint a new node, deriving attributes and consuming resources based on configuration. (Complex, requires NonReentrant)
11. `splitNode`: Burn an owned node and mint a set of new nodes or generate resources, based on the burned node's attributes and configuration. (Complex, requires NonReentrant)
12. `executeConditionalAction`: A versatile function to perform an action (e.g., attribute boost, resource transfer, reputation change) on a node or user *only if* a predefined set of on-chain conditions are met (using enum for action types and conditions). (Complex, requires NonReentrant)
13. `delegateActionPermission`: Grant a specific address permission to execute certain actions (like `updateNodeAttributes` or `triggerNodeDecay`) on a particular node owned by the caller.
14. `revokeActionPermission`: Remove a previously granted action delegation.
15. `getDelegatePermissions`: View the list of actions an address is permitted to perform on a node.
16. `previewCombineNodesResult`: Simulate the result (attributes of the new node, resource cost, reputation effect) of a `combineNodes` operation without executing it. (View function)
17. `previewSplitNodeResult`: Simulate the result (attributes of new nodes, resource output, reputation effect) of a `splitNode` operation. (View function)
18. `getNodeAttributeFormula`: View the currently set formula/parameters used for calculating attribute changes (e.g., decay rate, generation rate). (View function, Owner-set config)
19. `getLinkingConstraints`: View the currently set requirements (node types, min attributes, min reputation, resource cost) for linking specific node types. (View function, Owner-set config)
20. `getReputationThresholds`: View the reputation scores required to perform certain actions (e.g., create a specific node type). (View function, Owner-set config)
21. `batchUpdateNodeAttributes`: Update attributes for multiple nodes in a single transaction. (Requires NonReentrant)
22. `batchClaimGeneratedResources`: Claim resources for multiple nodes in a single transaction. (Requires NonReentrant)
23. `getTotalNodesOfType`: Get the total number of nodes minted for a specific type. (View function)
24. `setNodeAttributeFormula`: (Owner Only) Set or update the parameters for attribute formulas.
25. `setLinkingConstraints`: (Owner Only) Set or update the constraints required for linking nodes.
26. `setReputationThresholds`: (Owner Only) Set or update the reputation requirements for various actions.
27. `pause`: (Owner Only, Pausable) Pause core contract interactions.
28. `unpause`: (Owner Only, Pausable) Unpause core contract interactions.
29. `withdrawEth`: (Owner Only) Withdraw any ETH sent to the contract.

(Plus standard ERC721 functions: `name`, `symbol`, `totalSupply`, `balanceOf`, `ownerOf`, `transferFrom`, `safeTransferFrom`, `approve`, `setApprovalForAll`, `getApproved`, `isApprovedForAll`, `supportsInterface`, `transferOwnership`, `renounceOwnership`).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; // For tracking linked nodes efficiently

// --- Smart Contract: CryptoNexus ---
//
// Outline and Function Summary:
//
// This contract is an extension of ERC721, representing unique digital entities called "Nodes".
// Nodes have dynamic attributes, belong to specific types, and can interact with each other
// and their owners in complex ways based on reputation, resources, and predefined conditions.
//
// 1.  Core ERC721 Functionality: Standard NFT ownership, transfer, approval.
// 2.  Node State & Attributes: Define and manage Node types, dynamic attributes (e.g., power, decayRate, resourceGeneration), and associated metadata.
// 3.  Reputation System: Track reputation for users based on their interactions within the Nexus. Reputation can unlock capabilities.
// 4.  Resource System (Internal): Manage abstract resources required for or generated by Node interactions.
// 5.  Node Interactions: Creation, Attribute Management (Update, Decay, Claim), Linking, Combination/Splitting, Conditional Actions.
// 6.  Delegation: Allow users to delegate specific *action permissions* for their Nodes to other addresses.
// 7.  Configuration: Owner-controlled functions to set parameters, formulas, and thresholds.
// 8.  Utility & System: Standard Ownable, Pausable, ReentrancyGuard, withdrawal functions, plus helper views.
//
// Total Public/External/View Functions: Includes inherited ERC721 functions and custom functions (approx. 40+ total).
//
// Key Custom Functions (selected, see full list below):
// createNode, updateNodeAttributes, triggerNodeDecay, claimGeneratedResources,
// getReputation, getUserResourceBalance, linkNodes, unlinkNodes, getNodesLinkedTo,
// combineNodes, splitNode, executeConditionalAction, delegateActionPermission,
// revokeActionPermission, getDelegatePermissions, previewCombineNodesResult,
// previewSplitNodeResult, getNodeAttributeFormula, getLinkingConstraints,
// getReputationThresholds, batchUpdateNodeAttributes, batchClaimGeneratedResources,
// getTotalNodesOfType, setNodeAttributeFormula (Owner), setLinkingConstraints (Owner),
// setReputationThresholds (Owner), pause (Owner), unpause (Owner), withdrawEth (Owner).
// ----------------------------------

contract CryptoNexus is ERC721, Ownable, Pausable, ReentrancyGuard {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    using EnumerableSet for EnumerableSet.UintSet;
    using EnumerableSet for EnumerableSet.AddressSet;

    // --- Errors ---
    error CryptoNexus__InvalidNodeId();
    error CryptoNexus__NotNodeOwnerOrApproved();
    error CryptoNexus__NotNodeOwnerOrDelegate();
    error CryptoNexus__InsufficientReputation();
    error CryptoNexus__InsufficientResources();
    error CryptoNexus__InvalidNodeStateForOperation();
    error CryptoNexus__LinkingConstraintViolated();
    error CryptoNexus__NodesAlreadyLinked();
    error CryptoNexus__NodesNotLinked();
    error CryptoNexus__InvalidCombinationInput();
    error CryptoNexus__InvalidSplitInput();
    error CryptoNexus__InvalidConditionalAction();
    error CryptoNexus__ConditionsNotMet();
    error CryptoNexus__ActionPermissionDenied();
    error CryptoNexus__InvalidNodeAddressOrId();
    error CryptoNexus__NoEthToWithdraw();

    // --- Structs ---

    enum NodeType { Basic, Advanced, Elite } // Example Node Types

    struct NodeAttributes {
        uint256 power; // Example attribute
        uint256 decayRate; // How fast attributes decay (simulated)
        uint256 resourceGenerationRate; // How fast resources are generated (simulated)
        // Add more attributes as needed
    }

    struct Node {
        NodeType nodeType;
        NodeAttributes attributes;
        uint65 lastDecayOrClaimTime; // Use uint64 for timestamp (max ~584 billion years)
        string metadataURI;
    }

    // Structs for Configuration
    struct AttributeFormulaParams {
        int256 decayMultiplier;
        int256 generationMultiplier;
        // Add more parameters as needed for formulas
    }

    struct LinkingConstraint {
        NodeType requiredSourceType;
        NodeType requiredTargetType;
        uint256 minSourceAttribute;
        uint256 minTargetAttribute;
        uint256 minReputation;
        uint256 resourceCost;
    }

    struct ReputationThresholds {
        uint256 createAdvancedNode;
        uint256 createEliteNode;
        uint256 linkNodes;
        uint256 combineNodes;
        uint256 splitNode;
        // Add thresholds for other gated actions
    }

    enum ConditionalActionType {
        BoostAttribute,
        TransferResourceToOwner,
        ApplyReputationEffect,
        TriggerChainReaction // Example: trigger decay on linked nodes
    }

    enum ConditionType {
        NodeAttributeMin,
        NodeAttributeMax,
        UserReputationMin,
        UserResourceMin,
        TimeSinceLastAction
    }

    struct Condition {
        ConditionType conditionType;
        uint256 value; // Threshold value
        bytes32 attributeKey; // For NodeAttributeMin/Max (e.g., hash of "power")
        uint256 targetNodeId; // Which node to check (if applicable)
    }

    // --- State Variables ---

    mapping(uint256 => Node) private _nodes;
    mapping(address => uint256) private _reputation; // User reputation score
    mapping(address => uint256) private _resourceBalances; // User resource balance

    // Node Linking: node -> set of nodes it links *to*
    mapping(uint256 => EnumerableSet.UintSet) private _nodeLinks;

    // Delegation: node -> delegate address -> set of action types permitted
    mapping(uint256 => mapping(address => EnumerableSet.UintSet)) private _nodeActionDelegations;

    // Configuration Mappings
    mapping(NodeType => AttributeFormulaParams) private _attributeFormulas;
    LinkingConstraint[] private _linkingConstraints; // Array of possible linking rules
    ReputationThresholds private _reputationThresholds;

    // Mapping attribute name strings to bytes32 for Condition struct
    mapping(string => bytes32) private _attributeKeys;

    // --- Events ---

    event NodeCreated(uint256 indexed tokenId, address indexed owner, NodeType nodeType, NodeAttributes initialAttributes);
    event AttributesUpdated(uint256 indexed tokenId, NodeAttributes newAttributes);
    event ReputationChanged(address indexed user, int256 reputationDelta, uint256 newReputation);
    event ResourceBalanceChanged(address indexed user, int256 resourceDelta, uint256 newBalance);
    event NodesLinked(uint256 indexed sourceNodeId, uint256 indexed targetNodeId);
    event NodesUnlinked(uint256 indexed sourceNodeId, uint256 indexed targetNodeId);
    event NodesCombined(address indexed owner, uint256[] indexed burnedNodeIds, uint256 indexed newNodeId);
    event NodeSplit(address indexed owner, uint256 indexed burnedNodeId, uint256[] indexed newNodesIds, uint256 resourceOutput);
    event ConditionalActionExecuted(uint256 indexed tokenId, ConditionalActionType actionType, bytes actionData, bool success);
    event ActionPermissionDelegated(uint256 indexed tokenId, address indexed delegate, uint256 indexed actionType);
    event ActionPermissionRevoked(uint256 indexed tokenId, address indexed delegate, uint256 indexed actionType);
    event ConfigUpdated(bytes32 indexed configType); // Generic event for config changes

    // --- Constructor ---

    constructor(string memory name, string memory symbol)
        ERC721(name, symbol)
        Ownable(msg.sender)
    {
        // Initialize attribute keys
        _attributeKeys["power"] = keccak256("power");
        _attributeKeys["decayRate"] = keccak256("decayRate");
        _attributeKeys["resourceGenerationRate"] = keccak256("resourceGenerationRate");

        // Set some initial default configurations (Owner can change later)
        _attributeFormulas[NodeType.Basic] = AttributeFormulaParams({ decayMultiplier: -1, generationMultiplier: 2 });
        _attributeFormulas[NodeType.Advanced] = AttributeFormulaParams({ decayMultiplier: -2, generationMultiplier: 5 });
        _attributeFormulas[NodeType.Elite] = AttributeFormulaParams({ decayMultiplier: -3, generationMultiplier: 10 });

        _reputationThresholds = ReputationThresholds({
            createAdvancedNode: 10,
            createEliteNode: 50,
            linkNodes: 5,
            combineNodes: 20,
            splitNode: 30
        });

        // Add a default linking constraint example (Owner can add/remove more)
        _linkingConstraints.push(LinkingConstraint({
            requiredSourceType: NodeType.Basic,
            requiredTargetType: NodeType.Basic,
            minSourceAttribute: 5,
            minTargetAttribute: 5,
            minReputation: 0,
            resourceCost: 10
        }));

         _pause(); // Start paused, owner unpauses when ready
    }

    // --- Modifier for checking node ownership or specific delegation ---
    modifier onlyNodeOwnerOrDelegate(uint256 tokenId, ConditionalActionType actionType) {
        if (ownerOf(tokenId) != msg.sender) {
            if (!_nodeActionDelegations[tokenId][msg.sender].contains(uint256(actionType))) {
                 revert CryptoNexus__NotNodeOwnerOrDelegate();
            }
        }
        _;
    }

    // --- Core ERC721 Functions (Inherited) ---
    // name(), symbol(), totalSupply(), balanceOf(address), ownerOf(uint256),
    // transferFrom(address,address,uint256), safeTransferFrom(address,address,uint256),
    // approve(address,uint256), setApprovalForAll(address,bool), getApproved(uint256),
    // isApprovedForAll(address,address), supportsInterface(bytes4)
    // All inherited functions automatically respect Pausable and Ownable where applicable.

    // --- Node Management ---

    /// @notice Creates a new node instance. Requires sufficient reputation for higher tiers.
    /// @param nodeType The type of node to create.
    /// @param initialAttributes The initial attributes for the node.
    /// @param metadataURI The URI for the node's metadata.
    function createNode(NodeType nodeType, NodeAttributes memory initialAttributes, string memory metadataURI)
        public
        whenNotPaused
        nonReentrant
    {
        uint256 reputationRequired = 0;
        if (nodeType == NodeType.Advanced) reputationRequired = _reputationThresholds.createAdvancedNode;
        if (nodeType == NodeType.Elite) reputationRequired = _reputationThresholds.createEliteNode;

        if (_reputation[msg.sender] < reputationRequired) {
            revert CryptoNexus__InsufficientReputation();
        }

        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();

        _nodes[newTokenId] = Node({
            nodeType: nodeType,
            attributes: initialAttributes,
            lastDecayOrClaimTime: uint64(block.timestamp),
            metadataURI: metadataURI
        });

        _safeMint(msg.sender, newTokenId);

        emit NodeCreated(newTokenId, msg.sender, nodeType, initialAttributes);

        // Optional: Gain reputation for creating a node
        _gainReputation(msg.sender, 1);
    }

    /// @notice Allows the owner or delegate to update attributes of a node.
    /// @param tokenId The ID of the node.
    /// @param newAttributes The new attribute values.
    function updateNodeAttributes(uint256 tokenId, NodeAttributes memory newAttributes)
        public
        whenNotPaused
        onlyNodeOwnerOrDelegate(tokenId, ConditionalActionType.BoostAttribute) // Use BoostAttribute type for permission
    {
        if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId(); // Use internal _ownerOf for efficiency if needed, or rely on ERC721 check

        _nodes[tokenId].attributes = newAttributes;
        _nodes[tokenId].lastDecayOrClaimTime = uint64(block.timestamp); // Reset timer on update

        emit AttributesUpdated(tokenId, newAttributes);

        // Optional: Reputation effect?
    }

    /// @notice Triggers attribute decay for a specific node based on time elapsed.
    /// @param tokenId The ID of the node.
    function triggerNodeDecay(uint256 tokenId)
        public
        whenNotPaused
        nonReentrant // Prevent reentrancy issues if decay logic is complex
    {
        if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId(); // Use internal _ownerOf
         // Anyone can trigger decay? Or only owner/delegate? Let's allow anyone to prevent stagnation.
        // if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved(); // Example: only owner/approved

        Node storage node = _nodes[tokenId];
        uint256 timeElapsed = block.timestamp - node.lastDecayOrClaimTime;

        if (timeElapsed > 0) {
            // Calculate decay based on timeElapsed and node.decayRate and formulas
            AttributeFormulaParams memory formula = _attributeFormulas[node.nodeType];
            int256 decayAmount = int256(timeElapsed * node.attributes.decayRate) * formula.decayMultiplier / 1 days; // Example: decay per day

            // Apply decay (ensure attributes don't go below zero or a floor)
            node.attributes.power = uint256(int256(node.attributes.power) + decayAmount); // Assuming power is uint256, requires care with negative decay
            if (node.attributes.power > type(uint256).max / 2) node.attributes.power = 0; // Simple check against underflow for large decay
            // Apply to other attributes...

            node.lastDecayOrClaimTime = uint64(block.timestamp); // Reset timer

            emit AttributesUpdated(tokenId, node.attributes);
             // Optional: Event specifically for decay?
        }
        // If timeElapsed is 0, no decay happens
    }

    /// @notice Allows the owner of a node to claim resources generated over time.
    /// @param tokenId The ID of the node.
    function claimGeneratedResources(uint256 tokenId)
        public
        whenNotPaused
        nonReentrant
    {
        if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved();

        Node storage node = _nodes[tokenId];
        uint256 timeElapsed = block.timestamp - node.lastDecayOrClaimTime;

        if (timeElapsed > 0) {
            // Calculate generated resources based on timeElapsed and node.resourceGenerationRate and formulas
             AttributeFormulaParams memory formula = _attributeFormulas[node.nodeType];
            uint256 generatedAmount = timeElapsed * node.attributes.resourceGenerationRate * uint256(formula.generationMultiplier) / 1 days; // Example: generation per day

            if (generatedAmount > 0) {
                _resourceBalances[msg.sender] += generatedAmount;
                 emit ResourceBalanceChanged(msg.sender, int256(generatedAmount), _resourceBalances[msg.sender]);
            }

            node.lastDecayOrClaimTime = uint64(block.timestamp); // Reset timer

             // Optional: Event specifically for claiming?
        }
    }

    // --- Reputation and Resource Getters ---

    /// @notice Gets the reputation score of a user.
    /// @param user The address to check.
    /// @return The reputation score.
    function getReputation(address user) public view returns (uint256) {
        return _reputation[user];
    }

    /// @notice Gets the resource balance of a user.
    /// @param user The address to check.
    /// @return The resource balance.
    function getUserResourceBalance(address user) public view returns (uint256) {
        return _resourceBalances[user];
    }

    // --- Node Interactions ---

    /// @notice Creates a link from a source node to a target node. Requires ownership of both.
    /// @param sourceNodeId The ID of the source node.
    /// @param targetNodeId The ID of the target node.
    function linkNodes(uint256 sourceNodeId, uint256 targetNodeId)
        public
        whenNotPaused
        nonReentrant
    {
        if (ownerOf(sourceNodeId) != msg.sender || ownerOf(targetNodeId) != msg.sender) {
            revert CryptoNexus__NotNodeOwnerOrApproved(); // Simplified check
        }
         if (sourceNodeId == targetNodeId) revert CryptoNexus__InvalidNodeId();

        Node storage sourceNode = _nodes[sourceNodeId];
        Node storage targetNode = _nodes[targetNodeId];

        bool constraintMet = false;
        for(uint i = 0; i < _linkingConstraints.length; i++) {
            LinkingConstraint storage constraint = _linkingConstraints[i];
            if (sourceNode.nodeType == constraint.requiredSourceType &&
                targetNode.nodeType == constraint.requiredTargetType &&
                sourceNode.attributes.power >= constraint.minSourceAttribute && // Example attribute check
                targetNode.attributes.power >= constraint.minTargetAttribute && // Example attribute check
                _reputation[msg.sender] >= constraint.minReputation &&
                _resourceBalances[msg.sender] >= constraint.resourceCost) {

                // Check if already linked under this constraint type (or just if linked at all)
                 if (!_nodeLinks[sourceNodeId].contains(targetNodeId)) {
                    // Consume resources
                     _consumeResource(msg.sender, constraint.resourceCost);

                    // Establish link
                    _nodeLinks[sourceNodeId].add(targetNodeId);

                    // Optional: Reputation effect, attribute change
                    _gainReputation(msg.sender, 1); // Example

                    constraintMet = true;
                    emit NodesLinked(sourceNodeId, targetNodeId);
                    break; // Found a matching constraint and linked
                 } else {
                    revert CryptoNexus__NodesAlreadyLinked();
                 }
            }
        }

        if (!constraintMet) {
            revert CryptoNexus__LinkingConstraintViolated();
        }
    }

    /// @notice Removes a link from a source node to a target node.
    /// @param sourceNodeId The ID of the source node.
    /// @param targetNodeId The ID of the target node.
    function unlinkNodes(uint256 sourceNodeId, uint256 targetNodeId)
        public
        whenNotPaused
        nonReentrant
    {
        if (ownerOf(sourceNodeId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved(); // Only owner can unlink source

        if (_nodeLinks[sourceNodeId].remove(targetNodeId)) {
            emit NodesUnlinked(sourceNodeId, targetNodeId);
             // Optional: Reputation effect, resource refund?
        } else {
            revert CryptoNexus__NodesNotLinked();
        }
    }

    /// @notice Gets the list of nodes linked *from* a specific node.
    /// @param sourceNodeId The ID of the source node.
    /// @return An array of node IDs linked to.
    function getNodesLinkedTo(uint256 sourceNodeId) public view returns (uint256[] memory) {
        return _nodeLinks[sourceNodeId].values();
    }

    /// @notice Combines multiple nodes into a new node. Burns input nodes. Complex attribute derivation.
    /// @param burnedNodeIds The IDs of the nodes to burn.
    function combineNodes(uint256[] memory burnedNodeIds)
        public
        whenNotPaused
        nonReentrant
    {
        if (burnedNodeIds.length < 2) revert CryptoNexus__InvalidCombinationInput();
        if (_reputation[msg.sender] < _reputationThresholds.combineNodes) revert CryptoNexus__InsufficientReputation();

        NodeAttributes memory combinedAttributes;
        NodeType resultNodeType = NodeType.Basic; // Determine based on inputs
        uint256 totalResourceCost = 0; // Calculate based on input nodes

        // Check ownership and calculate combined attributes and cost
        for (uint i = 0; i < burnedNodeIds.length; i++) {
            uint256 tokenId = burnedNodeIds[i];
            if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved();

            Node storage node = _nodes[tokenId];
            combinedAttributes.power += node.attributes.power; // Example: Summing power
            // ... calculate other combined attributes ...

            // Example: Cost based on node type
            if (node.nodeType == NodeType.Basic) totalResourceCost += 20;
            if (node.nodeType == NodeType.Advanced) totalResourceCost += 50;
            if (node.nodeType == NodeType.Elite) totalResourceCost += 100;

            // Determine result node type (simplistic example: highest type dominates)
            if (node.nodeType > resultNodeType) resultNodeType = node.nodeType;
        }

        if (_resourceBalances[msg.sender] < totalResourceCost) revert CryptoNexus__InsufficientResources();

        // Consume resources
        _consumeResource(msg.sender, totalResourceCost);

        // Burn input nodes
        for (uint i = 0; i < burnedNodeIds.length; i++) {
            _burn(burnedNodeIds[i]);
             // Clean up links associated with the burned node (both outgoing and incoming - incoming requires iterating all nodes, maybe skip for complexity)
             delete _nodeLinks[burnedNodeIds[i]]; // Clear outgoing links
             // Note: Cleaning incoming links efficiently is complex. This version ignores incoming links.
        }

        // Create new node
        _tokenIdCounter.increment();
        uint256 newNodeId = _tokenIdCounter.current();

         // Apply some formula/scaling to the combined attributes, maybe based on resultNodeType
         combinedAttributes.power = combinedAttributes.power * 80 / 100; // Example: 80% efficiency

        _nodes[newNodeId] = Node({
            nodeType: resultNodeType,
            attributes: combinedAttributes,
            lastDecayOrClaimTime: uint64(block.timestamp),
            metadataURI: "ipfs://new-combined-node-metadata" // Example fixed URI
        });

        _safeMint(msg.sender, newNodeId);

        emit NodesCombined(msg.sender, burnedNodeIds, newNodeId);

         _gainReputation(msg.sender, uint256(burnedNodeIds.length * 2)); // Gain reputation

        // Optional: Apply some resources back?
    }

    /// @notice Splits a node into potentially multiple new nodes or resources. Burns input node.
    /// @param tokenId The ID of the node to split.
    function splitNode(uint256 tokenId)
        public
        whenNotPaused
        nonReentrant
    {
        if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved();
        if (_reputation[msg.sender] < _reputationThresholds.splitNode) revert CryptoNexus__InsufficientReputation();
         // Add checks for minimum attributes to split?

        Node storage nodeToSplit = _nodes[tokenId];
        uint256 baseResourceCost = 50; // Example base cost
        uint256 totalResourceCost = baseResourceCost + nodeToSplit.attributes.power / 10; // Cost depends on attributes

        if (_resourceBalances[msg.sender] < totalResourceCost) revert CryptoNexus__InsufficientResources();

        // Consume resources
        _consumeResource(msg.sender, totalResourceCost);

        // Burn the input node
        _burn(tokenId);
         delete _nodeLinks[tokenId]; // Clear outgoing links

        uint256 numNewNodes = 1; // Example: Splits into 1 Basic node + resources
        if (nodeToSplit.nodeType == NodeType.Advanced) numNewNodes = 2; // Example: Advanced splits into 2 Basic nodes
        if (nodeToSplit.nodeType == NodeType.Elite) numNewNodes = 1; // Example: Elite splits into 1 Advanced node + more resources

        uint256[] memory newNodesIds = new uint256[](numNewNodes);
        uint256 resourceOutput = 0;

        // Determine output based on burned node's attributes and type
        if (nodeToSplit.nodeType == NodeType.Basic) {
            resourceOutput = nodeToSplit.attributes.power * 5; // Example: Basic node power gives resources
        } else if (nodeToSplit.nodeType == NodeType.Advanced) {
            // Splits into two basic nodes, less resource
             for(uint i = 0; i < numNewNodes; i++) {
                 _tokenIdCounter.increment();
                 uint256 newNodeId = _tokenIdCounter.current();
                 newNodesIds[i] = newNodeId;
                 _nodes[newNodeId] = Node({
                     nodeType: NodeType.Basic, // Result is Basic
                     attributes: NodeAttributes({
                         power: nodeToSplit.attributes.power / numNewNodes / 2, // Split power, reduced
                         decayRate: 1,
                         resourceGenerationRate: 2
                     }),
                     lastDecayOrClaimTime: uint64(block.timestamp),
                     metadataURI: "ipfs://split-basic-node-metadata"
                 });
                 _safeMint(msg.sender, newNodeId);
             }
             resourceOutput = nodeToSplit.attributes.resourceGenerationRate * 10; // Example: Advanced generation gives resources
        } else if (nodeToSplit.nodeType == NodeType.Elite) {
            // Splits into one advanced node, more resource
            _tokenIdCounter.increment();
             uint256 newNodeId = _tokenIdCounter.current();
             newNodesIds[0] = newNodeId;
             _nodes[newNodeId] = Node({
                 nodeType: NodeType.Advanced, // Result is Advanced
                 attributes: NodeAttributes({
                     power: nodeToSplit.attributes.power / 2, // Power reduced
                     decayRate: 2,
                     resourceGenerationRate: 5
                 }),
                 lastDecayOrClaimTime: uint64(block.timestamp),
                 metadataURI: "ipfs://split-advanced-node-metadata"
             });
             _safeMint(msg.sender, newNodeId);
             resourceOutput = nodeToSplit.attributes.resourceGenerationRate * 20; // Example: Elite generation gives resources
        }


        if (resourceOutput > 0) {
             _resourceBalances[msg.sender] += resourceOutput;
             emit ResourceBalanceChanged(msg.sender, int256(resourceOutput), _resourceBalances[msg.sender]);
        }

        emit NodeSplit(msg.sender, tokenId, newNodesIds, resourceOutput);

         _loseReputation(msg.sender, 5); // Lose some reputation for splitting? Example.
    }

    /// @notice Executes a predefined action only if ALL specified conditions are met.
    /// @param actionType The type of action to perform.
    /// @param conditions Array of conditions that must be true.
    /// @param targetNodeId The ID of the node the action applies to (if applicable).
    /// @param targetUser The address the action applies to (if applicable).
    /// @param actionData Arbitrary data bytes interpreted based on actionType (e.g., attribute boost amount).
    function executeConditionalAction(
        ConditionalActionType actionType,
        Condition[] memory conditions,
        uint256 targetNodeId,
        address targetUser, // Can be address(0) if not used
        bytes calldata actionData // Use calldata for external calls
    )
        public
        whenNotPaused
        nonReentrant
    {
        // Check conditions
        for (uint i = 0; i < conditions.length; i++) {
            if (!_checkCondition(conditions[i], targetNodeId, msg.sender)) {
                revert CryptoNexus__ConditionsNotMet();
            }
        }

        bool success = false;
        // Execute action if conditions are met
        if (actionType == ConditionalActionType.BoostAttribute) {
            if (targetNodeId == 0 || _ownerOf[targetNodeId] == address(0)) revert CryptoNexus__InvalidNodeAddressOrId();
             // Requires delegate permission for BoostAttribute or owner
            if (ownerOf(targetNodeId) != msg.sender && !_nodeActionDelegations[targetNodeId][msg.sender].contains(uint256(ConditionalActionType.BoostAttribute))) {
                 revert CryptoNexus__ActionPermissionDenied();
            }
            // Decode actionData (e.g., attribute index and boost amount)
            (bytes32 attributeKeyToBoost, int256 boostAmount) = abi.decode(actionData, (bytes32, int256));

            Node storage node = _nodes[targetNodeId];
            if (attributeKeyToBoost == _attributeKeys["power"]) {
                node.attributes.power = uint256(int256(node.attributes.power) + boostAmount);
                 // Ensure no underflow
                 if (boostAmount < 0 && node.attributes.power > type(uint256).max / 2) node.attributes.power = 0;
                 success = true;
            }
             // Handle other attributes...

             if(success) emit AttributesUpdated(targetNodeId, node.attributes);

        } else if (actionType == ConditionalActionType.TransferResourceToOwner) {
            if (targetNodeId == 0 || _ownerOf[targetNodeId] == address(0)) revert CryptoNexus__InvalidNodeAddressOrId();
             address nodeOwner = ownerOf(targetNodeId);
             // Decode actionData (e.g., amount)
             uint256 transferAmount = abi.decode(actionData, (uint256));
             if (transferAmount > 0 && _resourceBalances[address(this)] >= transferAmount) { // Assuming contract holds some resource
                 _resourceBalances[nodeOwner] += transferAmount;
                  _resourceBalances[address(this)] -= transferAmount; // Resource comes from contract
                  emit ResourceBalanceChanged(nodeOwner, int256(transferAmount), _resourceBalances[nodeOwner]);
                  emit ResourceBalanceChanged(address(this), -int256(transferAmount), _resourceBalances[address(this)]);
                 success = true;
             }

        } else if (actionType == ConditionalActionType.ApplyReputationEffect) {
            if (targetUser == address(0)) revert CryptoNexus__InvalidNodeAddressOrId(); // Using as invalid user address
             // Decode actionData (e.g., reputation delta)
             int256 reputationDelta = abi.decode(actionData, (int256));
             if (reputationDelta > 0) {
                _gainReputation(targetUser, uint256(reputationDelta));
             } else {
                _loseReputation(targetUser, uint256(-reputationDelta));
             }
             success = true;

        } else if (actionType == ConditionalActionType.TriggerChainReaction) {
            if (targetNodeId == 0 || _ownerOf[targetNodeId] == address(0)) revert CryptoNexus__InvalidNodeAddressOrId();
             // Example: Trigger decay on all linked nodes from targetNodeId
             uint256[] memory linkedNodes = getNodesLinkedTo(targetNodeId);
             for(uint i = 0; i < linkedNodes.length; i++) {
                 // Recursively call triggerNodeDecay (handle potential gas limits for long chains)
                 triggerNodeDecay(linkedNodes[i]); // This call will check pausable etc internally
             }
             success = true;
        }
        // Add more action types...

        emit ConditionalActionExecuted(targetNodeId, actionType, actionData, success);
         if (!success) {
             // Decide whether to revert or just log failure based on action type
             // For now, we log success=false. Could revert specific failed types.
         }
    }

    /// @notice Delegate permission for a specific action type on a node to another address.
    /// @param tokenId The ID of the node.
    /// @param delegate The address to delegate permission to.
    /// @param actionType The type of action being delegated.
    function delegateActionPermission(uint256 tokenId, address delegate, ConditionalActionType actionType)
        public
        whenNotPaused
    {
        if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved(); // Only owner can delegate
        if (delegate == address(0)) revert CryptoNexus__InvalidNodeAddressOrId(); // Invalid delegate address
        if (delegate == msg.sender) revert CryptoNexus__InvalidNodeAddressOrId(); // Cannot delegate to self

        if (_nodeActionDelegations[tokenId][delegate].add(uint256(actionType))) {
            emit ActionPermissionDelegated(tokenId, delegate, uint256(actionType));
        }
    }

    /// @notice Revoke a specific action permission delegation for a node.
    /// @param tokenId The ID of the node.
    /// @param delegate The address the permission was delegated to.
    /// @param actionType The type of action being revoked.
    function revokeActionPermission(uint256 tokenId, address delegate, ConditionalActionType actionType)
        public
        whenNotPaused
    {
        if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved(); // Only owner can revoke
        if (delegate == address(0)) revert CryptoNexus__InvalidNodeAddressOrId(); // Invalid delegate address

        if (_nodeActionDelegations[tokenId][delegate].remove(uint256(actionType))) {
            emit ActionPermissionRevoked(tokenId, delegate, uint256(actionType));
        }
    }

    /// @notice Get the list of action types an address is delegated to perform on a node.
    /// @param tokenId The ID of the node.
    /// @param delegate The delegate address.
    /// @return An array of delegated action types (as uint256).
    function getDelegatePermissions(uint256 tokenId, address delegate) public view returns (uint256[] memory) {
         if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId();
         if (delegate == address(0)) revert CryptoNexus__InvalidNodeAddressOrId();
        return _nodeActionDelegations[tokenId][delegate].values();
    }

    // --- Utility / View Functions ---

    /// @notice Gets the full state details of a node.
    /// @param tokenId The ID of the node.
    /// @return The Node struct containing all state details.
    function getNodeState(uint256 tokenId) public view returns (Node memory) {
         if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId();
        return _nodes[tokenId];
    }

     /// @notice Gets only the attributes of a node.
    /// @param tokenId The ID of the node.
    /// @return The NodeAttributes struct.
     function getNodeAttributes(uint256 tokenId) public view returns (NodeAttributes memory) {
        if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId();
        return _nodes[tokenId].attributes;
    }


    /// @notice Previews the result of combining nodes without executing the transaction.
    /// @param burnedNodeIds The IDs of the nodes to preview combining.
    /// @return combinedAttributes The resulting attributes of the new node.
    /// @return resultNodeType The type of the new node.
    /// @return totalResourceCost The resource cost of the operation.
    /// @return reputationGain The reputation gain from the operation.
    function previewCombineNodesResult(uint256[] memory burnedNodeIds)
        public
        view
        returns (NodeAttributes memory combinedAttributes, NodeType resultNodeType, uint256 totalResourceCost, uint256 reputationGain)
    {
        if (burnedNodeIds.length < 2) revert CryptoNexus__InvalidCombinationInput();

        resultNodeType = NodeType.Basic; // Determine based on inputs
        totalResourceCost = 0; // Calculate based on input nodes

        // Check ownership (view function - minimal check) and calculate combined attributes and cost
        for (uint i = 0; i < burnedNodeIds.length; i++) {
            uint256 tokenId = burnedNodeIds[i];
             // Cannot use ownerOf directly on potentially non-existent tokens in view, but assuming valid inputs for preview
            Node storage node = _nodes[tokenId];
            combinedAttributes.power += node.attributes.power;
            // ... calculate other combined attributes ...

            if (node.nodeType == NodeType.Basic) totalResourceCost += 20;
            if (node.nodeType == NodeType.Advanced) totalResourceCost += 50;
            if (node.nodeType == NodeType.Elite) totalResourceCost += 100;

            if (node.nodeType > resultNodeType) resultNodeType = node.nodeType;
        }

         // Apply some formula/scaling to the combined attributes
         combinedAttributes.power = combinedAttributes.power * 80 / 100; // Example: 80% efficiency

         reputationGain = burnedNodeIds.length * 2; // Example

        return (combinedAttributes, resultNodeType, totalResourceCost, reputationGain);
    }

     /// @notice Previews the result of splitting a node without executing the transaction.
    /// @param tokenId The ID of the node to preview splitting.
    /// @return newNodesAttributes Array of attributes for the potential new nodes.
    /// @return newNodesTypes Array of types for the potential new nodes.
    /// @return resourceOutput The amount of resource generated.
    /// @return totalResourceCost The resource cost of the operation.
    /// @return reputationLoss The reputation loss from the operation.
    function previewSplitNodeResult(uint256 tokenId)
        public
        view
        returns (NodeAttributes[] memory newNodesAttributes, NodeType[] memory newNodesTypes, uint256 resourceOutput, uint256 totalResourceCost, uint256 reputationLoss)
    {
        // Cannot use ownerOf directly in view if the token might not exist
         if (_ownerOf[tokenId] == address(0)) revert CryptoNexus__InvalidNodeId();

        Node storage nodeToSplit = _nodes[tokenId];
        totalResourceCost = 50 + nodeToSplit.attributes.power / 10;

        uint256 numNewNodes = 1;
        if (nodeToSplit.nodeType == NodeType.Advanced) numNewNodes = 2;
        if (nodeToSplit.nodeType == NodeType.Elite) numNewNodes = 1;

        newNodesAttributes = new NodeAttributes[](numNewNodes);
        newNodesTypes = new NodeType[](numNewNodes);
        resourceOutput = 0;
        reputationLoss = 5;

        if (nodeToSplit.nodeType == NodeType.Basic) {
            resourceOutput = nodeToSplit.attributes.power * 5;
        } else if (nodeToSplit.nodeType == NodeType.Advanced) {
             for(uint i = 0; i < numNewNodes; i++) {
                 newNodesTypes[i] = NodeType.Basic;
                 newNodesAttributes[i] = NodeAttributes({
                     power: nodeToSplit.attributes.power / numNewNodes / 2,
                     decayRate: 1,
                     resourceGenerationRate: 2
                 });
             }
             resourceOutput = nodeToSplit.attributes.resourceGenerationRate * 10;
        } else if (nodeToSplit.nodeType == NodeType.Elite) {
            newNodesTypes[0] = NodeType.Advanced;
            newNodesAttributes[0] = NodeAttributes({
                 power: nodeToSplit.attributes.power / 2,
                 decayRate: 2,
                 resourceGenerationRate: 5
            });
             resourceOutput = nodeToSplit.attributes.resourceGenerationRate * 20;
        }

        return (newNodesAttributes, newNodesTypes, resourceOutput, totalResourceCost, reputationLoss);
    }


    /// @notice Gets the current attribute formula parameters for a node type.
    /// @param nodeType The node type.
    /// @return The AttributeFormulaParams struct.
    function getNodeAttributeFormula(NodeType nodeType) public view returns (AttributeFormulaParams memory) {
        return _attributeFormulas[nodeType];
    }

    /// @notice Gets the current linking constraints.
    /// @return An array of LinkingConstraint structs.
    function getLinkingConstraints() public view returns (LinkingConstraint[] memory) {
        return _linkingConstraints;
    }

    /// @notice Gets the current reputation thresholds for various actions.
    /// @return The ReputationThresholds struct.
    function getReputationThresholds() public view returns (ReputationThresholds memory) {
        return _reputationThresholds;
    }

    /// @notice Gets the total number of nodes minted for a specific type.
    /// @param nodeType The node type.
    /// @return The total count of nodes of that type.
    function getTotalNodesOfType(NodeType nodeType) public view returns (uint256) {
        uint256 count = 0;
        uint256 total = _tokenIdCounter.current();
        for(uint256 i = 1; i <= total; i++) {
            // Check if node exists and is of the type
            if (_ownerOf[i] != address(0) && _nodes[i].nodeType == nodeType) {
                count++;
            }
        }
        return count;
    }

    // --- Batch Operations ---

    /// @notice Updates attributes for multiple nodes in a single transaction.
    /// @param tokenIds Array of node IDs.
    /// @param newAttributes Array of new attributes (must match tokenIds length).
    function batchUpdateNodeAttributes(uint256[] memory tokenIds, NodeAttributes[] memory newAttributes)
        public
        whenNotPaused
        nonReentrant
    {
        if (tokenIds.length != newAttributes.length) revert CryptoNexus__InvalidCombinationInput(); // Misused error name, should be specific

        for(uint i = 0; i < tokenIds.length; i++) {
             uint256 tokenId = tokenIds[i];
             // Require owner or delegate permission for each node/action
             if (ownerOf(tokenId) != msg.sender && !_nodeActionDelegations[tokenId][msg.sender].contains(uint256(ConditionalActionType.BoostAttribute))) {
                 revert CryptoNexus__ActionPermissionDenied(); // Revert entire batch if any fails permission
             }
             _nodes[tokenId].attributes = newAttributes[i];
             _nodes[tokenId].lastDecayOrClaimTime = uint64(block.timestamp); // Reset timer
             emit AttributesUpdated(tokenId, newAttributes[i]);
        }
    }

     /// @notice Claims generated resources for multiple nodes in a single transaction.
    /// @param tokenIds Array of node IDs.
    function batchClaimGeneratedResources(uint256[] memory tokenIds)
        public
        whenNotPaused
        nonReentrant
    {
         uint256 totalGenerated = 0;
         for(uint i = 0; i < tokenIds.length; i++) {
             uint256 tokenId = tokenIds[i];
             if (ownerOf(tokenId) != msg.sender) revert CryptoNexus__NotNodeOwnerOrApproved(); // Owner of all nodes required

             Node storage node = _nodes[tokenId];
             uint256 timeElapsed = block.timestamp - node.lastDecayOrClaimTime;

             if (timeElapsed > 0) {
                  AttributeFormulaParams memory formula = _attributeFormulas[node.nodeType];
                 uint256 generatedAmount = timeElapsed * node.attributes.resourceGenerationRate * uint256(formula.generationMultiplier) / 1 days; // Example: generation per day
                 totalGenerated += generatedAmount;
                 node.lastDecayOrClaimTime = uint64(block.timestamp); // Reset timer
             }
         }

         if (totalGenerated > 0) {
             _resourceBalances[msg.sender] += totalGenerated;
              emit ResourceBalanceChanged(msg.sender, int256(totalGenerated), _resourceBalances[msg.sender]);
         }
         // No explicit event for each node update here, but ResourcesChanged covers the total effect.
    }


    // --- Configuration (Owner Only) ---

    /// @notice Sets the attribute formula parameters for a node type.
    /// @param nodeType The node type.
    /// @param params The new AttributeFormulaParams struct.
    function setNodeAttributeFormula(NodeType nodeType, AttributeFormulaParams memory params)
        public
        onlyOwner
        whenNotPaused
    {
        _attributeFormulas[nodeType] = params;
        emit ConfigUpdated(keccak256("NodeAttributeFormula"));
    }

    /// @notice Adds or updates a linking constraint.
    /// @param index The index of the constraint to update (use _linkingConstraints.length to add).
    /// @param constraint The new LinkingConstraint struct.
    function setLinkingConstraints(uint256 index, LinkingConstraint memory constraint)
        public
        onlyOwner
        whenNotPaused
    {
        if (index > _linkingConstraints.length) revert CryptoNexus__InvalidNodeId(); // Index out of bounds (misused error)

        if (index == _linkingConstraints.length) {
            _linkingConstraints.push(constraint);
        } else {
            _linkingConstraints[index] = constraint;
        }
        emit ConfigUpdated(keccak256("LinkingConstraints"));
    }

    /// @notice Sets the reputation thresholds for various actions.
    /// @param thresholds The new ReputationThresholds struct.
    function setReputationThresholds(ReputationThresholds memory thresholds)
        public
        onlyOwner
        whenNotPaused
    {
        _reputationThresholds = thresholds;
        emit ConfigUpdated(keccak256("ReputationThresholds"));
    }

    // --- System Functions ---

    /// @notice Pauses the contract.
    function pause() public onlyOwner {
        _pause();
    }

    /// @notice Unpauses the contract.
    function unpause() public onlyOwner {
        _unpause();
    }

    /// @notice Allows the owner to withdraw any ETH sent to the contract.
    function withdrawEth() public onlyOwner {
        uint256 balance = address(this).balance;
        if (balance == 0) revert CryptoNexus__NoEthToWithdraw();
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdraw failed");
    }

    // --- Internal Helper Functions ---

    /// @dev Increases a user's reputation.
    function _gainReputation(address user, uint256 amount) internal {
        if (amount > 0) {
             _reputation[user] += amount;
            emit ReputationChanged(user, int256(amount), _reputation[user]);
        }
    }

    /// @dev Decreases a user's reputation (clamped at 0).
    function _loseReputation(address user, uint256 amount) internal {
        if (amount > 0) {
            if (_reputation[user] >= amount) {
                 _reputation[user] -= amount;
                 emit ReputationChanged(user, -int256(amount), _reputation[user]);
            } else {
                uint256 oldReputation = _reputation[user];
                _reputation[user] = 0;
                emit ReputationChanged(user, -int256(oldReputation), 0);
            }
        }
    }

    /// @dev Consumes resources from a user. Reverts if insufficient.
    function _consumeResource(address user, uint256 amount) internal {
        if (_resourceBalances[user] < amount) revert CryptoNexus__InsufficientResources();
        _resourceBalances[user] -= amount;
        emit ResourceBalanceChanged(user, -int256(amount), _resourceBalances[user]);
    }

    /// @dev Checks if a single condition is met.
    function _checkCondition(Condition memory condition, uint256 targetNodeId, address actingUser) internal view returns (bool) {
        if (condition.conditionType == ConditionType.NodeAttributeMin || condition.conditionType == ConditionType.NodeAttributeMax) {
            if (targetNodeId == 0 || _ownerOf[targetNodeId] == address(0)) return false; // Node must exist

            Node storage node = _nodes[targetNodeId];
            uint256 attributeValue = 0;

            // Map attribute key to value
            if (condition.attributeKey == _attributeKeys["power"]) attributeValue = node.attributes.power;
            // Add checks for other attribute keys...
            else return false; // Invalid attribute key

            if (condition.conditionType == ConditionType.NodeAttributeMin) return attributeValue >= condition.value;
            if (condition.conditionType == ConditionType.NodeAttributeMax) return attributeValue <= condition.value;

        } else if (condition.conditionType == ConditionType.UserReputationMin) {
            return _reputation[actingUser] >= condition.value;

        } else if (condition.conditionType == ConditionType.UserResourceMin) {
            return _resourceBalances[actingUser] >= condition.value;

        } else if (condition.conditionType == ConditionType.TimeSinceLastAction) {
             if (targetNodeId == 0 || _ownerOf[targetNodeId] == address(0)) return false;
             // Check time since last decay/claim
             return (block.timestamp - _nodes[targetNodeId].lastDecayOrClaimTime) >= condition.value;
        }

        // Add more condition types...

        return false; // Unrecognized condition type
    }

    // Override _update and _safeMint to set initial lastDecayOrClaimTime
     function _update(address to, uint256 tokenId, address auth) internal override returns (address) {
        address owner = super._update(to, tokenId, auth);
         if (owner != address(0)) { // Check if minted, not burned
             _nodes[tokenId].lastDecayOrClaimTime = uint64(block.timestamp);
         } else { // Token is being burned
             delete _nodes[tokenId]; // Clean up node data
             delete _nodeLinks[tokenId]; // Clean up outgoing links
             // Cleaning incoming links is not done efficiently here
             delete _nodeActionDelegations[tokenId]; // Clean up delegations
         }
         return owner;
    }

    // Override tokenURI for dynamic metadata
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (!_exists(tokenId)) revert ERC721NonexistentToken(tokenId);
        // Example: Append node state to base URI or point to different URIs based on state/type
        // return string(abi.encodePacked(_nodes[tokenId].metadataURI, "?power=", Strings.toString(_nodes[tokenId].attributes.power))); // Example appending state
         return _nodes[tokenId].metadataURI; // Simple return as stored
    }

    // Override _increaseSupply for potential future use tracking total supply per type
    // function _increaseSupply(uint256 typeId, uint256 amount) internal { ... }

    // Fallback function to receive ETH (for `withdrawEth`)
    receive() external payable {}
    fallback() external payable {}
}
```

---

**Explanation of Advanced Concepts Used:**

1.  **Dynamic State & Attributes:** Nodes aren't just static tokens. They have mutable `attributes` and a `lastDecayOrClaimTime`. This state changes based on contract logic (`triggerNodeDecay`, `claimGeneratedResources`, `updateNodeAttributes`, `combineNodes`, `splitNode`).
2.  **Simulated Time-Based Mechanics:** `decayNodeAttribute` and `claimGeneratedResources` use `block.timestamp` to simulate processes happening over time (decay or generation). While not true passive income (they require a transaction to trigger), they implement the *concept* on-chain.
3.  **Internal Resource System:** Instead of relying on a separate ERC20 token, resources are managed directly within the contract (`_resourceBalances`). This simplifies the example and ties the resource closely to the Nexus ecosystem.
4.  **Reputation System:** Users build reputation (`_reputation`), which acts as a gatekeeper for higher-tier actions (`createNode`, `linkNodes`, `combineNodes`, `splitNode`). This adds a layer of progression or achievement within the contract.
5.  **Node Linking:** The `_nodeLinks` mapping represents a graph structure on-chain, allowing nodes to have relationships. Linking requires meeting `_linkingConstraints`, which themselves are dynamic and configurable.
6.  **Complex Interactions (Combine/Split):** `combineNodes` and `splitNode` are multi-step operations that burn tokens, mint new ones, consume resources, and derive new attributes based on the old ones and contract logic. These are far more complex than typical token functions.
7.  **Generic Conditional Logic:** `executeConditionalAction` is a powerful, flexible function. It takes an array of generic `Condition` structs and an action type. This allows defining complex logic paths where an action only occurs if multiple on-chain checks (attribute values, user reputation, resources, time) pass. The action itself is also parameterized via `actionData`.
8.  **Granular Delegation:** `delegateActionPermission` and `revokeActionPermission` allow users to grant *specific* permissions (defined by `ConditionalActionType` enum) on their nodes to others, going beyond the all-or-nothing `setApprovalForAll` or single-token `approve` of standard ERC721.
9.  **Dynamic Configuration:** The `OwnerOnly` functions for `setNodeAttributeFormula`, `setLinkingConstraints`, and `setReputationThresholds` allow the contract owner (or a future DAO) to adjust core economic and interaction parameters after deployment, making the system adaptable.
10. **Batch Operations:** `batchUpdateNodeAttributes` and `batchClaimGeneratedResources` are included for efficiency, allowing users to interact with multiple nodes in a single transaction.
11. **Preview Functions:** `previewCombineNodesResult` and `previewSplitNodeResult` are `view` functions that allow users or UIs to see the *potential* outcome of a complex, state-changing operation before paying gas to execute it.
12. **ReentrancyGuard:** Used in complex or multi-step functions (`combineNodes`, `splitNode`, `executeConditionalAction`, batch operations, decay, claim) to prevent reentrant calls, which is a common security vulnerability in contracts interacting with external calls (though in this case, it's primarily guarding against complex internal state changes).
13. **EnumerableSet:** Used for `_nodeLinks` and `_nodeActionDelegations` to manage sets of linked nodes or delegated action types efficiently, allowing addition, removal, and iteration.

This contract is a conceptual example. A real-world implementation would require significantly more detailed logic for attribute formulas, resource generation, specific conditional action effects, error handling, gas optimization, and potentially a robust testing suite.