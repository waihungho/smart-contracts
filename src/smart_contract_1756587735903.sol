This smart contract, named **SynergyVault**, is designed to be an advanced, creative, and trendy platform for decentralized intellectual property (IP) co-creation and management. It leverages AI oracles for dynamic contribution assessment, dispute resolution, and incorporates a decentralized governance model with a reputation system.

The core idea is to create "SynergyUnits" â€“ ERC721 NFTs representing intellectual property that can be collaboratively owned. Revenue shares for these units are dynamic and can be re-evaluated by AI or decided through human arbitration. Disputes are first routed to an AI oracle for a suggested ruling, which can then be challenged and escalated to a community-driven arbitration process. A reputation (Soul-Bound Token - SBT) system tracks creator performance and influence within the vault.

---

**Outline:**

*   **Contract Overview & Purpose**
*   **Interfaces & Libraries**
*   **State Variables & Data Structures**
*   **Events**
*   **Modifiers**
*   **Constructor**
*   **I. SynergyUnit (IP NFT) Management**
*   **II. Collaboration & Share Management**
*   **III. Revenue & Royalty Distribution**
*   **IV. AI Oracle Integration & Re-evaluation**
*   **V. Dispute Resolution & Arbitration**
*   **VI. Reputation (SBT) System**
*   **VII. Governance & Protocol Parameters**
*   **VIII. Utility & View Functions**

---

**Function Summary:**

1.  **`constructor(address _oracleAddress, address _arbitrationTokenAddress)`**: Initializes the contract, setting the address of the AI oracle and the ERC20 token used for staking by arbiters and governors.
2.  **`registerSynergyUnit(string _uri, uint256 _supplyCap, bytes32 _initialAIAnalysisHash)`**: Mints a new non-fungible `SynergyUnit` (ERC721 token) representing an IP asset. It stores metadata URI, a potential supply cap for derivatives, and a hash of an initial AI originality/quality assessment report. The creator is automatically assigned as a collaborator with 100% initial share.
3.  **`updateSynergyUnitMetadata(uint256 _tokenId, string _newUri, bytes32 _newAIAnalysisHash)`**: Allows the IP owner to update the metadata URI of a `SynergyUnit` and provide a new hash of an AI analysis, for instance, after significant updates to the IP.
4.  **`transferFrom(address _from, address _to, uint256 _tokenId)`**: Overrides the standard ERC721 `transferFrom`. When a `SynergyUnit` is transferred, existing collaboration shares are reset, and the new owner is assigned 100% of the shares.
5.  **`assignCollaborator(uint256 _tokenId, address _collaborator, uint256 _initialShareBps)`**: Adds a new collaborator to a `SynergyUnit` and defines their initial revenue share in basis points (10,000 BPS = 100%).
6.  **`removeCollaborator(uint256 _tokenId, address _collaborator)`**: Removes an existing collaborator from a `SynergyUnit`'s distribution list. The IP owner cannot be removed this way.
7.  **`updateCollaboratorShare(uint256 _tokenId, address _collaborator, uint256 _newShareBps)`**: Manually adjusts an existing collaborator's revenue share. This action typically requires the `SynergyUnit` owner's approval.
8.  **`requestAIReevaluation(uint256 _tokenId, string _contextUri)`**: Initiates an AI oracle request to re-evaluate the contribution shares for a `SynergyUnit`. This is based on new context or updated IP content, linked via `_contextUri`.
9.  **`finalizeAIReevaluation(uint256 _requestId, uint256 _tokenId, bytes32 _aiReportHash, address[] _collaborators, uint256[] _newSharesBps)`**: An oracle-only function that is called after the AI has processed a re-evaluation request. It submits the AI's suggested new share distribution, updating the `SynergyUnit`'s collaboration structure.
10. **`depositRevenue(uint256 _tokenId)`**: Allows any user to deposit native tokens (e.g., Ether) into the contract as revenue for a specific `SynergyUnit`.
11. **`withdrawRevenue(uint256 _tokenId, address _collaborator)`**: Enables a collaborator to withdraw their accrued share of the `SynergyUnit`'s deposited revenue.
12. **`setRoyaltyRecipient(uint256 _tokenId, address _recipient)`**: Designates an external address that should receive royalties generated by the `SynergyUnit` (e.g., from an integrated NFT marketplace).
13. **`initiateDispute(uint256 _tokenId, address _againstCollaborator, string _initialEvidenceUri)`**: Starts a formal dispute between collaborators regarding shares or IP usage, linking to initial evidence. Locks the stake of involved parties.
14. **`submitDisputeEvidence(uint256 _disputeId, string _evidenceUri)`**: Allows parties involved in an active dispute to submit additional evidence.
15. **`requestAIDisputeRuling(uint256 _disputeId, string _contextUri)`**: Sends a request to the AI oracle to provide a ruling on an active dispute, based on all submitted evidence and context.
16. **`submitAIDisputeRuling(uint256 _disputeId, bytes32 _aiRulingHash, address[] _parties, uint256[] _suggestedSharesBps)`**: An oracle-only function to record the AI's suggested resolution for a dispute, including proposed share adjustments.
17. **`challengeAIRuling(uint256 _disputeId)`**: Allows an eligible arbiter (one who has staked sufficient `arbitrationToken`) to challenge an AI's ruling, moving the dispute into a community-based human arbitration phase. Requires a challenge fee.
18. **`stakeForArbitration(uint256 _amount)`**: Allows users to stake `arbitrationToken` to become eligible human arbiters and gain voting power for dispute resolution and governance.
19. **`unstakeFromArbitration()`**: Enables a user to remove their staked `arbitrationToken`, provided their stake is not locked due to active dispute involvement or governance voting.
20. **`voteOnDispute(uint256 _disputeId, address _forParty, uint256 _voteWeight)`**: Human arbiters cast weighted votes (based on their staked amount) during a challenged dispute to determine the outcome.
21. **`finalizeDispute(uint256 _disputeId)`**: Concludes a dispute. It applies either the AI's ruling (if not challenged) or the community's arbitration decision, and updates the reputation scores of involved collaborators.
22. **`_updateReputation(address _creator, int256 _deltaScore)`**: An internal function to adjust a creator's reputation score (SBT) based on system events like successful collaborations, dispute outcomes, or AI assessments.
23. **`proposeGovernanceChange(string _proposalUri, address _target, bytes _calldata)`**: Allows users with staked tokens to propose changes to the protocol's parameters or logic. A URI links to proposal details, and `_calldata` specifies the function call to be executed if the proposal passes.
24. **`voteOnProposal(uint256 _proposalId, bool _support)`**: Stakers cast their weighted vote (based on their staked amount) on an active governance proposal.
25. **`executeProposal(uint256 _proposalId)`**: Executes an approved governance proposal. This function is restricted to the contract owner (or a designated execution role) after the voting period has ended and quorum/majority conditions are met.
26. **`getCreatorReputation(address _creator)`**: A view function to retrieve the current reputation score of a specific creator.
27. **`getSynergyUnitInfo(uint256 _tokenId)`**: A view function that returns comprehensive details about a `SynergyUnit`, including its owner, URI, collaborators, shares, and revenue.
28. **`getDisputeInfo(uint256 _disputeId)`**: A view function that provides all relevant information about a specific dispute, such as involved parties, evidence, AI ruling hash, and current status.

---
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

// Outline:
// Contract Overview & Purpose
// Interfaces & Libraries
// State Variables & Data Structures
// Events
// Modifiers
// Constructor
// I. SynergyUnit (IP NFT) Management
// II. Collaboration & Share Management
// III. Revenue & Royalty Distribution
// IV. AI Oracle Integration & Re-evaluation
// V. Dispute Resolution & Arbitration
// VI. Reputation (SBT) System
// VII. Governance & Protocol Parameters
// VIII. Utility & View Functions

// Function Summary:
// 1.  constructor(): Initializes the contract with an oracle address and the token used for staking in arbitration/governance.
// 2.  registerSynergyUnit(string _uri, uint256 _supplyCap, bytes32 _initialAIAnalysisHash): Mints a new non-fungible SynergyUnit representing an IP, storing its metadata and an initial AI originality/quality assessment hash.
// 3.  updateSynergyUnitMetadata(uint256 _tokenId, string _newUri, bytes32 _newAIAnalysisHash): Allows the IP owner to update the metadata URI and provide a new AI analysis hash (e.g., after IP updates or improvements).
// 4.  transferFrom(address _from, address _to, uint256 _tokenId): Standard ERC721 transfer, overridden to manage collaboration shares upon full ownership transfer.
// 5.  assignCollaborator(uint256 _tokenId, address _collaborator, uint256 _initialShareBps): Adds a new collaborator to a SynergyUnit and sets their initial revenue share in basis points (10,000 BPS = 100%).
// 6.  removeCollaborator(uint256 _tokenId, address _collaborator): Removes a collaborator from a SynergyUnit's distribution list.
// 7.  updateCollaboratorShare(uint256 _tokenId, address _collaborator, uint256 _newShareBps): Manually adjusts a collaborator's revenue share, requires owner approval.
// 8.  requestAIReevaluation(uint256 _tokenId, string _contextUri): Triggers an AI oracle request to re-evaluate contribution shares for a SynergyUnit based on new context, evidence, or updated IP.
// 9.  finalizeAIReevaluation(uint256 _requestId, uint256 _tokenId, bytes32 _aiReportHash, address[] _collaborators, uint256[] _newSharesBps): Oracle-only function to submit the AI's re-evaluated share distribution, which then updates the SynergyUnit's share structure.
// 10. depositRevenue(uint256 _tokenId): Allows anyone to deposit native tokens (e.g., ETH) as revenue for a specific SynergyUnit.
// 11. withdrawRevenue(uint256 _tokenId, address _collaborator): Enables a collaborator to withdraw their accrued share of the SynergyUnit's revenue.
// 12. setRoyaltyRecipient(uint256 _tokenId, address _recipient): Designates an external address to receive royalties (e.g., from an NFT marketplace integration) for a SynergyUnit.
// 13. initiateDispute(uint256 _tokenId, address _againstCollaborator, string _evidenceUri): Starts a formal dispute between collaborators over shares or IP usage, linking to initial evidence.
// 14. submitDisputeEvidence(uint256 _disputeId, string _evidenceUri): Allows participants in a dispute to submit additional evidence.
// 15. requestAIDisputeRuling(uint256 _disputeId, string _contextUri): Sends a request to the AI oracle for a ruling on an active dispute based on all submitted evidence.
// 16. submitAIDisputeRuling(uint256 _disputeId, bytes32 _aiRulingHash, address[] _parties, uint256[] _suggestedSharesBps): Oracle-only function to record the AI's suggested resolution and share adjustments for a dispute.
// 17. challengeAIRuling(uint256 _disputeId): Initiates a community-based arbitration phase if parties disagree with the AI's ruling. Requires a stake to challenge.
// 18. stakeForArbitration(uint256 _amount): Allows users to stake arbitrationToken to become eligible human arbiters and gain voting power.
// 19. unstakeFromArbitration(): Removes stake and eligibility for human arbitration, subject to lock-up periods if active disputes.
// 20. voteOnDispute(uint256 _disputeId, address _forParty, uint256 _voteWeight): Human arbiters cast weighted votes (based on stake) during a challenged dispute.
// 21. finalizeDispute(uint256 _disputeId): Concludes a dispute, applying either the AI ruling or the community's arbitration decision, and updates reputation.
// 22. _updateReputation(address _creator, int256 _deltaScore): Internal function to adjust a creator's reputation score (SBT) based on system events.
// 23. proposeGovernanceChange(string _proposalUri, address _target, bytes _calldata): Allows stakers to propose changes to contract parameters or logic, providing a URI to proposal details and calldata for execution.
// 24. voteOnProposal(uint256 _proposalId, bool _support): Stakers cast their weighted vote on a governance proposal.
// 25. executeProposal(uint256 _proposalId): Executes an approved governance proposal.
// 26. getCreatorReputation(address _creator): View function to get a creator's current reputation score.
// 27. getSynergyUnitInfo(uint256 _tokenId): View function to retrieve comprehensive information about a SynergyUnit.
// 28. getDisputeInfo(uint256 _disputeId): View function to retrieve comprehensive information about a dispute.

// This contract leverages AI oracles for dynamic IP contribution assessment and dispute resolution,
// alongside a decentralized governance model and reputation system for IP co-creation and management.

interface IOracle {
    // In a real scenario, this would be more complex, e.g., using Chainlink's fulfill method.
    // For this example, we assume the oracle directly calls specific `finalize` functions.
    // The `requestData` function is a placeholder for interaction with an off-chain oracle service.
    function requestData(uint256 _requestId, string calldata _jobId, string calldata _payload) external returns (bytes32);
}

contract SynergyVault is ERC721, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;

    // --- State Variables & Data Structures ---

    // ERC721 properties for SynergyUnits
    Counters.Counter private _synergyTokenIds;

    // Represents an Intellectual Property (IP) unit
    struct SynergyUnit {
        address owner; // The primary owner (can be a multi-sig or another contract)
        string uri; // Metadata URI for the IP
        uint256 supplyCap; // Max number of derivative NFTs if applicable (conceptual, not fully implemented for minting derivatives here)
        bytes32 initialAIAnalysisHash; // Hash of initial AI report on originality/quality
        mapping(address => uint256) collaboratorsSharesBps; // Collaborator shares in Basis Points (10,000 = 100%)
        address[] currentCollaborators; // Array of current collaborators for iteration
        uint256 totalSharesBps; // Sum of all current shares
        uint256 revenueBalance; // Accumulate native token revenue for this IP
        address royaltyRecipient; // External address for royalty distribution (e.g., from an NFT marketplace)
        mapping(address => uint256) revenueClaimed; // Track claimed revenue per collaborator
        bytes32 latestAIReevaluationHash; // Hash of the latest AI re-evaluation report
    }
    mapping(uint256 => SynergyUnit) public synergyUnits;

    // Represents a Reputation Soul-Bound Token (SBT) profile for creators
    struct CreatorReputation {
        uint256 score; // Reputation score
        string metadataUri; // URI for SBT metadata (e.g., badges, achievements)
        bool exists; // To check if an address has a reputation profile
    }
    mapping(address => CreatorReputation) public creatorReputations;

    // Dispute management
    enum DisputeStatus {
        Active,          // Dispute initiated, evidence being gathered
        AIRuled,         // AI has provided a ruling
        Challenged,      // AI ruling challenged, human arbitration phase
        Finalized        // Dispute concluded and resolved
    }

    struct Dispute {
        uint256 tokenId;
        address initiator;
        address againstCollaborator;
        string initialEvidenceUri;
        string[] evidenceUris; // All submitted evidence
        uint256 aiRulingRequestId; // Request ID for AI oracle call
        bytes32 aiRulingHash; // Hash of AI's suggested ruling report
        mapping(address => uint256) aiSuggestedSharesBps; // AI's suggested shares
        mapping(address => uint256) humanArbitersVotes; // Votes from human arbiters (stake-weighted)
        uint256 totalHumanVoteWeight;
        address winner; // Final winner of the dispute if applicable
        DisputeStatus status;
        uint256 createdAt;
        uint256 challengedAt; // Timestamp when AI ruling was challenged
        uint256 finalizedAt;
    }
    Counters.Counter private _disputeIds;
    mapping(uint256 => Dispute) public disputes;

    // Governance
    enum ProposalStatus {
        Pending,   // Created but not yet active for voting (can be removed for simplicity if voting starts immediately)
        Active,    // Open for voting
        Queued,    // Passed voting, ready for execution (can be removed if execute is direct)
        Executed,  // Successfully executed
        Failed     // Failed to pass or execution failed
    }

    struct Proposal {
        uint256 id;
        string proposalUri; // URI to detailed proposal text/context
        address target; // Address of the contract to call for execution
        bytes calldataPayload; // Calldata to execute if proposal passes
        uint256 voteStartTime;
        uint256 voteEndTime;
        uint256 quorumRequired; // Min vote weight needed for approval
        uint256 forVotes;
        uint256 againstVotes;
        mapping(address => bool) hasVoted; // Check if an address has voted
        ProposalStatus status;
    }
    Counters.Counter private _proposalIds;
    mapping(uint256 => Proposal) public proposals;

    // Arbitration & Governance Staking
    IERC20 public arbitrationToken; // Token used for staking by arbiters/governors
    mapping(address => uint256) public stakedAmount;
    mapping(address => uint256) public lockedStakeUntil; // Prevents unstaking if involved in active dispute or governance vote
    uint256 public constant MAX_SHARE_BPS = 10000; // Basis points for 100%
    uint256 public MIN_ARBITRATION_STAKE = 1 ether; // Minimum stake to be an arbiter (in arbitrationToken units)
    uint256 public AI_CHALLENGE_STAKE_FEE = 0.1 ether; // Fee to challenge an AI ruling (in native token)

    // Oracle configuration
    address public oracleAddress;
    mapping(uint256 => uint256) public oracleRequests; // Map request ID to entity ID (tokenId or disputeId)
    Counters.Counter private _oracleRequestId; // Unique ID for each oracle request

    // --- Events ---
    event SynergyUnitRegistered(uint256 indexed tokenId, address indexed owner, string uri, bytes32 initialAIAnalysisHash);
    event SynergyUnitMetadataUpdated(uint256 indexed tokenId, string newUri, bytes32 newAIAnalysisHash);
    event CollaboratorAssigned(uint256 indexed tokenId, address indexed collaborator, uint256 shareBps);
    event CollaboratorRemoved(uint256 indexed tokenId, address indexed collaborator);
    event CollaboratorShareUpdated(uint256 indexed tokenId, address indexed collaborator, uint256 newShareBps);
    event AIReevaluationRequested(uint256 indexed requestId, uint256 indexed tokenId, string contextUri);
    event AIReevaluationFinalized(uint256 indexed requestId, uint256 indexed tokenId, bytes32 aiReportHash);
    event RevenueDeposited(uint256 indexed tokenId, address indexed depositor, uint256 amount);
    event RevenueWithdrawn(uint256 indexed tokenId, address indexed collaborator, uint256 amount);
    event RoyaltyRecipientSet(uint256 indexed tokenId, address indexed recipient);
    event DisputeInitiated(uint256 indexed disputeId, uint256 indexed tokenId, address indexed initiator, address againstCollaborator, string initialEvidenceUri);
    event DisputeEvidenceSubmitted(uint256 indexed disputeId, address indexed submitter, string evidenceUri);
    event AIDisputeRulingRequested(uint256 indexed requestId, uint256 indexed disputeId, string contextUri);
    event AIDisputeRulingSubmitted(uint256 indexed requestId, uint256 indexed disputeId, bytes32 aiRulingHash);
    event AIRulingChallenged(uint256 indexed disputeId, address indexed challenger);
    event ArbiterStaked(address indexed arbiter, uint256 amount);
    event ArbiterUnstaked(address indexed arbiter, uint256 amount);
    event DisputeVoteCast(uint256 indexed disputeId, address indexed arbiter, address forParty, uint256 voteWeight);
    event DisputeFinalized(uint256 indexed disputeId, DisputeStatus finalStatus);
    event ReputationUpdated(address indexed creator, uint256 newScore);
    event ProposalCreated(uint256 indexed proposalId, string proposalUri, address indexed proposer);
    event ProposalVoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 voteWeight);
    event ProposalExecuted(uint256 indexed proposalId);

    // --- Modifiers ---
    modifier onlySynergyUnitOwner(uint256 _tokenId) {
        require(ERC721.ownerOf(_tokenId) == msg.sender, "SV: Not SynergyUnit owner");
        _;
    }

    modifier onlyCollaborator(uint256 _tokenId) {
        require(synergyUnits[_tokenId].collaboratorsSharesBps[msg.sender] > 0 || ERC721.ownerOf(_tokenId) == msg.sender, "SV: Not a collaborator or owner");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == oracleAddress, "SV: Only oracle can call this function");
        _;
    }

    modifier onlyArbiter() {
        require(stakedAmount[msg.sender] >= MIN_ARBITRATION_STAKE, "SV: Not an eligible arbiter");
        _;
    }

    // --- Constructor ---
    constructor(address _oracleAddress, address _arbitrationTokenAddress)
        ERC721("SynergyVaultIP", "SYNERGYIP")
        Ownable(msg.sender)
    {
        require(_oracleAddress != address(0), "SV: Invalid oracle address");
        require(_arbitrationTokenAddress != address(0), "SV: Invalid arbitration token address");
        oracleAddress = _oracleAddress;
        arbitrationToken = IERC20(_arbitrationTokenAddress);
    }

    // Allows contract to receive native token (ETH)
    receive() external payable {}

    // --- I. SynergyUnit (IP NFT) Management ---

    function registerSynergyUnit(string memory _uri, uint256 _supplyCap, bytes32 _initialAIAnalysisHash)
        external
        nonReentrant
        returns (uint256)
    {
        _synergyTokenIds.increment();
        uint256 newItemId = _synergyTokenIds.current();

        _safeMint(msg.sender, newItemId); // Mints the ERC721 to the creator
        synergyUnits[newItemId].owner = msg.sender;
        synergyUnits[newItemId].uri = _uri;
        synergyUnits[newItemId].supplyCap = _supplyCap;
        synergyUnits[newItemId].initialAIAnalysisHash = _initialAIAnalysisHash;
        
        // Automatically assign the creator as a collaborator with 100% initial share
        // and add them to the currentCollaborators array.
        synergyUnits[newItemId].collaboratorsSharesBps[msg.sender] = MAX_SHARE_BPS;
        synergyUnits[newItemId].currentCollaborators.push(msg.sender);
        synergyUnits[newItemId].totalSharesBps = MAX_SHARE_BPS;

        // Ensure creator has a reputation profile
        if (!creatorReputations[msg.sender].exists) {
            _updateReputation(msg.sender, 0); // Initialize with default score
        }

        emit SynergyUnitRegistered(newItemId, msg.sender, _uri, _initialAIAnalysisHash);
        return newItemId;
    }

    function updateSynergyUnitMetadata(uint256 _tokenId, string memory _newUri, bytes32 _newAIAnalysisHash)
        external
        onlySynergyUnitOwner(_tokenId)
    {
        synergyUnits[_tokenId].uri = _newUri;
        synergyUnits[_tokenId].latestAIReevaluationHash = _newAIAnalysisHash; // Can be a new AI analysis or just update
        emit SynergyUnitMetadataUpdated(_tokenId, _newUri, _newAIAnalysisHash);
    }

    // Overrides the ERC721 transfer method to manage custom collaboration logic.
    // Full ownership transfer means all existing collaboration shares are reset for simplicity.
    function transferFrom(address _from, address _to, uint256 _tokenId)
        public
        override(ERC721)
        nonReentrant
    {
        // Standard ERC721 checks
        require(_isApprovedOrOwner(msg.sender, _tokenId), "ERC721: transfer caller is not owner nor approved");
        require(ownerOf(_tokenId) == _from, "ERC721: transfer from incorrect owner");
        require(_to != address(0), "ERC721: transfer to the zero address");

        // Custom logic for SynergyVault: reset collaborations upon full ownership transfer
        SynergyUnit storage unit = synergyUnits[_tokenId];
        
        // Transfer any outstanding revenue to the old owner before clearing
        for (uint256 i = 0; i < unit.currentCollaborators.length; i++) {
            address collab = unit.currentCollaborators[i];
            uint256 share = unit.collaboratorsSharesBps[collab];
            if (share > 0) {
                uint256 availableToClaim = (unit.revenueBalance * share) / MAX_SHARE_BPS;
                uint256 amountToWithdraw = availableToClaim - unit.revenueClaimed[collab];
                if (amountToWithdraw > 0) {
                    unit.revenueClaimed[collab] += amountToWithdraw; // Mark as claimed
                    (bool success, ) = payable(collab).call{value: amountToWithdraw}("");
                    require(success, "SV: Failed to send residual Ether to old collaborator");
                    emit RevenueWithdrawn(_tokenId, collab, amountToWithdraw);
                }
            }
        }
        unit.revenueBalance = 0; // Clear any remaining revenue after distribution attempts

        // Clear existing collaboration data
        delete unit.collaboratorsSharesBps;
        delete unit.currentCollaborators;
        unit.totalSharesBps = 0;
        delete unit.revenueClaimed;

        // Perform the actual ERC721 transfer
        _transfer(_from, _to, _tokenId);
        unit.owner = _to; // Update our custom owner field

        // Automatically assign new owner as collaborator with 100% initial share
        unit.collaboratorsSharesBps[_to] = MAX_SHARE_BPS;
        unit.currentCollaborators.push(_to);
        unit.totalSharesBps = MAX_SHARE_BPS;

        // Ensure new owner has a reputation profile
        if (!creatorReputations[_to].exists) {
            _updateReputation(_to, 0); // Initialize with default score
        }
    }

    // ERC721's internal _transfer method that is called by transferFrom.
    // No additional custom logic needed here beyond what's in transferFrom override.
    function _transfer(address from, address to, uint256 tokenId) internal override {
        // Clear approval for the token being transferred
        _approve(address(0), tokenId);

        _balances[from] = _balances[from] - 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    // --- II. Collaboration & Share Management ---

    function assignCollaborator(uint256 _tokenId, address _collaborator, uint256 _initialShareBps)
        public
        onlySynergyUnitOwner(_tokenId)
        nonReentrant
    {
        require(_collaborator != address(0), "SV: Invalid collaborator address");
        require(_initialShareBps > 0 && _initialShareBps <= MAX_SHARE_BPS, "SV: Share must be between 1 and 10000 BPS");
        require(synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator] == 0, "SV: Collaborator already assigned");
        require(synergyUnits[_tokenId].totalSharesBps + _initialShareBps <= MAX_SHARE_BPS, "SV: Total shares exceed 100%");

        synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator] = _initialShareBps;
        synergyUnits[_tokenId].currentCollaborators.push(_collaborator);
        synergyUnits[_tokenId].totalSharesBps += _initialShareBps;

        // Ensure collaborator has a reputation profile
        if (!creatorReputations[_collaborator].exists) {
            _updateReputation(_collaborator, 0); // Initialize with default score
        }

        emit CollaboratorAssigned(_tokenId, _collaborator, _initialShareBps);
    }

    function removeCollaborator(uint256 _tokenId, address _collaborator)
        external
        onlySynergyUnitOwner(_tokenId)
        nonReentrant
    {
        require(_collaborator != address(0), "SV: Invalid collaborator address");
        uint256 shareToRemove = synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator];
        require(shareToRemove > 0, "SV: Collaborator not found or has no share");
        require(ownerOf(_tokenId) != _collaborator, "SV: Cannot remove the IP owner as a collaborator directly; transfer ownership instead.");

        delete synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator];
        synergyUnits[_tokenId].totalSharesBps -= shareToRemove;

        // Remove from dynamic array by swapping with last element and popping
        for (uint256 i = 0; i < synergyUnits[_tokenId].currentCollaborators.length; i++) {
            if (synergyUnits[_tokenId].currentCollaborators[i] == _collaborator) {
                synergyUnits[_tokenId].currentCollaborators[i] = synergyUnits[_tokenId].currentCollaborators[synergyUnits[_tokenId].currentCollaborators.length - 1];
                synergyUnits[_tokenId].currentCollaborators.pop();
                break;
            }
        }
        emit CollaboratorRemoved(_tokenId, _collaborator);
    }

    function updateCollaboratorShare(uint256 _tokenId, address _collaborator, uint256 _newShareBps)
        external
        onlySynergyUnitOwner(_tokenId)
        nonReentrant
    {
        require(_collaborator != address(0), "SV: Invalid collaborator address");
        uint256 oldShare = synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator];
        require(oldShare > 0, "SV: Collaborator not found");
        require(_newShareBps > 0 && _newShareBps <= MAX_SHARE_BPS, "SV: New share must be between 1 and 10000 BPS");

        uint256 totalSharesExcludingCollaborator = synergyUnits[_tokenId].totalSharesBps - oldShare;
        require(totalSharesExcludingCollaborator + _newShareBps <= MAX_SHARE_BPS, "SV: Total shares exceed 100%");

        synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator] = _newShareBps;
        synergyUnits[_tokenId].totalSharesBps = totalSharesExcludingCollaborator + _newShareBps;
        emit CollaboratorShareUpdated(_tokenId, _collaborator, _newShareBps);
    }

    // --- III. Revenue & Royalty Distribution ---

    function depositRevenue(uint256 _tokenId) external payable nonReentrant {
        require(synergyUnits[_tokenId].owner != address(0), "SV: SynergyUnit does not exist");
        require(msg.value > 0, "SV: Deposit amount must be greater than zero");
        synergyUnits[_tokenId].revenueBalance += msg.value;
        emit RevenueDeposited(_tokenId, msg.sender, msg.value);
    }

    function withdrawRevenue(uint256 _tokenId, address _collaborator) external nonReentrant {
        require(synergyUnits[_tokenId].owner != address(0), "SV: SynergyUnit does not exist");
        require(synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator] > 0, "SV: Not an active collaborator");

        uint256 share = synergyUnits[_tokenId].collaboratorsSharesBps[_collaborator];
        uint256 totalRevenue = synergyUnits[_tokenId].revenueBalance;
        uint256 alreadyClaimed = synergyUnits[_tokenId].revenueClaimed[_collaborator];

        // Calculate current collaborator's proportional share based on existing revenue
        uint256 availableToClaim = (totalRevenue * share) / MAX_SHARE_BPS;
        uint256 amountToWithdraw = availableToClaim - alreadyClaimed;

        require(amountToWithdraw > 0, "SV: No revenue available to withdraw");

        synergyUnits[_tokenId].revenueClaimed[_collaborator] += amountToWithdraw;

        // Ensure the contract has enough balance
        require(address(this).balance >= amountToWithdraw, "SV: Insufficient contract balance for withdrawal");

        (bool success, ) = payable(_collaborator).call{value: amountToWithdraw}("");
        require(success, "SV: Failed to send Ether");

        emit RevenueWithdrawn(_tokenId, _collaborator, amountToWithdraw);
    }

    function setRoyaltyRecipient(uint256 _tokenId, address _recipient)
        external
        onlySynergyUnitOwner(_tokenId)
    {
        synergyUnits[_tokenId].royaltyRecipient = _recipient;
        emit RoyaltyRecipientSet(_tokenId, _recipient);
    }

    // --- IV. AI Oracle Integration & Re-evaluation ---

    function requestAIReevaluation(uint256 _tokenId, string memory _contextUri)
        external
        onlySynergyUnitOwner(_tokenId)
        nonReentrant
        returns (uint256 requestId)
    {
        require(synergyUnits[_tokenId].owner != address(0), "SV: SynergyUnit does not exist");
        requestId = _oracleRequestId.current();
        _oracleRequestId.increment();
        oracleRequests[requestId] = _tokenId; // Store tokenId for callback

        // This is a placeholder for actual oracle interaction (e.g., Chainlink Functions/External Adapter)
        // The `_contextUri` would typically point to the IP content, code, or evidence for AI analysis.
        IOracle(oracleAddress).requestData(requestId, "AI_RE_EVAL_JOB", _contextUri);

        emit AIReevaluationRequested(requestId, _tokenId, _contextUri);
        return requestId;
    }

    function finalizeAIReevaluation(uint256 _requestId, uint256 _tokenId, bytes32 _aiReportHash, address[] memory _collaborators, uint256[] memory _newSharesBps)
        external
        onlyOracle
        nonReentrant
    {
        require(oracleRequests[_requestId] == _tokenId, "SV: Mismatched request ID or token ID");
        SynergyUnit storage unit = synergyUnits[_tokenId];
        require(unit.owner != address(0), "SV: SynergyUnit does not exist");
        require(_collaborators.length == _newSharesBps.length, "SV: Collaborator and share arrays mismatch");

        uint256 newTotalShares = 0;
        for (uint256 i = 0; i < _newSharesBps.length; i++) {
            newTotalShares += _newSharesBps[i];
        }
        require(newTotalShares <= MAX_SHARE_BPS, "SV: New total shares exceed 100%");

        // Clear existing shares and set new ones
        delete unit.collaboratorsSharesBps;
        delete unit.currentCollaborators;
        unit.totalSharesBps = 0;

        for (uint256 i = 0; i < _collaborators.length; i++) {
            address collab = _collaborators[i];
            uint256 share = _newSharesBps[i];
            unit.collaboratorsSharesBps[collab] = share;
            unit.currentCollaborators.push(collab);
            unit.totalSharesBps += share;
        }

        unit.latestAIReevaluationHash = _aiReportHash;
        delete oracleRequests[_requestId]; // Clear the request

        emit AIReevaluationFinalized(_requestId, _tokenId, _aiReportHash);
    }

    // --- V. Dispute Resolution & Arbitration ---

    function initiateDispute(uint256 _tokenId, address _againstCollaborator, string memory _initialEvidenceUri)
        external
        onlyCollaborator(_tokenId)
        nonReentrant
        returns (uint256)
    {
        require(synergyUnits[_tokenId].collaboratorsSharesBps[_againstCollaborator] > 0 || ownerOf(_tokenId) == _againstCollaborator, "SV: Target is not a collaborator or owner");
        require(msg.sender != _againstCollaborator, "SV: Cannot initiate dispute against self");

        _disputeIds.increment();
        uint256 newDisputeId = _disputeIds.current();

        Dispute storage newDispute = disputes[newDisputeId];
        newDispute.tokenId = _tokenId;
        newDispute.initiator = msg.sender;
        newDispute.againstCollaborator = _againstCollaborator;
        newDispute.initialEvidenceUri = _initialEvidenceUri;
        newDispute.evidenceUris.push(_initialEvidenceUri);
        newDispute.status = DisputeStatus.Active;
        newDispute.createdAt = block.timestamp;

        // Lock relevant collaborators' stakes indefinitely until dispute finalizes
        lockedStakeUntil[msg.sender] = type(uint256).max;
        lockedStakeUntil[_againstCollaborator] = type(uint256).max;

        emit DisputeInitiated(newDisputeId, _tokenId, msg.sender, _againstCollaborator, _initialEvidenceUri);
        return newDisputeId;
    }

    function submitDisputeEvidence(uint256 _disputeId, string memory _evidenceUri)
        external
        nonReentrant
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.Active, "SV: Dispute not in active state for evidence submission");
        require(msg.sender == dispute.initiator || msg.sender == dispute.againstCollaborator, "SV: Only dispute parties can submit evidence");
        require(bytes(_evidenceUri).length > 0, "SV: Evidence URI cannot be empty");

        dispute.evidenceUris.push(_evidenceUri);
        emit DisputeEvidenceSubmitted(_disputeId, msg.sender, _evidenceUri);
    }

    function requestAIDisputeRuling(uint256 _disputeId, string memory _contextUri)
        external
        nonReentrant
        returns (uint256 requestId)
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.Active, "SV: Dispute not active");
        require(msg.sender == dispute.initiator || msg.sender == dispute.againstCollaborator || ownerOf(dispute.tokenId) == msg.sender, "SV: Only parties or owner can request AI ruling");

        requestId = _oracleRequestId.current();
        _oracleRequestId.increment();
        oracleRequests[requestId] = _disputeId;
        dispute.aiRulingRequestId = requestId;

        // Payload for AI might include all evidence URIs and the dispute context
        IOracle(oracleAddress).requestData(requestId, "AI_DISPUTE_JOB", _contextUri);

        emit AIDisputeRulingRequested(requestId, _disputeId, _contextUri);
        return requestId;
    }

    function submitAIDisputeRuling(uint256 _disputeId, bytes32 _aiRulingHash, address[] memory _parties, uint256[] memory _suggestedSharesBps)
        external
        onlyOracle
        nonReentrant
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.Active, "SV: Dispute not active for AI ruling submission");
        require(oracleRequests[dispute.aiRulingRequestId] == _disputeId, "SV: Mismatched oracle request ID for dispute");
        require(_parties.length == _suggestedSharesBps.length, "SV: Parties and shares arrays mismatch");

        // Validate that suggested shares are for the dispute participants (or associated owner/collaborators)
        // and that total doesn't exceed 100%
        uint256 newTotalShares = 0;
        for (uint256 i = 0; i < _suggestedSharesBps.length; i++) {
            newTotalShares += _suggestedSharesBps[i];
        }
        // AI might suggest re-distribution of a *portion* of shares, not necessarily full 100%
        // So this check might need adjustment depending on how AI applies its ruling
        // For simplicity, we assume AI provides a full re-evaluation up to 100% or less.
        require(newTotalShares <= MAX_SHARE_BPS, "SV: AI suggested total shares exceed 100%");

        dispute.aiRulingHash = _aiRulingHash;
        for (uint256 i = 0; i < _parties.length; i++) {
            dispute.aiSuggestedSharesBps[_parties[i]] = _suggestedSharesBps[i];
        }
        dispute.status = DisputeStatus.AIRuled;
        delete oracleRequests[dispute.aiRulingRequestId]; // Clear the request

        emit AIDisputeRulingSubmitted(dispute.aiRulingRequestId, _disputeId, _aiRulingHash);
    }

    function challengeAIRuling(uint256 _disputeId)
        external
        payable
        onlyArbiter // Only eligible arbiters can challenge
        nonReentrant
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.AIRuled, "SV: AI ruling not available or already challenged/finalized");
        require(msg.value >= AI_CHALLENGE_STAKE_FEE, "SV: Insufficient fee to challenge AI ruling");

        // The AI_CHALLENGE_STAKE_FEE is collected by the contract. It can be used to reward human arbiters
        // if the AI ruling is upheld, or returned to the challenger if the AI ruling is overturned.
        // For simplicity here, it just adds to contract balance.
        
        dispute.status = DisputeStatus.Challenged;
        dispute.challengedAt = block.timestamp;

        // Lock challenger's stake temporarily during arbitration voting.
        if (lockedStakeUntil[msg.sender] < block.timestamp + 14 days) { // Lock for ~2 weeks
            lockedStakeUntil[msg.sender] = block.timestamp + 14 days;
        }

        emit AIRulingChallenged(_disputeId, msg.sender);
    }

    function stakeForArbitration(uint256 _amount) external nonReentrant {
        require(_amount > 0, "SV: Stake amount must be positive");
        require(arbitrationToken.transferFrom(msg.sender, address(this), _amount), "SV: Token transfer failed");

        stakedAmount[msg.sender] += _amount;
        // If not already locked indefinitely by a dispute, apply a minimum lock period
        if (lockedStakeUntil[msg.sender] == 0 || lockedStakeUntil[msg.sender] < block.timestamp + 7 days) {
            lockedStakeUntil[msg.sender] = block.timestamp + 7 days; // Example lock period
        }
        emit ArbiterStaked(msg.sender, _amount);
    }

    function unstakeFromArbitration() external nonReentrant {
        require(stakedAmount[msg.sender] > 0, "SV: No stake to withdraw");
        require(block.timestamp >= lockedStakeUntil[msg.sender], "SV: Stake is currently locked due to active involvement or lock-up period");

        uint256 amountToUnstake = stakedAmount[msg.sender];
        stakedAmount[msg.sender] = 0;
        lockedStakeUntil[msg.sender] = 0; // Reset lock

        require(arbitrationToken.transfer(msg.sender, amountToUnstake), "SV: Token transfer failed");
        emit ArbiterUnstaked(msg.sender, amountToUnstake);
    }

    function voteOnDispute(uint256 _disputeId, address _forParty, uint256 _voteWeight)
        external
        onlyArbiter
        nonReentrant
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.Challenged, "SV: Dispute not in challenged state for voting");
        require(_forParty == dispute.initiator || _forParty == dispute.againstCollaborator, "SV: Can only vote for initiator or against collaborator");
        require(stakedAmount[msg.sender] >= _voteWeight, "SV: Not enough stake for the requested vote weight");
        require(dispute.humanArbitersVotes[msg.sender] == 0, "SV: Arbiter already voted"); // Simplified: only one vote per arbiter

        dispute.humanArbitersVotes[msg.sender] += _voteWeight; // For simplicity, vote for a specific party directly
        dispute.totalHumanVoteWeight += _voteWeight;

        // Lock the voter's stake until the dispute is finalized.
        if (lockedStakeUntil[msg.sender] < type(uint256).max) { // Lock only if not already indefinitely locked
            lockedStakeUntil[msg.sender] = block.timestamp + 14 days; // Example: Lock during voting + buffer
        }

        emit DisputeVoteCast(_disputeId, msg.sender, _forParty, _voteWeight);
    }

    function finalizeDispute(uint256 _disputeId)
        external
        nonReentrant
    {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.status == DisputeStatus.AIRuled || dispute.status == DisputeStatus.Challenged, "SV: Dispute not ready for finalization");

        SynergyUnit storage unit = synergyUnits[dispute.tokenId];
        require(unit.owner != address(0), "SV: Associated SynergyUnit does not exist");

        // Determine final share distribution
        mapping(address => uint256) newCollaboratorShares; // Temporary map for new shares
        address[] memory currentCollaborators = unit.currentCollaborators;
        uint256 totalNewSharesBps = 0;

        // Start with existing collaborators' shares, then adjust based on ruling
        for (uint256 i = 0; i < currentCollaborators.length; i++) {
            newCollaboratorShares[currentCollaborators[i]] = unit.collaboratorsSharesBps[currentCollaborators[i]];
        }
        
        // Apply AI ruling as base
        if (dispute.aiRulingHash != bytes32(0)) {
            newCollaboratorShares[dispute.initiator] = dispute.aiSuggestedSharesBps[dispute.initiator];
            newCollaboratorShares[dispute.againstCollaborator] = dispute.aiSuggestedSharesBps[dispute.againstCollaborator];
        }

        if (dispute.status == DisputeStatus.Challenged) {
            // Overwrite with human arbitration decision if it passes
            uint256 initiatorVotes = dispute.humanArbitersVotes[dispute.initiator];
            uint256 againstVotes = dispute.humanArbitersVotes[dispute.againstCollaborator];

            if (initiatorVotes > againstVotes) {
                // Initiator wins - assign their preferred share or a predefined outcome
                newCollaboratorShares[dispute.initiator] = newCollaboratorShares[dispute.initiator] + (MAX_SHARE_BPS / 10); // Example: boost their share by 10%
                newCollaboratorShares[dispute.againstCollaborator] = newCollaboratorShares[dispute.againstCollaborator] > (MAX_SHARE_BPS / 20) ? newCollaboratorShares[dispute.againstCollaborator] - (MAX_SHARE_BPS / 20) : 0; // Penalize opponent
                _updateReputation(dispute.initiator, 50); // Boost reputation for winning
                _updateReputation(dispute.againstCollaborator, -25); // Penalize for losing
            } else if (againstVotes > initiatorVotes) {
                // Against collaborator wins
                newCollaboratorShares[dispute.againstCollaborator] = newCollaboratorShares[dispute.againstCollaborator] + (MAX_SHARE_BPS / 10);
                newCollaboratorShares[dispute.initiator] = newCollaboratorShares[dispute.initiator] > (MAX_SHARE_BPS / 20) ? newCollaboratorShares[dispute.initiator] - (MAX_SHARE_BPS / 20) : 0;
                _updateReputation(dispute.againstCollaborator, 50);
                _updateReputation(dispute.initiator, -25);
            } else {
                // Tie, AI ruling stands or balanced outcome (e.g., 50/50 split of disputed amount)
                _updateReputation(dispute.initiator, 5); // Minor boost for participating
                _updateReputation(dispute.againstCollaborator, 5);
            }
        } else { // AI_Ruled status, not challenged
            _updateReputation(dispute.initiator, 10); // Small boost for resolving via AI
            _updateReputation(dispute.againstCollaborator, 10);
        }

        // Re-calculate total shares and apply to SynergyUnit, ensuring it doesn't exceed 100%
        unit.totalSharesBps = 0;
        for (uint256 i = 0; i < currentCollaborators.length; i++) {
            address collab = currentCollaborators[i];
            unit.collaboratorsSharesBps[collab] = newCollaboratorShares[collab];
            unit.totalSharesBps += newCollaboratorShares[collab];
        }
        // Ensure total shares don't exceed MAX_SHARE_BPS, adjust proportionately if necessary (simplified)
        if (unit.totalSharesBps > MAX_SHARE_BPS) {
             // Redistribute excess or cap. For simplicity, we'll cap.
             // In a real system, would involve proportional reduction or owner gets excess.
             // For now, if AI/human arbitration suggests >100%, it implies a system misconfig or error,
             // or dynamic reallocation rules need to be very explicit.
             // For this example, if it somehow exceeds, we can make it revert or proportionally adjust.
             revert("SV: Final total shares exceed 100% after dispute resolution. This indicates an invalid share distribution.");
        }


        dispute.status = DisputeStatus.Finalized;
        dispute.finalizedAt = block.timestamp;

        // Unlock stakes of dispute parties
        lockedStakeUntil[dispute.initiator] = 0;
        lockedStakeUntil[dispute.againstCollaborator] = 0;

        emit DisputeFinalized(_disputeId, DisputeStatus.Finalized);
    }

    // --- VI. Reputation (SBT) System ---

    // Internal function to update reputation scores
    function _updateReputation(address _creator, int256 _deltaScore) internal {
        if (!creatorReputations[_creator].exists) {
            creatorReputations[_creator] = CreatorReputation({
                score: 100, // Initial default score
                metadataUri: "", // Placeholder for future SBT metadata
                exists: true
            });
        }

        int256 currentScore = int256(creatorReputations[_creator].score);
        int256 newScore = currentScore + _deltaScore;

        if (newScore < 0) newScore = 0; // Reputation cannot go below 0
        // No explicit max reputation to allow for high achievement. Prevents overflow if it goes too high.
        if (newScore > type(int256).max) newScore = type(int256).max; 

        creatorReputations[_creator].score = uint256(newScore);
        emit ReputationUpdated(_creator, uint256(newScore));
    }

    function getCreatorReputation(address _creator) external view returns (uint256) {
        return creatorReputations[_creator].score;
    }

    // --- VII. Governance & Protocol Parameters ---

    function proposeGovernanceChange(string memory _proposalUri, address _target, bytes memory _calldata)
        external
        nonReentrant
        returns (uint256)
    {
        require(stakedAmount[msg.sender] > 0, "SV: Proposer must have stake");
        _proposalIds.increment();
        uint256 newProposalId = _proposalIds.current();

        Proposal storage newProposal = proposals[newProposalId];
        newProposal.id = newProposalId;
        newProposal.proposalUri = _proposalUri;
        newProposal.target = _target;
        newProposal.calldataPayload = _calldata;
        newProposal.voteStartTime = block.timestamp;
        newProposal.voteEndTime = block.timestamp + 7 days; // 7-day voting period
        newProposal.quorumRequired = totalStaked() / 10; // Example: 10% of total staked tokens for quorum
        newProposal.status = ProposalStatus.Active;

        // Lock proposer's stake for the duration of the vote
        if (lockedStakeUntil[msg.sender] < newProposal.voteEndTime) {
            lockedStakeUntil[msg.sender] = newProposal.voteEndTime;
        }

        emit ProposalCreated(newProposalId, _proposalUri, msg.sender);
        return newProposalId;
    }

    function voteOnProposal(uint256 _proposalId, bool _support)
        external
        nonReentrant
    {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.status == ProposalStatus.Active, "SV: Proposal not active for voting");
        require(block.timestamp >= proposal.voteStartTime && block.timestamp <= proposal.voteEndTime, "SV: Voting period not active");
        require(stakedAmount[msg.sender] > 0, "SV: Voter must have stake");
        require(!proposal.hasVoted[msg.sender], "SV: Already voted on this proposal");

        uint256 voteWeight = stakedAmount[msg.sender];
        if (_support) {
            proposal.forVotes += voteWeight;
        } else {
            proposal.againstVotes += voteWeight;
        }
        proposal.hasVoted[msg.sender] = true;

        // Lock voter's stake for the duration of the vote
        if (lockedStakeUntil[msg.sender] < proposal.voteEndTime) {
            lockedStakeUntil[msg.sender] = proposal.voteEndTime;
        }

        emit ProposalVoteCast(_proposalId, msg.sender, _support, voteWeight);
    }

    function executeProposal(uint256 _proposalId)
        external
        nonReentrant
        onlyOwner // Only owner (or a designated execution multisig/timelock) can execute after passing
    {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.status == ProposalStatus.Active, "SV: Proposal not active");
        require(block.timestamp > proposal.voteEndTime, "SV: Voting period not ended");

        if (proposal.forVotes > proposal.againstVotes && proposal.forVotes >= proposal.quorumRequired) {
            // Proposal passes
            (bool success, ) = proposal.target.call(proposal.calldataPayload);
            require(success, "SV: Proposal execution failed");
            proposal.status = ProposalStatus.Executed;
        } else {
            proposal.status = ProposalStatus.Failed;
        }
        emit ProposalExecuted(_proposalId);
    }

    // --- VIII. Utility & View Functions ---

    function totalStaked() public view returns (uint256) {
        // Returns the total amount of arbitrationToken held by this contract,
        // which represents the total staked amount available for voting.
        return arbitrationToken.balanceOf(address(this));
    }

    function getSynergyUnitInfo(uint256 _tokenId)
        external
        view
        returns (
            address owner,
            string memory uri,
            uint256 supplyCap,
            bytes32 initialAIAnalysisHash,
            bytes32 latestAIReevaluationHash,
            address[] memory collaborators,
            uint256[] memory sharesBps,
            uint256 totalRevenue,
            address royaltyRecipient
        )
    {
        SynergyUnit storage unit = synergyUnits[_tokenId];
        owner = unit.owner;
        uri = unit.uri;
        supplyCap = unit.supplyCap;
        initialAIAnalysisHash = unit.initialAIAnalysisHash;
        latestAIReevaluationHash = unit.latestAIReevaluationHash;
        
        collaborators = new address[](unit.currentCollaborators.length);
        sharesBps = new uint256[](unit.currentCollaborators.length);
        for (uint256 i = 0; i < unit.currentCollaborators.length; i++) {
            collaborators[i] = unit.currentCollaborators[i];
            sharesBps[i] = unit.collaboratorsSharesBps[unit.currentCollaborators[i]];
        }
        totalRevenue = unit.revenueBalance;
        royaltyRecipient = unit.royaltyRecipient;
    }

    function getDisputeInfo(uint256 _disputeId)
        external
        view
        returns (
            uint256 tokenId,
            address initiator,
            address againstCollaborator,
            string[] memory evidenceUris,
            bytes32 aiRulingHash,
            DisputeStatus status,
            uint256 createdAt,
            uint256 challengedAt,
            uint256 finalizedAt
        )
    {
        Dispute storage dispute = disputes[_disputeId];
        tokenId = dispute.tokenId;
        initiator = dispute.initiator;
        againstCollaborator = dispute.againstCollaborator;
        // Clone the array to return it
        evidenceUris = new string[](dispute.evidenceUris.length);
        for (uint256 i = 0; i < dispute.evidenceUris.length; i++) {
            evidenceUris[i] = dispute.evidenceUris[i];
        }
        aiRulingHash = dispute.aiRulingHash;
        status = dispute.status;
        createdAt = dispute.createdAt;
        challengedAt = dispute.challengedAt;
        finalizedAt = dispute.finalizedAt;
    }
}
```