This smart contract, `ChronicleForge`, introduces a novel concept of "Digital Ecosystems" on the blockchain. It manages unique, dynamic NFTs called "Chronicles" which are not static images but "living" digital entities that evolve, generate resources, and interact with a global, mutable environment. It integrates a decentralized narrative layer, an influence/reputation system, and adaptive game mechanics.

---

## ChronicleForge Smart Contract

**Outline:**

The `ChronicleForge` contract is a complex system managing two primary tokens: `Chronicle` (an ERC721-like dynamic NFT) and `Essence` (an ERC20-like utility token). It provides mechanisms for:

1.  **Chronicle Lifecycle Management:** Minting new Chronicles with unique initial attributes, tracking their state, decay, and the ability to "nourish" them.
2.  **Dynamic NFT Mechanics:** Chronicles passively generate `Essence` based on their internal properties. They can also "mutate" their core "Archetype" based on probabilistic events and user input.
3.  **Essence Economy:** `Essence` is generated by Chronicles, claimed by owners, and used to interact with the system (e.g., nourish Chronicles, trigger mutations, submit narratives).
4.  **Global Environmental Variables:** The contract maintains global parameters that influence all Chronicles (e.g., decay rate, mutation base chance). These parameters can be updated by governance.
5.  **Decentralized Governance/Influence:** A system for proposing and voting on changes to the global environment. Users earn "Influence" for active participation.
6.  **Narrative Layer:** A unique feature allowing users to contribute short "Glyphs" (narrative snippets) which can be voted on and incorporated into the contract's "Chronicle Lore." This creates an on-chain, evolving story.
7.  **Pseudo-Randomness:** Utilizes block-based data for basic pseudo-random attribute generation and mutation probability, acknowledging the limitations for true randomness on-chain.

**Key Advanced Concepts & Trendy Functions:**

*   **Dynamic NFTs:** Chronicles have mutable attributes (`health`, `complexity`, `potential`) that change over time based on on-chain actions and environmental factors. Their value and functionality are not fixed.
*   **On-Chain Resource Generation:** Chronicles continuously accumulate `Essence` based on their `complexity` and the global `essenceGenerationRate`. This creates a passive income stream for NFT holders.
*   **Decay Mechanics:** Chronicles decay (`health` decreases) over time, requiring `Essence` to be "nourished." This encourages active participation and creates an `Essence` sink.
*   **Probabilistic Mutation System:** Chronicles can undergo "mutation" to change their `Archetype`, a core attribute. This is a probabilistic event influenced by `potential` and global `mutationBaseChance`, requiring `Essence` and introducing an element of strategic risk/reward.
*   **Adaptive Environmental Variables:** Global contract parameters can change, simulating an evolving ecosystem. These changes affect all Chronicles, creating a dynamic meta-game.
*   **On-Chain Governance & Influence:** Users can propose and vote on changes to the environmental variables. An `Influence` score, earned through active participation, can be delegated, forming a primitive reputation/delegated voting system.
*   **Decentralized Narrative Layer:** The `submitGlyph`, `voteOnGlyph`, and `incorporateGlyph` functions enable users to collaboratively build an on-chain lore or story associated with the ecosystem. This moves beyond simple metadata and integrates creative content directly into the contract.
*   **Stimulus Mechanic:** Temporarily boosts a Chronicle's performance (e.g., essence generation) by consuming `Essence`, providing a short-term strategic advantage.

---

### Function Summary (20+ Functions):

**I. Core ERC721-like Chronicle Management:**
1.  `constructor()`: Initializes the contract, sets names, symbols, and initial global parameters.
2.  `balanceOf(address owner)`: Returns the number of Chronicles owned by an address.
3.  `ownerOf(uint256 tokenId)`: Returns the owner of a specific Chronicle.
4.  `approve(address to, uint256 tokenId)`: Grants approval to an address to manage a specific Chronicle.
5.  `getApproved(uint256 tokenId)`: Returns the approved address for a specific Chronicle.
6.  `setApprovalForAll(address operator, bool approved)`: Grants/revokes operator status for all Chronicles of an owner.
7.  `isApprovedForAll(address owner, address operator)`: Checks if an address is an operator for an owner.
8.  `transferFrom(address from, address to, uint256 tokenId)`: Transfers ownership of a Chronicle.
9.  `safeTransferFrom(address from, address to, uint256 tokenId)`: Safely transfers ownership of a Chronicle (checks if recipient can receive NFTs).

**II. Core ERC20-like Essence Management:**
10. `essenceBalanceOf(address account)`: Returns the Essence balance of an account.
11. `essenceTransfer(address recipient, uint256 amount)`: Transfers Essence tokens to another address.
12. `essenceApprove(address spender, uint256 amount)`: Approves a third party to spend Essence on behalf of the caller.
13. `essenceTransferFrom(address sender, address recipient, uint256 amount)`: Transfers Essence using an allowance.
14. `_mintEssence(address account, uint256 amount)`: Internal function to mint Essence.
15. `_burnEssence(address account, uint256 amount)`: Internal function to burn Essence.

**III. Chronicle Lifecycle & Dynamics:**
16. `mintChronicle()`: Mints a new Chronicle NFT, assigning initial dynamic attributes (health, complexity, potential, archetype) using pseudo-randomness.
17. `getChronicleDetails(uint256 chronicleId)`: Retrieves all current dynamic attributes and state of a specified Chronicle.
18. `claimEssence(uint256 chronicleId)`: Allows the owner to claim accumulated `Essence` from their Chronicle, calculated based on time elapsed and Chronicle attributes.
19. `nourishChronicle(uint256 chronicleId, uint256 amount)`: Spends `Essence` to replenish a Chronicle's `health`, preventing decay and restoring its vitality.
20. `triggerMutation(uint256 chronicleId)`: Attempts to mutate a Chronicle's `Archetype` based on its `potential`, current `health`, global `mutationBaseChance`, and a cost in `Essence`. This is a probabilistic action.
21. `stimulateChronicle(uint256 chronicleId, uint256 duration)`: Spends `Essence` to apply a temporary "stimulus" buff to a Chronicle, boosting its `Essence` generation rate for a set duration.
22. `_updateChronicleState(uint256 chronicleId)`: Internal helper function to update a Chronicle's health, accumulated essence, and other time-dependent states.
23. `getChronicleEpochState(uint256 chronicleId)`: Returns the current state variables relevant to the Chronicle's interaction with the global environment.

**IV. Global Environmental Variables & Governance:**
24. `updateGlobalEpochParameters()`: Callable by the contract owner (or a designated role/DAO), this function updates global environmental parameters based on a predefined schedule or conditions, affecting all Chronicles.
25. `proposeEnvironmentalShift(uint256 paramIndex, int256 delta)`: Allows users with sufficient Influence/Essence to propose a change to a global environmental parameter.
26. `voteOnEnvironmentalShift(uint256 proposalId, bool vote)`: Users cast their vote (for/against) on an active environmental shift proposal.
27. `executeEnvironmentalShift(uint256 proposalId)`: Executes an environmental shift proposal if it has gathered enough votes and the voting period has ended.
28. `getEnvironmentalParameter(uint256 paramIndex)`: Retrieves the current value and details of a specific global environmental parameter.

**V. Decentralized Narrative Layer:**
29. `submitGlyph(string memory text)`: Allows users to submit a short narrative "Glyph" (text snippet) by paying `Essence`, proposing it for inclusion in the lore.
30. `voteOnGlyph(uint256 glyphId, bool approve)`: Users vote on the quality or relevance of proposed Glyphs.
31. `incorporateGlyph(uint256 glyphId)`: Incorporates a highly-voted Glyph into the permanent `chronicleLore` array, making it part of the official on-chain narrative.
32. `getGlyph(uint256 glyphId)`: Retrieves the details of a submitted Glyph.
33. `getChronicleLore(uint256 index)`: Retrieves an incorporated lore entry from the public narrative.

**VI. Reputation & Influence System:**
34. `getInfluenceScore(address account)`: Returns the current Influence score of an address, reflecting their active participation.
35. `delegateInfluence(address delegatee, uint256 amount)`: Allows a user to delegate a portion of their Influence score to another address for voting purposes.

---
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ChronicleForge
 * @dev A smart contract managing dynamic NFTs ("Chronicles") and an ERC20 utility token ("Essence")
 *      within an evolving digital ecosystem.
 *
 * Concepts:
 * - Dynamic NFTs (Chronicles): Attributes change based on time, user actions, and global events.
 * - On-Chain Resource Generation: Chronicles passively generate 'Essence' based on their properties.
 * - Adaptive Mechanics: Decay, mutation, and resource generation rates are influenced by global state.
 * - Decentralized Narrative Layer: Users contribute and vote on 'Glyphs' (narrative snippets)
 *   to build an on-chain lore.
 * - Influence/Reputation System: Active participation earns 'Influence' for governance.
 * - Pseudo-Randomness: Basic block-based randomness for initial attributes and probabilistic events.
 *
 * Functions Summary:
 * I. Core ERC721-like Chronicle Management:
 *    1.  constructor()
 *    2.  balanceOf(address owner)
 *    3.  ownerOf(uint256 tokenId)
 *    4.  approve(address to, uint256 tokenId)
 *    5.  getApproved(uint256 tokenId)
 *    6.  setApprovalForAll(address operator, bool approved)
 *    7.  isApprovedForAll(address owner, bool operator)
 *    8.  transferFrom(address from, address to, uint256 tokenId)
 *    9.  safeTransferFrom(address from, address to, uint256 tokenId)
 * II. Core ERC20-like Essence Management:
 *    10. essenceBalanceOf(address account)
 *    11. essenceTransfer(address recipient, uint256 amount)
 *    12. essenceApprove(address spender, uint256 amount)
 *    13. essenceTransferFrom(address sender, address recipient, uint256 amount)
 *    14. _mintEssence(address account, uint256 amount) (Internal)
 *    15. _burnEssence(address account, uint256 amount) (Internal)
 * III. Chronicle Lifecycle & Dynamics:
 *    16. mintChronicle()
 *    17. getChronicleDetails(uint256 chronicleId)
 *    18. claimEssence(uint256 chronicleId)
 *    19. nourishChronicle(uint256 chronicleId, uint256 amount)
 *    20. triggerMutation(uint256 chronicleId)
 *    21. stimulateChronicle(uint256 chronicleId, uint256 duration)
 *    22. _updateChronicleState(uint256 chronicleId) (Internal)
 *    23. getChronicleEpochState(uint256 chronicleId)
 * IV. Global Environmental Variables & Governance:
 *    24. updateGlobalEpochParameters()
 *    25. proposeEnvironmentalShift(uint256 paramIndex, int256 delta)
 *    26. voteOnEnvironmentalShift(uint256 proposalId, bool vote)
 *    27. executeEnvironmentalShift(uint256 proposalId)
 *    28. getEnvironmentalParameter(uint256 paramIndex)
 * V. Decentralized Narrative Layer:
 *    29. submitGlyph(string memory text)
 *    30. voteOnGlyph(uint256 glyphId, bool approve)
 *    31. incorporateGlyph(uint256 glyphId)
 *    32. getGlyph(uint256 glyphId)
 *    33. getChronicleLore(uint256 index)
 * VI. Reputation & Influence System:
 *    34. getInfluenceScore(address account)
 *    35. delegateInfluence(address delegatee, uint256 amount)
 */

contract ChronicleForge {

    // --- ERC721 & ERC20 Core Definitions ---
    string public constant NAME = "ChronicleForge";
    string public constant SYMBOL = "CHRON";
    string public constant ESSENCE_NAME = "Essence";
    string public constant ESSENCE_SYMBOL = "ESS";
    uint8 public constant ESSENCE_DECIMALS = 0; // Essence is an integer resource

    uint256 private _nextTokenId;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    mapping(address => uint256) private _essenceBalances;
    mapping(address => mapping(address => uint256)) private _essenceAllowances;
    uint256 private _totalEssenceSupply;

    // --- Access Control ---
    address public owner; // Simple owner-based access control for certain functions

    modifier onlyOwner() {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    // --- Events ---
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event EssenceTransfer(address indexed from, address indexed to, uint256 value);
    event EssenceApproval(address indexed owner, address indexed spender, uint256 value);
    event ChronicleMinted(uint256 indexed chronicleId, address indexed owner, uint256 creationTime, uint8 archetype, uint256 health, uint256 complexity, uint256 potential);
    event EssenceClaimed(uint256 indexed chronicleId, address indexed owner, uint256 amount);
    event ChronicleNourished(uint256 indexed chronicleId, address indexed nourisher, uint256 amount, uint256 newHealth);
    event ChronicleMutated(uint256 indexed chronicleId, uint8 oldArchetype, uint8 newArchetype);
    event ChronicleStimulated(uint256 indexed chronicleId, address indexed stimulator, uint256 duration, uint256 boostMultiplier);
    event GlobalEpochParametersUpdated(uint256 lastUpdatedBlock, uint256 essenceGenerationRate, uint256 decayRate, uint256 mutationBaseChance);
    event EnvironmentalShiftProposed(uint256 indexed proposalId, uint256 indexed paramIndex, int256 delta, address indexed proposer);
    event EnvironmentalShiftVoted(uint256 indexed proposalId, address indexed voter, bool vote);
    event EnvironmentalShiftExecuted(uint256 indexed proposalId, uint256 indexed paramIndex, int256 newValue);
    event GlyphSubmitted(uint256 indexed glyphId, address indexed proposer, string text);
    event GlyphVoted(uint256 indexed glyphId, address indexed voter, bool approve);
    event GlyphIncorporated(uint256 indexed glyphId);
    event InfluenceChanged(address indexed account, uint256 newScore);
    event InfluenceDelegated(address indexed delegator, address indexed delegatee, uint256 amount);

    // --- Chronicle & System Enums/Structs ---
    enum Archetype {
        Mystic,
        Warrior,
        Scholar,
        Artisan,
        Nomad,
        Diplomat,
        Innovator,
        Sentinel,
        Explorer,
        Dreamweaver // 10 archetypes
    }

    struct Chronicle {
        uint256 id;
        address owner; // Redundant with _owners mapping but convenient for struct return
        Archetype archetype;
        uint256 creationTime;
        uint256 lastNourishTime;
        uint256 lastEssenceClaimTime;
        uint256 health; // 0-100, decays over time
        uint256 complexity; // 1-10, affects essence generation & mutation difficulty
        uint256 potential; // 1-100, increases mutation chance
        uint256 accumulatedEssence; // Essence generated but not yet claimed
        uint256 stimulusEndTime; // When stimulus effect ends
        uint256 stimulusEssenceRateMultiplier; // Multiplier during stimulus
    }
    mapping(uint256 => Chronicle) public chronicles;

    struct EnvironmentalParameter {
        string name;
        int256 value;
        int256 min;
        int256 max;
        uint256 lastUpdated;
    }
    EnvironmentalParameter[] public environmentalParameters;
    uint256 public constant ESSENCE_GENERATION_RATE_INDEX = 0; // Units: Essence per complexity per day
    uint256 public constant CHRONICLE_DECAY_RATE_INDEX = 1;     // Units: Health per day
    uint256 public constant MUTATION_BASE_CHANCE_INDEX = 2;     // Units: Percentage (0-100)

    uint256 private _nextEnvironmentalShiftProposalId;
    struct EnvironmentalShiftProposal {
        uint256 paramIndex;
        int256 delta;
        uint256 proposeTime;
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted; // Tracks unique votes
        bool executed;
        bool approved; // indicates if proposal passed
        uint256 votingEndTime;
    }
    mapping(uint256 => EnvironmentalShiftProposal) public environmentalShiftProposals;
    uint256 public constant VOTING_PERIOD = 3 days;
    uint256 public constant MIN_VOTES_FOR_EXECUTION = 3; // Minimum votes to execute a proposal

    uint256 private _nextGlyphId;
    struct Glyph {
        address proposer;
        string text;
        uint256 proposalTime;
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted;
        bool incorporated;
        uint256 votingEndTime;
        bool approved;
    }
    mapping(uint256 => Glyph) public glyphs;
    string[] public chronicleLore; // Array of incorporated glyph texts
    uint256 public constant GLYPH_VOTING_PERIOD = 2 days;
    uint256 public constant MIN_GLYPH_VOTES_FOR_INCORPORATION = 2; // Minimum votes for a glyph to be incorporated

    mapping(address => uint256) public influenceScores;
    mapping(address => address) public delegatedInfluence; // delegator => delegatee

    // --- Constructor ---
    constructor() {
        owner = msg.sender;
        _nextTokenId = 1; // Start token IDs from 1
        _totalEssenceSupply = 0; // Initial supply is 0

        // Initialize environmental parameters
        environmentalParameters.push(EnvironmentalParameter("EssenceGenerationRate", 100, 10, 500, block.timestamp)); // 100 Essence per Complexity per Day
        environmentalParameters.push(EnvironmentalParameter("ChronicleDecayRate", 10, 1, 50, block.timestamp));   // 10 Health per Day
        environmentalParameters.push(EnvironmentalParameter("MutationBaseChance", 5, 0, 20, block.timestamp));   // 5% base chance
    }

    // --- ERC721-like Chronicle Management ---

    /**
     * @dev Returns the number of Chronicles owned by `owner`.
     */
    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[_owner];
    }

    /**
     * @dev Returns the owner of the `tokenId` Chronicle.
     */
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner_ = _owners[tokenId];
        require(owner_ != address(0), "ERC721: owner query for nonexistent token");
        return owner_;
    }

    /**
     * @dev Approves `to` to operate on the `tokenId` Chronicle.
     *      The token must be owned by `msg.sender` or `msg.sender` must be an approved operator.
     */
    function approve(address to, uint256 tokenId) public {
        address owner_ = ownerOf(tokenId);
        require(to != owner_, "ERC721: approval to current owner");
        require(msg.sender == owner_ || isApprovedForAll(owner_, msg.sender), "ERC721: approve caller is not owner nor approved for all");

        _tokenApprovals[tokenId] = to;
        emit Approval(owner_, to, tokenId);
    }

    /**
     * @dev Returns the approved address for `tokenId`.
     */
    function getApproved(uint256 tokenId) public view returns (address) {
        require(_owners[tokenId] != address(0), "ERC721: approved query for nonexistent token");
        return _tokenApprovals[tokenId];
    }

    /**
     * @dev Sets or unsets the approval of `operator` as an operator for `msg.sender`.
     *      Operators can manage all Chronicles of `msg.sender`.
     */
    function setApprovalForAll(address operator, bool approved) public {
        require(operator != msg.sender, "ERC721: approve for all to caller");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /**
     * @dev Returns if the `operator` is an approved operator for `owner`.
     */
    function isApprovedForAll(address _owner, address operator) public view returns (bool) {
        return _operatorApprovals[_owner][operator];
    }

    /**
     * @dev Transfers ownership of `tokenId` from `from` to `to`.
     *      Requires `msg.sender` to be the owner, an approved address, or an operator.
     */
    function transferFrom(address from, address to, uint256 tokenId) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _transfer(from, to, tokenId);
    }

    /**
     * @dev Safely transfers ownership of `tokenId` from `from` to `to`.
     *      If `to` is a contract, it must implement `onERC721Received` to accept the transfer.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev Safely transfers ownership of `tokenId` from `from` to `to`, with `_data`.
     *      If `to` is a contract, it must implement `onERC721Received` to accept the transfer.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Internal function to check if `spender` is approved or is the owner of `tokenId`.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner_ = ownerOf(tokenId);
        return (spender == owner_ || getApproved(tokenId) == spender || isApprovedForAll(owner_, spender));
    }

    /**
     * @dev Internal function to transfer ownership.
     */
    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not owned by from");
        require(to != address(0), "ERC721: transfer to the zero address");

        // Clear approvals before transfer
        delete _tokenApprovals[tokenId];

        _balances[from]--;
        _balances[to]++;
        _owners[tokenId] = to;
        chronicles[tokenId].owner = to; // Update owner in chronicle struct

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Internal function to check if a contract can receive ERC721 tokens.
     */
    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer (no data)");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        }
        return true;
    }

    // --- ERC20-like Essence Management ---

    /**
     * @dev Returns the Essence balance of `account`.
     */
    function essenceBalanceOf(address account) public view returns (uint256) {
        return _essenceBalances[account];
    }

    /**
     * @dev Transfers `amount` of Essence from `msg.sender` to `recipient`.
     * @return A boolean indicating whether the operation succeeded.
     */
    function essenceTransfer(address recipient, uint256 amount) public returns (bool) {
        _essenceTransfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `msg.sender`'s Essence.
     * @return A boolean indicating whether the operation succeeded.
     */
    function essenceApprove(address spender, uint256 amount) public returns (bool) {
        _essenceApprove(msg.sender, spender, amount);
        return true;
    }

    /**
     * @dev Moves `amount` of Essence from `sender` to `recipient` using the allowance mechanism.
     *      `msg.sender` must be an approved `spender`.
     * @return A boolean indicating whether the operation succeeded.
     */
    function essenceTransferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        uint256 currentAllowance = _essenceAllowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        _essenceApprove(sender, msg.sender, currentAllowance - amount); // Decrease allowance
        _essenceTransfer(sender, recipient, amount);
        return true;
    }

    /**
     * @dev Internal function to mint `amount` of Essence to `account`.
     */
    function _mintEssence(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");
        _totalEssenceSupply += amount;
        _essenceBalances[account] += amount;
        emit EssenceTransfer(address(0), account, amount);
    }

    /**
     * @dev Internal function to burn `amount` of Essence from `account`.
     */
    function _burnEssence(address account, uint256 amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");
        require(_essenceBalances[account] >= amount, "ERC20: burn amount exceeds balance");
        _essenceBalances[account] -= amount;
        _totalEssenceSupply -= amount;
        emit EssenceTransfer(account, address(0), amount);
    }

    /**
     * @dev Internal function to transfer Essence.
     */
    function _essenceTransfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(_essenceBalances[sender] >= amount, "ERC20: transfer amount exceeds balance");

        _essenceBalances[sender] -= amount;
        _essenceBalances[recipient] += amount;
        emit EssenceTransfer(sender, recipient, amount);
    }

    /**
     * @dev Internal function to set allowance.
     */
    function _essenceApprove(address owner_, address spender, uint256 amount) internal {
        require(owner_ != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _essenceAllowances[owner_][spender] = amount;
        emit EssenceApproval(owner_, spender, amount);
    }

    // --- Chronicle Lifecycle & Dynamics ---

    /**
     * @dev Mints a new Chronicle NFT to the caller, with pseudo-random initial attributes.
     */
    function mintChronicle() public {
        uint256 newTokenId = _nextTokenId++;
        require(_owners[newTokenId] == address(0), "Chronicle: token ID already exists"); // Should not happen with _nextTokenId++

        // Basic pseudo-randomness for initial attributes
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, newTokenId)));

        Archetype initialArchetype = Archetype(seed % 10); // 10 archetypes
        uint256 initialHealth = 80 + (seed % 21); // 80-100
        uint256 initialComplexity = 3 + (seed % 8); // 3-10
        uint256 initialPotential = 50 + (seed % 51); // 50-100

        Chronicle memory newChronicle = Chronicle({
            id: newTokenId,
            owner: msg.sender,
            archetype: initialArchetype,
            creationTime: block.timestamp,
            lastNourishTime: block.timestamp,
            lastEssenceClaimTime: block.timestamp,
            health: initialHealth,
            complexity: initialComplexity,
            potential: initialPotential,
            accumulatedEssence: 0,
            stimulusEndTime: 0,
            stimulusEssenceRateMultiplier: 1
        });

        chronicles[newTokenId] = newChronicle;
        _owners[newTokenId] = msg.sender;
        _balances[msg.sender]++;

        emit ChronicleMinted(newTokenId, msg.sender, block.timestamp, uint8(initialArchetype), initialHealth, initialComplexity, initialPotential);
        emit Transfer(address(0), msg.sender, newTokenId);
    }

    /**
     * @dev Retrieves all current dynamic attributes and state of a specified Chronicle.
     * @param chronicleId The ID of the Chronicle.
     * @return A tuple containing all Chronicle details.
     */
    function getChronicleDetails(uint256 chronicleId)
        public view
        returns (
            uint256 id,
            address owner_,
            Archetype archetype,
            uint256 creationTime,
            uint256 lastNourishTime,
            uint256 lastEssenceClaimTime,
            uint256 health,
            uint256 complexity,
            uint256 potential,
            uint256 accumulatedEssence,
            uint256 stimulusEndTime,
            uint256 stimulusEssenceRateMultiplier
        )
    {
        Chronicle storage c = chronicles[chronicleId];
        require(c.id != 0, "Chronicle: nonexistent chronicle");

        // Simulate state without changing it
        uint256 currentHealth = c.health;
        uint256 currentAccumulatedEssence = c.accumulatedEssence;

        uint256 timeSinceLastNourish = block.timestamp - c.lastNourishTime;
        uint256 timeSinceLastClaim = block.timestamp - c.lastEssenceClaimTime;

        uint256 decayRatePerSec = uint256(environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].value) / 1 days; // Convert to per second
        currentHealth = currentHealth > (decayRatePerSec * timeSinceLastNourish) ? currentHealth - (decayRatePerSec * timeSinceLastNourish) : 0;

        uint256 essenceRatePerSec = uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value) * c.complexity * c.stimulusEssenceRateMultiplier / 1 days; // Convert to per second
        currentAccumulatedEssence += (essenceRatePerSec * timeSinceLastClaim);

        return (
            c.id,
            c.owner,
            c.archetype,
            c.creationTime,
            c.lastNourishTime,
            c.lastEssenceClaimTime,
            currentHealth,
            c.complexity,
            c.potential,
            currentAccumulatedEssence,
            c.stimulusEndTime,
            c.stimulusEssenceRateMultiplier
        );
    }

    /**
     * @dev Internal helper function to update a Chronicle's health, accumulated essence, and other time-dependent states.
     *      Called before any operation that depends on the current state.
     */
    function _updateChronicleState(uint256 chronicleId) internal {
        Chronicle storage c = chronicles[chronicleId];
        require(c.id != 0, "Chronicle: nonexistent chronicle");

        // Apply decay
        uint256 timeSinceLastNourish = block.timestamp - c.lastNourishTime;
        if (timeSinceLastNourish > 0) {
            uint256 decayRatePerSec = uint256(environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].value) / 1 days;
            uint256 healthDecay = decayRatePerSec * timeSinceLastNourish;
            c.health = c.health > healthDecay ? c.health - healthDecay : 0;
            c.lastNourishTime = block.timestamp; // Update last nourish time after applying decay
        }

        // Apply stimulus end
        if (c.stimulusEndTime > 0 && block.timestamp >= c.stimulusEndTime) {
            c.stimulusEssenceRateMultiplier = 1;
            c.stimulusEndTime = 0;
        }

        // Accumulate Essence
        uint256 timeSinceLastClaim = block.timestamp - c.lastEssenceClaimTime;
        if (timeSinceLastClaim > 0) {
            uint256 essenceRatePerSec = uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value) * c.complexity * c.stimulusEssenceRateMultiplier / 1 days;
            c.accumulatedEssence += (essenceRatePerSec * timeSinceLastClaim);
            c.lastEssenceClaimTime = block.timestamp; // Update last essence claim time after accumulation
        }
    }

    /**
     * @dev Allows the owner to claim accumulated Essence from their Chronicle.
     *      Automatically updates Chronicle state before claiming.
     * @param chronicleId The ID of the Chronicle.
     */
    function claimEssence(uint256 chronicleId) public {
        require(ownerOf(chronicleId) == msg.sender, "Chronicle: caller is not owner of chronicle");
        _updateChronicleState(chronicleId); // Ensure state is up-to-date

        Chronicle storage c = chronicles[chronicleId];
        uint256 amountToClaim = c.accumulatedEssence;
        require(amountToClaim > 0, "Chronicle: no essence to claim");

        c.accumulatedEssence = 0;
        _mintEssence(msg.sender, amountToClaim);
        emit EssenceClaimed(chronicleId, msg.sender, amountToClaim);

        // Increase influence for active participation
        influenceScores[msg.sender] += (amountToClaim / 100); // 1 influence per 100 essence claimed
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Spends Essence to replenish a Chronicle's Health and prevent decay.
     * @param chronicleId The ID of the Chronicle.
     * @param amount The amount of Essence to spend. Each Essence restores 1 health.
     */
    function nourishChronicle(uint256 chronicleId, uint256 amount) public {
        require(ownerOf(chronicleId) == msg.sender, "Chronicle: caller is not owner of chronicle");
        require(amount > 0, "Chronicle: nourishment amount must be positive");
        _updateChronicleState(chronicleId); // Ensure state is up-to-date

        Chronicle storage c = chronicles[chronicleId];
        _burnEssence(msg.sender, amount); // Burn Essence from caller

        uint256 healthBefore = c.health;
        c.health = (c.health + amount) > 100 ? 100 : (c.health + amount); // Health capped at 100
        emit ChronicleNourished(chronicleId, msg.sender, amount, c.health);

        // Increase influence for active participation
        influenceScores[msg.sender] += (amount / 50); // 1 influence per 50 essence nourished
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Attempts to mutate a Chronicle's Archetype.
     *      Probabilistic based on current health, potential, and global mutation chance.
     *      Requires Essence payment.
     * @param chronicleId The ID of the Chronicle.
     */
    function triggerMutation(uint256 chronicleId) public {
        require(ownerOf(chronicleId) == msg.sender, "Chronicle: caller is not owner of chronicle");
        _updateChronicleState(chronicleId); // Ensure state is up-to-date

        Chronicle storage c = chronicles[chronicleId];
        require(c.health > 50, "Chronicle: health too low for mutation (min 50)");

        uint256 mutationCost = c.complexity * 50; // Example: 50 Essence per complexity point
        _burnEssence(msg.sender, mutationCost);

        uint256 pseudoRandom = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, c.id, msg.sender)));
        uint256 baseChance = uint256(environmentalParameters[MUTATION_BASE_CHANCE_INDEX].value); // 0-100
        uint256 effectiveChance = baseChance + (c.potential / 10) - (c.complexity * 2); // Higher potential increases chance, higher complexity decreases
        if (effectiveChance > 100) effectiveChance = 100;
        if (effectiveChance < 0) effectiveChance = 0;

        if (pseudoRandom % 100 < effectiveChance) {
            // Mutation successful
            Archetype oldArchetype = c.archetype;
            Archetype newArchetype = Archetype(pseudoRandom % 10);
            while (newArchetype == oldArchetype) { // Ensure a different archetype
                newArchetype = Archetype((pseudoRandom + 1) % 10);
                pseudoRandom = uint256(keccak256(abi.encodePacked(pseudoRandom))); // Re-seed
            }
            c.archetype = newArchetype;
            c.potential = 1 + (pseudoRandom % 100); // Reset potential after mutation (new starting point)
            c.complexity = 1 + (pseudoRandom % 10); // New complexity based on mutation

            emit ChronicleMutated(chronicleId, uint8(oldArchetype), uint8(newArchetype));
        } else {
            // Mutation failed
            c.potential = c.potential > 10 ? c.potential - 10 : 0; // Penalize potential on failure
            // No event for failure, but user pays cost
        }

        // Increase influence for active participation
        influenceScores[msg.sender] += (mutationCost / 10); // 1 influence per 10 essence spent on mutation
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Spends Essence to apply a temporary "stimulus" buff to a Chronicle.
     *      Boosts essence generation rate for a set duration.
     * @param chronicleId The ID of the Chronicle.
     * @param duration The duration in seconds for the stimulus. Max 7 days.
     */
    function stimulateChronicle(uint256 chronicleId, uint256 duration) public {
        require(ownerOf(chronicleId) == msg.sender, "Chronicle: caller is not owner of chronicle");
        require(duration > 0 && duration <= 7 days, "Chronicle: stimulus duration must be between 1 second and 7 days");
        _updateChronicleState(chronicleId); // Ensure state is up-to-date

        Chronicle storage c = chronicles[chronicleId];
        uint256 stimulusCost = duration * c.complexity * 10 / 1 days; // Example: 10 Essence per complexity per day of stimulus
        _burnEssence(msg.sender, stimulusCost);

        c.stimulusEndTime = block.timestamp + duration;
        c.stimulusEssenceRateMultiplier = 2; // Doubles the essence generation rate during stimulus

        emit ChronicleStimulated(chronicleId, msg.sender, duration, c.stimulusEssenceRateMultiplier);

        // Increase influence for active participation
        influenceScores[msg.sender] += (stimulusCost / 20); // 1 influence per 20 essence spent on stimulus
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Returns the current state variables relevant to the Chronicle's interaction with the global environment.
     *      Useful for UIs or external logic to understand current global effects.
     */
    function getChronicleEpochState(uint256 chronicleId)
        public view
        returns (
            uint256 currentEssenceGenerationRate,
            uint256 currentDecayRate,
            uint256 currentMutationBaseChance,
            uint256 effectiveEssenceRateMultiplier,
            bool isStimulated
        )
    {
        Chronicle storage c = chronicles[chronicleId];
        require(c.id != 0, "Chronicle: nonexistent chronicle");

        currentEssenceGenerationRate = uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value);
        currentDecayRate = uint256(environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].value);
        currentMutationBaseChance = uint256(environmentalParameters[MUTATION_BASE_CHANCE_INDEX].value);

        isStimulated = (c.stimulusEndTime > 0 && block.timestamp < c.stimulusEndTime);
        effectiveEssenceRateMultiplier = isStimulated ? c.stimulusEssenceRateMultiplier : 1;

        return (
            currentEssenceGenerationRate,
            currentDecayRate,
            currentMutationBaseChance,
            effectiveEssenceRateMultiplier,
            isStimulated
        );
    }

    // --- Global Environmental Variables & Governance ---

    /**
     * @dev Callable by the contract owner to update global environmental parameters.
     *      Simulates an "epoch change" or major environmental shift.
     *      These values can be fixed, derived from an oracle (if integrated), or part of DAO governance.
     */
    function updateGlobalEpochParameters() public onlyOwner {
        // This is a placeholder for a more complex update logic.
        // For demonstration, it just updates lastUpdated time.
        // In a real scenario, this could read from a trusted oracle,
        // or be triggered by DAO vote results.

        environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].lastUpdated = block.timestamp;
        environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].lastUpdated = block.timestamp;
        environmentalParameters[MUTATION_BASE_CHANCE_INDEX].lastUpdated = block.timestamp;

        // Example: Periodically adjust parameters slightly
        // uint256 currentEssenceRate = uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value);
        // environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value = int256(currentEssenceRate * 101 / 100); // +1%

        emit GlobalEpochParametersUpdated(
            block.number,
            uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value),
            uint256(environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].value),
            uint256(environmentalParameters[MUTATION_BASE_CHANCE_INDEX].value)
        );
    }

    /**
     * @dev Allows a user to propose a change to a global environmental parameter.
     *      Requires a minimum influence score or Essence payment to propose.
     * @param paramIndex The index of the parameter to change (0: EssenceRate, 1: DecayRate, 2: MutationChance).
     * @param delta The signed integer change to apply to the parameter's value.
     */
    function proposeEnvironmentalShift(uint256 paramIndex, int256 delta) public {
        require(paramIndex < environmentalParameters.length, "EnvironmentalShift: invalid parameter index");
        require(influenceScores[msg.sender] >= 100 || _essenceBalances[msg.sender] >= 1000, "EnvironmentalShift: insufficient influence or essence to propose");
        _burnEssence(msg.sender, 500); // Cost to propose

        uint256 proposalId = _nextEnvironmentalShiftProposalId++;
        EnvironmentalShiftProposal storage proposal = environmentalShiftProposals[proposalId];
        proposal.paramIndex = paramIndex;
        proposal.delta = delta;
        proposal.proposeTime = block.timestamp;
        proposal.votingEndTime = block.timestamp + VOTING_PERIOD;

        emit EnvironmentalShiftProposed(proposalId, paramIndex, delta, msg.sender);

        // Increase influence for active participation
        influenceScores[msg.sender] += 50;
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Users cast their vote (for/against) on an active environmental shift proposal.
     *      Votes are weighted by the voter's influence score (or delegated influence).
     * @param proposalId The ID of the proposal to vote on.
     * @param vote True for 'for', false for 'against'.
     */
    function voteOnEnvironmentalShift(uint256 proposalId, bool vote) public {
        EnvironmentalShiftProposal storage proposal = environmentalShiftProposals[proposalId];
        require(proposal.proposeTime != 0, "EnvironmentalShift: proposal does not exist");
        require(block.timestamp < proposal.votingEndTime, "EnvironmentalShift: voting period has ended");
        require(!proposal.hasVoted[msg.sender], "EnvironmentalShift: already voted on this proposal");

        address voter = msg.sender;
        if (delegatedInfluence[msg.sender] != address(0)) {
            voter = delegatedInfluence[msg.sender];
        }
        uint256 voterInfluence = influenceScores[voter];
        require(voterInfluence > 0, "EnvironmentalShift: caller has no influence to vote");

        proposal.hasVoted[msg.sender] = true;
        if (vote) {
            proposal.votesFor += voterInfluence;
        } else {
            proposal.votesAgainst += voterInfluence;
        }

        emit EnvironmentalShiftVoted(proposalId, msg.sender, vote);

        // Increase influence for active participation
        influenceScores[msg.sender] += 5; // Small influence for voting
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Executes an environmental shift proposal if it has gathered enough votes and the voting period has ended.
     *      Anyone can call this to trigger execution.
     * @param proposalId The ID of the proposal to execute.
     */
    function executeEnvironmentalShift(uint256 proposalId) public {
        EnvironmentalShiftProposal storage proposal = environmentalShiftProposals[proposalId];
        require(proposal.proposeTime != 0, "EnvironmentalShift: proposal does not exist");
        require(block.timestamp >= proposal.votingEndTime, "EnvironmentalShift: voting period not ended");
        require(!proposal.executed, "EnvironmentalShift: proposal already executed");

        // Simple majority vote and minimum participation threshold
        require(proposal.votesFor > proposal.votesAgainst, "EnvironmentalShift: proposal did not pass");
        require(proposal.votesFor + proposal.votesAgainst >= MIN_VOTES_FOR_EXECUTION, "EnvironmentalShift: not enough total votes");

        EnvironmentalParameter storage param = environmentalParameters[proposal.paramIndex];
        int256 new_value = param.value + proposal.delta;

        // Enforce min/max bounds
        if (new_value < param.min) new_value = param.min;
        if (new_value > param.max) new_value = param.max;

        param.value = new_value;
        param.lastUpdated = block.timestamp;
        proposal.executed = true;
        proposal.approved = true;

        emit EnvironmentalShiftExecuted(proposalId, proposal.paramIndex, new_value);
        emit GlobalEpochParametersUpdated(
            block.number,
            uint256(environmentalParameters[ESSENCE_GENERATION_RATE_INDEX].value),
            uint256(environmentalParameters[CHRONICLE_DECAY_RATE_INDEX].value),
            uint256(environmentalParameters[MUTATION_BASE_CHANCE_INDEX].value)
        );
    }

    /**
     * @dev Retrieves the current value and details of a specific global environmental parameter.
     */
    function getEnvironmentalParameter(uint256 paramIndex)
        public view
        returns (string memory name, int256 value, int256 min, int256 max, uint256 lastUpdated)
    {
        require(paramIndex < environmentalParameters.length, "EnvironmentalParameter: invalid index");
        EnvironmentalParameter storage param = environmentalParameters[paramIndex];
        return (param.name, param.value, param.min, param.max, param.lastUpdated);
    }

    // --- Decentralized Narrative Layer ---

    /**
     * @dev Allows users to submit a short narrative "Glyph" (text snippet) by paying Essence,
     *      proposing it for inclusion in the lore.
     * @param text The narrative text (max 256 characters).
     */
    function submitGlyph(string memory text) public {
        require(bytes(text).length > 0 && bytes(text).length <= 256, "Glyph: text length must be between 1 and 256");
        uint256 glyphCost = 100; // Example cost in Essence
        _burnEssence(msg.sender, glyphCost);

        uint256 glyphId = _nextGlyphId++;
        Glyph storage newGlyph = glyphs[glyphId];
        newGlyph.proposer = msg.sender;
        newGlyph.text = text;
        newGlyph.proposalTime = block.timestamp;
        newGlyph.votingEndTime = block.timestamp + GLYPH_VOTING_PERIOD;

        emit GlyphSubmitted(glyphId, msg.sender, text);

        // Increase influence for active participation
        influenceScores[msg.sender] += 25;
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Users vote on the quality or relevance of proposed Glyphs.
     *      Votes are weighted by influence.
     * @param glyphId The ID of the Glyph to vote on.
     * @param approve True for 'approve', false for 'disapprove'.
     */
    function voteOnGlyph(uint256 glyphId, bool approve) public {
        Glyph storage glyph = glyphs[glyphId];
        require(glyph.proposer != address(0), "Glyph: does not exist");
        require(block.timestamp < glyph.votingEndTime, "Glyph: voting period has ended");
        require(!glyph.incorporated, "Glyph: already incorporated");
        require(!glyph.hasVoted[msg.sender], "Glyph: already voted on this glyph");

        address voter = msg.sender;
        if (delegatedInfluence[msg.sender] != address(0)) {
            voter = delegatedInfluence[msg.sender];
        }
        uint256 voterInfluence = influenceScores[voter];
        require(voterInfluence > 0, "Glyph: caller has no influence to vote");

        glyph.hasVoted[msg.sender] = true;
        if (approve) {
            glyph.votesFor += voterInfluence;
        } else {
            glyph.votesAgainst += voterInfluence;
        }

        emit GlyphVoted(glyphId, msg.sender, approve);

        // Increase influence for active participation
        influenceScores[msg.sender] += 3; // Small influence for voting
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
    }

    /**
     * @dev Incorporates a highly-voted Glyph into the permanent `chronicleLore` array.
     *      Anyone can call this to trigger incorporation if conditions are met.
     * @param glyphId The ID of the Glyph to incorporate.
     */
    function incorporateGlyph(uint256 glyphId) public {
        Glyph storage glyph = glyphs[glyphId];
        require(glyph.proposer != address(0), "Glyph: does not exist");
        require(block.timestamp >= glyph.votingEndTime, "Glyph: voting period not ended");
        require(!glyph.incorporated, "Glyph: already incorporated");

        require(glyph.votesFor > glyph.votesAgainst, "Glyph: Glyph did not receive enough positive votes");
        require(glyph.votesFor >= MIN_GLYPH_VOTES_FOR_INCORPORATION, "Glyph: not enough total votes for incorporation");

        glyph.incorporated = true;
        glyph.approved = true;
        chronicleLore.push(glyph.text);

        emit GlyphIncorporated(glyphId);

        // Reward proposer with influence
        influenceScores[glyph.proposer] += 100;
        emit InfluenceChanged(glyph.proposer, influenceScores[glyph.proposer]);
    }

    /**
     * @dev Retrieves the details of a submitted Glyph.
     * @param glyphId The ID of the Glyph.
     */
    function getGlyph(uint256 glyphId)
        public view
        returns (address proposer, string memory text, uint256 proposalTime, uint256 votesFor, uint256 votesAgainst, bool incorporated, uint256 votingEndTime)
    {
        Glyph storage glyph = glyphs[glyphId];
        require(glyph.proposer != address(0), "Glyph: does not exist");
        return (glyph.proposer, glyph.text, glyph.proposalTime, glyph.votesFor, glyph.votesAgainst, glyph.incorporated, glyph.votingEndTime);
    }

    /**
     * @dev Retrieves an incorporated lore entry from the public narrative.
     * @param index The index of the lore entry in the chronicleLore array.
     */
    function getChronicleLore(uint256 index) public view returns (string memory) {
        require(index < chronicleLore.length, "ChronicleLore: index out of bounds");
        return chronicleLore[index];
    }

    // --- Reputation & Influence System ---

    /**
     * @dev Returns the current Influence score of an account.
     *      Influence is gained by active participation in the ecosystem.
     */
    function getInfluenceScore(address account) public view returns (uint256) {
        return influenceScores[account];
    }

    /**
     * @dev Allows a user to delegate a portion of their Influence score to another address for voting purposes.
     *      This creates a simple delegated voting mechanism.
     * @param delegatee The address to delegate influence to.
     * @param amount The amount of influence to delegate.
     */
    function delegateInfluence(address delegatee, uint256 amount) public {
        require(amount <= influenceScores[msg.sender], "Influence: insufficient influence to delegate");
        require(delegatee != address(0), "Influence: cannot delegate to zero address");
        require(delegatee != msg.sender, "Influence: cannot delegate to self");

        if (delegatedInfluence[msg.sender] != address(0) && delegatedInfluence[msg.sender] != delegatee) {
            // Remove influence from previous delegatee if changing delegation
            influenceScores[delegatedInfluence[msg.sender]] -= influenceScores[msg.sender]; // Remove full score temporarily
            emit InfluenceChanged(delegatedInfluence[msg.sender], influenceScores[delegatedInfluence[msg.sender]]);
        }

        delegatedInfluence[msg.sender] = delegatee;
        influenceScores[msg.sender] -= amount; // Deduct from delegator's direct score
        influenceScores[delegatee] += amount; // Add to delegatee's score

        emit InfluenceDelegated(msg.sender, delegatee, amount);
        emit InfluenceChanged(msg.sender, influenceScores[msg.sender]);
        emit InfluenceChanged(delegatee, influenceScores[delegatee]);
    }
}

/**
 * @dev Interface for the ERC721 Receiver hook.
 */
interface IERC721Receiver {
    /**
     * @dev Whenever an {IERC721} `tokenId` is transferred to this contract via {IERC721-safeTransferFrom}
     *      by `operator` from `from`, this function is called.
     *
     *      It must return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
     *      (i.e. 0x150b7a02) if the transfer is to be accepted.
     *
     *      If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * @param operator The address which initiated the transfer (i.e. `msg.sender`).
     * @param from The address which previously owned the token.
     * @param tokenId The ID of the token being transferred.
     * @param data Optional data with no specified format.
     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` if successful.
     */
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}
```