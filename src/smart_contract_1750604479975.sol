Okay, let's create a smart contract concept around "Quantum Fluctuations" of abstract on-chain "units". This allows us to explore probabilistic state changes, energy dynamics, entanglement, and system-wide interactions â€“ concepts inspired by quantum mechanics but implemented deterministically (or pseudo-deterministically) on the blockchain.

It will *not* be an ERC-20 or ERC-721 standard contract directly, but it manages owned abstract units with dynamic properties.

---

**Contract Name:** `QuantumFluctuations`

**Concept:** A system of abstract on-chain "units" that exist in various dynamic states (Superposition, Entangled, Decayed, Stable). User interactions ("Observations") and time influence the probabilistic transitions between these states, consuming or generating "Energy" within the units and the system. The contract owner can influence system-wide parameters, and users can attempt to stabilize or react units.

**Core Mechanics:**

1.  **Units:** Each unit has an ID, an owner, a state, energy level, and tracking for entanglement and last interaction time.
2.  **States:**
    *   `Superposition`: Highly unstable, prone to change upon observation.
    *   `Entangled`: Linked to another unit, their fates potentially intertwined upon observation.
    *   `Decayed`: Irreversible state, effectively inactive but potentially reclaimable.
    *   `Stable`: Less prone to change, requires significant energy or specific interactions to shift.
3.  **Energy:** A numerical value associated with each unit. Influences state transition probabilities and is consumed/generated by actions. Total system energy fluctuates.
4.  **Observation:** The primary user interaction. Causes a unit's state to be "measured", triggering a probabilistic transition based on its current state, energy, time since last interaction, and system parameters.
5.  **Entanglement:** Users can link two units in Superposition to become Entangled. Observing one Entangled unit affects both.
6.  **Decay:** Units in Superposition or Stable states have a chance to decay over time, accelerated by low energy or lack of interaction.
7.  **Stabilization:** Users can spend energy (or potentially pay ETH/tokens, but let's keep it internal energy for now) to attempt to shift a unit towards the Stable state.
8.  **Catalysis:** A complex reaction where multiple units interact, potentially merging properties or triggering cascades of state changes.
9.  **System Fluctuations:** Owner-triggered event causing a probabilistic state check on *all* units simultaneously.
10. **Parameter Evolution:** Owner can set parameters, and potentially the contract could evolve parameters based on system state distribution (an advanced concept).

**Outline & Function Summary:**

*   **Data Structures:**
    *   `State` enum: Defines the possible states of a unit.
    *   `FluctuatingUnit` struct: Holds properties of a single unit.
    *   `FluctuationParameters` struct: Holds system-wide probabilities and thresholds.
*   **State Variables:**
    *   Mapping for units: `id => FluctuatingUnit`.
    *   Counter for next unit ID.
    *   Owner address.
    *   System-wide fluctuation parameters.
    *   Pseudo-randomness seed/nonce.
*   **Events:** To signal key actions and state changes.
*   **Modifiers:** `onlyOwner` for administrative functions.
*   **Randomness (Pseudo):** Internal function for generating pseudo-random numbers on-chain. *Requires strong warning about potential manipulation.*
*   **Core Unit Management (Creation & Basic Interaction):**
    1.  `mintUnit()`: Creates a new unit, assigning initial state/energy probabilistically.
    2.  `observeUnit(uint256 _unitId)`: Triggers state measurement and probabilistic transition for a unit. (Core logic)
    3.  `getUnitDetails(uint256 _unitId)`: View function to retrieve all details of a unit.
    4.  `queryState(uint256 _unitId)`: View function to get just the state of a unit.
    5.  `listUnitsByState(State _state)`: View function to get IDs of units in a specific state.
    6.  `getTotalUnits()`: View function for the total number of units.
*   **Energy Management:**
    7.  `transferEnergy(uint256 _fromUnitId, uint256 _toUnitId, uint256 _amount)`: Transfer energy between two units owned by the caller.
    8.  `addEnergyToUnit(uint256 _unitId, uint256 _amount)`: Add energy to a unit (from caller, could require payment in a real scenario).
    9.  `getTotalSystemEnergy()`: View function for the sum of energy across all non-decayed units.
*   **State Manipulation & Special Interactions:**
    10. `entangleUnits(uint256 _unitId1, uint256 _unitId2)`: Attempts to entangle two units.
    11. `disentangleUnit(uint256 _unitId)`: Attempts to disentangle a unit.
    12. `stabilizeUnit(uint256 _unitId, uint256 _energyCost)`: Attempts to move a unit towards the Stable state by spending energy.
    13. `reclaimDecayedUnit(uint256 _unitId)`: Attempts to reclaim value (e.g., some energy back) from a Decayed unit.
    14. `checkAndTriggerDecay(uint256 _unitId)`: Allows anyone to potentially trigger a decay check on a specific unit based on time/energy.
    15. `catalyzeReaction(uint256[] calldata _unitIds, uint256 _targetUnitId)`: Triggers a complex reaction involving multiple units contributing to a target unit.
*   **System Configuration & Control (Owner Only):**
    16. `setFluctuationParameters(FluctuationParameters calldata _params)`: Set the system-wide probabilities/thresholds.
    17. `triggerSystemFluctuation()`: Triggers a probabilistic state check for *all* active units.
    18. `evolveSystemParameters()`: (Advanced) Triggers a potential evolution of parameters based on the current distribution of unit states.
*   **Query & Analysis (View):**
    19. `getFluctuationParameters()`: View function to get the current system parameters.
    20. `getEntangledPairs()`: View function to list all currently entangled unit pairs.
    21. `predictNextStateProbability(uint256 _unitId)`: (Advanced/Conceptual) Calculates the *probability* distribution of potential next states upon observation without changing state.
    22. `querySystemHealth()`: View function providing aggregated stats (e.g., count per state, average energy).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title QuantumFluctuations
 * @author YourName (or Pseudonym)
 * @notice A smart contract simulating abstract "Quantum Fluctuations" of on-chain units
 *         with dynamic states, energy, entanglement, and probabilistic transitions.
 *         This contract is a conceptual exploration and *not* suitable for applications
 *         requiring secure, unpredictable randomness due to on-chain limitations.
 */

/*
 * Outline & Function Summary:
 *
 * Data Structures:
 *   - State enum: Possible states (Superposition, Entangled, Decayed, Stable).
 *   - FluctuatingUnit struct: Properties of an individual unit (ID, owner, state, energy, etc.).
 *   - FluctuationParameters struct: System-wide parameters controlling state transitions.
 *
 * State Variables:
 *   - units: Mapping of unit ID to FluctuatingUnit struct.
 *   - _nextTokenId: Counter for minting new unit IDs.
 *   - owner: Contract deployer/administrator.
 *   - fluctuationParameters: Current system parameters.
 *   - _randomnessNonce: Counter for pseudo-randomness generation.
 *
 * Events: To signal key actions and state changes for off-chain monitoring.
 *   - UnitMinted: When a new unit is created.
 *   - StateChanged: When a unit transitions state.
 *   - EnergyTransferred: When energy moves between units.
 *   - UnitsEntangled: When two units become entangled.
 *   - UnitDisentangled: When a unit is disentangled.
 *   - UnitDecayed: When a unit enters the Decayed state.
 *   - UnitStabilized: When a unit successfully stabilizes.
 *   - UnitReclaimed: When a Decayed unit is reclaimed.
 *   - ReactionCatalyzed: When a catalytic reaction occurs.
 *   - ParametersUpdated: When system parameters are changed.
 *   - SystemFluctuationTriggered: When the system-wide fluctuation is initiated.
 *
 * Modifiers:
 *   - onlyOwner: Restricts function access to the contract owner.
 *
 * Pseudo-Randomness Helper:
 *   - _generatePseudoRandomNumber: Internal helper (WARNING: NOT SECURE FOR CRITICAL RANDOMNESS).
 *
 * Core Unit Management (Creation & Basic Interaction):
 * 1.  mintUnit(): Creates a new unit with initial random-ish state/energy.
 * 2.  observeUnit(uint256 _unitId): Core function triggering probabilistic state change based on observation.
 * 3.  getUnitDetails(uint256 _unitId): View function to get all data for a unit.
 * 4.  queryState(uint256 _unitId): View function to get just the state of a unit.
 * 5.  listUnitsByState(State _state): View function to get IDs of units in a given state.
 * 6.  getTotalUnits(): View function for the total number of minted units.
 *
 * Energy Management:
 * 7.  transferEnergy(uint256 _fromUnitId, uint256 _toUnitId, uint256 _amount): Move energy between caller's units.
 * 8.  addEnergyToUnit(uint256 _unitId, uint256 _amount): Add energy to a unit (simulated, could be linked to ETH/token in real app).
 * 9.  getTotalSystemEnergy(): View function for sum of energy in active units.
 *
 * State Manipulation & Special Interactions:
 * 10. entangleUnits(uint256 _unitId1, uint256 _unitId2): Attempt to link two units.
 * 11. disentangleUnit(uint256 _unitId): Attempt to break an entanglement.
 * 12. stabilizeUnit(uint256 _unitId, uint256 _energyCost): Use energy to attempt stabilization.
 * 13. reclaimDecayedUnit(uint256 _unitId): Attempt to get value back from a Decayed unit.
 * 14. checkAndTriggerDecay(uint256 _unitId): Allow anyone to check and potentially trigger decay based on time/energy.
 * 15. catalyzeReaction(uint256[] calldata _unitIds, uint256 _targetUnitId): Combine effects of multiple units on a target unit.
 *
 * System Configuration & Control (Owner Only):
 * 16. setFluctuationParameters(FluctuationParameters calldata _params): Update system probabilities and thresholds.
 * 17. triggerSystemFluctuation(): Apply probabilistic change chance to all active units.
 * 18. evolveSystemParameters(): (Conceptual) Adjust parameters based on overall system state distribution.
 *
 * Query & Analysis (View):
 * 19. getFluctuationParameters(): View function for current system parameters.
 * 20. getEntangledPairs(): View function to list active entangled pairs.
 * 21. predictNextStateProbability(uint256 _unitId): (Conceptual) Predict state transition probabilities on observation *without* changing state.
 * 22. querySystemHealth(): View function summarizing system state distribution and energy.
 */


contract QuantumFluctuations {

    enum State { Superposition, Entangled, Decayed, Stable }

    struct FluctuatingUnit {
        uint256 id;
        address owner;
        State state;
        uint256 energy;
        uint256 lastInteractionTime;
        uint256 entangledWith; // 0 if not entangled, else ID of entangled unit
        bool reclaimed;       // Flag for decayed units that have been reclaimed
    }

    struct FluctuationParameters {
        uint256 superpositionDecayRate; // higher = faster decay likelihood from superpos
        uint256 entanglementStabilityBoost; // higher = entangled units more likely to stay/become stable on observe
        uint256 energyInfluenceFactor; // higher = energy impacts probabilities more strongly
        uint256 stableDecayThreshold; // energy below this threshold increases decay chance from stable
        uint256 baseStabilizeSuccessChance; // Base chance for stabilizeUnit
        uint256 catalyzeSuccessBoostPerUnit; // Boost chance in catalyzeReaction
        uint256 observationEnergyCost; // Energy consumed by observeUnit
        uint256 decayCheckTimeThreshold; // Time in seconds after which decay check is relevant
    }

    mapping(uint256 => FluctuatingUnit) public units;
    uint256 private _nextTokenId;
    address public owner;
    FluctuationParameters public fluctuationParameters;
    uint256 private _randomnessNonce;

    // --- Events ---
    event UnitMinted(uint256 indexed unitId, address indexed owner, State initialState, uint256 initialEnergy);
    event StateChanged(uint256 indexed unitId, State oldState, State newState, uint256 energyChange);
    event EnergyTransferred(uint256 indexed fromUnitId, uint256 indexed toUnitId, uint256 amount);
    event UnitsEntangled(uint256 indexed unitId1, uint256 indexed unitId2);
    event UnitDisentangled(uint256 indexed unitId, uint256 indexed otherUnitId);
    event UnitDecayed(uint256 indexed unitId);
    event UnitStabilized(uint256 indexed unitId, uint256 energyCost);
    event UnitReclaimed(uint256 indexed unitId, address indexed reclaimingOwner, uint256 energyReclaimed);
    event ReactionCatalyzed(uint256 indexed targetUnitId, uint256[] involvedUnitIds, uint256 energyTransferred);
    event ParametersUpdated(FluctuationParameters newParameters);
    event SystemFluctuationTriggered(uint256 numberOfUnitsAffected);

    // --- Modifiers ---
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    // --- Constructor ---
    constructor() {
        owner = msg.sender;
        _nextTokenId = 1; // Unit IDs start from 1

        // Set initial default parameters
        fluctuationParameters = FluctuationParameters({
            superpositionDecayRate: 10, // 10% base chance to decay per decay check period
            entanglementStabilityBoost: 20, // 20% boost to stability chance when entangled
            energyInfluenceFactor: 5, // Energy value divided by this factor influences probabilities
            stableDecayThreshold: 50, // Units with < 50 energy in Stable state have higher decay chance
            baseStabilizeSuccessChance: 30, // 30% base chance to stabilize
            catalyzeSuccessBoostPerUnit: 5, // Each unit adds 5% boost to catalyze success chance
            observationEnergyCost: 2, // Observe costs 2 energy
            decayCheckTimeThreshold: 1 days // Check decay if not interacted with for 1 day
        });

        _randomnessNonce = 0;
    }

    // --- Internal Helpers ---

    /**
     * @dev Generates a pseudo-random number using block data, sender, and a nonce.
     * WARNING: This is NOT cryptographically secure and is susceptible to front-running.
     * Do not use for high-value randomness requirements in production.
     * @return A pseudo-random uint256.
     */
    function _generatePseudoRandomNumber(uint256 _seed) internal returns (uint256) {
        _randomnessNonce++;
        uint256 randomNumber = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty, // Consider block.prevrandao in PoS
            msg.sender,
            _randomnessNonce,
            _seed
        )));
        return randomNumber;
    }

    /**
     * @dev Internal function to handle state transitions based on probabilities.
     * This is the core "quantum" simulation logic.
     * @param _unit The unit being observed/checked.
     * @return The new state of the unit.
     */
    function _determineNextState(FluctuatingUnit storage _unit) internal returns (State) {
        if (_unit.state == State.Decayed) {
            return State.Decayed; // Decayed state is terminal (unless reclaimed, handled separately)
        }

        uint256 randomValue = _generatePseudoRandomNumber(_unit.id + _unit.energy + _unit.lastInteractionTime);
        uint256 chance = randomValue % 100; // Get a value between 0 and 99

        uint256 timeSinceLastInteraction = block.timestamp - _unit.lastInteractionTime;
        uint256 energyInfluence = _unit.energy / fluctuationParameters.energyInfluenceFactor;

        // Base chances - these are adjusted below
        uint256 decayChance = 0;
        uint256 stabilizeChance = 0; // Chance to move towards stable
        uint256 entangleChance = 0; // Chance to move towards entangled (from Superposition)
        uint256 fluctuateChance = 0; // Chance to move back to Superposition (from Stable/Entangled)

        if (_unit.state == State.Superposition) {
            // Superposition is unstable
            decayChance = fluctuationParameters.superpositionDecayRate;
            entangleChance = 15; // Base chance to become entangled
            stabilizeChance = energyInfluence / 2; // Higher energy slightly increases stabilize chance
            fluctuateChance = 0; // Already in superposition

            // Time increases decay likelihood
            if (timeSinceLastInteraction >= fluctuationParameters.decayCheckTimeThreshold) {
                 decayChance = decayChance + (timeSinceLastInteraction / fluctuationParameters.decayCheckTimeThreshold) * 5; // Add 5% for each threshold period passed
            }

        } else if (_unit.state == State.Entangled) {
            // Entangled states influenced by connection
            stabilizeChance = fluctuationParameters.entanglementStabilityBoost + (energyInfluence / 3); // Entangled + Energy boosts stable chance
            fluctuateChance = 20 - (energyInfluence / 5); // Less energy/entanglement boost makes it more likely to fluctuate back
            decayChance = 5; // Base decay chance

            // Check entanglement partner state? (Optional complexity - impacts gas. Let's keep it simple for now, base chance)

        } else if (_unit.state == State.Stable) {
            // Stable states resist change
            fluctuateChance = 10 + (timeSinceLastInteraction / fluctuationParameters.decayCheckTimeThreshold) * 3; // Time/lack of interaction increases fluctuation
            decayChance = (_unit.energy < fluctuationParameters.stableDecayThreshold) ? 15 : 5; // Higher decay chance if low energy
            stabilizeChance = 0; // Already stable

        }

        // Ensure chances don't exceed 100 (or sum doesn't exceed 100 for non-exclusive transitions)
        // For simplicity here, let's make transitions somewhat prioritized or exclusive based on rolls.
        // A more complex model would be weighted probabilities summing to 100.
        // Let's use thresholds: check against decay, then stabilize, then entangle, otherwise fluctuate.

        if (chance < decayChance) return State.Decayed;
        chance -= decayChance;

        if (_unit.state != State.Stable && chance < stabilizeChance) return State.Stable;
        if (_unit.state != State.Stable) chance -= stabilizeChance; // Only consume chance if it was a possible transition

        if (_unit.state == State.Superposition && chance < entangleChance) return State.Entangled;
         if (_unit.state == State.Superposition) chance -= entangleChance; // Only consume chance if it was a possible transition

        // If none of the above, fluctuate (move back to Superposition) or stay
        if (_unit.state != State.Superposition && chance < fluctuateChance) return State.Superposition;

        // Default: stay in current state
        return _unit.state;
    }

    /**
     * @dev Internal function to check and potentially trigger decay for a unit.
     * @param _unitId The ID of the unit to check.
     */
    function _checkAndTriggerDecay(uint256 _unitId) internal {
         FluctuatingUnit storage unit = units[_unitId];
         if (unit.state == State.Decayed) return; // Already decayed

         uint256 timeSinceLastInteraction = block.timestamp - unit.lastInteractionTime;
         uint256 randomValue = _generatePseudoRandomNumber(_unitId + unit.energy + timeSinceLastInteraction);
         uint256 chance = randomValue % 100;

         uint256 decayChance = 0;
         if (unit.state == State.Superposition) {
             decayChance = fluctuationParameters.superpositionDecayRate;
             if (timeSinceLastInteraction >= fluctuationParameters.decayCheckTimeThreshold) {
                  decayChance = decayChance + (timeSinceLastInteraction / fluctuationParameters.decayCheckTimeThreshold) * 5; // Add 5% for each threshold period passed
             }
         } else if (unit.state == State.Stable && unit.energy < fluctuationParameters.stableDecayThreshold) {
             decayChance = 15; // Higher chance if low energy in Stable
         } else if (unit.state == State.Entangled) {
             decayChance = 5; // Base chance for entangled
         }
         // Clamp chance at 100
         if (decayChance > 100) decayChance = 100;


         if (chance < decayChance) {
             State oldState = unit.state;
             unit.state = State.Decayed;
             emit UnitDecayed(_unitId);
             emit StateChanged(_unitId, oldState, State.Decayed, 0);

             // If entangled, disentangle the partner
             if (oldState == State.Entangled && unit.entangledWith != 0) {
                 uint256 partnerId = unit.entangledWith;
                 FluctuatingUnit storage partner = units[partnerId];
                 partner.entangledWith = 0;
                 unit.entangledWith = 0; // Ensure both are cleared
                 // Partner might also decay or revert to Superposition
                 if(partner.state != State.Decayed) {
                      State partnerOldState = partner.state;
                      partner.state = State.Superposition; // Partner reverts to superposition
                      emit UnitDisentangled(partnerId, _unitId);
                      emit StateChanged(partnerId, partnerOldState, State.Superposition, 0);
                 } else {
                     emit UnitDisentangled(partnerId, _unitId); // Still emit disentangle even if partner decayed
                 }
             }
         }
    }


    // --- Core Unit Management ---

    /**
     * @notice Mints a new FluctuatingUnit.
     * Initial state is Superposition, initial energy is random-ish.
     */
    function mintUnit() public {
        uint256 newId = _nextTokenId++;
        uint256 initialEnergy = (_generatePseudoRandomNumber(newId + block.difficulty) % 50) + 50; // Energy between 50 and 100

        units[newId] = FluctuatingUnit({
            id: newId,
            owner: msg.sender,
            state: State.Superposition,
            energy: initialEnergy,
            lastInteractionTime: block.timestamp,
            entangledWith: 0,
            reclaimed: false
        });

        emit UnitMinted(newId, msg.sender, State.Superposition, initialEnergy);
    }

    /**
     * @notice Observes a unit, potentially triggering a state change based on probabilities, energy, and time.
     * Costs observation energy.
     * @param _unitId The ID of the unit to observe.
     */
    function observeUnit(uint256 _unitId) public {
        require(units[_unitId].id != 0, "Unit does not exist");
        FluctuatingUnit storage unit = units[_unitId];
        require(unit.state != State.Decayed, "Unit has decayed and cannot be observed");

        // Check and potentially trigger decay first, before main observation logic
        _checkAndTriggerDecay(_unitId);

        // If it decayed during check, observation stops
        if (unit.state == State.Decayed) {
             // Re-emit decay event for clarity if it happened now
             emit UnitDecayed(_unitId);
             return;
        }


        // Consume energy for observation
        uint256 energyConsumed = fluctuationParameters.observationEnergyCost;
        if (unit.energy < energyConsumed) {
             // Not enough energy, force decay or fluctuation?
             State oldState = unit.state;
             unit.energy = 0;
             unit.state = (oldState == State.Stable) ? State.Superposition : State.Decayed; // Stable unit without energy just fluctuates, others decay
             emit EnergyTransferred(_unitId, 0, energyConsumed); // Indicate energy was *supposed* to be consumed
             emit StateChanged(_unitId, oldState, unit.state, -(energyConsumed));
             if(unit.state == State.Decayed) emit UnitDecayed(_unitId);
             return; // Observation fails
        }
        unit.energy -= energyConsumed;
        emit EnergyTransferred(_unitId, 0, energyConsumed); // 0 indicates energy left the unit


        // Determine next state
        State oldState = unit.state;
        State newState = _determineNextState(unit);

        // Apply state change
        if (newState != oldState) {
            // Handle disentanglement if state changes from Entangled
            if (oldState == State.Entangled && newState != State.Entangled && unit.entangledWith != 0) {
                uint256 partnerId = unit.entangledWith;
                FluctuatingUnit storage partner = units[partnerId];
                 // Partner also gets disentangled and potentially fluctuates
                partner.entangledWith = 0;
                unit.entangledWith = 0; // Ensure both are cleared

                // Partner's state might change too (e.g., revert to Superposition)
                if(partner.state != State.Decayed) {
                    State partnerOldState = partner.state;
                    partner.state = _determineNextState(partner); // Partner observed implicitly
                     emit UnitDisentangled(partnerId, _unitId);
                     emit StateChanged(partnerId, partnerOldState, partner.state, 0); // No energy change from disentanglement itself here
                } else {
                    emit UnitDisentangled(partnerId, _unitId); // Still emit disentangle even if partner decayed
                }
            }

            unit.state = newState;
            // Add or remove energy based on transition? (Optional complexity)
            // e.g., becoming stable costs energy, becoming superposition releases energy?
            // For simplicity, energy change is only from the observation cost here.

            emit StateChanged(_unitId, oldState, newState, -(energyConsumed));

            // Special handling if new state is Decayed
            if (newState == State.Decayed) {
                 emit UnitDecayed(_unitId);
            }
        } else {
             // State did not change, but energy was still consumed
             // No state change event, but energy transfer event happened above.
        }

        unit.lastInteractionTime = block.timestamp; // Update interaction time regardless of state change
    }

    /**
     * @notice Gets all details for a specific unit.
     * @param _unitId The ID of the unit.
     * @return A tuple containing all unit properties.
     */
    function getUnitDetails(uint256 _unitId) public view returns (uint256 id, address owner, State state, uint256 energy, uint256 lastInteractionTime, uint256 entangledWith, bool reclaimed) {
         require(units[_unitId].id != 0, "Unit does not exist");
         FluctuatingUnit storage unit = units[_unitId];
         return (unit.id, unit.owner, unit.state, unit.energy, unit.lastInteractionTime, unit.entangledWith, unit.reclaimed);
    }


    /**
     * @notice Gets the current state of a specific unit.
     * @param _unitId The ID of the unit.
     * @return The current State enum value.
     */
    function queryState(uint256 _unitId) public view returns (State) {
         require(units[_unitId].id != 0, "Unit does not exist");
         return units[_unitId].state;
    }

    /**
     * @notice Lists the IDs of all units currently in a specific state.
     * @param _state The State to filter by.
     * @return An array of unit IDs.
     */
    function listUnitsByState(State _state) public view returns (uint256[] memory) {
        uint256[] memory unitIds = new uint256[](_nextTokenId - 1);
        uint256 count = 0;
        for (uint256 i = 1; i < _nextTokenId; i++) {
            if (units[i].id != 0 && units[i].state == _state) {
                unitIds[count] = i;
                count++;
            }
        }
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = unitIds[i];
        }
        return result;
    }

     /**
      * @notice Returns the total number of units minted so far.
      */
     function getTotalUnits() public view returns (uint256) {
         return _nextTokenId - 1;
     }

    // --- Energy Management ---

    /**
     * @notice Transfers energy between two units owned by the caller.
     * @param _fromUnitId The ID of the unit to transfer energy from.
     * @param _toUnitId The ID of the unit to transfer energy to.
     * @param _amount The amount of energy to transfer.
     */
    function transferEnergy(uint256 _fromUnitId, uint256 _toUnitId, uint256 _amount) public {
        require(units[_fromUnitId].id != 0, "From unit does not exist");
        require(units[_toUnitId].id != 0, "To unit does not exist");
        require(units[_fromUnitId].owner == msg.sender, "Caller does not own the 'from' unit");
        require(units[_toUnitId].owner == msg.sender, "Caller does not own the 'to' unit");
        require(units[_fromUnitId].state != State.Decayed, "Cannot transfer energy from a decayed unit");
        require(units[_toUnitId].state != State.Decayed, "Cannot transfer energy to a decayed unit");
        require(units[_fromUnitId].energy >= _amount, "Insufficient energy in the 'from' unit");
        require(_fromUnitId != _toUnitId, "Cannot transfer energy to the same unit");

        units[_fromUnitId].energy -= _amount;
        units[_toUnitId].energy += _amount;

        emit EnergyTransferred(_fromUnitId, _toUnitId, _amount);
    }

    /**
     * @notice Adds energy to a specific unit.
     * (In a real dApp, this might require sending ETH or a specific token).
     * @param _unitId The ID of the unit to add energy to.
     * @param _amount The amount of energy to add.
     */
    function addEnergyToUnit(uint256 _unitId, uint256 _amount) public {
        require(units[_unitId].id != 0, "Unit does not exist");
        require(units[_unitId].owner == msg.sender, "Caller does not own this unit");
        require(units[_unitId].state != State.Decayed, "Cannot add energy to a decayed unit");

        units[_unitId].energy += _amount;
        emit EnergyTransferred(0, _unitId, _amount); // 0 indicates energy came from outside
    }

    /**
     * @notice Calculates the total sum of energy across all non-decayed units.
     * @return The total energy in the system.
     */
    function getTotalSystemEnergy() public view returns (uint256) {
        uint256 totalEnergy = 0;
        for (uint256 i = 1; i < _nextTokenId; i++) {
            if (units[i].id != 0 && units[i].state != State.Decayed) {
                totalEnergy += units[i].energy;
            }
        }
        return totalEnergy;
    }


    // --- State Manipulation & Special Interactions ---

    /**
     * @notice Attempts to entangle two units owned by the caller.
     * Requires both units to be in Superposition state.
     * @param _unitId1 The ID of the first unit.
     * @param _unitId2 The ID of the second unit.
     */
    function entangleUnits(uint256 _unitId1, uint256 _unitId2) public {
        require(units[_unitId1].id != 0 && units[_unitId2].id != 0, "One or both units do not exist");
        require(units[_unitId1].owner == msg.sender && units[_unitId2].owner == msg.sender, "Caller must own both units");
        require(_unitId1 != _unitId2, "Cannot entangle a unit with itself");
        require(units[_unitId1].state == State.Superposition && units[_unitId2].state == State.Superposition, "Both units must be in Superposition state");
        require(units[_unitId1].entangledWith == 0 && units[_unitId2].entangledWith == 0, "One or both units are already entangled");

        units[_unitId1].entangledWith = _unitId2;
        units[_unitId2].entangledWith = _unitId1;

        // State change to Entangled
        State oldState1 = units[_unitId1].state;
        State oldState2 = units[_unitId2].state;
        units[_unitId1].state = State.Entangled;
        units[_unitId2].state = State.Entangled;

        emit UnitsEntangled(_unitId1, _unitId2);
        emit StateChanged(_unitId1, oldState1, State.Entangled, 0);
        emit StateChanged(_unitId2, oldState2, State.Entangled, 0);
    }

    /**
     * @notice Attempts to disentangle a unit from its partner.
     * @param _unitId The ID of the unit to disentangle.
     */
    function disentangleUnit(uint256 _unitId) public {
         require(units[_unitId].id != 0, "Unit does not exist");
         require(units[_unitId].owner == msg.sender, "Caller does not own this unit");
         require(units[_unitId].state == State.Entangled && units[_unitId].entangledWith != 0, "Unit is not currently entangled");

         uint256 partnerId = units[_unitId].entangledWith;
         require(units[partnerId].id != 0, "Entangled partner does not exist (system error)");
         require(units[partnerId].entangledWith == _unitId, "Entangled partner link is broken (system error)"); // Consistency check

         // Break links
         units[_unitId].entangledWith = 0;
         units[partnerId].entangledWith = 0;

         // Revert both units to Superposition state
         State oldState1 = units[_unitId].state;
         State oldState2 = units[partnerId].state;
         units[_unitId].state = State.Superposition;
         units[partnerId].state = State.Superposition;


         emit UnitDisentangled(_unitId, partnerId);
         emit StateChanged(_unitId, oldState1, State.Superposition, 0);
         emit StateChanged(partnerId, oldState2, State.Superposition, 0);
    }

    /**
     * @notice Spends energy to attempt to stabilize a unit.
     * Probability of success is based on base chance and unit energy.
     * @param _unitId The ID of the unit to stabilize.
     * @param _energyCost The amount of energy to spend on the attempt.
     */
    function stabilizeUnit(uint256 _unitId, uint256 _energyCost) public {
         require(units[_unitId].id != 0, "Unit does not exist");
         require(units[_unitId].owner == msg.sender, "Caller does not own this unit");
         require(units[_unitId].state != State.Decayed, "Cannot stabilize a decayed unit");
         require(units[_unitId].state != State.Stable, "Unit is already stable");
         require(units[_unitId].energy >= _energyCost, "Insufficient energy in the unit");
         require(_energyCost > 0, "Energy cost must be positive");

         units[_unitId].energy -= _energyCost;
         emit EnergyTransferred(_unitId, 0, _energyCost);

         uint256 randomValue = _generatePseudoRandomNumber(_unitId + _energyCost + block.timestamp);
         uint256 chance = randomValue % 100;

         uint256 successChance = fluctuationParameters.baseStabilizeSuccessChance + (_energyCost / fluctuationParameters.energyInfluenceFactor);
         if (successChance > 100) successChance = 100; // Clamp chance

         if (chance < successChance) {
             State oldState = units[_unitId].state;
             units[_unitId].state = State.Stable;

             // If entangled, partner also likely stabilizes or disentangles?
             // Let's make stabilization break entanglement and partner reverts to Superposition
             if (oldState == State.Entangled && units[_unitId].entangledWith != 0) {
                 uint256 partnerId = units[_unitId].entangledWith;
                 FluctuatingUnit storage partner = units[partnerId];
                 partner.entangledWith = 0;
                 units[_unitId].entangledWith = 0;

                 if(partner.state != State.Decayed) {
                    State partnerOldState = partner.state;
                    partner.state = State.Superposition; // Partner reverts
                    emit UnitDisentangled(partnerId, _unitId);
                    emit StateChanged(partnerId, partnerOldState, State.Superposition, 0);
                 } else {
                    emit UnitDisentangled(partnerId, _unitId); // Still emit disentangle
                 }
             }

             emit UnitStabilized(_unitId, _energyCost);
             emit StateChanged(_unitId, oldState, State.Stable, -_energyCost);
         }
         // Else: Stabilization attempt failed, energy is still consumed. No state change event.
     }

    /**
     * @notice Allows reclaiming a portion of energy from a Decayed unit.
     * Can only be called once per unit.
     * @param _unitId The ID of the decayed unit to reclaim from.
     */
    function reclaimDecayedUnit(uint256 _unitId) public {
        require(units[_unitId].id != 0, "Unit does not exist");
        require(units[_unitId].owner == msg.sender, "Caller does not own this unit");
        require(units[_unitId].state == State.Decayed, "Unit is not in Decayed state");
        require(!units[_unitId].reclaimed, "Unit has already been reclaimed");

        // Reclaim a portion of its energy (e.g., 50%)
        uint256 energyReclaimedAmount = units[_unitId].energy / 2;
        units[_unitId].energy -= energyReclaimedAmount; // Reduce energy in the decayed unit

        // Add reclaimed energy to a new Superposition unit owned by the user?
        // Or simply add it to one of their *other* units? Let's add to a random active unit they own.
        uint256[] memory activeUnitIds = listUnitsByState(State.Superposition); // Find one of their active units
        uint256 randomIdx = _generatePseudoRandomNumber(_unitId + energyReclaimedAmount) % activeUnitIds.length;
        uint256 targetUnitId = activeUnitIds[randomIdx]; // Random active unit ID owned by msg.sender

        require(units[targetUnitId].owner == msg.sender, "System error finding active unit owned by caller"); // Should not happen if listUnitsByState is correct


        units[targetUnitId].energy += energyReclaimedAmount;

        units[_unitId].reclaimed = true;

        emit UnitReclaimed(_unitId, msg.sender, energyReclaimedAmount);
        emit EnergyTransferred(_unitId, targetUnitId, energyReclaimedAmount);
    }

    /**
     * @notice Allows anyone to trigger a decay check for a specific unit.
     * This costs gas but doesn't require ownership.
     * @param _unitId The ID of the unit to check for decay.
     */
    function checkAndTriggerDecay(uint256 _unitId) public {
         require(units[_unitId].id != 0, "Unit does not exist");
         require(units[_unitId].state != State.Decayed, "Unit has already decayed");
         // Anyone can trigger, cost gas to do so
         _checkAndTriggerDecay(_unitId);
    }


    /**
     * @notice Catalyzes a reaction involving multiple units, potentially influencing a target unit.
     * Requires caller to own all involved units. Transfers energy from involved units to target.
     * Has a chance to trigger a major state shift or energy boost on the target unit.
     * @param _unitIds An array of IDs of units involved in the reaction (contributing energy/influence).
     * @param _targetUnitId The ID of the unit that is the target of the reaction.
     */
    function catalyzeReaction(uint256[] calldata _unitIds, uint256 _targetUnitId) public {
        require(units[_targetUnitId].id != 0, "Target unit does not exist");
        require(units[_targetUnitId].owner == msg.sender, "Caller must own the target unit");
        require(units[_targetUnitId].state != State.Decayed, "Target unit cannot be decayed");
        require(_unitIds.length > 0, "Must involve at least one other unit");

        uint256 totalEnergyContributed = 0;
        uint256 successBoost = 0;

        for (uint256 i = 0; i < _unitIds.length; i++) {
            uint256 involvedUnitId = _unitIds[i];
            require(units[involvedUnitId].id != 0, "Involved unit does not exist");
            require(units[involvedUnitId].owner == msg.sender, "Caller must own all involved units");
            require(involvedUnitId != _targetUnitId, "Target unit cannot be an involved unit");
            require(units[involvedUnitId].state != State.Decayed, "Involved unit cannot be decayed");
            require(units[involvedUnitId].energy > 0, "Involved unit must have energy"); // Require some energy to contribute

            // Transfer some energy from involved unit to target (e.g., 25% or a fixed amount)
            uint256 energyToMove = units[involvedUnitId].energy / 4; // Example: move 25%
            if (energyToMove == 0 && units[involvedUnitId].energy > 0) energyToMove = 1; // Ensure at least 1 if energy > 0

            units[involvedUnitId].energy -= energyToMove;
            units[_targetUnitId].energy += energyToMove;
            totalEnergyContributed += energyToMove;
             emit EnergyTransferred(involvedUnitId, _targetUnitId, energyToMove);

            successBoost += fluctuationParameters.catalyzeSuccessBoostPerUnit;
        }

        // Probabilistic outcome on the target unit based on units involved and energy
        uint256 randomValue = _generatePseudoRandomNumber(_targetUnitId + totalEnergyContributed + block.timestamp);
        uint256 chance = randomValue % 100;

        uint256 baseSuccessChance = 10; // Base chance for catalytic effect
        uint256 totalSuccessChance = baseSuccessChance + successBoost + (totalEnergyContributed / fluctuationParameters.energyInfluenceFactor / 2);
        if (totalSuccessChance > 90) totalSuccessChance = 90; // Cap effect chance

        if (chance < totalSuccessChance) {
            // Catalytic effect success: potentially major state change or energy boost
            State oldState = units[_targetUnitId].state;
            uint256 effectRandom = _generatePseudoRandomNumber(_targetUnitId + block.number);

            if (effectRandom % 3 == 0) {
                 // Big energy boost
                 uint256 boostAmount = totalEnergyContributed * 2; // Double contributed energy
                 units[_targetUnitId].energy += boostAmount;
                 emit EnergyTransferred(0, _targetUnitId, boostAmount); // Indicate energy created/boosted
            } else if (effectRandom % 3 == 1 && oldState != State.Stable) {
                 // Force stabilize
                 units[_targetUnitId].state = State.Stable;
                 // Disentangle if needed
                 if (oldState == State.Entangled && units[_targetUnitId].entangledWith != 0) {
                     uint256 partnerId = units[_targetUnitId].entangledWith;
                     units[_targetUnitId].entangledWith = 0;
                      if(units[partnerId].id != 0 && units[partnerId].entangledWith == _targetUnitId) {
                          units[partnerId].entangledWith = 0;
                           if(units[partnerId].state != State.Decayed) units[partnerId].state = State.Superposition; // Partner reverts
                           emit UnitDisentangled(partnerId, _targetUnitId);
                           if(units[partnerId].state != State.Decayed) emit StateChanged(partnerId, units[partnerId].state, State.Superposition, 0);
                      }
                 }
                 emit UnitStabilized(_targetUnitId, 0); // Stabilized via catalysis, no direct energy cost
                 emit StateChanged(_targetUnitId, oldState, State.Stable, 0);
            } else {
                 // Force Superposition with energy boost
                 units[_targetUnitId].state = State.Superposition;
                  uint256 boostAmount = totalEnergyContributed;
                 units[_targetUnitId].energy += boostAmount;
                  emit EnergyTransferred(0, _targetUnitId, boostAmount);

                 // Disentangle if needed (catalysis is a chaotic event)
                 if (oldState == State.Entangled && units[_targetUnitId].entangledWith != 0) {
                     uint256 partnerId = units[_targetUnitId].entangledWith;
                     units[_targetUnitId].entangledWith = 0;
                      if(units[partnerId].id != 0 && units[partnerId].entangledWith == _targetUnitId) {
                          units[partnerId].entangledWith = 0;
                           if(units[partnerId].state != State.Decayed) units[partnerId].state = State.Superposition; // Partner reverts
                           emit UnitDisentangled(partnerId, _targetUnitId);
                           if(units[partnerId].state != State.Decayed) emit StateChanged(partnerId, units[partnerId].state, State.Superposition, 0);
                      }
                 }
                 if(oldState != State.Superposition) emit StateChanged(_targetUnitId, oldState, State.Superposition, 0);
            }
        }
        // Else: Catalysis attempt failed, energy still transferred.

        emit ReactionCatalyzed(_targetUnitId, _unitIds, totalEnergyContributed);
        units[_targetUnitId].lastInteractionTime = block.timestamp; // Update interaction time
    }


    // --- System Configuration & Control (Owner Only) ---

    /**
     * @notice Allows the owner to update the system-wide fluctuation parameters.
     * @param _params The new set of fluctuation parameters.
     */
    function setFluctuationParameters(FluctuationParameters calldata _params) public onlyOwner {
        fluctuationParameters = _params;
        emit ParametersUpdated(_params);
    }

    /**
     * @notice Triggers a probabilistic state check for all active (non-decayed) units.
     * Simulates a system-wide fluctuation event. Can be gas-intensive with many units.
     */
    function triggerSystemFluctuation() public onlyOwner {
        uint256 unitsAffectedCount = 0;
        for (uint256 i = 1; i < _nextTokenId; i++) {
            // Check for decay first (already handles disentanglement if needed)
             if (units[i].id != 0 && units[i].state != State.Decayed) {
                _checkAndTriggerDecay(i);
             }

            // If not decayed after check, apply fluctuation chance
            if (units[i].id != 0 && units[i].state != State.Decayed) {
                 FluctuatingUnit storage unit = units[i];
                 State oldState = unit.state;
                 State newState = _determineNextState(unit);

                 if (newState != oldState) {
                      // Handle disentanglement if state changes from Entangled
                      if (oldState == State.Entangled && newState != State.Entangled && unit.entangledWith != 0) {
                         uint256 partnerId = unit.entangledWith;
                         FluctuatingUnit storage partner = units[partnerId];
                          partner.entangledWith = 0;
                          unit.entangledWith = 0;

                          if(partner.id != 0 && partner.state != State.Decayed) {
                              State partnerOldState = partner.state;
                              partner.state = _determineNextState(partner); // Partner observed implicitly
                              emit UnitDisentangled(partnerId, i);
                              emit StateChanged(partnerId, partnerOldState, partner.state, 0);
                          } else {
                              emit UnitDisentangled(partnerId, i); // Still emit disentangle
                          }
                      }

                     unit.state = newState;
                     emit StateChanged(i, oldState, newState, 0); // No energy change from system fluctuation itself

                     // Special handling if new state is Decayed
                     if (newState == State.Decayed) {
                         emit UnitDecayed(i);
                     }
                 }
                 unit.lastInteractionTime = block.timestamp; // Update interaction time
                 unitsAffectedCount++;
            }
        }
        emit SystemFluctuationTriggered(unitsAffectedCount);
    }

    /**
     * @notice (Conceptual) Owner function to evolve system parameters based on current state distribution.
     * Example: If many units are Decayed, increase StabilizeSuccessChance or decrease DecayRates.
     */
    function evolveSystemParameters() public onlyOwner {
         uint256[] memory counts = querySystemHealth(); // counts: [Superposition, Entangled, Decayed, Stable]
         uint256 totalUnits = getTotalUnits();

         if (totalUnits == 0) return; // Nothing to evolve if no units

         FluctuationParameters memory currentParams = fluctuationParameters;
         bool changed = false;

         // Example logic: If more than 30% units are Decayed, make things easier to stabilize/harder to decay
         if (counts[2] * 100 / totalUnits > 30) {
             if (currentParams.baseStabilizeSuccessChance < 50) {
                  currentParams.baseStabilizeSuccessChance += 5; // Increase stabilize chance
                  changed = true;
             }
             if (currentParams.superpositionDecayRate > 5) {
                 currentParams.superpositionDecayRate -= 2; // Decrease decay rate
                 changed = true;
             }
         }

         // Example logic: If more than 50% units are Stable, make things more volatile
         if (counts[3] * 100 / totalUnits > 50) {
             if (currentParams.baseStabilizeSuccessChance > 10) {
                 currentParams.baseStabilizeSuccessChance -= 5; // Decrease stabilize chance
                  changed = true;
             }
             if (currentParams.energyInfluenceFactor < 10) {
                 currentParams.energyInfluenceFactor += 1; // Make energy less influential
                 changed = true;
             }
         }

         if (changed) {
             fluctuationParameters = currentParams;
             emit ParametersUpdated(currentParams);
         }
         // Else: Parameters did not evolve based on current rules.
     }


    // --- Query & Analysis (View) ---

    /**
     * @notice Gets the current system-wide fluctuation parameters.
     * @return The current FluctuationParameters struct.
     */
    function getFluctuationParameters() public view returns (FluctuationParameters memory) {
         return fluctuationParameters;
    }

    /**
     * @notice Lists all currently entangled pairs of unit IDs.
     * Returns an array where each pair is [unitId1, unitId2].
     * Avoids listing the same pair twice ([1, 2] and [2, 1]).
     * @return An array of entangled pairs.
     */
    function getEntangledPairs() public view returns (uint256[][] memory) {
        uint256[][] memory entangledPairs = new uint256[][](_nextTokenId - 1); // Max possible pairs
        uint256 count = 0;

        for (uint256 i = 1; i < _nextTokenId; i++) {
            if (units[i].id != 0 && units[i].state == State.Entangled && units[i].entangledWith != 0) {
                // Ensure we only add the pair once (e.g., don't add [2, 1] if [1, 2] is added)
                if (i < units[i].entangledWith) {
                    entangledPairs[count] = new uint256[](2);
                    entangledPairs[count][0] = i;
                    entangledPairs[count][1] = units[i].entangledWith;
                    count++;
                }
            }
        }

        uint256[][] memory result = new uint256[][](count);
        for (uint256 i = 0; i < count; i++) {
            result[i] = entangledPairs[i];
        }
        return result;
    }


    /**
     * @notice (Conceptual) Predicts the probability distribution of states a unit might transition to upon observation.
     * This is a view function that *calculates* probabilities based on current state/parameters,
     * but does NOT trigger the actual probabilistic outcome or change state.
     * @param _unitId The ID of the unit to predict for.
     * @return An array of probability chances for each state: [Decayed, Stable, Entangled, Superposition, StayInCurrent].
     *         Note: probabilities are simplified here (e.g., out of 100), not necessarily summing to 100 if logic is complex.
     *         This implementation returns the *thresholds* used in _determineNextState logic simplified.
     * WARNING: This prediction is based on the simplified internal probabilistic model and does NOT guarantee the actual outcome.
     */
    function predictNextStateProbability(uint256 _unitId) public view returns (uint256[5] memory chances) {
        require(units[_unitId].id != 0, "Unit does not exist");
        FluctuatingUnit storage unit = units[_unitId];

         // Return 100% for Decayed state if already decayed
         if (unit.state == State.Decayed) {
              return [100, 0, 0, 0, 0]; // [Decayed, Stable, Entangled, Superposition, Stay]
         }

         // Simulate the logic from _determineNextState to get the chances/thresholds
         uint256 timeSinceLastInteraction = block.timestamp - unit.lastInteractionTime;
         uint256 energyInfluence = unit.energy / fluctuationParameters.energyInfluenceFactor;

         uint256 decayChance = 0;
         uint256 stabilizeChance = 0;
         uint256 entangleChance = 0;
         uint256 fluctuateChance = 0; // Chance to move back to Superposition
         uint256 stayChance = 0;

         if (unit.state == State.Superposition) {
             decayChance = fluctuationParameters.superpositionDecayRate;
             entangleChance = 15;
             stabilizeChance = energyInfluence / 2;
             // Time increases decay likelihood
             if (timeSinceLastInteraction >= fluctuationParameters.decayCheckTimeThreshold) {
                  decayChance = decayChance + (timeSinceLastInteraction / fluctuationParameters.decayCheckTimeThreshold) * 5;
             }
             // The remaining chance after decay, entangle, stabilize roll results in staying Superposition (fluctuate back)
             uint256 rolledAgainst = decayChance + entangleChance + stabilizeChance;
             if (rolledAgainst < 100) stayChance = 100 - rolledAgainst; else stayChance = 0; // Simplified stay chance

         } else if (unit.state == State.Entangled) {
             stabilizeChance = fluctuationParameters.entanglementStabilityBoost + (energyInfluence / 3);
             fluctuateChance = 20 - (energyInfluence / 5);
             decayChance = 5;
             // Time effect? (Not in current determine logic, but could be added)
              uint256 rolledAgainst = decayChance + stabilizeChance + fluctuateChance;
             if (rolledAgainst < 100) stayChance = 100 - rolledAgainst; else stayChance = 0;

         } else if (unit.state == State.Stable) {
             fluctuateChance = 10 + (timeSinceLastInteraction / fluctuationParameters.decayCheckTimeThreshold) * 3;
             decayChance = (unit.energy < fluctuationParameters.stableDecayThreshold) ? 15 : 5;
             stabilizeChance = 0; // Cannot stabilize further
             uint256 rolledAgainst = decayChance + fluctuateChance;
             if (rolledAgainst < 100) stayChance = 100 - rolledAgainst; else stayChance = 0;
         }

         // Clamp values and ensure they represent the chances based on the _determineNextState logic thresholds
         // The chances array maps to [Decayed, Stable, Entangled, Superposition, StayInCurrent]
         chances[0] = decayChance > 100 ? 100 : decayChance;
         chances[1] = stabilizeChance > 100 ? 100 : stabilizeChance;
         chances[2] = entangleChance > 100 ? 100 : entangleChance;
         chances[3] = fluctuateChance > 100 ? 100 : fluctuateChance;
         // Stay chance is implicit if none of the above thresholds are met by the random number
         // This simple prediction cannot perfectly mirror the sequential checks in _determineNextState
         // A more accurate prediction would calculate weighted probabilities if the underlying logic used them.
         // For this example, we'll return the *maximum possible* chances for each transition based on parameters.
         // A better representation might be: chance to decay, chance to stabilize (if not stable), chance to entangle (if superpos), chance to fluctuate (if not superpos).
         // Let's return [Chance_Decay, Chance_To_Stable, Chance_To_Entangled, Chance_To_Superposition, Chance_To_Stay]
         chances[0] = decayChance;
         chances[1] = (unit.state != State.Stable) ? stabilizeChance : 0;
         chances[2] = (unit.state == State.Superposition) ? entangleChance : 0;
         chances[3] = (unit.state != State.Superposition) ? fluctuateChance : 0;
         // Calculating "stay" probability is tricky with sequential checks.
         // Let's return the individual chances as calculated, understanding they are NOT mutually exclusive probabilities summing to 100 with this internal logic model.
         // This highlights the complexity of predicting non-linear on-chain outcomes.
         // We'll just return the calculated chances before clamping for the final state pick.

         return [
             decayChance,        // Chance to become Decayed
             (unit.state != State.Stable) ? stabilizeChance : 0, // Chance to become Stable (if not already)
             (unit.state == State.Superposition) ? entangleChance : 0, // Chance to become Entangled (if Superposition)
             (unit.state != State.Superposition) ? fluctuateChance : 0, // Chance to become Superposition (if not already)
             0 // Cannot easily calculate "stay" chance with sequential checks
         ];
     }


    /**
     * @notice Provides a summary of the system's health, including state distribution.
     * @return An array of counts for each state: [Superposition, Entangled, Decayed, Stable].
     */
    function querySystemHealth() public view returns (uint256[4] memory stateCounts) {
         stateCounts = [0, 0, 0, 0]; // [Superposition, Entangled, Decayed, Stable]
         for (uint256 i = 1; i < _nextTokenId; i++) {
             if (units[i].id != 0) {
                 if (units[i].state == State.Superposition) stateCounts[0]++;
                 else if (units[i].state == State.Entangled) stateCounts[1]++;
                 else if (units[i].state == State.Decayed) stateCounts[2]++;
                 else if (units[i].state == State.Stable) stateCounts[3]++;
             }
         }
         return stateCounts;
    }

    // Fallback/Receive functions (optional, but good practice if sending ETH)
    // receive() external payable {}
    // fallback() external payable {}
}
```