Here's a Solidity smart contract named `ChronoscribeNexus`, designed with interesting, advanced, creative, and trendy functions, while aiming to avoid direct duplication of existing open-source projects by combining unique mechanics.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// Outline and Function Summary
/*
Contract: ChronoscribeNexus

I. Introduction & Core Concept:
`ChronoscribeNexus` is a decentralized platform where unique digital artifacts called "ChronoScrolls" (ERC721 NFTs)
possess an inherent ability to evolve, narrate, and interact with a temporal economy. These scrolls accumulate
"Essence" (an ERC20 token) over time, which fuels their evolution and participation in the ecosystem.
The platform integrates conceptual AI-curation for "Narrative Fragments" and features a novel
"Temporal Delegation" governance model, along with a "Chronoscore" reputation system.

II. Core Components:
*   **ChronoScrolls (ERC721):** Dynamic NFTs whose traits evolve based on accumulated Essence, absorbed Narrative Fragments,
    and completion of Epochal Quests. They serve as the central evolving assets of the ecosystem.
*   **Essence (ERC20):** A fungible token representing temporal energy, automatically accrued by holding ChronoScrolls.
    It is the primary in-ecosystem currency, used for upgrades, quest participation, and influencing governance.
*   **Narrative Fragments:** Conceptual data structures (represented by hashes/URIs) that embody pieces of narrative.
    These are intended to be fed via an oracle (simulating AI or curated input) and can be "absorbed" by scrolls
    to alter their traits and history.
*   **Epochal Quests:** Time-gated, on-chain challenges that require ChronoScrolls to meet specific trait conditions
    and consume Essence. Completing quests is a primary mechanism for ChronoScroll evolution.
*   **Temporal Delegation:** A unique governance model where delegated voting power (derived from Essence and Chronoscore)
    decays linearly over time. This design encourages active re-delegation or direct participation, discouraging passive,
    indefinite power delegation.
*   **Chronoscore:** A non-transferable, on-chain reputation score (akin to a Soulbound Token's non-transferability),
    reflecting a user's engagement, contributions, successful governance interactions, and overall positive
    participation within the Nexus. It influences proposal power and other privileges.

III. Function Summary:

A. ChronoScroll Management (ERC721 & Dynamic Traits)
1.  **`mintChronoScroll()`: `external`**
    Mints a new ChronoScroll NFT to the caller with initial random-like themes and base traits.
    (Initially callable by `owner` or a configured minter role).
2.  **`claimEssence(uint256 _tokenId)`: `public`**
    Allows the owner of a ChronoScroll to claim the accumulated Essence generated by that scroll
    since its last claim or mint time.
3.  **`absorbNarrativeFragment(uint256 _tokenId, bytes32 _fragmentId)`: `public`**
    Enables a scroll owner to apply a pre-approved Narrative Fragment to their scroll. This action consumes Essence
    and potentially modifies the scroll's dynamic traits (e.g., `auraLevel`, `theme`).
4.  **`evolveScroll(uint256 _tokenId, uint256 _questId)`: `public`**
    Triggers a ChronoScroll's evolution if the specified `_questId` conditions are met (trait requirements, quest active)
    and the required Essence is consumed. Successfully evolving a scroll updates its `evolutionStage` and increases its
    base Essence accrual rate.
5.  **`getScrollDetails(uint256 _tokenId)`: `public view`**
    Retrieves all dynamic traits (e.g., `mintTime`, `lastEssenceClaimTime`, `baseEssenceAccrualRate`, `theme`,
    `evolutionStage`, `auraLevel`), current pending Essence, and total Essence claimed for a specific ChronoScroll.
6.  **`getCurrentEssenceAccrualRate(uint256 _tokenId)`: `public view`**
    Returns the effective per-second Essence accrual rate for a given scroll, factoring in its unique traits
    and the global Essence accrual rate factor.

B. Essence Token (ERC20 Standard & Custom Logic)
7.  **`transfer(address to, uint256 amount)`: `public virtual`**
    Standard ERC20 function: Transfers `amount` of Essence tokens to `to` address.
8.  **`approve(address spender, uint256 amount)`: `public virtual`**
    Standard ERC20 function: Allows `spender` to spend `amount` of Essence tokens on behalf of the caller.
9.  **`allowance(address owner, address spender)`: `public view virtual`**
    Standard ERC20 function: Returns the amount of Essence `owner` allowed `spender` to withdraw.
10. **`burn(uint256 amount)`: `public`**
    Allows users to burn their own Essence tokens. This action may have implications for a user's Chronoscore.

C. Narrative Fragment & Epochal Quest Management
11. **`submitNarrativeFragment(bytes32 _fragmentId, string memory _fragmentURI)`: `public`**
    Allows users with a specific "Scribe" role or a sufficiently high Chronoscore to propose new conceptual
    Narrative Fragments for review by curators/oracles.
12. **`curateNarrativeFragment(bytes32 _fragmentId, bool _approved)`: `public`**
    Allows designated "Oracle" or "Guardian" roles to approve or reject submitted Narrative Fragments,
    making them available for absorption by ChronoScrolls. This action impacts the Chronoscore of the fragment submitter.
13. **`createEpochalQuest(string memory _questName, string memory _questURI, uint256 _requiredEssence, TraitCondition[] memory _requiredTraits, uint256 _duration)`: `public`**
    Admin/governance function to define new Epochal Quests, specifying their name, URI for details, Essence cost,
    required ChronoScroll traits, and duration.
14. **`startEpochalQuest(uint256 _questId)`: `public`**
    Initiates a previously defined Epochal Quest, making it active and available for participants to begin working on.
15. **`completeEpochalQuestChallenge(uint256 _questId, uint256 _tokenId)`: `public`**
    A conceptual function that represents a ChronoScroll owner completing a specific sub-challenge or step within an
    Epochal Quest. This acts as an intermediate marker before the final `evolveScroll` completion.

D. Temporal Delegation (Governance)
16. **`delegateTemporalVote(address _delegatee)`: `public`**
    Delegates the caller's current and future Essence-based voting power (combined with Chronoscore influence)
    to another address. The effectiveness of this delegated power decays over time.
17. **`undelegateTemporalVote()`: `public`**
    Revokes any active delegation previously made by the caller, returning their voting power to them,
    recalibrated based on the elapsed time and decay.
18. **`getEffectiveVotePower(address _voter)`: `public view`**
    Returns the current effective voting power of an address. This power is derived from their Essence balance
    and Chronoscore, adjusted by any active temporal delegation (if delegated, their personal power is zero).
19. **`proposeCollectiveEvolution(uint256 _tokenId, uint8 _targetStage, uint256 _duration)`: `public`**
    Allows users with sufficient Chronoscore or effective vote power to propose a collective evolution path for
    a specific type of ChronoScroll, initiating a community-wide governance vote.
20. **`voteOnProposal(uint256 _proposalId, bool _support)`: `public`**
    Casts a vote (for or against) on an active governance proposal, using the caller's current effective vote power.
21. **`executeProposal(uint256 _proposalId)`: `public`**
    Executes a governance proposal once its voting period has ended and it has succeeded (more votes For than Against).
    This function applies the changes proposed, such as evolving a target ChronoScroll.

E. Chronoscore (Reputation System)
22. **`getChronoscore(address _user)`: `public view`**
    Retrieves the non-transferable Chronoscore (reputation score) of a specific user.
23. **`_updateChronoscoreInternal(address _user, int256 _amount)`: `internal`**
    An internal function called by various other contract logics (e.g., quest completion, successful proposals,
    active delegation) to adjust a user's Chronoscore. (Not directly callable externally).

F. Admin & Oracle Management
24. **`setOracleAddress(address _newOracle)`: `public`**
    Allows the contract owner to update the trusted oracle address that submits off-chain data.
25. **`submitOracleData(bytes32 _dataHash, uint256 _timestamp, bytes memory _signature)`: `public`**
    Allows the registered oracle to submit cryptographically signed off-chain data (e.g., AI output, real-world events)
    to the contract. This data can then be referenced for dynamic trait changes or quest conditions.
26. **`updateGlobalEssenceAccrualRate(uint256 _newRate)`: `public`**
    Allows the contract owner (or later, governance) to adjust the global baseline Essence accrual rate for all scrolls,
    influencing the ecosystem's economy.

G. Utility/View Functions
27. **`tokenURI(uint256 tokenId)`: `public view override`**
    Generates a dynamic token URI for a ChronoScroll NFT, embedding its current traits (theme, stage, aura)
    directly into the URI, allowing for dynamic metadata.
*/

contract ChronoscribeNexus is ERC721Enumerable, ERC20, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using SafeMath for uint256; // OpenZeppelin's SafeMath is generally deprecated in 0.8.0+, but useful for explicit checks.

    // --- State Variables ---

    // ChronoScrolls (ERC721)
    Counters.Counter private _tokenIdCounter;

    struct ChronoScroll {
        uint256 mintTime; // Timestamp of minting
        uint256 lastEssenceClaimTime; // Last time Essence was claimed
        uint256 baseEssenceAccrualRate; // Essence per second, before global factor
        mapping(string => string) traits; // Dynamic traits like "theme", "evolutionStage", "auraLevel"
        mapping(bytes32 => bool) absorbedFragments; // Tracks absorbed Narrative Fragments
        uint256 essenceClaimedTotal; // Total essence claimed by this scroll over its lifetime
    }
    mapping(uint256 => ChronoScroll) private _chronoScrolls;

    // Essence (ERC20)
    uint256 public globalEssenceAccrualRateFactor = 1000; // Factor for essence accrual (e.g., 1000 = 1 Essence per base rate unit)

    // Narrative Fragments
    struct NarrativeFragment {
        string fragmentURI; // IPFS URI or similar for the fragment content
        bool isApproved; // Whether this fragment can be absorbed
        address creator; // The address that submitted this fragment
    }
    mapping(bytes32 => NarrativeFragment) public narrativeFragments; // fragmentId => NarrativeFragment
    bytes32[] public approvedFragmentIds; // List of approved fragment IDs for potential off-chain display/selection

    // Epochal Quests
    Counters.Counter private _questIdCounter;
    enum QuestStatus { Inactive, Active, Completed }

    struct TraitCondition {
        string traitName;
        string requiredValue;
    }

    struct EpochalQuest {
        string name;
        string uri; // URI for quest details/description
        uint256 requiredEssence;
        TraitCondition[] requiredTraits; // Traits required on the scroll to complete the quest
        uint256 duration; // Duration quest is active after start
        uint256 startTime; // When the quest became active
        QuestStatus status;
        mapping(uint256 => bool) completedScrolls; // tokenId => true if scroll completed this quest
    }
    mapping(uint256 => EpochalQuest) public epochalQuests;

    // Temporal Delegation (Governance)
    struct Delegation {
        address delegatee;
        uint256 delegationTime; // Timestamp of delegation
        uint256 initialVotePowerSnapshot; // Snapshot of vote power at delegation time (Essence balance + Chronoscore)
        uint256 decayRatePerSecond; // How much vote power decays per second
    }
    mapping(address => Delegation) public temporalDelegations;
    uint256 public constant DELEGATION_DECAY_PERIOD_SECONDS = 30 * 24 * 60 * 60; // Example: 30 days for 100% linear decay of initial power

    // Chronoscore (Reputation) - SBT-like
    mapping(address => int256) private _chronoscores; // Can be negative for penalties, capped at a floor.

    // Oracle Management
    address public oracleAddress; // Trusted address for submitting off-chain data
    mapping(bytes32 => bool) public processedOracleData; // dataHash => true if processed

    // Governance Proposals
    Counters.Counter private _proposalIdCounter;
    enum ProposalStatus { Pending, Active, Succeeded, Failed }

    struct Proposal {
        string description;
        address proposer;
        uint256 startTime;
        uint256 endTime;
        uint256 votesFor;
        uint256 votesAgainst;
        ProposalStatus status;
        mapping(address => bool) hasVoted; // Voter address => true
        // Specific proposal data for collective evolution
        uint256 targetTokenId;
        uint8 targetEvolutionStage;
    }
    mapping(uint256 => Proposal) public proposals;

    // --- Events ---
    event ChronoScrollMinted(uint256 indexed tokenId, address indexed owner, string initialTheme);
    event EssenceClaimed(uint256 indexed tokenId, address indexed owner, uint256 amount);
    event NarrativeFragmentSubmitted(bytes32 indexed fragmentId, address indexed creator, string uri);
    event NarrativeFragmentCurated(bytes32 indexed fragmentId, bool approved);
    event ScrollAbsorbedFragment(uint256 indexed tokenId, bytes32 indexed fragmentId, string newTraitValue);
    event ScrollEvolved(uint256 indexed tokenId, uint256 indexed questId, uint8 newStage);
    event EpochalQuestCreated(uint256 indexed questId, string name, uint256 requiredEssence);
    event EpochalQuestStarted(uint256 indexed questId, uint256 startTime);
    event EpochalQuestChallengeCompleted(uint256 indexed questId, uint256 indexed tokenId);
    event DelegatedTemporalVote(address indexed delegator, address indexed delegatee, uint256 initialPowerSnapshot);
    event UndelegatedTemporalVote(address indexed delegator, uint256 finalPower);
    event ChronoscoreUpdated(address indexed user, int256 newScore);
    event OracleDataSubmitted(bytes32 indexed dataHash, uint256 timestamp);
    event GlobalEssenceAccrualRateUpdated(uint256 newRate);
    event ProposalCreated(uint256 indexed proposalId, address indexed proposer);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votePower);
    event ProposalExecuted(uint256 indexed proposalId, ProposalStatus finalStatus);

    // --- Constructor ---
    constructor(address _oracleAddress) ERC721("ChronoScroll", "CHRONOS") ERC20("Essence", "ESS") Ownable(msg.sender) {
        require(_oracleAddress != address(0), "Oracle address cannot be zero");
        oracleAddress = _oracleAddress;
    }

    // --- Modifiers ---
    modifier onlyOracle() {
        require(msg.sender == oracleAddress, "Caller is not the oracle");
        _;
    }

    modifier onlyScribeOrHighChronoscore() {
        // Defines who can submit Narrative Fragments
        require(msg.sender == owner() || _chronoscores[msg.sender] >= 500, "Access denied: Scribe role or sufficient Chronoscore (>= 500) required.");
        _;
    }

    modifier onlyGuardianOrOracle() {
        // Defines who can curate Narrative Fragments (owner is also implicitly a guardian)
        require(msg.sender == owner() || msg.sender == oracleAddress, "Access denied: Guardian or Oracle required.");
        _;
    }

    modifier notZeroAddress(address _addr) {
        require(_addr != address(0), "Address cannot be zero");
        _;
    }

    // --- A. ChronoScroll Management (ERC721 & Dynamic Traits) ---

    // 1. mintChronoScroll()
    function mintChronoScroll() public onlyOwner nonReentrant returns (uint256) {
        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();

        _safeMint(msg.sender, newTokenId);

        // Initialize scroll data
        ChronoScroll storage newScroll = _chronoScrolls[newTokenId];
        newScroll.mintTime = block.timestamp;
        newScroll.lastEssenceClaimTime = block.timestamp;
        newScroll.baseEssenceAccrualRate = 1; // Base rate: 1 unit per second initially

        // Set initial random-like traits (conceptual; in a dApp, could use Chainlink VRF for more randomness)
        newScroll.traits["theme"] = "Cosmic Nexus";
        newScroll.traits["evolutionStage"] = "1";
        newScroll.traits["auraLevel"] = "0"; // Will increase with fragment absorption

        emit ChronoScrollMinted(newTokenId, msg.sender, newScroll.traits["theme"]);
        return newTokenId;
    }

    // Internal helper to calculate pending essence
    function _calculatePendingEssence(uint256 _tokenId) internal view returns (uint256) {
        ChronoScroll storage scroll = _chronoScrolls[_tokenId];
        uint256 timeElapsed = block.timestamp.sub(scroll.lastEssenceClaimTime);
        // Essence = timeElapsed * baseRate * globalFactor / 1000 (for scaling precision)
        return timeElapsed.mul(scroll.baseEssenceAccrualRate).mul(globalEssenceAccrualRateFactor).div(1000);
    }

    // 2. claimEssence(uint256 _tokenId)
    function claimEssence(uint256 _tokenId) public nonReentrant {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        require(ownerOf(_tokenId) == msg.sender, "Caller is not ChronoScroll owner");

        ChronoScroll storage scroll = _chronoScrolls[_tokenId];
        uint256 pendingEssence = _calculatePendingEssence(_tokenId);

        require(pendingEssence > 0, "No essence to claim");

        scroll.lastEssenceClaimTime = block.timestamp;
        _mint(msg.sender, pendingEssence); // Mint ERC20 Essence tokens to the scroll owner
        scroll.essenceClaimedTotal = scroll.essenceClaimedTotal.add(pendingEssence);

        _updateChronoscoreInternal(msg.sender, 1); // Small Chronoscore reward for active participation
        emit EssenceClaimed(_tokenId, msg.sender, pendingEssence);
    }

    // 3. absorbNarrativeFragment(uint256 _tokenId, bytes32 _fragmentId)
    function absorbNarrativeFragment(uint256 _tokenId, bytes32 _fragmentId) public nonReentrant {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        require(ownerOf(_tokenId) == msg.sender, "Caller is not ChronoScroll owner");
        require(narrativeFragments[_fragmentId].creator != address(0), "Narrative Fragment does not exist");
        require(narrativeFragments[_fragmentId].isApproved, "Narrative Fragment not approved for absorption");

        ChronoScroll storage scroll = _chronoScrolls[_tokenId];
        require(!scroll.absorbedFragments[_fragmentId], "Fragment already absorbed by this scroll");

        uint256 absorptionCost = 100 * (10 ** decimals()); // Example cost: 100 Essence
        require(balanceOf(msg.sender) >= absorptionCost, "Insufficient Essence for absorption");
        _burn(msg.sender, absorptionCost); // Burn Essence from the caller

        scroll.absorbedFragments[_fragmentId] = true;
        // Example dynamic trait update:
        uint8 currentAuraLevel = uint8(bytes(scroll.traits["auraLevel"])[0] - 48); // Convert char to int
        scroll.traits["auraLevel"] = Strings.toString(currentAuraLevel + 1); // Increase aura level
        
        // This is a simplified example. In reality, fragment absorption could trigger complex trait changes
        // based on the fragment's specific properties or oracle input.
        scroll.traits["theme"] = string(abi.encodePacked("Narrated ", Strings.toString(currentAuraLevel + 1))); 

        _updateChronoscoreInternal(msg.sender, 5); // Chronoscore reward for interacting deeply
        emit ScrollAbsorbedFragment(_tokenId, _fragmentId, scroll.traits["auraLevel"]);
    }

    // 4. evolveScroll(uint256 _tokenId, uint256 _questId)
    function evolveScroll(uint256 _tokenId, uint256 _questId) public nonReentrant {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        require(ownerOf(_tokenId) == msg.sender, "Caller is not ChronoScroll owner");
        EpochalQuest storage quest = epochalQuests[_questId];
        require(quest.status == QuestStatus.Active, "Quest is not active");
        require(!quest.completedScrolls[_tokenId], "Scroll has already completed this quest");

        // Check quest expiration
        require(block.timestamp <= quest.startTime + quest.duration, "Quest has expired");

        // Check Essence requirement
        require(balanceOf(msg.sender) >= quest.requiredEssence, "Insufficient Essence for quest evolution");
        _burn(msg.sender, quest.requiredEssence); // Burn Essence

        // Check scroll trait conditions
        ChronoScroll storage scroll = _chronoScrolls[_tokenId];
        for (uint i = 0; i < quest.requiredTraits.length; i++) {
            // Using keccak256 for string comparison to avoid stack too deep errors with direct string comparison
            require(keccak256(abi.encodePacked(scroll.traits[quest.requiredTraits[i].traitName])) ==
                    keccak256(abi.encodePacked(quest.requiredTraits[i].requiredValue)),
                    string(abi.encodePacked("Scroll does not meet required trait: ", quest.requiredTraits[i].traitName, " must be ", quest.requiredTraits[i].requiredValue)));
        }

        quest.completedScrolls[_tokenId] = true; // Mark this scroll as having completed the quest

        // Evolve scroll traits
        uint8 currentStage = uint8(bytes(scroll.traits["evolutionStage"])[0] - 48); // Convert char to int
        scroll.traits["evolutionStage"] = Strings.toString(currentStage + 1); // Increment evolution stage
        scroll.baseEssenceAccrualRate = scroll.baseEssrualRate.add(1); // Increase Essence accrual rate upon evolution

        _updateChronoscoreInternal(msg.sender, 10); // Significant Chronoscore reward for evolving a scroll
        emit ScrollEvolved(_tokenId, _questId, currentStage + 1);
    }

    // 5. getScrollDetails(uint256 _tokenId)
    function getScrollDetails(uint256 _tokenId) public view returns (
        uint256 mintTime,
        uint256 lastEssenceClaimTime,
        uint256 baseEssenceAccrualRate,
        string memory theme,
        string memory evolutionStage,
        string memory auraLevel,
        uint256 pendingEssence,
        uint256 essenceClaimedTotal
    ) {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        ChronoScroll storage scroll = _chronoScrolls[_tokenId];
        mintTime = scroll.mintTime;
        lastEssenceClaimTime = scroll.lastEssenceClaimTime;
        baseEssenceAccrualRate = scroll.baseEssenceAccrualRate;
        theme = scroll.traits["theme"];
        evolutionStage = scroll.traits["evolutionStage"];
        auraLevel = scroll.traits["auraLevel"];
        pendingEssence = _calculatePendingEssence(_tokenId);
        essenceClaimedTotal = scroll.essenceClaimedTotal;
    }

    // 6. getCurrentEssenceAccrualRate(uint256 _tokenId)
    function getCurrentEssenceAccrualRate(uint256 _tokenId) public view returns (uint256) {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        return _chronoScrolls[_tokenId].baseEssenceAccrualRate.mul(globalEssenceAccrualRateFactor).div(1000);
    }

    // --- B. Essence Token (ERC20 Standard & Custom Logic) ---

    // 7. transfer(address to, uint256 amount) - Inherited from ERC20
    // 8. approve(address spender, uint256 amount) - Inherited from ERC20
    // 9. allowance(address owner, address spender) - Inherited from ERC20

    // 10. burn(uint256 amount)
    function burn(uint256 amount) public {
        _burn(msg.sender, amount); // Call ERC20's internal burn
        _updateChronoscoreInternal(msg.sender, -1); // Small Chronoscore penalty, discourages speculative dumping
    }

    // --- C. Narrative Fragment & Epochal Quest Management ---

    // 11. submitNarrativeFragment(bytes32 _fragmentId, string memory _fragmentURI)
    function submitNarrativeFragment(bytes32 _fragmentId, string memory _fragmentURI) public onlyScribeOrHighChronoscore {
        require(narrativeFragments[_fragmentId].creator == address(0), "Fragment ID already exists");
        narrativeFragments[_fragmentId] = NarrativeFragment({
            fragmentURI: _fragmentURI,
            isApproved: false,
            creator: msg.sender
        });
        emit NarrativeFragmentSubmitted(_fragmentId, msg.sender, _fragmentURI);
    }

    // 12. curateNarrativeFragment(bytes32 _fragmentId, bool _approved)
    function curateNarrativeFragment(bytes32 _fragmentId, bool _approved) public onlyGuardianOrOracle {
        require(narrativeFragments[_fragmentId].creator != address(0), "Fragment ID does not exist");
        require(narrativeFragments[_fragmentId].isApproved != _approved, "Fragment already in target approval state"); // Prevent redundant calls

        narrativeFragments[_fragmentId].isApproved = _approved;
        if (_approved) {
            bool found = false;
            for(uint i=0; i < approvedFragmentIds.length; i++){
                if(approvedFragmentIds[i] == _fragmentId){
                    found = true;
                    break;
                }
            }
            if(!found){ // Only push if not already present
                approvedFragmentIds.push(_fragmentId);
            }
        }
        _updateChronoscoreInternal(narrativeFragments[_fragmentId].creator, _approved ? 10 : -5); // Reward/penalize submitter based on curation outcome
        emit NarrativeFragmentCurated(_fragmentId, _approved);
    }

    // 13. createEpochalQuest(string memory _questName, string memory _questURI, uint256 _requiredEssence, TraitCondition[] memory _requiredTraits, uint256 _duration)
    function createEpochalQuest(
        string memory _questName,
        string memory _questURI,
        uint256 _requiredEssence,
        TraitCondition[] memory _requiredTraits,
        uint256 _duration
    ) public onlyOwner returns (uint256) {
        _questIdCounter.increment();
        uint256 newQuestId = _questIdCounter.current();

        EpochalQuest storage newQuest = epochalQuests[newQuestId];
        newQuest.name = _questName;
        newQuest.uri = _questURI;
        newQuest.requiredEssence = _requiredEssence;
        newQuest.requiredTraits = _requiredTraits;
        newQuest.duration = _duration;
        newQuest.status = QuestStatus.Inactive;

        emit EpochalQuestCreated(newQuestId, _questName, _requiredEssence);
        return newQuestId;
    }

    // 14. startEpochalQuest(uint256 _questId)
    function startEpochalQuest(uint256 _questId) public onlyOwner {
        EpochalQuest storage quest = epochalQuests[_questId];
        require(quest.status == QuestStatus.Inactive, "Quest is already active or completed");
        quest.startTime = block.timestamp;
        quest.status = QuestStatus.Active;
        emit EpochalQuestStarted(_questId, quest.startTime);
    }

    // 15. completeEpochalQuestChallenge(uint256 _questId, uint256 _tokenId)
    // This function marks a specific *sub-challenge* or *step* within an Epochal Quest as completed for a scroll.
    // The final "evolution" still occurs via `evolveScroll` after meeting all conditions.
    // In a full dApp, this might be triggered by an oracle verifying off-chain activity (e.g., AI model output, external data).
    function completeEpochalQuestChallenge(uint256 _questId, uint256 _tokenId) public nonReentrant {
        require(_exists(_tokenId), "ChronoScroll does not exist");
        require(ownerOf(_tokenId) == msg.sender, "Caller is not ChronoScroll owner");
        EpochalQuest storage quest = epochalQuests[_questId];
        require(quest.status == QuestStatus.Active, "Quest is not active");
        require(block.timestamp <= quest.startTime + quest.duration, "Quest has expired");
        require(!quest.completedScrolls[_tokenId], "Scroll already completed this quest"); // Ensure full quest not completed

        // Conceptual check for challenge completion. Could involve specific oracle data.
        // For example, perhaps an oracle confirms an off-chain AI analysis has occurred for this scroll.
        // This function would primarily update internal state about the scroll's progression in the quest.
        // For demo purposes, simply marks engagement.
        
        _updateChronoscoreInternal(msg.sender, 2); // Small Chronoscore reward for challenge engagement
        emit EpochalQuestChallengeCompleted(_questId, _tokenId);
    }

    // --- D. Temporal Delegation (Governance) ---

    // Internal helper to calculate current combined power (Essence + Chronoscore) for snapshot
    function _getCurrentCombinedPower(address _user) internal view returns (uint256) {
        uint256 essencePower = balanceOf(_user);
        uint256 chronoscorePower = _chronoscores[_user] > 0 ? uint256(_chronoscores[_user]) : 0; // Only positive Chronoscore adds power
        return essencePower.add(chronoscorePower);
    }

    // Internal helper to calculate decayed delegated power
    function _getEffectiveDelegatedPower(address _delegator) internal view returns (uint256) {
        Delegation storage delegation = temporalDelegations[_delegator];
        if (delegation.delegatee == address(0)) {
            return 0; // No delegation
        }

        uint256 timeElapsed = block.timestamp.sub(delegation.delegationTime);
        if (timeElapsed >= DELEGATION_DECAY_PERIOD_SECONDS) {
            return 0; // Fully decayed
        }
        
        // Linear decay: remaining_power = initial_power * (1 - (time_elapsed / decay_period))
        uint256 remainingPower = delegation.initialVotePowerSnapshot.mul(DELEGATION_DECAY_PERIOD_SECONDS.sub(timeElapsed)).div(DELEGATION_DECAY_PERIOD_SECONDS);
        return remainingPower;
    }

    // 16. delegateTemporalVote(address _delegatee)
    function delegateTemporalVote(address _delegatee) public notZeroAddress(_delegatee) {
        require(msg.sender != _delegatee, "Cannot delegate to self");
        // If already delegated, undelegate first to reset
        if (temporalDelegations[msg.sender].delegatee != address(0)) {
            undelegateTemporalVote();
        }

        uint256 initialPowerSnapshot = _getCurrentCombinedPower(msg.sender);
        require(initialPowerSnapshot > 0, "No power to delegate (Essence + Chronoscore must be positive)");

        temporalDelegations[msg.sender] = Delegation({
            delegatee: _delegatee,
            delegationTime: block.timestamp,
            initialVotePowerSnapshot: initialPowerSnapshot,
            decayRatePerSecond: initialPowerSnapshot.div(DELEGATION_DECAY_PERIOD_SECONDS) // Calculated for linear decay over period
        });

        _updateChronoscoreInternal(msg.sender, 3); // Reward for participating in governance via delegation
        emit DelegatedTemporalVote(msg.sender, _delegatee, initialPowerSnapshot);
    }

    // 17. undelegateTemporalVote()
    function undelegateTemporalVote() public {
        Delegation storage delegation = temporalDelegations[msg.sender];
        require(delegation.delegatee != address(0), "No active delegation to undelegate");

        uint256 finalPower = _getEffectiveDelegatedPower(msg.sender); // Calculate power before clearing

        // Clear delegation
        delete temporalDelegations[msg.sender];

        _updateChronoscoreInternal(msg.sender, -2); // Small penalty for undelegating (encourages commitment)
        emit UndelegatedTemporalVote(msg.sender, finalPower);
    }

    // 18. getEffectiveVotePower(address _voter)
    function getEffectiveVotePower(address _voter) public view returns (uint256) {
        // If _voter has delegated their power, they have 0 effective direct vote power.
        if (temporalDelegations[_voter].delegatee != address(0) && temporalDelegations[_voter].delegatee != _voter) {
            return 0;
        }

        // If _voter is a delegatee, this function does NOT sum up delegated power from others.
        // A true DAO would track this via an inverted mapping or checkpoint system (e.g., Compound/Aave governance models).
        // For this contract, it returns the _voter's direct power (Essence + Chronoscore).
        return _getCurrentCombinedPower(_voter);
    }

    // 19. proposeCollectiveEvolution(uint256 _tokenId, uint8 _targetStage, uint256 _duration)
    function proposeCollectiveEvolution(
        uint256 _tokenId,
        uint8 _targetStage,
        uint256 _duration // Duration in seconds for voting
    ) public nonReentrant returns (uint256) {
        // Requires a certain threshold of effective vote power or Chronoscore to prevent spam
        uint256 proposerPower = getEffectiveVotePower(msg.sender);
        require(proposerPower >= 1000 * (10 ** decimals()) || _chronoscores[msg.sender] >= 100, "Insufficient power to propose");
        require(_exists(_tokenId), "Target ChronoScroll does not exist");
        require(_targetStage > uint8(bytes(_chronoScrolls[_tokenId].traits["evolutionStage"])[0] - 48), "Target stage must be higher than current");
        require(_duration > 0, "Voting duration must be positive");

        _proposalIdCounter.increment();
        uint256 newProposalId = _proposalIdCounter.current();

        proposals[newProposalId] = Proposal({
            description: string(abi.encodePacked("Propose collective evolution for Scroll ID ", Strings.toString(_tokenId), " to stage ", Strings.toString(_targetStage))),
            proposer: msg.sender,
            startTime: block.timestamp,
            endTime: block.timestamp.add(_duration),
            votesFor: 0,
            votesAgainst: 0,
            status: ProposalStatus.Active,
            targetTokenId: _tokenId,
            targetEvolutionStage: _targetStage,
            hasVoted: new mapping(address => bool) // Initialize the nested mapping
        });

        _updateChronoscoreInternal(msg.sender, 5); // Reward for proposing
        emit ProposalCreated(newProposalId, msg.sender);
        return newProposalId;
    }

    // 20. voteOnProposal(uint256 _proposalId, bool _support)
    function voteOnProposal(uint256 _proposalId, bool _support) public nonReentrant {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.proposer != address(0), "Proposal does not exist");
        require(proposal.status == ProposalStatus.Active, "Proposal not active (must be Pending or Active)");
        require(block.timestamp >= proposal.startTime && block.timestamp <= proposal.endTime, "Voting period is not active");
        require(!proposal.hasVoted[msg.sender], "Caller has already voted on this proposal");

        uint256 voterPower;
        // If the voter has delegated their power, their delegatee's power is used.
        // If not delegated, use their own effective power.
        address actualVoter = msg.sender;
        if (temporalDelegations[msg.sender].delegatee != address(0)) {
            actualVoter = temporalDelegations[msg.sender].delegatee;
            voterPower = _getEffectiveDelegatedPower(msg.sender); // Get power that was delegated
        } else {
            voterPower = getEffectiveVotePower(msg.sender); // Get direct power
        }
        
        require(voterPower > 0, "No effective vote power to cast a vote");

        if (_support) {
            proposal.votesFor = proposal.votesFor.add(voterPower);
        } else {
            proposal.votesAgainst = proposal.votesAgainst.add(voterPower);
        }
        proposal.hasVoted[msg.sender] = true;

        _updateChronoscoreInternal(msg.sender, 1); // Small reward for casting a vote
        emit VoteCast(_proposalId, msg.sender, _support, voterPower);
    }
    
    // 21. executeProposal(uint256 _proposalId)
    function executeProposal(uint256 _proposalId) public nonReentrant {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.proposer != address(0), "Proposal does not exist");
        require(proposal.status == ProposalStatus.Active, "Proposal is not active");
        require(block.timestamp > proposal.endTime, "Voting period has not ended yet"); // Must wait for voting to conclude

        if (proposal.votesFor > proposal.votesAgainst) {
            proposal.status = ProposalStatus.Succeeded;
            // Apply the proposed collective evolution
            ChronoScroll storage targetScroll = _chronoScrolls[proposal.targetTokenId];
            uint8 currentStage = uint8(bytes(targetScroll.traits["evolutionStage"])[0] - 48);
            if (proposal.targetEvolutionStage > currentStage) { // Only evolve if target is higher
                targetScroll.traits["evolutionStage"] = Strings.toString(proposal.targetEvolutionStage);
                targetScroll.baseEssenceAccrualRate = targetScroll.baseEssenceAccrualRate.add(2); // Boost for collective evolution
            }
             _updateChronoscoreInternal(proposal.proposer, 20); // Significant reward for successful proposal
        } else {
            proposal.status = ProposalStatus.Failed;
            _updateChronoscoreInternal(proposal.proposer, -10); // Penalty for failed proposal
        }
        emit ProposalExecuted(_proposalId, proposal.status);
    }


    // --- E. Chronoscore (Reputation System) ---

    // 22. getChronoscore(address _user)
    function getChronoscore(address _user) public view returns (int256) {
        return _chronoscores[_user];
    }

    // 23. _updateChronoscoreInternal(address _user, int256 _amount)
    // Internal function to adjust a user's Chronoscore.
    // This allows the contract to manage reputation based on in-ecosystem actions.
    function _updateChronoscoreInternal(address _user, int256 _amount) internal {
        int256 newScore = _chronoscores[_user] + _amount;
        // Set a floor for the Chronoscore to prevent excessively negative scores.
        // For example, a floor of -100 means it won't go below this point.
        if (newScore < -100) newScore = -100;
        _chronoscores[_user] = newScore;
        emit ChronoscoreUpdated(_user, newScore);
    }

    // --- F. Admin & Oracle Management ---

    // 24. setOracleAddress(address _newOracle)
    function setOracleAddress(address _newOracle) public onlyOwner notZeroAddress(_newOracle) {
        oracleAddress = _newOracle;
    }

    // 25. submitOracleData(bytes32 _dataHash, uint256 _timestamp, bytes memory _signature)
    // This function acts as the entry point for off-chain data from the oracle.
    // The _signature would typically be verified using `ecrecover` to ensure data authenticity.
    function submitOracleData(bytes32 _dataHash, uint256 _timestamp, bytes memory _signature) public onlyOracle {
        // In a real application, you'd verify the signature:
        // address signer = ECDSA.recover(keccak256(abi.encodePacked(_dataHash, _timestamp)), _signature);
        // require(signer == oracleAddress, "Invalid oracle signature");

        require(!processedOracleData[_dataHash], "Oracle data with this hash already processed");
        processedOracleData[_dataHash] = true;
        
        // This dataHash (and its off-chain content) could then be used for:
        // - Triggering specific narrative fragment approvals (conceptual AI output)
        // - Influencing quest conditions or outcomes
        // - Periodically updating scroll traits based on real-world events (e.g., weather, market data)
        emit OracleDataSubmitted(_dataHash, _timestamp);
    }

    // 26. updateGlobalEssenceAccrualRate(uint256 _newRate)
    function updateGlobalEssenceAccrualRate(uint256 _newRate) public onlyOwner {
        require(_newRate > 0, "Rate must be positive");
        globalEssenceAccrualRateFactor = _newRate;
        emit GlobalEssenceAccrualRateUpdated(_newRate);
    }

    // --- G. Utility/View Functions (ERC721Enumerable overrides) ---

    // 27. tokenURI(uint256 tokenId)
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        ChronoScroll storage scroll = _chronoScrolls[tokenId];

        // Construct a dynamic token URI. This URI would point to an off-chain JSON metadata file,
        // which itself would contain a reference to the image and other attributes.
        // By embedding traits in the URI, metadata can be dynamic without on-chain storage of JSON.
        string memory baseURI = "ipfs://QmbzG4H7YV5X2JkL9T8R0C1S6F3W4A5B6C7D8E9F0G1H2I3J4K5L6M7N8O9P0Q1R2S3T4U5V6W7X8Y9Z/"; // Example IPFS base URI
        string memory uri = string(abi.encodePacked(
            baseURI,
            Strings.toString(tokenId),
            ".json?theme=", scroll.traits["theme"],
            "&stage=", scroll.traits["evolutionStage"],
            "&aura=", scroll.traits["auraLevel"],
            "&claimedEssence=", Strings.toString(scroll.essenceClaimedTotal)
        ));
        return uri;
    }
}
```