Okay, let's design a complex and creative smart contract. We'll build a "Metaverse Forge" where users can own unique Land parcels, craft various Items and Resources from recipes, manage reputation, delegate rights, and participate in a basic reputation-based governance system.

This contract will combine aspects of ERC721 (for unique Land), ERC1155 (for fungible Resources/Items), complex state changes (crafting, upgrading), reputation tracking, and a simple on-chain governance mechanism.

**Outline and Function Summary: MetaverseForge**

This smart contract represents a core system for a decentralized Metaverse. It manages Land ownership (ERC721), Resource and Item ownership (ERC1155), crafting mechanics, land upgrades, user reputation, delegation of rights, and a basic on-chain governance system based on reputation.

**Key Concepts:**

1.  **Land:** Unique ERC721 tokens representing parcels within the Metaverse. Land can have attributes (type, level, resource production).
2.  **Items/Resources:** ERC1155 tokens used for crafting, upgrading land, or as collectibles. Can be fungible (resources) or non-fungible/limited supply (rare items).
3.  **Crafting:** A core mechanic where users consume input items/resources based on defined recipes to produce output items/resources.
4.  **Reputation:** An on-chain score reflecting a user's participation and success (e.g., successful crafting). Can influence governance power or other mechanics.
5.  **Delegation:** Users can delegate specific rights (like managing their land or voting power) to other users.
6.  **Governance:** A simple system where users with sufficient reputation can propose new crafting recipes and vote on them.

---

**Function Summary (25+ functions):**

**Core Standard Implementations (Built upon OpenZeppelin for safety):**

1.  `constructor()`: Initializes the contract with owner, ERC721/ERC1155 names/symbols/URIs.
2.  `supportsInterface(bytes4 interfaceId)`: Standard ERC165 for interface detection.
3.  `tokenURI(uint256 tokenId)`: Returns metadata URI for Land (ERC721). Dynamic placeholder.
4.  `uri(uint256 id)`: Returns metadata URI for Items/Resources (ERC1155). Dynamic placeholder.
5.  `balanceOf(address account, uint256 id)`: Standard ERC1155 function.
6.  `balanceOfBatch(address[] accounts, uint256[] ids)`: Standard ERC1155 function.
7.  `setApprovalForAll(address operator, bool approved)`: Standard ERC1155 function.
8.  `isApprovedForAll(address account, address operator)`: Standard ERC1155 function.
9.  `safeTransferFrom(address from, address to, uint256 tokenId)`: Standard ERC721 function.
10. `safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)`: Standard ERC1155 function (single).
11. `safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)`: Standard ERC1155 function (batch).

**Admin/Setup Functions (Restricted Access):**

12. `pause()`: Pauses contract interactions (crafting, claiming, upgrading, voting).
13. `unpause()`: Unpauses the contract.
14. `addAdmin(address account)`: Grants admin role (can add recipes, mint initial items/land, etc.).
15. `removeAdmin(address account)`: Revokes admin role.
16. `createItemType(uint256 itemId, string memory itemURI, bool isFungible)`: Defines a new ERC1155 item/resource type and its properties.
17. `mintLand(address recipient, uint256 landId, uint256 landType)`: Mints a new ERC721 land parcel to a recipient with a specific type. (Admin only for initial minting).
18. `mintItems(address recipient, uint256 itemId, uint256 amount)`: Mints a specific amount of an ERC1155 item/resource. (Admin only for initial supply).

**User Interaction Functions:**

19. `craftItem(uint256 recipeId)`: Executes a crafting recipe, consuming inputs and minting outputs. Updates user reputation.
20. `upgradeLand(uint256 landId, uint256 upgradeType)`: Upgrades a land parcel, potentially consuming items/resources and changing land attributes. Requires land ownership or management delegation. Updates user reputation.
21. `claimPassiveResources(uint256 landId)`: Allows land owner/manager to claim resources passively generated by land over time (based on land type/level and time since last claim).
22. `delegateLandManagement(uint256 landId, address delegatee)`: Allows land owner to delegate land upgrade/claim rights to another address.
23. `revokeLandManagementDelegation(uint256 landId)`: Revokes land management delegation.
24. `delegateVotingPower(address delegatee)`: Allows a user to delegate their reputation-based voting power for governance proposals.
25. `revokeVotingPowerDelegation()`: Revokes voting power delegation.

**Query/Getter Functions:**

26. `getLandAttributes(uint256 landId)`: Retrieves the current attributes of a specific land parcel (type, level, lastClaimTimestamp).
27. `getItemAttributes(uint256 itemId)`: Retrieves the defined attributes of an item type (isFungible).
28. `getRecipe(uint256 recipeId)`: Retrieves details of a crafting recipe (inputs, outputs).
29. `getUserReputation(address account)`: Retrieves a user's current reputation score.
30. `getLandManager(uint256 landId)`: Returns the address delegated to manage a land parcel, if any.
31. `getVotingDelegatee(address account)`: Returns the address a user has delegated their voting power to, if any.

**Governance Functions (Reputation-based):**

32. `submitRecipeProposal(uint256 proposalId, Recipe memory recipe, string memory description)`: Allows users with minimum reputation to propose adding a new crafting recipe.
33. `voteOnProposal(uint256 proposalId, bool support)`: Allows users (or their delegatees) with reputation to vote on an active recipe proposal.
34. `executeProposal(uint256 proposalId)`: Executes a proposal if it has passed its voting period and met quorum/threshold based on reputation. Adds the new recipe.
35. `getProposalState(uint256 proposalId)`: Returns the current state of a proposal (Pending, Active, Succeeded, Failed, Executed).
36. `getProposalVoteCounts(uint256 proposalId)`: Returns the current vote counts (support, against) for a proposal.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"; // For dynamic token URI, though we'll make it abstract
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol"; // For dynamic token URI, though we'll make it abstract
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

// Outline and Function Summary is provided at the top of this file.

contract MetaverseForge is ERC721, ERC1155, Ownable, Pausable {
    using EnumerableSet for EnumerableSet.AddressSet;

    // --- State Variables ---

    // ERC721: Land
    uint256 public nextLandId; // Counter for unique land IDs
    mapping(uint256 => LandAttributes) private landAttributes;
    mapping(uint256 => address) private landManagers; // Delegation: landId => delegatee

    struct LandAttributes {
        uint256 landType; // e.g., 1=Forest, 2=Mountain, 3=Field
        uint256 level; // e.g., 1-5, determines production rate
        uint48 lastClaimTimestamp; // Timestamp of last resource claim
    }

    // ERC1155: Items & Resources
    mapping(uint256 => ItemAttributes) private itemAttributes; // itemId => attributes

    struct ItemAttributes {
        bool isFungible; // true for resources, false for unique items
        string itemURI; // Base URI for the item type
    }
    uint256 public nextItemId = 1000; // Start item IDs higher to avoid conflict with potential future standard IDs

    // Crafting Recipes
    mapping(uint256 => Recipe) private recipes; // recipeId => recipe details
    EnumerableSet.UintSet private availableRecipeIds; // Keep track of active recipes

    struct Recipe {
        uint256[] inputItemIds;
        uint256[] inputAmounts;
        uint256[] outputItemIds;
        uint256[] outputAmounts;
        uint256 requiredReputation; // Minimum reputation to craft
        bool active; // Can this recipe be used?
    }
    uint256 public nextRecipeId; // Counter for unique recipe IDs

    // User Reputation
    mapping(address => uint256) private userReputation; // user => reputation score
    mapping(address => address) private votingDelegates; // user => delegatee for governance votes

    // Governance (Simple Reputation-Based)
    mapping(uint256 => Proposal) private proposals; // proposalId => proposal details
    uint256 public nextProposalId; // Counter for unique proposal IDs
    uint256 public proposalVotingPeriod = 7 days; // Default voting period
    uint256 public minReputationToPropose = 10; // Min reputation required to create proposal
    uint256 public minReputationToVote = 1; // Min reputation required to vote
    uint256 public proposalQuorumRate = 50; // Percentage of total reputation needed for quorum (e.g., 50 for 50%)
    uint256 public proposalApprovalRate = 60; // Percentage of *participating* reputation needed for approval (e.g., 60 for 60%)

    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Failed,
        Executed
    }

    struct Proposal {
        Recipe recipe; // The recipe proposed
        string description; // Short description of the proposal
        uint48 startTimestamp;
        uint48 endTimestamp;
        uint256 totalReputationAtProposal; // Total reputation when proposal was created (for quorum)
        uint256 supportReputation; // Total reputation of supporting voters
        uint256 againstReputation; // Total reputation of opposing voters
        EnumerableSet.AddressSet voters; // Set of addresses who voted
        ProposalState state;
    }

    // Admin Roles
    EnumerableSet.AddressSet private admins;

    // --- Events ---

    event LandMinted(uint256 indexed landId, address indexed owner, uint256 landType);
    event LandUpgraded(uint256 indexed landId, address indexed account, uint256 newLevel);
    event ResourcesClaimed(uint256 indexed landId, address indexed account, uint256[] itemIds, uint256[] amounts);
    event LandManagementDelegated(uint256 indexed landId, address indexed owner, address indexed delegatee);
    event LandManagementRevoked(uint256 indexed landId, address indexed owner, address indexed delegatee);

    event ItemTypeCreated(uint256 indexed itemId, bool isFungible, string itemURI);
    event ItemsMinted(uint256 indexed itemId, address indexed recipient, uint256 amount);
    event ItemsBurned(uint256 indexed itemId, address indexed account, uint256 amount);

    event RecipeAdded(uint256 indexed recipeId);
    event RecipeRemoved(uint256 indexed recipeId);
    event ItemCrafted(uint256 indexed recipeId, address indexed crafter, uint256[] outputItemIds, uint256[] outputAmounts);

    event ReputationUpdated(address indexed account, uint256 newReputation);
    event VotingPowerDelegated(address indexed delegator, address indexed delegatee);
    event VotingPowerRevoked(address indexed account);

    event ProposalSubmitted(uint256 indexed proposalId, address indexed proposer, string description);
    event Voted(uint256 indexed proposalId, address indexed voter, bool support, uint256 reputationWeight);
    event ProposalStateChanged(uint256 indexed proposalId, ProposalState newState);

    event AdminAdded(address indexed account);
    event AdminRemoved(address indexed account);

    // --- Modifiers ---

    modifier onlyAdmin() {
        require(admins.contains(_msgSender()) || owner() == _msgSender(), "MF: Not an admin");
        _;
    }

    modifier onlyLandOwnerOrManager(uint256 landId) {
        require(_isLandOwnerOrManager(_msgSender(), landId), "MF: Not land owner or manager");
        _;
    }

    modifier whenNotPausedOrExceptional() {
        // Allows certain core functions even when paused, e.g., admin controls, querying state.
        // Add specific checks if needed, but for now, basic `whenNotPaused` is sufficient for *most* user actions.
        whenNotPaused();
        _;
    }

    // --- Constructor ---

    constructor(string memory name, string memory symbol, string memory landBaseURI, string memory itemBaseURI)
        ERC721(name, symbol)
        ERC1155(itemBaseURI) // Initial ERC1155 URI, can be overridden per item type
        Ownable(_msgSender())
    {
        // Grant deployer admin role
        admins.add(_msgSender());
        emit AdminAdded(_msgSender());

        // Set base URIs (can be dynamic or point to a server)
        _setLandBaseURI(landBaseURI); // Custom internal function below
        _setBaseURI(itemBaseURI); // Standard ERC1155 function
    }

    // --- Admin Functions ---

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function addAdmin(address account) external onlyOwner {
        require(account != address(0), "MF: Zero address");
        require(!admins.contains(account), "MF: Already admin");
        admins.add(account);
        emit AdminAdded(account);
    }

    function removeAdmin(address account) external onlyOwner {
        require(account != _msgSender(), "MF: Cannot remove yourself");
        require(admins.contains(account), "MF: Not an admin");
        admins.remove(account);
        emit AdminRemoved(account);
    }

    function isAdmin(address account) public view returns (bool) {
        return admins.contains(account);
    }

    function createItemType(uint256 itemId, string memory __itemURI, bool isFungible) external onlyAdmin {
        require(itemAttributes[itemId].itemURI.length == 0, "MF: Item type already exists");
        require(itemId >= nextItemId, "MF: Item ID must be >= nextItemId"); // Prevent re-using lower IDs
        itemAttributes[itemId] = ItemAttributes({
            isFungible: isFungible,
            itemURI: __itemURI
        });
        if (itemId >= nextItemId) {
            nextItemId = itemId + 1; // Auto-increment nextItemId if a higher one is used
        }
        emit ItemTypeCreated(itemId, isFungible, __itemURI);
    }

    function mintLand(address recipient, uint256 landType) external onlyAdmin {
        require(recipient != address(0), "MF: Zero address");
        uint256 landId = nextLandId++;
        _safeMint(recipient, landId);
        landAttributes[landId] = LandAttributes({
            landType: landType,
            level: 1, // Start at level 1
            lastClaimTimestamp: uint48(block.timestamp) // Set initial claim time
        });
        emit LandMinted(landId, recipient, landType);
    }

    function mintItems(address recipient, uint256 itemId, uint256 amount) external onlyAdmin {
        require(recipient != address(0), "MF: Zero address");
        require(itemAttributes[itemId].itemURI.length > 0, "MF: Item type not defined");
        _mint(recipient, itemId, amount, "");
        emit ItemsMinted(itemId, recipient, amount);
    }

    // --- ERC721 Overrides & Extensions ---

    // Custom internal function to set the base URI for land tokens
    function _setLandBaseURI(string memory baseURI_) internal {
        // In a real scenario, ERC721URIStorage would handle this better.
        // For this example, we just note it. A simple implementation
        // would concatenate this base URI with the token ID in tokenURI.
        // baseURI = baseURI_; // Placeholder
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        // Ensure token exists (ERC721 handles this)
        // Retrieve land attributes to potentially build a dynamic URI
        LandAttributes storage attrs = landAttributes[tokenId];
        // Example: return concatenate(baseURI, tokenId.toString(), "/", attrs.landType.toString(), "/", attrs.level.toString())
        // For simplicity, return a placeholder + ID
        return string(abi.encodePacked("ipfs://metaverse-forge/land/", Strings.toString(tokenId)));
    }

    // --- ERC1155 Overrides & Extensions ---

    // We override uri to potentially provide item-specific URIs
    function uri(uint256 id) public view override returns (string memory) {
        ItemAttributes storage attrs = itemAttributes[id];
        if (bytes(attrs.itemURI).length > 0) {
            return attrs.itemURI;
        }
        // Fallback to the base URI set in the constructor if no specific URI for the item type
        return super.uri(id);
    }

    // --- Core Mechanics: Crafting ---

    function addRecipe(Recipe memory recipe) internal onlyAdmin {
        // Internal function primarily called by governance, can be called by admin directly too
        uint256 recipeId = nextRecipeId++;
        recipes[recipeId] = recipe;
        recipes[recipeId].active = true; // Mark as active immediately if added by admin
        availableRecipeIds.add(recipeId);
        emit RecipeAdded(recipeId);
    }

    function removeRecipe(uint256 recipeId) external onlyAdmin {
        require(recipes[recipeId].active, "MF: Recipe not active");
        recipes[recipeId].active = false;
        availableRecipeIds.remove(recipeId);
        emit RecipeRemoved(recipeId);
    }

    function craftItem(uint256 recipeId) external whenNotPaused {
        Recipe storage recipe = recipes[recipeId];
        require(recipe.active, "MF: Recipe not active");
        require(userReputation[_msgSender()] >= recipe.requiredReputation, "MF: Not enough reputation");

        // Check inputs and burn them
        for (uint i = 0; i < recipe.inputItemIds.length; i++) {
            uint256 inputId = recipe.inputItemIds[i];
            uint256 requiredAmount = recipe.inputAmounts[i];
            require(balanceOf(_msgSender(), inputId) >= requiredAmount, "MF: Not enough input items");
            _burn(_msgSender(), inputId, requiredAmount);
            emit ItemsBurned(inputId, _msgSender(), requiredAmount);
        }

        // Mint outputs
        for (uint i = 0; i < recipe.outputItemIds.length; i++) {
            uint256 outputId = recipe.outputItemIds[i];
            uint256 amount = recipe.outputAmounts[i];
            require(itemAttributes[outputId].itemURI.length > 0, "MF: Output item type not defined");
            _mint(_msgSender(), outputId, amount, "");
            emit ItemsMinted(outputId, _msgSender(), amount);
        }

        // Update reputation based on successful craft
        _updateReputation(_msgSender(), 1); // Gain 1 reputation per successful craft
        emit ItemCrafted(recipeId, _msgSender(), recipe.outputItemIds, recipe.outputAmounts);
    }

    function getRecipe(uint256 recipeId) public view returns (Recipe memory) {
        require(recipes[recipeId].active, "MF: Recipe not active"); // Only return active recipes via this getter
        return recipes[recipeId];
    }

    function listAvailableRecipes() public view returns (uint256[] memory) {
        uint256[] memory ids = new uint256[](availableRecipeIds.length());
        for (uint i = 0; i < availableRecipeIds.length(); i++) {
            ids[i] = availableRecipeIds.at(i);
        }
        return ids;
    }

    // --- Core Mechanics: Land ---

    function upgradeLand(uint256 landId, uint256 upgradeType) external whenNotPaused onlyLandOwnerOrManager(landId) {
        // Placeholder logic for upgrade. In a real contract, upgradeType would map to a specific recipe/cost.
        // Requires consuming items, time lock, etc.
        // Example: Upgrade Type 1 -> requires 10x Wood (ID 1001), 5x Stone (ID 1002)
        require(_exists(landId), "MF: Land does not exist");
        // Check if land is already max level (e.g., level 5)
        require(landAttributes[landId].level < 5, "MF: Land already at max level");

        // Simulate cost and time
        // require enough items... burn items...
        // require time since last upgrade...
        // landAttributes[landId].level++; // Increment level

        // *** Simplified Example Implementation: Just increments level and reputation ***
        landAttributes[landId].level++;
        _updateReputation(_msgSender(), 2); // Gain 2 reputation for upgrading
        emit LandUpgraded(landId, _msgSender(), landAttributes[landId].level);
    }

    function claimPassiveResources(uint256 landId) external whenNotPaused onlyLandOwnerOrManager(landId) {
        require(_exists(landId), "MF: Land does not exist");
        LandAttributes storage attrs = landAttributes[landId];
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - attrs.lastClaimTimestamp;

        // Placeholder logic for resource generation
        // Based on landType and level, calculate resources generated over timeElapsed
        uint256[] memory claimedItemIds = new uint256[](1); // Example: only one type of resource
        uint256[] memory claimedAmounts = new uint256[](1);

        // Example: Forest (type 1) produces Wood (ID 1001) based on level and time
        if (attrs.landType == 1 && timeElapsed > 0) {
            uint256 woodAmount = (timeElapsed / 3600) * attrs.level; // 1 Wood/hour per level
            if (woodAmount > 0) {
                 // Ensure Wood item type exists (ID 1001) - would be created by admin setup
                 if(itemAttributes[1001].itemURI.length > 0 && itemAttributes[1001].isFungible) {
                     claimedItemIds[0] = 1001;
                     claimedAmounts[0] = woodAmount;
                     _mint(_msgSender(), 1001, woodAmount, "");
                     attrs.lastClaimTimestamp = uint48(currentTime); // Update claim time
                     emit ResourcesClaimed(landId, _msgSender(), claimedItemIds, claimedAmounts);
                 }
            }
        } else {
             // No resources claimed
             claimedItemIds = new uint256[](0);
             claimedAmounts = new uint256[](0);
        }

         if (claimedAmounts.length > 0 && claimedAmounts[0] > 0) {
             // Optionally update reputation for claiming
             _updateReputation(_msgSender(), 1); // Gain 1 reputation for claiming
         }
    }


    function delegateLandManagement(uint256 landId, address delegatee) external whenNotPaused {
        require(_exists(landId), "MF: Land does not exist");
        require(ownerOf(landId) == _msgSender(), "MF: Not land owner");
        require(delegatee != address(0), "MF: Cannot delegate to zero address");
        require(delegatee != _msgSender(), "MF: Cannot delegate to yourself");
        landManagers[landId] = delegatee;
        emit LandManagementDelegated(landId, _msgSender(), delegatee);
    }

    function revokeLandManagementDelegation(uint256 landId) external whenNotPaused {
        require(_exists(landId), "MF: Land does not exist");
        require(ownerOf(landId) == _msgSender(), "MF: Not land owner");
        require(landManagers[landId] != address(0), "MF: No delegation exists");
        address delegatee = landManagers[landId];
        delete landManagers[landId];
        emit LandManagementRevoked(landId, _msgSender(), delegatee);
    }

    // --- Core Mechanics: Reputation ---

    function _updateReputation(address account, uint256 amount) internal {
        // Internal function to add reputation
        userReputation[account] += amount;
        emit ReputationUpdated(account, userReputation[account]);
    }

    function getUserReputation(address account) public view returns (uint256) {
        return userReputation[account];
    }

    function delegateVotingPower(address delegatee) external whenNotPaused {
        require(delegatee != address(0), "MF: Cannot delegate to zero address");
        require(delegatee != _msgSender(), "MF: Cannot delegate to yourself");
        votingDelegates[_msgSender()] = delegatee;
        emit VotingPowerDelegated(_msgSender(), delegatee);
    }

    function revokeVotingPowerDelegation() external whenNotPaused {
        require(votingDelegates[_msgSender()] != address(0), "MF: No delegation exists");
        address delegatee = votingDelegates[_msgSender()];
        delete votingDelegates[_msgSender()];
        emit VotingPowerRevoked(_msgSender());
    }

    function getVotingDelegatee(address account) public view returns (address) {
        return votingDelegates[account];
    }

    function _getEffectiveVoter(address account) internal view returns (address) {
         address delegatee = votingDelegates[account];
         // Return delegatee if set, otherwise return self. Handle delegation chains if needed (not implemented here)
         return delegatee == address(0) ? account : delegatee;
    }


    // --- Governance Functions ---

    function submitRecipeProposal(uint256 proposalId, Recipe memory recipe, string memory description) external whenNotPaused {
        require(userReputation[_msgSender()] >= minReputationToPropose, "MF: Not enough reputation to propose");
        require(proposals[proposalId].state == ProposalState.Pending, "MF: Proposal ID already exists or is not in Pending state");
        require(recipe.outputItemIds.length > 0, "MF: Recipe must have outputs");
        // Basic checks on recipe inputs/outputs (e.g., item types must exist)
         for (uint i = 0; i < recipe.inputItemIds.length; i++) {
             require(itemAttributes[recipe.inputItemIds[i]].itemURI.length > 0, "MF: Input item type not defined");
         }
         for (uint i = 0; i < recipe.outputItemIds.length; i++) {
             require(itemAttributes[recipe.outputItemIds[i]].itemURI.length > 0, "MF: Output item type not defined");
         }


        uint256 totalRep = _getTotalReputation(); // Snapshot total reputation for quorum check
        require(totalRep > 0, "MF: Cannot propose with zero total reputation in the system"); // Avoid division by zero

        proposals[proposalId] = Proposal({
            recipe: recipe,
            description: description,
            startTimestamp: uint48(block.timestamp),
            endTimestamp: uint48(block.timestamp + proposalVotingPeriod),
            totalReputationAtProposal: totalRep,
            supportReputation: 0,
            againstReputation: 0,
            voters: EnumerableSet.AddressSet(0), // Initialize set
            state: ProposalState.Active
        });

        if (proposalId >= nextProposalId) {
             nextProposalId = proposalId + 1; // Auto-increment if a higher ID is used
         } else {
             nextProposalId++; // Standard increment
         }

        emit ProposalSubmitted(proposalId, _msgSender(), description);
        emit ProposalStateChanged(proposalId, ProposalState.Active);
    }

    function voteOnProposal(uint256 proposalId, bool support) external whenNotPaused {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "MF: Proposal not active");
        require(block.timestamp <= proposal.endTimestamp, "MF: Voting period has ended");

        address voter = _msgSender();
        address effectiveVoter = _getEffectiveVoter(voter); // Use delegated voting power

        require(!proposal.voters.contains(effectiveVoter), "MF: Voter already voted");
        require(userReputation[effectiveVoter] >= minReputationToVote, "MF: Not enough reputation to vote");

        uint256 reputationWeight = userReputation[effectiveVoter];
        require(reputationWeight > 0, "MF: Voter must have > 0 reputation to vote");

        proposal.voters.add(effectiveVoter);

        if (support) {
            proposal.supportReputation += reputationWeight;
        } else {
            proposal.againstReputation += reputationWeight;
        }

        emit Voted(proposalId, voter, support, reputationWeight);
    }

    function executeProposal(uint256 proposalId) external whenNotPaused {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == ProposalState.Active, "MF: Proposal not active");
        require(block.timestamp > proposal.endTimestamp, "MF: Voting period not ended");

        uint256 totalVotesReputation = proposal.supportReputation + proposal.againstReputation;

        // Check Quorum: total reputation voting >= QuorumRate of total reputation at proposal time
        // Avoid division by zero if totalReputationAtProposal was 0 (though check in submit handles this)
        bool passedQuorum = proposal.totalReputationAtProposal > 0 &&
                            (totalVotesReputation * 100) >= (proposal.totalReputationAtProposal * proposalQuorumRate);

        // Check Approval: support reputation >= ApprovalRate of total votes reputation
        // Avoid division by zero if totalVotesReputation was 0
        bool passedApproval = totalVotesReputation > 0 &&
                              (proposal.supportReputation * 100) >= (totalVotesReputation * proposalApprovalRate);

        if (passedQuorum && passedApproval) {
            proposal.state = ProposalState.Succeeded;
            emit ProposalStateChanged(proposalId, ProposalState.Succeeded);

            // Add the recipe if successful
            uint256 newRecipeId = nextRecipeId++;
            recipes[newRecipeId] = proposal.recipe;
            recipes[newRecipeId].active = true; // Mark as active
            availableRecipeIds.add(newRecipeId);

             // Clear the recipe from the proposal struct to save gas/storage after execution
            delete proposal.recipe;

            proposal.state = ProposalState.Executed;
            emit RecipeAdded(newRecipeId);
            emit ProposalStateChanged(proposalId, ProposalState.Executed);

        } else {
            proposal.state = ProposalState.Failed;
            emit ProposalStateChanged(proposalId, ProposalState.Failed);
        }
    }

    function getProposalState(uint256 proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[proposalId];
        if (proposal.state == ProposalState.Active && block.timestamp > proposal.endTimestamp) {
            // Automatically transition state if voting period ended and not executed
            // This view function doesn't modify state, the actual transition happens on executeProposal
            return ProposalState.Failed; // Assume failed if not executed after end time
        }
        return proposal.state;
    }

    function getProposalVoteCounts(uint256 proposalId) public view returns (uint256 support, uint256 against, uint256 totalReputationAtProposal) {
         Proposal storage proposal = proposals[proposalId];
         return (proposal.supportReputation, proposal.againstReputation, proposal.totalReputationAtProposal);
    }


    function _getTotalReputation() internal view returns (uint256) {
         // This is a simplified way to get total reputation.
         // In a real DAO, you might snapshot reputation or use a dedicated token for voting power.
         // Iterating over all users is not gas-efficient for a large user base.
         // For this example, let's assume a limited set or use a more efficient method
         // like tracking total reputation during updates or using a dedicated voting token.
         // *** WARNING: Iterating through all possible addresses is NOT feasible on-chain. ***
         // This function is a placeholder. A real implementation needs a different mechanism.
         // For the sake of *this example* demonstrating the concept, we'll return 1000
         // as a placeholder for "total reputation in the system".
         // A robust solution would track this or use a different voting mechanism (e.g., token).
         return 1000; // <-- PLACEHOLDER: Replace with actual total reputation tracking/snapshotting
    }


    // --- Query Functions (Land & Items) ---

    function getLandAttributes(uint256 landId) public view returns (uint256 landType, uint256 level, uint48 lastClaimTimestamp) {
        require(_exists(landId), "MF: Land does not exist");
        LandAttributes storage attrs = landAttributes[landId];
        return (attrs.landType, attrs.level, attrs.lastClaimTimestamp);
    }

     function getItemAttributes(uint256 itemId) public view returns (bool isFungible, string memory __itemURI) {
         ItemAttributes storage attrs = itemAttributes[itemId];
         require(bytes(attrs.itemURI).length > 0, "MF: Item type not defined");
         return (attrs.isFungible, attrs.itemURI);
     }

     function getLandManager(uint256 landId) public view returns (address) {
        require(_exists(landId), "MF: Land does not exist");
        return landManagers[landId];
     }

    // --- Internal Helper Functions ---

    function _isLandOwnerOrManager(address account, uint256 landId) internal view returns (bool) {
        return ownerOf(landId) == account || landManagers[landId] == account;
    }

    // Override ERC721 _beforeTokenTransfer to potentially add hooks
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override(ERC721, ERC1155) {
        // If a land token is transferred, clear any management delegation
        if (batchSize == 0) { // Indicates ERC721 transfer
             if(landManagers[tokenId] != address(0)) {
                 address delegatee = landManagers[tokenId];
                 delete landManagers[tokenId];
                 emit LandManagementRevoked(tokenId, from, delegatee); // Emit event for the old owner
             }
        }
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }

     // Override ERC1155 _beforeTokenTransfer to potentially add hooks
    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal virtual override(ERC1155)
    {
         // Add any ERC1155 specific hooks here if needed before transfer
         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }

    // Need to override supportsInterface to support both ERC721 and ERC1155
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC1155) returns (bool) {
        return ERC721.supportsInterface(interfaceId) || ERC1155.supportsInterface(interfaceId);
    }

    // ERC721 standard requires _beforeTokenTransfer with different signature.
    // ERC1155 standard requires _beforeTokenTransfer with different signature.
    // We need to resolve the ambiguity by explicitly overriding and calling the base implementations.
    // The ERC721 _beforeTokenTransfer override above handles this by checking batchSize == 0.
    // The ERC1155 _beforeTokenTransfer override above handles this for batch and single transfers.
    // This setup allows both standards to coexist by carefully routing the single function call.

}
```

**Explanation of Advanced/Creative Concepts Used:**

1.  **Hybrid Token Standard (ERC721 + ERC1155):** The contract manages both unique Land parcels (ERC721) and fungible/non-fungible Items/Resources (ERC1155) within a single contract. This is more gas-efficient and complex than deploying separate contracts for each.
2.  **Dynamic Metadata (Conceptual):** The `tokenURI` (Land) and `uri` (Items/Resources) functions are designed to *potentially* return URIs based on the token's current state (e.g., land level, item attributes). While the example returns simple static-looking URIs, the structure allows for an off-chain service to serve dynamic JSON metadata based on the on-chain attributes retrieved by the URI.
3.  **Complex State Changes (Crafting & Upgrading):** These functions (`craftItem`, `upgradeLand`) involve consuming multiple inputs (burning tokens) and producing multiple outputs (minting tokens), coupled with updating specific attributes of other tokens (land level) or the user's state (reputation). This is more complex than simple token transfers.
4.  **Reputation System:** An on-chain integer `userReputation` is maintained and updated based on successful actions (crafting, upgrading, claiming resources). This introduces a non-transferable, accumulated value tied to participation (similar in *concept* to Soulbound Tokens, though implemented simply here as an integer score).
5.  **Delegation of Rights:**
    *   **Land Management:** Owners can delegate the *specific* right to manage (upgrade, claim resources) their land to another address without transferring ownership.
    *   **Voting Power:** Users can delegate their reputation-based voting power to another address for governance. This allows for proxy voting.
6.  **Reputation-Based On-Chain Governance:** A simple DAO structure is implemented:
    *   Proposals can be submitted by users meeting a reputation threshold.
    *   Voting power is based on reputation (or delegated reputation).
    *   Proposal execution requires passing quorum and approval thresholds calculated based on the reputation weighted votes.
7.  **Enumerable Sets:** Used for tracking admin addresses and active recipe IDs efficiently, allowing for iteration (though iterating *all* users for total reputation snapshot is highlighted as a limitation in the example).
8.  **Pausable with Caveats:** The `Pausable` pattern is used for safety, allowing the owner to pause critical actions.

This contract goes beyond standard token implementations by adding layered mechanics for asset interaction, progression, social coordination (delegation), and decentralized decision-making, all integrated within a single system. The reputation system influencing governance and actions adds a unique layer compared to simple token-weighted voting. The delegation features offer practical utility for users.