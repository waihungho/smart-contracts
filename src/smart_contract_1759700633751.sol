This smart contract, named **AetheriumCore**, is designed to be the central hub for a self-evolving, AI-assisted protocol. Its core innovation lies in enabling a decentralized autonomous organization (DAO) to govern the integration of AI-generated "Architectural Fragments" that modify the protocol's functionality and parameters over time.

---

## AetheriumCore: The Self-Evolving Protocol for Decentralized Generative Architectures

**Author:** (Simulated for this exercise)

**Notice:** This contract introduces a novel mechanism for an on-chain protocol to evolve through a cycle involving community proposals, off-chain AI interpretation, and DAO-led crystallization of new features or parameter adjustments. It leverages advanced concepts like upgradeable proxies (UUPS), granular access control (ERC-742), and a modular architecture to ensure flexibility and future-proofing. The "AI" interaction is simulated via an oracle pattern, where an off-chain AI service submits its structured output back to the contract.

---

### Outline and Function Summary

**I. Core System Setup & Access Control**
1.  **`initialize(address _initialOwner, address _daoTokenAddress)`**: UUPS initializer. Sets up initial roles (Admin, Pauser, Oracle) and the Aetherium Council (DAO) token address.
2.  **`_authorizeUpgrade(address newImplementation)`**: Internal UUPS hook. Restricts contract upgrades to `DAO_GOVERNOR_ROLE` only.
3.  **`setGovernanceToken(address _daoTokenAddress)`**: Allows the `DAO_GOVERNOR_ROLE` to update the address of the Aetherium Council (DAO) token.
4.  **`pauseSystem()`**: Pauses certain critical functions, callable by the `PAUSER_ROLE`.
5.  **`unpauseSystem()`**: Unpauses the system, callable by the `PAUSER_ROLE`.
6.  **`withdrawProtocolFees(address _token, address _to, uint256 _amount)`**: Allows `DAO_GOVERNOR_ROLE` to withdraw accumulated fees (e.g., from blueprint stakes) in a specific ERC20 token to a specified address.

**II. Blueprint Submission & Lifecycle**
7.  **`submitBlueprint(string calldata _blueprintHash, string calldata _metadataURI, uint256 _stakeAmount)`**: Allows an "Architect" (user) to submit a new idea or specification ("Blueprint"). This requires staking a minimum amount of the DAO token. The blueprint content is off-chain (referenced by `_blueprintHash` and `_metadataURI`).
8.  **`cancelBlueprint(uint256 _blueprintId)`**: Allows an Architect to cancel their own blueprint if it's still in the `Pending` state, refunding their staked tokens.
9.  **`getBlueprintDetails(uint256 _blueprintId)`**: View function to retrieve all details of a specific blueprint.

**III. AI Oracle Interaction (Off-chain Triggered)**
10. **`requestFragmentGeneration(uint256 _blueprintId)`**: Initiates the off-chain AI interpretation process for a `Pending` blueprint. Callable only by the `ORACLE_ROLE`, it emits an event for off-chain AI services to pick up.
11. **`submitGeneratedFragment(uint256 _blueprintId, bytes32 _fragmentHash, string calldata _fragmentURI, uint256 _aiCost)`**: Called by the `ORACLE_ROLE` (the AI Oracle) to submit the structured output ("Architectural Fragment") generated by the AI for a given blueprint. It also records the AI's operational cost and pays a fixed `fragmentGenerationFee`.
12. **`rejectFragmentGeneration(uint256 _blueprintId, string calldata _reason)`**: Allows the `ORACLE_ROLE` to reject a blueprint for AI processing, e.g., if it's malformed or unsafe.

**IV. Aetherium Council (DAO) Governance & Voting**
13. **`proposeCrystallization(uint256 _blueprintId, bytes calldata _crystallizationPayload)`**: A `DAO_GOVERNOR_ROLE` member proposes to "crystallize" (apply) an AI-generated fragment. The `_crystallizationPayload` contains the encoded instructions for how the fragment should modify the system.
14. **`voteOnProposal(uint256 _proposalId, bool _support)`**: Aetherium Council token holders can vote 'for' or 'against' active crystallization proposals, using their DAO token voting power.
15. **`executeProposal(uint256 _proposalId)`**: After a proposal has passed its voting period, garnered enough 'for' votes, and cleared an `executionDelay`, a `DAO_GOVERNOR_ROLE` member can execute it, triggering the actual system modification.
16. **`_checkProposalState(uint256 _proposalId)`**: Internal function to evaluate a proposal's state (Active, Succeeded, Failed) based on voting period, votes, and quorum.

**V. Crystallization (System Modification)**
17. **`_crystallizeFragment(uint256 _blueprintId, bytes calldata _crystallizationPayload)`**: An internal, core function called during proposal execution. It parses the `_crystallizationPayload` and dispatches calls to other internal functions or registered modules to enact the changes defined by the AI-generated fragment. This is where the protocol "evolves."
18. **`_updateModuleConfiguration(uint256 _moduleId, bytes calldata _newConfigData)`**: Internal function, callable only via `_crystallizeFragment`, to update the flexible configuration bytes of an existing, registered module.
19. **`_registerNewModule(address _moduleAddress, bytes4 _interfaceId, string calldata _name)`**: Internal function, callable only via `_crystallizeFragment`, to onboard a new functional module contract into the Aetherium ecosystem. The module must implement a specific interface (e.g., `IAetheriumModule`).
20. **`_deactivateModule(uint256 _moduleId)`**: Internal function, callable only via `_crystallizeFragment`, to logically disable a previously registered module.

**VI. Reputation & Rewards**
21. **`claimBlueprintStake(uint256 _blueprintId)`**: Allows an Architect to reclaim their initial DAO token stake for a blueprint that has been successfully `Crystallized`.
22. **`distributeArchitectReward(address _architect, uint256 _amount)`**: Allows `DAO_GOVERNOR_ROLE` to explicitly send a reward (in DAO tokens) from the protocol's balance to an Architect.
23. **`penalizeArchitect(address _architect, uint256 _amount)`**: Allows `DAO_GOVERNOR_ROLE` to penalize an Architect, for instance, by reducing their reputation score. (In a more complex system, this could involve slashing staked tokens).
24. **`updateArchitectReputation(address _architect, int252 _delta)`**: Allows `DAO_GOVERNOR_ROLE` to adjust an Architect's on-chain reputation score, which could influence future interactions or privileges.

**VII. Configuration & Parameters**
25. **`_setMinimumBlueprintStake(uint256 _newStake)`**: Internal setter for the minimum DAO token stake required for blueprint submission. Callable only via `_crystallizeFragment`.
26. **`_setFragmentGenerationFee(uint256 _newFee)`**: Internal setter for the fee paid to the AI Oracle for fragment generation. Callable only via `_crystallizeFragment`.
27. **`_setVotingPeriod(uint256 _newPeriod)`**: Internal setter for the duration (in seconds) that proposals are open for voting. Callable only via `_crystallizeFragment`.
28. **`_setExecutionDelay(uint256 _newDelay)`**: Internal setter for the delay (in seconds) between a proposal passing and when it can be executed. Callable only via `_crystallizeFragment`.

**VIII. View Functions & Getters**
29. **`getArchitectReputation(address _architect)`**: Returns the current reputation score for a given architect.
30. **`getModuleAddress(uint256 _moduleId)`**: Returns the contract address of a registered and active module.
31. **`getCurrentModuleConfig(uint256 _moduleId)`**: Returns the raw configuration bytes for a specific module.
32. **`getProposalState(uint256 _proposalId)`**: Returns the current state of a proposal, dynamically checking if the voting period has ended for active proposals.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol"; // For granular roles
import "@openzeppelin/contracts/utils/Pausable.sol";     // For pausing critical operations
import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // For DAO token staking and fees
import "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol"; // For contract upgradeability
import "@openzeppelin/contracts/utils/introspection/IERC165.sol"; // For module interface support check

// --- Custom Errors for Gas Efficiency and Clarity ---
error Aetherium__Unauthorized();
error Aetherium__BlueprintNotFound();
error Aetherium__BlueprintNotPending();
error Aetherium__BlueprintAlreadyFragmented(); // Used when fragment already exists
error Aetherium__FragmentNotFound(); // Not explicitly used but good for completeness
error Aetherium__ProposalNotFound();
error Aetherium__ProposalNotActive();
error Aetherium__ProposalNotExecutable();
error Aetherium__ProposalAlreadyExecuted();
error Aetherium__InsufficientStake();
error Aetherium__VoteAlreadyCast();
error Aetherium__InvalidModuleAddress();
error Aetherium__ModuleNotFound();
error Aetherium__ModuleAlreadyActive();
error Aetherium__ModuleAlreadyInactive();
error Aetherium__InvalidCrystallizationPayload();
error Aetherium__ZeroAddress();
error Aetherium__TransferFailed();
error Aetherium__InvalidAIResponse(); // e.g., empty fragment hash

// --- Interfaces ---

// @dev Interface for the Aetherium Council (DAO) governance token.
// Assumes a standard ERC20 with a voting extension (like OpenZeppelin's ERC20Votes).
interface IAetheriumCouncilToken is IERC20 {
    function getVotes(address account) external view returns (uint256);
    // totalSupply() from IERC20 is also needed for quorum calculation
}

// @dev Interface for pluggable Aetherium Modules.
// All modules must implement ERC-165 (IERC165) for interface discovery.
interface IAetheriumModule is IERC165 {
    function getModuleName() external view returns (string memory);
    function getModuleVersion() external view returns (uint256);
    // Modules would have specific functions, e.g., `updateParameter(bytes calldata _config)`
    // that the `_crystallizeFragment` could call via `abi.decode` and `call()`.
}

/**
 * @title AetheriumCore: The Self-Evolving Protocol for Decentralized Generative Architectures
 * @author (Simulated for this exercise)
 * @notice This contract serves as the central hub for a decentralized, AI-assisted, self-evolving protocol.
 *         Architects propose "Blueprints" (ideas/parameters/logic fragments). An off-chain AI Oracle
 *         interprets these blueprints into "Architectural Fragments" (structured data outputs).
 *         The Aetherium Council (DAO) then votes to "crystallize" these fragments, applying them
 *         to modify the protocol's behavior, register new functional modules, or adjust parameters.
 *         This system is designed to be highly modular, upgradeable, and governed by its community,
 *         allowing the protocol to adapt and evolve autonomously.
 */
contract AetheriumCore is UUPSUpgradeable, Pausable, AccessControl {

    /*///////////////////////////////////////////////////////////////
                            OUTLINE AND SUMMARY
    //////////////////////////////////////////////////////////////*/

    // --- I. Core System Setup & Access Control ---
    // 1.  initialize(address _initialOwner, address _daoTokenAddress): UUPS initializer. Sets up initial roles (Admin, Pauser, Oracle) and the Aetherium Council (DAO) token address.
    // 2.  _authorizeUpgrade(address newImplementation): Internal UUPS hook. Restricts contract upgrades to DAO_GOVERNOR_ROLE only.
    // 3.  setGovernanceToken(address _daoTokenAddress): Allows the DAO_GOVERNOR_ROLE to update the address of the Aetherium Council (DAO) token.
    // 4.  pauseSystem(): Pauses certain critical functions, callable by the PAUSER_ROLE.
    // 5.  unpauseSystem(): Unpauses the system, callable by the PAUSER_ROLE.
    // 6.  withdrawProtocolFees(address _token, address _to, uint256 _amount): Allows DAO_GOVERNOR_ROLE to withdraw accumulated fees (e.g., from blueprint stakes) in a specific ERC20 token to a specified address.

    // --- II. Blueprint Submission & Lifecycle ---
    // 7.  submitBlueprint(string calldata _blueprintHash, string calldata _metadataURI, uint256 _stakeAmount): Allows an "Architect" (user) to submit a new idea or specification ("Blueprint"). This requires staking a minimum amount of the DAO token. The blueprint content is off-chain (referenced by _blueprintHash and _metadataURI).
    // 8.  cancelBlueprint(uint256 _blueprintId): Allows an Architect to cancel their own blueprint if it's still in the Pending state, refunding their staked tokens.
    // 9.  getBlueprintDetails(uint256 _blueprintId): View function to retrieve all details of a specific blueprint.

    // --- III. AI Oracle Interaction (Off-chain Triggered) ---
    // 10. requestFragmentGeneration(uint256 _blueprintId): Initiates the off-chain AI interpretation process for a Pending blueprint. Callable only by the ORACLE_ROLE, it emits an event for off-chain AI services to pick up.
    // 11. submitGeneratedFragment(uint256 _blueprintId, bytes32 _fragmentHash, string calldata _fragmentURI, uint256 _aiCost): Called by the ORACLE_ROLE (the AI Oracle) to submit the structured output ("Architectural Fragment") generated by the AI for a given blueprint. It also records the AI's operational cost and pays a fixed fragmentGenerationFee.
    // 12. rejectFragmentGeneration(uint256 _blueprintId, string calldata _reason): Allows the ORACLE_ROLE to reject a blueprint for AI processing, e.g., if it's malformed or unsafe.

    // --- IV. Aetherium Council (DAO) Governance & Voting ---
    // 13. proposeCrystallization(uint256 _blueprintId, bytes calldata _crystallizationPayload): A DAO_GOVERNOR_ROLE member proposes to "crystallize" (apply) an AI-generated fragment. The _crystallizationPayload contains the encoded instructions for how the fragment should modify the system.
    // 14. voteOnProposal(uint256 _proposalId, bool _support): Aetherium Council token holders can vote 'for' or 'against' active crystallization proposals, using their DAO token voting power.
    // 15. executeProposal(uint256 _proposalId): After a proposal has passed its voting period, garnered enough 'for' votes, and cleared an executionDelay, a DAO_GOVERNOR_ROLE member can execute it, triggering the actual system modification.
    // 16. _checkProposalState(uint256 _proposalId): Internal function to evaluate a proposal's state (Active, Succeeded, Failed) based on voting period, votes, and quorum.

    // --- V. Crystallization (System Modification) ---
    // 17. _crystallizeFragment(uint256 _blueprintId, bytes calldata _crystallizationPayload): An internal, core function called during proposal execution. It parses the _crystallizationPayload and dispatches calls to other internal functions or registered modules to enact the changes defined by the AI-generated fragment. This is where the protocol "evolves."
    // 18. _updateModuleConfiguration(uint256 _moduleId, bytes calldata _newConfigData): Internal function, callable only via _crystallizeFragment, to update the flexible configuration bytes of an existing, registered module.
    // 19. _registerNewModule(address _moduleAddress, bytes4 _interfaceId, string calldata _name): Internal function, callable only via _crystallizeFragment, to onboard a new functional module contract into the Aetherium ecosystem. The module must implement a specific interface (e.g., IAetheriumModule).
    // 20. _deactivateModule(uint256 _moduleId): Internal function, callable only via _crystallizeFragment, to logically disable a previously registered module.

    // --- VI. Reputation & Rewards ---
    // 21. claimBlueprintStake(uint256 _blueprintId): Allows an Architect to reclaim their initial DAO token stake for a blueprint that has been successfully Crystallized.
    // 22. distributeArchitectReward(address _architect, uint256 _amount): Allows DAO_GOVERNOR_ROLE to explicitly send a reward (in DAO tokens) from the protocol's balance to an Architect.
    // 23. penalizeArchitect(address _architect, uint256 _amount): Allows DAO_GOVERNOR_ROLE to penalize an Architect, for instance, by reducing their reputation score. (In a more complex system, this could involve slashing staked tokens).
    // 24. updateArchitectReputation(address _architect, int252 _delta): Allows DAO_GOVERNOR_ROLE to adjust an Architect's on-chain reputation score, which could influence future interactions or privileges.

    // --- VII. Configuration & Parameters ---
    // 25. _setMinimumBlueprintStake(uint256 _newStake): Internal setter for the minimum DAO token stake required for blueprint submission. Callable only via _crystallizeFragment.
    // 26. _setFragmentGenerationFee(uint256 _newFee): Internal setter for the fee paid to the AI Oracle for fragment generation. Callable only via _crystallizeFragment.
    // 27. _setVotingPeriod(uint256 _newPeriod): Internal setter for the duration (in seconds) that proposals are open for voting. Callable only via _crystallizeFragment.
    // 28. _setExecutionDelay(uint256 _newDelay): Internal setter for the delay (in seconds) between a proposal passing and when it can be executed. Callable only via _crystallizeFragment.

    // --- VIII. View Functions & Getters ---
    // 29. getArchitectReputation(address _architect): Returns the current reputation score for a given architect.
    // 30. getModuleAddress(uint256 _moduleId): Returns the contract address of a registered and active module.
    // 31. getCurrentModuleConfig(uint256 _moduleId): Returns the raw configuration bytes for a specific module.
    // 32. getProposalState(uint256 _proposalId): Returns the current state of a proposal, dynamically checking if the voting period has ended for active proposals.

    /*///////////////////////////////////////////////////////////////
                            ROLES AND EVENTS
    //////////////////////////////////////////////////////////////*/

    // --- Access Control Roles (ERC-742) ---
    bytes32 public constant DAO_GOVERNOR_ROLE = keccak256("DAO_GOVERNOR_ROLE");
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE"); // For AI Oracle system
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    // --- Enums for State Management ---
    enum BlueprintState { Pending, GeneratingFragment, FragmentGenerated, RejectedByAI, CrystallizationProposed, CrystallizationApproved, CrystallizationRejected, Crystallized, Canceled }
    enum ProposalState { Pending, Active, Succeeded, Failed, Executed }

    // --- Structs for Data Storage ---
    struct Blueprint {
        uint256 id;
        address architect;
        string blueprintHash;       // IPFS CID or similar for the original blueprint content
        string metadataURI;         // URI for rich metadata display
        uint256 stakeAmount;
        uint256 submissionTimestamp;
        BlueprintState state;
        bytes32 fragmentHash;       // IPFS CID or similar for the AI-generated fragment content
        string fragmentURI;         // URI for rich metadata display of fragment
        uint256 aiCost;             // Cost incurred by the AI oracle (for potential reimbursement/tracking)
        uint256 proposalId;         // ID of the crystallization proposal, if any
    }

    struct Proposal {
        uint256 id;
        uint256 blueprintId;
        address proposer;
        uint256 startTimestamp;
        uint256 endTimestamp;
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted; // Tracks if an address has voted
        ProposalState state;
        bytes crystallizationPayload; // The encoded call data for _crystallizeFragment
        uint256 executionTimestamp; // When the proposal can be executed after passing
    }

    struct Module {
        uint256 id;
        address moduleAddress;
        bytes4 interfaceId; // ERC-165 interface ID for verification
        string name;
        bytes configData;   // Flexible configuration bytes for the module
        bool active;
    }

    // --- State Variables ---
    IAetheriumCouncilToken public daoToken;
    uint256 public nextBlueprintId;
    uint256 public nextProposalId;
    uint256 public nextModuleId;

    mapping(uint256 => Blueprint) public blueprints;
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => Module) public modules;
    mapping(address => int252) public architectReputation; // Architect's reputation score (using int252 for efficient storage)

    uint256 public minimumBlueprintStake;
    uint256 public fragmentGenerationFee; // Fee paid to the AI Oracle (in DAO token)
    uint256 public votingPeriod;          // Duration for proposal voting (seconds)
    uint256 public executionDelay;        // Delay after proposal passes before it can be executed (seconds)

    // --- Events ---
    event BlueprintSubmitted(uint256 indexed blueprintId, address indexed architect, string blueprintHash, uint256 stakeAmount);
    event BlueprintCanceled(uint256 indexed blueprintId, address indexed architect);
    event FragmentGenerationRequested(uint256 indexed blueprintId, address indexed requestor);
    event FragmentGenerated(uint256 indexed blueprintId, bytes32 fragmentHash, string fragmentURI, uint256 aiCost);
    event FragmentGenerationRejected(uint256 indexed blueprintId, string reason);
    event CrystallizationProposed(uint256 indexed proposalId, uint256 indexed blueprintId, address indexed proposer, uint256 startTimestamp, uint256 endTimestamp);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votes);
    event ProposalStateChanged(uint256 indexed proposalId, ProposalState newState);
    event ProposalExecuted(uint256 indexed proposalId, uint256 indexed blueprintId);
    event BlueprintCrystallized(uint256 indexed blueprintId, uint256 indexed proposalId);
    event ArchitectStakeClaimed(uint256 indexed blueprintId, address indexed architect, uint256 amount);
    event ArchitectRewardDistributed(address indexed architect, uint256 amount);
    event ArchitectPenalized(address indexed architect, uint256 amount);
    event ArchitectReputationUpdated(address indexed architect, int252 newReputation);
    event ModuleRegistered(uint256 indexed moduleId, address indexed moduleAddress, string name, bytes4 interfaceId);
    event ModuleConfigurationUpdated(uint256 indexed moduleId, bytes newConfigData);
    event ModuleDeactivated(uint256 indexed moduleId);
    event MinimumBlueprintStakeUpdated(uint256 newStake);
    event FragmentGenerationFeeUpdated(uint256 newFee);
    event VotingPeriodUpdated(uint256 newPeriod);
    event ExecutionDelayUpdated(uint256 newDelay);
    event GovernanceTokenSet(address indexed newDaoToken);
    event ProtocolFeesWithdrawn(address indexed token, address indexed recipient, uint256 amount);
    event CoreImplementationUpgraded(address indexed newImplementation);

    /**
     * @dev Initializer for UUPS proxy. Sets up initial roles and DAO token.
     * @param _initialOwner The address of the initial contract owner (who will grant DAO_GOVERNOR_ROLE).
     * @param _daoTokenAddress The address of the Aetherium Council (DAO) ERC20 token.
     */
    function initialize(address _initialOwner, address _daoTokenAddress) public initializer {
        __UUPSUpgradeable_init(); // Initialize UUPS functionality
        __Pausable_init();        // Initialize Pausable functionality
        
        // Grant initial roles to the deployer/initial owner
        _grantRole(DEFAULT_ADMIN_ROLE, _initialOwner);
        _grantRole(PAUSER_ROLE, _initialOwner);
        _grantRole(ORACLE_ROLE, _initialOwner); // This role should be transferred to a dedicated AI Oracle contract/address

        if (_daoTokenAddress == address(0)) revert Aetherium__ZeroAddress();
        daoToken = IAetheriumCouncilToken(_daoTokenAddress);

        // Set initial protocol parameters
        minimumBlueprintStake = 1 ether;   // Example: 1 DAO token for blueprint stake
        fragmentGenerationFee = 0.1 ether; // Example: 0.1 DAO token fee for AI oracle service
        votingPeriod = 7 days;             // 7 days for voting on proposals
        executionDelay = 1 days;           // 1 day delay before a passed proposal can be executed

        // Initialize counters for unique IDs
        nextBlueprintId = 1;
        nextProposalId = 1;
        nextModuleId = 1;
    }

    /**
     * @dev Internal function for UUPS upgrade authorization. Only `DAO_GOVERNOR_ROLE` can authorize upgrades.
     * @param newImplementation The address of the new logic contract.
     */
    function _authorizeUpgrade(address newImplementation) internal override onlyRole(DAO_GOVERNOR_ROLE) {}

    /*///////////////////////////////////////////////////////////////
                            I. Core System Setup & Access Control
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Sets the address of the Aetherium Council (DAO) governance token.
     *      Can only be called by an account with the `DAO_GOVERNOR_ROLE`.
     * @param _daoTokenAddress The new address for the DAO governance token.
     */
    function setGovernanceToken(address _daoTokenAddress) public onlyRole(DAO_GOVERNOR_ROLE) {
        if (_daoTokenAddress == address(0)) revert Aetherium__ZeroAddress();
        daoToken = IAetheriumCouncilToken(_daoTokenAddress);
        emit GovernanceTokenSet(_daoTokenAddress);
    }

    /**
     * @dev Pauses the system. Prevents blueprint submission, fragment generation requests, and proposal execution.
     *      Can only be called by an account with the `PAUSER_ROLE`.
     */
    function pauseSystem() public onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @dev Unpauses the system.
     *      Can only be called by an account with the `PAUSER_ROLE`.
     */
    function unpauseSystem() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    /**
     * @dev Allows `DAO_GOVERNOR_ROLE` to withdraw collected protocol fees for a specific ERC20 token.
     *      Fees could come from blueprint stakes, generation fees, etc.
     * @param _token The address of the ERC20 token to withdraw.
     * @param _to The recipient address for the withdrawn tokens.
     * @param _amount The amount of tokens to withdraw.
     */
    function withdrawProtocolFees(address _token, address _to, uint256 _amount) public onlyRole(DAO_GOVERNOR_ROLE) {
        if (_to == address(0)) revert Aetherium__ZeroAddress();
        if (_amount == 0) return;
        
        IERC20 tokenContract = IERC20(_token);
        // Ensure the contract has enough balance of the specified token
        if (tokenContract.balanceOf(address(this)) < _amount) revert Aetherium__TransferFailed();

        // Perform the token transfer
        if (!tokenContract.transfer(_to, _amount)) revert Aetherium__TransferFailed();
        emit ProtocolFeesWithdrawn(_token, _to, _amount);
    }

    /*///////////////////////////////////////////////////////////////
                            II. Blueprint Submission & Lifecycle
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Allows an Architect to submit a new blueprint to the Aetherium.
     *      Requires staking a minimum amount of the DAO token.
     * @param _blueprintHash A hash (e.g., IPFS CID) pointing to the actual blueprint content off-chain.
     * @param _metadataURI A URI for rich metadata (e.g., image, description) for the blueprint.
     * @param _stakeAmount The amount of DAO tokens to stake for this blueprint.
     */
    function submitBlueprint(
        string calldata _blueprintHash,
        string calldata _metadataURI,
        uint256 _stakeAmount
    ) public whenNotPaused {
        // Ensure the staked amount meets the minimum requirement
        if (_stakeAmount < minimumBlueprintStake) revert Aetherium__InsufficientStake();

        // Transfer stake from architect to this contract. Requires prior approval.
        if (!daoToken.transferFrom(msg.sender, address(this), _stakeAmount)) {
            revert Aetherium__TransferFailed();
        }

        uint256 currentId = nextBlueprintId++; // Get next unique ID
        blueprints[currentId] = Blueprint({
            id: currentId,
            architect: msg.sender,
            blueprintHash: _blueprintHash,
            metadataURI: _metadataURI,
            stakeAmount: _stakeAmount,
            submissionTimestamp: block.timestamp,
            state: BlueprintState.Pending, // Initial state
            fragmentHash: "",
            fragmentURI: "",
            aiCost: 0,
            proposalId: 0
        });

        emit BlueprintSubmitted(currentId, msg.sender, _blueprintHash, _stakeAmount);
    }

    /**
     * @dev Allows an Architect to cancel their own blueprint if it's still in the `Pending` state.
     *      The staked tokens are returned to the architect.
     * @param _blueprintId The ID of the blueprint to cancel.
     */
    function cancelBlueprint(uint256 _blueprintId) public whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();      // Check if blueprint exists
        if (blueprint.architect != msg.sender) revert Aetherium__Unauthorized(); // Only owner can cancel
        if (blueprint.state != BlueprintState.Pending) revert Aetherium__BlueprintNotPending(); // Must be in pending state

        blueprint.state = BlueprintState.Canceled; // Update blueprint state

        // Return staked tokens to the architect
        if (!daoToken.transfer(blueprint.architect, blueprint.stakeAmount)) {
            revert Aetherium__TransferFailed();
        }

        emit BlueprintCanceled(_blueprintId, msg.sender);
    }

    /**
     * @dev Returns the details of a specific blueprint.
     * @param _blueprintId The ID of the blueprint.
     * @return Blueprint struct containing all details.
     */
    function getBlueprintDetails(uint256 _blueprintId) public view returns (Blueprint memory) {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound(); // Ensure blueprint exists
        return blueprint;
    }

    /*///////////////////////////////////////////////////////////////
                            III. AI Oracle Interaction
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Requests the off-chain AI Oracle to interpret a pending blueprint and generate a fragment.
     *      Callable only by an account with the `ORACLE_ROLE`.
     * @param _blueprintId The ID of the blueprint to process.
     */
    function requestFragmentGeneration(uint256 _blueprintId) public onlyRole(ORACLE_ROLE) whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();      // Ensure blueprint exists
        if (blueprint.state != BlueprintState.Pending) revert Aetherium__BlueprintNotPending(); // Must be in pending state

        blueprint.state = BlueprintState.GeneratingFragment; // Update state to indicate processing
        emit FragmentGenerationRequested(_blueprintId, msg.sender);
    }

    /**
     * @dev Called by the off-chain AI Oracle to submit the generated fragment for a blueprint.
     *      The protocol pays a `fragmentGenerationFee` to the oracle for this service.
     *      Callable only by an account with the `ORACLE_ROLE`.
     * @param _blueprintId The ID of the blueprint for which the fragment was generated.
     * @param _fragmentHash A hash (e.g., IPFS CID) pointing to the AI-generated fragment content.
     * @param _fragmentURI A URI for rich metadata (e.g., visualization, description) of the fragment.
     * @param _aiCost The cost incurred by the AI oracle for generation (for tracking/reimbursement)
     */
    function submitGeneratedFragment(
        uint256 _blueprintId,
        bytes32 _fragmentHash,
        string calldata _fragmentURI,
        uint256 _aiCost
    ) public onlyRole(ORACLE_ROLE) whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();      // Ensure blueprint exists
        if (blueprint.state != BlueprintState.GeneratingFragment) revert Aetherium__BlueprintNotPending(); // Must be in generation state
        if (_fragmentHash == bytes32(0)) revert Aetherium__InvalidAIResponse(); // Ensure valid AI output

        // Update blueprint with AI-generated fragment details
        blueprint.state = BlueprintState.FragmentGenerated;
        blueprint.fragmentHash = _fragmentHash;
        blueprint.fragmentURI = _fragmentURI;
        blueprint.aiCost = _aiCost; 

        // Protocol pays the AI oracle its fixed fee for generation (from collected DAO tokens)
        if (daoToken.balanceOf(address(this)) < fragmentGenerationFee) {
             revert Aetherium__TransferFailed(); // Not enough funds to pay the oracle
        }
        if (!daoToken.transfer(msg.sender, fragmentGenerationFee)) {
            revert Aetherium__TransferFailed(); // Transfer failed
        }

        emit FragmentGenerated(_blueprintId, _fragmentHash, _fragmentURI, _aiCost);
    }

    /**
     * @dev Called by the off-chain AI Oracle to reject a blueprint for fragment generation.
     *      Callable only by an account with the `ORACLE_ROLE`.
     * @param _blueprintId The ID of the blueprint to reject.
     * @param _reason A string explaining the reason for rejection (e.g., "malformed", "unsafe content").
     */
    function rejectFragmentGeneration(uint256 _blueprintId, string calldata _reason) public onlyRole(ORACLE_ROLE) whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();      // Ensure blueprint exists
        if (blueprint.state != BlueprintState.GeneratingFragment) revert Aetherium__BlueprintNotPending(); // Must be in generation state

        blueprint.state = BlueprintState.RejectedByAI; // Update state
        // Optionally, refund stake to architect or penalize them. For now, just change state.
        
        emit FragmentGenerationRejected(_blueprintId, _reason);
    }

    /*///////////////////////////////////////////////////////////////
                            IV. Aetherium Council (DAO) Governance & Voting
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Proposes to "crystallize" an AI-generated fragment, applying its changes to the protocol.
     *      Callable only by `DAO_GOVERNOR_ROLE`.
     * @param _blueprintId The ID of the blueprint whose fragment is to be crystallized.
     * @param _crystallizationPayload The encoded call data that will be executed if the proposal passes.
     *                                This payload will be passed to `_crystallizeFragment`.
     */
    function proposeCrystallization(uint256 _blueprintId, bytes calldata _crystallizationPayload) public onlyRole(DAO_GOVERNOR_ROLE) whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();              // Ensure blueprint exists
        if (blueprint.state != BlueprintState.FragmentGenerated) revert Aetherium__BlueprintAlreadyFragmented(); // Must have a generated fragment
        if (_crystallizationPayload.length == 0) revert Aetherium__InvalidCrystallizationPayload(); // Payload cannot be empty

        uint256 currentId = nextProposalId++; // Get next unique proposal ID
        uint256 start = block.timestamp;
        uint256 end = start + votingPeriod;

        proposals[currentId] = Proposal({
            id: currentId,
            blueprintId: _blueprintId,
            proposer: msg.sender,
            startTimestamp: start,
            endTimestamp: end,
            votesFor: 0,
            votesAgainst: 0,
            state: ProposalState.Active, // Initial proposal state
            crystallizationPayload: _crystallizationPayload,
            executionTimestamp: 0
        });

        blueprint.state = BlueprintState.CrystallizationProposed; // Update blueprint state
        blueprint.proposalId = currentId;

        emit CrystallizationProposed(currentId, _blueprintId, msg.sender, start, end);
    }

    /**
     * @dev Allows DAO token holders to vote on an active proposal.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _support True for 'for' vote, false for 'against' vote.
     */
    function voteOnProposal(uint256 _proposalId, bool _support) public whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.id == 0) revert Aetherium__ProposalNotFound();       // Ensure proposal exists
        if (proposal.state != ProposalState.Active) revert Aetherium__ProposalNotActive(); // Must be active
        if (block.timestamp >= proposal.endTimestamp) revert Aetherium__ProposalNotActive(); // Voting period must be ongoing
        if (proposal.hasVoted[msg.sender]) revert Aetherium__VoteAlreadyCast(); // Cannot vote twice

        uint256 votes = daoToken.getVotes(msg.sender); // Get voter's token-weighted votes
        if (votes == 0) revert Aetherium__Unauthorized(); // Voter must have voting power

        proposal.hasVoted[msg.sender] = true; // Mark as voted
        if (_support) {
            proposal.votesFor += votes;
        } else {
            proposal.votesAgainst += votes;
        }

        emit VoteCast(_proposalId, msg.sender, _support, votes);

        // Immediately check if the proposal state needs to be updated (e.g., if quorum/majority is met early)
        _checkProposalState(_proposalId);
    }

    /**
     * @dev Executes a passed proposal, applying the AI-generated fragment's changes.
     *      Callable only by `DAO_GOVERNOR_ROLE` after the proposal has succeeded and its `executionDelay` has passed.
     * @param _proposalId The ID of the proposal to execute.
     */
    function executeProposal(uint256 _proposalId) public onlyRole(DAO_GOVERNOR_ROLE) whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.id == 0) revert Aetherium__ProposalNotFound();           // Ensure proposal exists
        if (proposal.state == ProposalState.Executed) revert Aetherium__ProposalAlreadyExecuted(); // Cannot execute twice
        
        // Ensure proposal state is up-to-date (in case _checkProposalState was not called after the last vote)
        _checkProposalState(_proposalId);

        if (proposal.state != ProposalState.Succeeded) revert Aetherium__ProposalNotExecutable(); // Must have succeeded
        if (block.timestamp < proposal.executionTimestamp) revert Aetherium__ProposalNotExecutable(); // Execution delay must be over

        Blueprint storage blueprint = blueprints[proposal.blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound(); // Should always exist if proposal refers to it

        // Execute the crystallization payload, which modifies the system
        _crystallizeFragment(blueprint.id, proposal.crystallizationPayload);

        blueprint.state = BlueprintState.Crystallized; // Update blueprint state
        proposal.state = ProposalState.Executed;      // Update proposal state
        emit ProposalExecuted(_proposalId, blueprint.id);
        emit BlueprintCrystallized(blueprint.id, _proposalId);
    }

    /**
     * @dev Internal function to update the state of a proposal based on time and votes.
     *      This function is called after each vote and when `executeProposal` is attempted.
     * @param _proposalId The ID of the proposal.
     */
    function _checkProposalState(uint256 _proposalId) internal {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.state != ProposalState.Active) return; // Only process active proposals

        // Only check if voting period has ended or if we are actively checking before execution
        if (block.timestamp < proposal.endTimestamp && proposal.executionTimestamp == 0) return;

        uint256 totalVotes = proposal.votesFor + proposal.votesAgainst;
        uint256 currentSupply = daoToken.totalSupply(); 
        uint256 quorumThreshold = currentSupply / 10; // Example: 10% of total supply needed for quorum

        if (totalVotes >= quorumThreshold && proposal.votesFor > proposal.votesAgainst) {
            // Proposal succeeded
            proposal.state = ProposalState.Succeeded;
            proposal.executionTimestamp = block.timestamp + executionDelay; // Set execution timestamp
            emit ProposalStateChanged(_proposalId, ProposalState.Succeeded);
        } else {
            // Proposal failed (either no quorum or 'against' votes won)
            proposal.state = ProposalState.Failed;
            emit ProposalStateChanged(_proposalId, ProposalState.Failed);
            // Revert blueprint state from 'CrystallizationProposed' if the proposal failed
            blueprints[proposal.blueprintId].state = BlueprintState.CrystallizationRejected;
        }
    }

    /*///////////////////////////////////////////////////////////////
                            V. Crystallization (System Modification)
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Internal function to apply the changes defined by a successful crystallization proposal.
     *      This function parses the `_crystallizationPayload` to call specific internal setters
     *      or update module configurations. This is the core "evolution" mechanism.
     *      It acts as a dispatcher for various governance actions.
     * @param _blueprintId The ID of the blueprint whose fragment is being crystallized.
     * @param _crystallizationPayload The encoded instructions for modifying the system.
     */
    function _crystallizeFragment(uint256 _blueprintId, bytes calldata _crystallizationPayload) internal {
        // The payload is expected to be `abi.encodeCall(targetFunction, (args...))`.
        // We extract the selector to dispatch to the correct internal function or module call.
        bytes4 selector = bytes4(0);
        if (_crystallizationPayload.length >= 4) {
            assembly {
                selector := mload(add(_crystallizationPayload, 32)) // Load the first 4 bytes (selector)
            }
        }

        // --- Dispatcher for various system modification functions ---
        // This structure allows the DAO to trigger predefined, safe internal modifications.
        if (selector == this._updateModuleConfiguration.selector) {
            (uint256 moduleId, bytes memory newConfigData) = abi.decode(_crystallizationPayload[4:], (uint256, bytes));
            _updateModuleConfiguration(moduleId, newConfigData);
        } else if (selector == this._registerNewModule.selector) {
            (address moduleAddress, bytes4 interfaceId, string memory name) = abi.decode(_crystallizationPayload[4:], (address, bytes4, string));
            _registerNewModule(moduleAddress, interfaceId, name);
        } else if (selector == this._deactivateModule.selector) {
            (uint256 moduleId) = abi.decode(_crystallizationPayload[4:], (uint256));
            _deactivateModule(moduleId);
        } else if (selector == this._setMinimumBlueprintStake.selector) {
            (uint256 newStake) = abi.decode(_crystallizationPayload[4:], (uint256));
            _setMinimumBlueprintStake(newStake);
        } else if (selector == this._setFragmentGenerationFee.selector) {
            (uint256 newFee) = abi.decode(_crystallizationPayload[4:], (uint256));
            _setFragmentGenerationFee(newFee);
        } else if (selector == this._setVotingPeriod.selector) {
            (uint256 newPeriod) = abi.decode(_crystallizationPayload[4:], (uint256));
            _setVotingPeriod(newPeriod);
        } else if (selector == this._setExecutionDelay.selector) {
            (uint256 newDelay) = abi.decode(_crystallizationPayload[4:], (uint256));
            _setExecutionDelay(newDelay);
        } else if (selector == this.upgradeToAndCall.selector) {
             // Enables UUPS upgrades of the AetheriumCore's logic contract itself
             (address newImplementation, bytes memory data) = abi.decode(_crystallizationPayload[4:], (address, bytes));
             upgradeToAndCall(newImplementation, data);
        }
        else {
             // If the payload does not match any known internal dispatch, it's considered invalid.
             revert Aetherium__InvalidCrystallizationPayload(); 
        }
    }

    /**
     * @dev Internal function to update the configuration data for a registered module.
     *      Called as part of a successful crystallization (via `_crystallizeFragment`).
     * @param _moduleId The ID of the module to update.
     * @param _newConfigData The new configuration bytes for the module.
     */
    function _updateModuleConfiguration(uint256 _moduleId, bytes calldata _newConfigData) internal {
        Module storage module = modules[_moduleId];
        if (module.id == 0 || !module.active) revert Aetherium__ModuleNotFound(); // Module must exist and be active

        module.configData = _newConfigData; // Update the stored configuration

        // In a real scenario, you might also want to call a function on the module itself
        // to notify it of the configuration change, e.g.:
        // (bool success, bytes memory returndata) = module.moduleAddress.call(
        //     abi.encodeWithSelector(IAetheriumModule.updateConfig.selector, _newConfigData)
        // );
        // require(success, "Module config update call failed");

        emit ModuleConfigurationUpdated(_moduleId, _newConfigData);
    }

    /**
     * @dev Internal function to register a new functional module with the protocol.
     *      Called as part of a successful crystallization (via `_crystallizeFragment`).
     *      The module must implement `IAetheriumModule` (which includes `IERC165`).
     * @param _moduleAddress The address of the new module contract.
     * @param _interfaceId The ERC-165 interface ID that the module claims to support.
     * @param _name A human-readable name for the module.
     */
    function _registerNewModule(address _moduleAddress, bytes4 _interfaceId, string calldata _name) internal {
        if (_moduleAddress == address(0)) revert Aetherium__InvalidModuleAddress();

        // Check if a module with this address already exists
        for (uint256 i = 1; i < nextModuleId; i++) {
            if (modules[i].moduleAddress == _moduleAddress) {
                if (modules[i].active) revert Aetherium__ModuleAlreadyActive(); // Cannot register active module twice
                // If the module exists but is inactive, reactivate it instead of creating a new entry
                modules[i].active = true;
                emit ModuleRegistered(i, _moduleAddress, _name, _interfaceId);
                return;
            }
        }

        // Basic check if the module contract supports the declared interface (ERC-165)
        // This is a safety check; actual module security requires thorough auditing and governance review.
        require(IAetheriumModule(_moduleAddress).supportsInterface(_interfaceId), "Aetherium: Module does not support interface");

        uint256 currentId = nextModuleId++; // Get next unique module ID
        modules[currentId] = Module({
            id: currentId,
            moduleAddress: _moduleAddress,
            interfaceId: _interfaceId,
            name: _name,
            configData: "", // Initialize with empty config
            active: true    // Mark as active
        });

        emit ModuleRegistered(currentId, _moduleAddress, _name, _interfaceId);
    }

    /**
     * @dev Internal function to deactivate an existing module, preventing its further use.
     *      Called as part of a successful crystallization (via `_crystallizeFragment`).
     * @param _moduleId The ID of the module to deactivate.
     */
    function _deactivateModule(uint256 _moduleId) internal {
        Module storage module = modules[_moduleId];
        if (module.id == 0) revert Aetherium__ModuleNotFound();         // Ensure module exists
        if (!module.active) revert Aetherium__ModuleAlreadyInactive(); // Must be active to deactivate

        module.active = false; // Mark as inactive
        emit ModuleDeactivated(_moduleId);
    }

    /*///////////////////////////////////////////////////////////////
                            VI. Reputation & Rewards
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Allows the original Architect of a successfully crystallized blueprint to claim their staked tokens.
     *      Additional rewards for successful crystallization could be integrated here.
     * @param _blueprintId The ID of the blueprint whose stake is to be claimed.
     */
    function claimBlueprintStake(uint256 _blueprintId) public whenNotPaused {
        Blueprint storage blueprint = blueprints[_blueprintId];
        if (blueprint.id == 0) revert Aetherium__BlueprintNotFound();      // Ensure blueprint exists
        if (blueprint.architect != msg.sender) revert Aetherium__Unauthorized(); // Only the architect can claim
        if (blueprint.state != BlueprintState.Crystallized) revert Aetherium__BlueprintNotPending(); // Must be crystallized

        uint256 amountToReturn = blueprint.stakeAmount;
        blueprint.stakeAmount = 0; // Prevent double claim by zeroing out the stake

        if (!daoToken.transfer(blueprint.architect, amountToReturn)) {
            revert Aetherium__TransferFailed(); // Transfer of stake back to architect failed
        }

        // Optional: Implement a reward mechanism for architects with successful blueprints
        // For example: uint256 rewardAmount = calculateReward(_blueprintId);
        // if (rewardAmount > 0) {
        //     if (!daoToken.transfer(blueprint.architect, rewardAmount)) revert Aetherium__TransferFailed();
        //     emit ArchitectRewardDistributed(blueprint.architect, rewardAmount);
        // }

        emit ArchitectStakeClaimed(_blueprintId, msg.sender, amountToReturn);
    }

    /**
     * @dev Allows `DAO_GOVERNOR_ROLE` to distribute an explicit reward to an Architect.
     *      Reward comes from the protocol's DAO token balance.
     * @param _architect The address of the architect to reward.
     * @param _amount The amount of DAO tokens to reward.
     */
    function distributeArchitectReward(address _architect, uint256 _amount) public onlyRole(DAO_GOVERNOR_ROLE) {
        if (_architect == address(0)) revert Aetherium__ZeroAddress();
        if (_amount == 0) return;

        // Ensure the contract has enough DAO tokens to distribute the reward
        if (daoToken.balanceOf(address(this)) < _amount) revert Aetherium__TransferFailed();
        if (!daoToken.transfer(_architect, _amount)) {
            revert Aetherium__TransferFailed();
        }
        emit ArchitectRewardDistributed(_architect, _amount);
    }

    /**
     * @dev Allows `DAO_GOVERNOR_ROLE` to penalize an Architect, for instance, by reducing their reputation score.
     *      More complex implementations could directly slash staked tokens if managed centrally.
     * @param _architect The address of the architect to penalize.
     * @param _amount The conceptual amount of penalty (could translate to reputation reduction).
     */
    function penalizeArchitect(address _architect, uint256 _amount) public onlyRole(DAO_GOVERNOR_ROLE) {
        if (_architect == address(0)) revert Aetherium__ZeroAddress();
        if (_amount == 0) return;

        // For this contract, penalty translates to a reduction in reputation score.
        // In a more advanced system, this could involve seizing or burning staked tokens.
        updateArchitectReputation(_architect, - (int252(_amount))); // Reduce reputation score
        emit ArchitectPenalized(_architect, _amount);
    }

    /**
     * @dev Updates an Architect's reputation score. Can be positive or negative.
     *      Callable by `DAO_GOVERNOR_ROLE`.
     * @param _architect The address of the architect.
     * @param _delta The amount to add or subtract from the reputation score.
     */
    function updateArchitectReputation(address _architect, int252 _delta) public onlyRole(DAO_GOVERNOR_ROLE) {
        if (_architect == address(0)) revert Aetherium__ZeroAddress();
        architectReputation[_architect] += _delta;
        emit ArchitectReputationUpdated(_architect, architectReputation[_architect]);
    }

    /*///////////////////////////////////////////////////////////////
                            VII. Configuration & Parameters
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Internal setter for the minimum blueprint stake. Only callable via `_crystallizeFragment` (DAO proposal).
     * @param _newStake The new minimum stake amount.
     */
    function _setMinimumBlueprintStake(uint256 _newStake) internal {
        minimumBlueprintStake = _newStake;
        emit MinimumBlueprintStakeUpdated(_newStake);
    }

    /**
     * @dev Internal setter for the fragment generation fee. Only callable via `_crystallizeFragment` (DAO proposal).
     * @param _newFee The new fee for the AI oracle.
     */
    function _setFragmentGenerationFee(uint256 _newFee) internal {
        fragmentGenerationFee = _newFee;
        emit FragmentGenerationFeeUpdated(_newFee);
    }

    /**
     * @dev Internal setter for the voting period. Only callable via `_crystallizeFragment` (DAO proposal).
     * @param _newPeriod The new voting period in seconds.
     */
    function _setVotingPeriod(uint256 _newPeriod) internal {
        if (_newPeriod == 0) revert("Aetherium: Voting period cannot be zero");
        votingPeriod = _newPeriod;
        emit VotingPeriodUpdated(_newPeriod);
    }

    /**
     * @dev Internal setter for the execution delay. Only callable via `_crystallizeFragment` (DAO proposal).
     * @param _newDelay The new execution delay in seconds.
     */
    function _setExecutionDelay(uint256 _newDelay) internal {
        executionDelay = _newDelay;
        emit ExecutionDelayUpdated(_newDelay);
    }

    /*///////////////////////////////////////////////////////////////
                            VIII. View Functions & Getters
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev Returns an Architect's current reputation score.
     * @param _architect The address of the architect.
     * @return The architect's reputation score.
     */
    function getArchitectReputation(address _architect) public view returns (int252) {
        return architectReputation[_architect];
    }

    /**
     * @dev Returns the address of a registered and active module.
     * @param _moduleId The ID of the module.
     * @return The address of the module.
     */
    function getModuleAddress(uint256 _moduleId) public view returns (address) {
        Module storage module = modules[_moduleId];
        if (module.id == 0 || !module.active) revert Aetherium__ModuleNotFound(); // Must be a valid and active module
        return module.moduleAddress;
    }

    /**
     * @dev Returns the current configuration data bytes for a registered module.
     * @param _moduleId The ID of the module.
     * @return The configuration data bytes.
     */
    function getCurrentModuleConfig(uint256 _moduleId) public view returns (bytes memory) {
        Module storage module = modules[_moduleId];
        if (module.id == 0 || !module.active) revert Aetherium__ModuleNotFound(); // Must be a valid and active module
        return module.configData;
    }

    /**
     * @dev Returns the current state of a proposal.
     *      Dynamically checks if an active proposal's voting period has ended to reflect its final state.
     * @param _proposalId The ID of the proposal.
     * @return The current state of the proposal.
     */
    function getProposalState(uint256 _proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.id == 0) revert Aetherium__ProposalNotFound(); // Ensure proposal exists
        
        // If the proposal is currently active, check if its voting period has expired
        if (proposal.state == ProposalState.Active && block.timestamp >= proposal.endTimestamp) {
            uint256 totalVotes = proposal.votesFor + proposal.votesAgainst;
            uint256 currentSupply = daoToken.totalSupply();
            uint256 quorumThreshold = currentSupply / 10; // Same quorum logic as in _checkProposalState

            if (totalVotes >= quorumThreshold && proposal.votesFor > proposal.votesAgainst) {
                return ProposalState.Succeeded;
            } else {
                return ProposalState.Failed;
            }
        }
        return proposal.state; // Return current stored state if not active or period not ended
    }

    // --- Fallback and Receive functions ---
    // Allow the contract to receive Ether, though its primary operations use the DAO ERC20 token.
    receive() external payable {
        // Ether received could be used for future protocol treasury or gas payments for operations.
    }
    fallback() external payable {
        // Fallback for unexpected calls or direct ETH transfers.
    }
}
```