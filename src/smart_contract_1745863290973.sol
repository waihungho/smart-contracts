Okay, here is a Solidity smart contract concept that aims to be interesting, advanced, creative, and trendy, focusing on dynamic, stateful digital entities and complex interactions, while avoiding direct replication of common open-source patterns like standard ERC-20/721/1155 logic (though borrowing concepts) or standard DeFi/DAO mechanics.

This contract, `DimensionalNexus`, manages unique digital "Dimensions" that users can create, influence, merge, split, and evolve. It incorporates an internal "Nexus Energy" system required for interactions.

---

## DimensionalNexus Smart Contract

**Outline & Summary:**

This contract creates a system for managing unique, stateful digital assets called "Dimensions". Users can interact with these dimensions, influencing their properties like energy, stability, and resonance. The contract features complex mechanics such as merging and splitting dimensions, triggering mutations, and an internal energy system ("Nexus Energy") derived from deposited Ether.

**Core Concepts:**

1.  **Dimensions:** Unique, non-fungible assets with dynamic properties stored within the contract. They have an owner, energy level, stability, resonance frequency, type, and generate Nexus Energy over time based on their stability.
2.  **Nexus Energy:** An internal fungible resource required for most interactions (creation, interaction, merging, splitting). Users acquire Nexus Energy by depositing Ether into the contract and can burn Nexus Energy to withdraw Ether. Nexus Energy is also generated passively by owned Dimensions.
3.  **Interactions:** Users can `depositEnergy`, `extractEssence`, `stabilize`, `destabilize`, `attune`, and `resonate` with dimensions, changing their properties.
4.  **Advanced Transformations:** `mergeDimensions` combines two dimensions into one, pooling/transforming properties. `splitDimension` divides a dimension into two new ones. `triggerMutation` attempts a random, potentially drastic change to a dimension's properties or type.
5.  **Dynamic Properties:** Dimension properties change based on interactions and internal generation/decay mechanics (simulated via interaction effects and energy claims).
6.  **Owner-Controlled Parameters:** The contract owner can adjust costs, rates, and thresholds, allowing for evolution of the game/system mechanics.

**Key Features:**

*   Custom stateful digital asset (`Dimension` struct) management.
*   Internal fungible resource (`Nexus Energy`) with ETH backing and passive generation.
*   Complex asset transformation mechanics (Merge, Split, Mutate).
*   Parameterized interaction effects.
*   Pausable contract state for upgrades/maintenance.
*   Extensive view functions for querying dimension states and user balances.

**Function Summary:**

*   **Admin (Owner-Only):**
    *   `updateParameters`: Modify interaction costs, energy rates, etc.
    *   `pauseInteractions`: Halt core user interaction functions.
    *   `unpauseInteractions`: Resume core user interaction functions.
*   **Nexus Energy Management:**
    *   `depositETHForEnergy`: Deposit ETH to gain Nexus Energy.
    *   `withdrawETHFromEnergy`: Burn Nexus Energy to withdraw ETH.
    *   `claimGeneratedEnergy`: Collect passive Nexus Energy generated by owned dimensions.
*   **Dimension Management (Ownership & Info):**
    *   `createDimension`: Mint a new Dimension.
    *   `ownerOf`: Get the owner of a specific Dimension ID.
    *   `balanceOf`: Get the number of Dimensions owned by an address.
    *   `transferDimension`: Transfer ownership of a Dimension.
    *   `getDimensionDetails`: Retrieve detailed information about a Dimension.
    *   `getTotalDimensions`: Get the total number of Dimensions created.
    *   `getDimensionsByOwner`: Get list of Dimension IDs owned by an address.
*   **Dimension Interactions:**
    *   `depositEnergy`: Add Nexus Energy to a Dimension's internal pool.
    *   `extractEssence`: Attempt to extract Nexus Energy/Essence from a Dimension (risky if unstable).
    *   `stabilizeDimension`: Spend Nexus Energy to increase a Dimension's stability.
    *   `destabilizeDimension`: Spend Nexus Energy to decrease a Dimension's stability (antagonistic or strategic).
    *   `attuneDimension`: Spend Nexus Energy to change a Dimension's resonance frequency.
    *   `resonateWithDimension`: Trigger a special effect based on Dimension Type and Resonance Frequency.
*   **Advanced Transformations:**
    *   `mergeDimensions`: Combine two owned Dimensions into a new one.
    *   `splitDimension`: Split an owned Dimension into two new ones.
    *   `triggerMutation`: Attempt to randomly mutate a Dimension's properties/type.
*   **View Functions (Read-Only):**
    *   `getNexusEnergyBalance`: Get a user's Nexus Energy balance.
    *   `getDimensionEnergyGenerationRate`: Calculate the current passive energy generation rate for a specific Dimension.
    *   `getDimensionGeneratedEnergy`: Calculate unclaimed passive energy for a specific Dimension.
    *   `calculateStabilityScore`: Calculate a normalized stability score for a Dimension.
    *   `predictResonanceEffect`: Provide a hint about the potential effect of `resonateWithDimension`.
    *   `getDimensionLastClaimTime`: Get the timestamp of the last energy claim for a Dimension.
    *   `getDimensionOwnerIndex`: Internal helper view, exposed for debugging/exploration (gets index in owner's array).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Ownable.sol"; // Assuming OpenZeppelin's Ownable for simplicity of owner management

// Custom errors for clarity and gas efficiency
error NotOwnerOfDimension(uint256 dimensionId, address caller);
error DimensionDoesNotExist(uint256 dimensionId);
error InsufficientNexusEnergy(uint256 required, uint256 available);
error InsufficientDimensionEnergy(uint256 required, uint256 available);
error InvalidDimensionIds();
error CannotMergeSameDimension();
error MergeFailed(string reason);
error SplitFailed(string reason);
error MutationFailed(string reason);
error ExtractionFailed(string reason);
error ResonanceConditionsNotMet(string reason);
error ZeroAddress();
error ContractPaused();
error ContractNotPaused();
error TransferRequiresDifferentOwner();
error CannotTransferToSelf();
error InvalidParameters();
error InsufficientETH();

contract DimensionalNexus is Ownable {
    // --- Enums ---
    enum DimensionType {
        Void,          // Starting type, low energy/stability
        Ephemeral,     // Fast decay, quick energy gen
        Stable,        // High stability, steady gen
        Chaotic,       // Unpredictable interactions, mutation prone
        Resonant,      // Enhanced resonance effects
        NexusPrime     // Rare, high gen, unique effects
    }

    // --- Structs ---
    struct Dimension {
        uint256 id;
        address owner;
        uint64 creationTime;
        uint64 lastInteractionTime; // Used for decay/generation calculations
        uint64 lastClaimTime; // For passive energy generation
        uint256 internalEnergy; // Energy stored within the dimension itself
        uint256 stability; // Affects generation, interaction success, risk
        uint256 resonanceFrequency; // Influences resonance interaction
        DimensionType dimensionType;
        bool exists; // To check if ID is valid after potential burning (merge/split)
    }

    // --- State Variables ---

    // Contract State
    bool public paused = false;

    // Dimension Data
    uint256 private _nextDimensionId = 1;
    mapping(uint256 => Dimension) private _dimensions;
    mapping(address => uint256[]) private _ownerDimensions; // List of IDs owned by an address
    mapping(uint256 => uint256) private _dimensionOwnerIndex; // Index of dimension ID in owner's array for faster removal

    // Nexus Energy Data (Internal Fungible Token Concept)
    mapping(address => uint256) private _nexusEnergyBalances;
    uint256 public totalNexusEnergy = 0; // Tracks total outstanding internal energy

    // Contract Parameters (Tunable by owner)
    struct ContractParameters {
        uint256 creationCostEnergy;
        uint256 transferCostEnergy;
        uint256 depositEnergyCostBase; // Base cost to deposit energy into dimension
        uint256 extractEssenceCostBase; // Base cost to attempt extraction
        uint256 stabilizeCostBase; // Base cost to stabilize
        uint256 destabilizeCostBase; // Base cost to destabilize
        uint256 attuneCostBase; // Base cost to attune
        uint256 resonateCostBase; // Base cost to resonate
        uint256 mergeCostEnergy;
        uint256 splitCostEnergy;
        uint256 mutationCostEnergy;
        uint256 energyGenerationRatePerStability; // Energy generated per second per point of stability
        uint256 stabilityDecayRate; // Stability lost per second of inactivity (simplified)
        uint256 ethToEnergyRatio; // How many Nexus Energy per 1 wei of ETH
        uint256 extractionSuccessStabilityThreshold; // Min stability for guaranteed extraction success (percentage)
        uint256 mutationSuccessStabilityThreshold; // Min stability for higher mutation success chance (percentage)
    }
    ContractParameters public params;

    // --- Events ---
    event DimensionCreated(uint256 indexed id, address indexed owner, DimensionType dimensionType, uint64 creationTime);
    event DimensionTransferred(uint256 indexed id, address indexed from, address indexed to);
    event NexusEnergyDeposited(address indexed user, uint256 ethAmount, uint256 energyAmount);
    event NexusEnergyWithdrawal(address indexed user, uint255 energyAmount, uint256 ethAmount);
    event NexusEnergyClaimed(address indexed owner, uint256 indexed dimensionId, uint256 amount);
    event DimensionEnergyDeposited(uint256 indexed dimensionId, address indexed user, uint256 amount);
    event DimensionEssenceExtracted(uint256 indexed dimensionId, address indexed user, uint256 amount);
    event DimensionStabilized(uint256 indexed dimensionId, address indexed user, uint256 stabilityGained);
    event DimensionDestabilized(uint256 indexed dimensionId, address indexed user, uint256 stabilityLost);
    event DimensionAttuned(uint256 indexed dimensionId, address indexed user, uint256 newFrequency);
    event DimensionResonated(uint256 indexed dimensionId, address indexed user, string effect);
    event DimensionsMerged(uint256 indexed id1, uint256 indexed id2, uint256 indexed newId);
    event DimensionSplit(uint256 indexed originalId, uint256 indexed newId1, uint256 indexed newId2);
    event DimensionMutated(uint256 indexed dimensionId, bool success, DimensionType newType, uint256 newFrequency);
    event ParametersUpdated(ContractParameters newParams);
    event ContractPausedStateChanged(bool indexed paused);
    event DimensionBurned(uint256 indexed dimensionId); // For internal burning during merge/split

    // --- Modifiers ---
    modifier whenNotPaused() {
        if (paused) revert ContractPaused();
        _;
    }

    modifier whenPaused() {
        if (!paused) revert ContractNotPaused();
        _;
    }

    // --- Constructor ---
    constructor(ContractParameters initialParams) Ownable(msg.sender) {
        if (initialParams.ethToEnergyRatio == 0) revert InvalidParameters(); // Prevent division by zero
        params = initialParams;
    }

    // --- Admin Functions (Owner Only) ---

    function updateParameters(ContractParameters newParams) external onlyOwner {
        if (newParams.ethToEnergyRatio == 0) revert InvalidParameters();
        params = newParams;
        emit ParametersUpdated(params);
    }

    function pauseInteractions() external onlyOwner whenNotPaused {
        paused = true;
        emit ContractPausedStateChanged(true);
    }

    function unpauseInteractions() external onlyOwner whenPaused {
        paused = false;
        emit ContractPausedStateChanged(false);
    }

    // --- Internal Helpers for Dimension Ownership Management ---

    function _addOwnerDimension(address owner, uint256 dimensionId) private {
        _ownerDimensions[owner].push(dimensionId);
        _dimensionOwnerIndex[dimensionId] = _ownerDimensions[owner].length - 1;
    }

    function _removeOwnerDimension(address owner, uint256 dimensionId) private {
        uint256 index = _dimensionOwnerIndex[dimensionId];
        uint256 lastIndex = _ownerDimensions[owner].length - 1;
        uint256 lastDimensionId = _ownerDimensions[owner][lastIndex];

        // Move the last dimension to the removed dimension's position
        _ownerDimensions[owner][index] = lastDimensionId;
        _dimensionOwnerIndex[lastDimensionId] = index;

        // Remove the last element (which is now a duplicate)
        _ownerDimensions[owner].pop();
        delete _dimensionOwnerIndex[dimensionId];
    }

    function _safeTransferOwnership(address from, address to, uint256 dimensionId) private {
        require(from == _dimensions[dimensionId].owner, "Not the current owner"); // Should be guaranteed by caller
        if (to == address(0)) revert ZeroAddress();
        if (from == to) revert CannotTransferToSelf();

        _removeOwnerDimension(from, dimensionId);
        _dimensions[dimensionId].owner = to;
        _addOwnerDimension(to, dimensionId);

        emit DimensionTransferred(dimensionId, from, to);
    }

    // --- Nexus Energy Management ---

    function depositETHForEnergy() external payable whenNotPaused {
        if (msg.value == 0) revert InsufficientETH();
        uint256 energyAmount = msg.value * params.ethToEnergyRatio;
        _nexusEnergyBalances[msg.sender] += energyAmount;
        totalNexusEnergy += energyAmount; // Track total supply
        emit NexusEnergyDeposited(msg.sender, msg.value, energyAmount);
    }

    function withdrawETHFromEnergy(uint256 energyAmount) external whenNotPaused {
        if (_nexusEnergyBalances[msg.sender] < energyAmount) revert InsufficientNexusEnergy(energyAmount, _nexusEnergyBalances[msg.sender]);

        uint256 ethAmount = energyAmount / params.ethToEnergyRatio;
        if (address(this).balance < ethAmount) {
             // This indicates total Nexus Energy exceeds contract ETH balance
             // which shouldn't happen if ratio is constant and only source is ETH deposit
             // but adding as a safeguard or if future energy sources are added.
             // In a real system, this might require more complex accounting or liquidation.
            revert InsufficientETH();
        }

        _nexusEnergyBalances[msg.sender] -= energyAmount;
        totalNexusEnergy -= energyAmount; // Track total supply
        // Use call to prevent reentrancy
        (bool success, ) = payable(msg.sender).call{value: ethAmount}("");
        if (!success) {
             // Refund energy if ETH transfer fails
            _nexusEnergyBalances[msg.sender] += energyAmount;
             totalNexusEnergy += energyAmount;
             revert InsufficientETH(); // Or a more specific error
        }
        emit NexusEnergyWithdrawal(msg.sender, energyAmount, ethAmount);
    }

    function claimGeneratedEnergy(uint256 dimensionId) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);

        uint256 generated = getDimensionGeneratedEnergy(dimensionId);
        if (generated > 0) {
            _nexusEnergyBalances[msg.sender] += generated;
            // totalNexusEnergy might increase here if this generation isn't already tracked
            // For simplicity, let's assume passive generation adds to the 'internal' supply,
            // which is paid out from ETH deposits. This might lead to ETH/Energy imbalance
            // if passive gen is too high relative to deposits. A more robust system
            // would need a different model (e.g., passive gen creates *new* ETH/USDC via fees,
            // or passive gen reduces the *dimension's* internal energy which can then be extracted).
            // Let's refine: passive gen increases *user's* Nexus Energy balance, effectively
            // increasing the total supply without new ETH deposit. This requires careful
            // management of the ETH backing or accepting that total energy > deposited ETH is possible.
            // Let's stick with the current model for now, acknowledging this limitation for simplicity.
            totalNexusEnergy += generated; // Passive generation increases total supply
            dim.lastClaimTime = uint64(block.timestamp);
            emit NexusEnergyClaimed(msg.sender, dimensionId, generated);
        }
    }

    // --- Dimension Management ---

    function createDimension() external whenNotPaused {
        uint256 cost = params.creationCostEnergy;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        // Cost energy is removed from circulation or sent somewhere?
        // For simplicity, let's assume it's burned for now.
        // In a real system, this could go to a treasury, or be redistributed.
        totalNexusEnergy -= cost; // Burn cost energy

        uint256 newId = _nextDimensionId++;
        uint64 currentTime = uint64(block.timestamp);

        // Initial properties - could be based on randomness, input parameters, etc.
        // Simple initial properties for demonstration:
        _dimensions[newId] = Dimension({
            id: newId,
            owner: msg.sender,
            creationTime: currentTime,
            lastInteractionTime: currentTime,
            lastClaimTime: currentTime,
            internalEnergy: 100, // Starting internal energy
            stability: 500,      // Starting stability
            resonanceFrequency: uint256(keccak256(abi.encodePacked(newId, currentTime, msg.sender))) % 1000, // Pseudo-random frequency
            dimensionType: DimensionType.Void, // Start as Void
            exists: true
        });

        _addOwnerDimension(msg.sender, newId);

        emit DimensionCreated(newId, msg.sender, DimensionType.Void, currentTime);
    }

    function transferDimension(address to, uint256 dimensionId) external whenNotPaused {
        if (to == address(0)) revert ZeroAddress();
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);
        if (msg.sender == to) revert CannotTransferToSelf();

        uint256 cost = params.transferCostEnergy;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        _safeTransferOwnership(msg.sender, to, dimensionId);
    }

    function ownerOf(uint256 dimensionId) public view returns (address) {
        if (!_dimensions[dimensionId].exists) revert DimensionDoesNotExist(dimensionId);
        return _dimensions[dimensionId].owner;
    }

    function balanceOf(address owner) public view returns (uint256) {
        return _ownerDimensions[owner].length;
    }

    function getDimensionDetails(uint256 dimensionId) external view returns (Dimension memory) {
         if (!_dimensions[dimensionId].exists) revert DimensionDoesNotExist(dimensionId);
         return _dimensions[dimensionId];
    }

    function getTotalDimensions() external view returns (uint256) {
        return _nextDimensionId - 1; // IDs are 1-based
    }

    function getDimensionsByOwner(address owner) external view returns (uint256[] memory) {
        return _ownerDimensions[owner];
    }


    // --- Dimension Interactions ---

    function depositEnergy(uint256 dimensionId, uint256 amount) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        // Can deposit to any dimension, not just owned ones
        uint256 cost = params.depositEnergyCostBase + amount / 10; // Example cost scaling
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        dim.internalEnergy += amount;
        dim.lastInteractionTime = uint64(block.timestamp);
        emit DimensionEnergyDeposited(dimensionId, msg.sender, amount);
    }

    function extractEssence(uint256 dimensionId, uint256 requestedAmount) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);
        if (dim.internalEnergy < requestedAmount) revert InsufficientDimensionEnergy(requestedAmount, dim.internalEnergy);

        uint256 cost = params.extractEssenceCostBase;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        // Success chance based on stability
        uint256 currentStabilityScore = calculateStabilityScore(dimensionId); // Returns percentage 0-100
        // Simple success model: guaranteed above threshold, linear chance below
        bool success = (currentStabilityScore >= params.extractionSuccessStabilityThreshold) ||
                       (uint256(keccak256(abi.encodePacked(dimensionId, block.timestamp, msg.sender, block.difficulty))) % 100 < currentStabilityScore); // Pseudo-random chance

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        dim.lastInteractionTime = uint64(block.timestamp);

        if (success) {
            dim.internalEnergy -= requestedAmount;
            // Stability loss proportional to extracted amount and inversely proportional to current stability
            dim.stability = dim.stability > 0 ? dim.stability * (1e18 - (requestedAmount * 1e18 / (dim.internalEnergy + requestedAmount)) * 1e18 / calculateStabilityScore(dimensionId) / 100) / 1e18 : 0; // Example decay formula
            // Prevent underflow/excessive loss - cap stability at 0
            if (dim.stability > dim.stability + (requestedAmount * 1e18 / (dim.internalEnergy + requestedAmount)) * 1e18 / calculateStabilityScore(dimensionId) / 100) dim.stability = 0;


            _nexusEnergyBalances[msg.sender] += requestedAmount; // User gains Nexus Energy
            totalNexusEnergy += requestedAmount; // Increase total supply

            emit DimensionEssenceExtracted(dimensionId, msg.sender, requestedAmount);
        } else {
            // Failure: Maybe lose some stability or internal energy anyway?
            dim.stability = dim.stability > 0 ? dim.stability * 95 / 100 : 0; // Lose 5% stability on failure
            dim.internalEnergy = dim.internalEnergy * 90 / 100; // Lose 10% internal energy on failure
            emit ExtractionFailed("Extraction attempt failed due to instability.");
        }
    }

    function stabilizeDimension(uint256 dimensionId, uint256 amount) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);

        uint256 cost = params.stabilizeCostBase + amount / 5; // Example cost scaling
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        dim.stability += amount;
        dim.lastInteractionTime = uint64(block.timestamp);
        emit DimensionStabilized(dimensionId, msg.sender, amount);
    }

     function destabilizeDimension(uint256 dimensionId, uint256 amount) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        // Anyone can attempt to destabilize
        uint256 cost = params.destabilizeCostBase + amount / 10; // Example cost scaling
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        // Prevent underflow
        if (dim.stability < amount) {
            dim.stability = 0;
        } else {
            dim.stability -= amount;
        }

        dim.lastInteractionTime = uint64(block.timestamp);
        emit DimensionDestabilized(dimensionId, msg.sender, amount);
    }

    function attuneDimension(uint256 dimensionId, uint256 newFrequency) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);

        uint256 cost = params.attuneCostBase + (uint256(int256(newFrequency) - int256(dim.resonanceFrequency))**2 / 1000); // Cost scales with magnitude of change
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        dim.resonanceFrequency = newFrequency;
        dim.lastInteractionTime = uint64(block.timestamp);
        emit DimensionAttuned(dimensionId, msg.sender, newFrequency);
    }

    function resonateWithDimension(uint256 dimensionId) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        // Can resonate with any dimension, but owner might get special benefits or different effects
        bool isOwner = (dim.owner == msg.sender);

        uint256 cost = params.resonateCostBase;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        dim.lastInteractionTime = uint64(block.timestamp);

        string memory effectDescription = "Standard Resonance";
        // Example Resonance Effects based on Type and Frequency
        if (dim.dimensionType == DimensionType.Resonant && dim.resonanceFrequency > 800) {
            dim.internalEnergy += 500; // Boost internal energy
            effectDescription = "Harmonic Energy Amplification";
        } else if (dim.dimensionType == DimensionType.Chaotic && dim.stability < 300) {
             // Chance of small mutation
            if (uint256(keccak256(abi.encodePacked(dimensionId, block.timestamp, msg.sender))) % 100 < 20) { // 20% chance
                _triggerMutation(dimensionId, false); // Attempt mutation internally, no cost check here
                effectDescription = "Chaotic Fluctuation Triggered Mutation";
            } else {
                 dim.stability = dim.stability * 90 / 100; // Lose some stability if no mutation
                 effectDescription = "Chaotic Destabilization";
            }
        } else if (isOwner && dim.dimensionType == DimensionType.Stable && dim.stability > 700) {
             // Owner benefit: small immediate energy claim
            uint256 generated = getDimensionGeneratedEnergy(dimensionId);
            uint256 claimAmount = generated > 1000 ? 1000 : generated; // Claim up to 1000
            if (claimAmount > 0) {
                 _nexusEnergyBalances[msg.sender] += claimAmount;
                 totalNexusEnergy += claimAmount; // Increase total supply
                 // Don't update lastClaimTime unless full claim is possible/done
                 effectDescription = string(abi.encodePacked("Owner Collected Partial Energy (", uint256(claimAmount).toString(), ")"));
            } else {
                 effectDescription = "Stable Field Hum";
            }
        }
        // Add more complex effects based on specific frequency ranges, type combinations, etc.

        emit DimensionResonated(dimensionId, msg.sender, effectDescription);
    }


    // --- Advanced Transformations ---

    function mergeDimensions(uint256 dimensionId1, uint256 dimensionId2) external whenNotPaused {
        if (dimensionId1 == dimensionId2) revert CannotMergeSameDimension();
        Dimension storage dim1 = _dimensions[dimensionId1];
        Dimension storage dim2 = _dimensions[dimensionId2];

        if (!dim1.exists || !dim2.exists) revert InvalidDimensionIds();
        if (dim1.owner != msg.sender || dim2.owner != msg.sender) revert NotOwnerOfDimension(0, msg.sender); // Use 0 or specific error

        uint256 cost = params.mergeCostEnergy;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);

        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        // --- Merge Logic ---
        // Example: Combine properties, maybe average stability, sum energy, new frequency/type?
        uint256 newId = _nextDimensionId++;
        uint64 currentTime = uint64(block.timestamp);

        uint256 newInternalEnergy = dim1.internalEnergy + dim2.internalEnergy;
        uint256 newStability = (dim1.stability + dim2.stability) / 2; // Average stability
        uint256 newFrequency = (dim1.resonanceFrequency + dim2.resonanceFrequency) / 2; // Average frequency

        // Logic for determining new type could be complex:
        // - Weighted chance based on input types
        // - Specific combinations lead to specific output types
        // - Higher stability/energy increases chance of better type
        DimensionType newType = DimensionType.Void; // Default
        uint256 typeRandomness = uint256(keccak256(abi.encodePacked(dimensionId1, dimensionId2, currentTime, msg.sender)));

        if (dim1.dimensionType == DimensionType.Stable && dim2.dimensionType == DimensionType.Stable && newStability > 800) {
             newType = DimensionType.Stable; // Keep Stable if both are stable and result is highly stable
        } else if ((dim1.dimensionType == DimensionType.Ephemeral && dim2.dimensionType == DimensionType.Chaotic) ||
                   (dim1.dimensionType == DimensionType.Chaotic && dim2.dimensionType == DimensionType.Ephemeral)) {
             newType = DimensionType.Chaotic; // Specific combo -> Chaotic
        } else if (newInternalEnergy > 2000 && newStability > 900 && typeRandomness % 100 < 5) { // 5% chance for high stats
             newType = DimensionType.NexusPrime; // Rare chance for high-tier type
        } else {
             // Default based on some logic, e.g., higher stats lean towards Stable/Resonant
             if (newStability > 600 && newInternalEnergy > 500 && typeRandomness % 2 == 0) newType = DimensionType.Stable;
             else if (newFrequency > 700 && typeRandomness % 2 == 1) newType = DimensionType.Resonant;
             else newType = (typeRandomness % 2 == 0) ? DimensionType.Ephemeral : DimensionType.Void; // Fallback
        }


        _dimensions[newId] = Dimension({
            id: newId,
            owner: msg.sender,
            creationTime: currentTime,
            lastInteractionTime: currentTime,
            lastClaimTime: currentTime, // New dimension starts fresh claim cycle
            internalEnergy: newInternalEnergy,
            stability: newStability,
            resonanceFrequency: newFrequency,
            dimensionType: newType,
            exists: true
        });

        _addOwnerDimension(msg.sender, newId);

        // Burn the original dimensions
        _burnDimension(dimensionId1);
        _burnDimension(dimensionId2);

        emit DimensionsMerged(dimensionId1, dimensionId2, newId);
    }

    function splitDimension(uint256 dimensionId) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);

        uint256 cost = params.splitCostEnergy;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);
        // Add minimum requirements for splitting? e.g., min energy, min stability
        if (dim.internalEnergy < 500 || dim.stability < 400) revert SplitFailed("Dimension too low energy or stability to split.");


        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        // --- Split Logic ---
        uint256 newId1 = _nextDimensionId++;
        uint256 newId2 = _nextDimensionId++;
        uint64 currentTime = uint64(block.timestamp);

        // Example: Divide properties, maybe some loss, new frequencies/types?
        uint256 splitEnergy1 = dim.internalEnergy / 2;
        uint256 splitEnergy2 = dim.internalEnergy - splitEnergy1; // Handle odd numbers
        uint256 splitStability1 = dim.stability * 45 / 100; // Lose some stability during split
        uint256 splitStability2 = dim.stability * 45 / 100;

        // New frequencies could be perturbations of the original
        uint256 freqOffset1 = uint256(keccak256(abi.encodePacked(dimensionId, currentTime, msg.sender, 1))) % 200 - 100; // +/- 100
        uint256 freqOffset2 = uint256(keccak256(abi.encodePacked(dimensionId, currentTime, msg.sender, 2))) % 200 - 100;
        uint256 newFrequency1 = (dim.resonanceFrequency + freqOffset1) % 1000;
        uint256 newFrequency2 = (dim.resonanceFrequency + freqOffset2) % 1000;


        // New types could be same as original, or degenerate, or a random split
        DimensionType newType1 = dim.dimensionType;
        DimensionType newType2 = dim.dimensionType;
         uint256 typeRandomness = uint256(keccak256(abi.encodePacked(dimensionId, currentTime, msg.sender)));
         if (typeRandomness % 100 < 10) { // 10% chance one becomes Void
             newType1 = DimensionType.Void;
         } else if (typeRandomness % 100 < 20) { // 10% chance the other becomes Void
             newType2 = DimensionType.Void;
         }


        _dimensions[newId1] = Dimension({
            id: newId1,
            owner: msg.sender,
            creationTime: currentTime,
            lastInteractionTime: currentTime,
            lastClaimTime: currentTime,
            internalEnergy: splitEnergy1,
            stability: splitStability1,
            resonanceFrequency: newFrequency1,
            dimensionType: newType1,
            exists: true
        });

        _dimensions[newId2] = Dimension({
            id: newId2,
            owner: msg.sender,
            creationTime: currentTime,
            lastInteractionTime: currentTime,
            lastClaimTime: currentTime,
            internalEnergy: splitEnergy2,
            stability: splitStability2,
            resonanceFrequency: newFrequency2,
            dimensionType: newType2,
            exists: true
        });

        _addOwnerDimension(msg.sender, newId1);
        _addOwnerDimension(msg.sender, newId2);

        // Burn the original dimension
        _burnDimension(dimensionId);

        emit DimensionSplit(dimensionId, newId1, newId2);
    }

    function triggerMutation(uint256 dimensionId) external whenNotPaused {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId);
        if (dim.owner != msg.sender) revert NotOwnerOfDimension(dimensionId, msg.sender);

        uint256 cost = params.mutationCostEnergy;
        if (_nexusEnergyBalances[msg.sender] < cost) revert InsufficientNexusEnergy(cost, _nexusEnergyBalances[msg.sender]);
        // Add minimum requirements for mutation? e.g., min energy
         if (dim.internalEnergy < 300) revert MutationFailed("Dimension too low energy to mutate.");


        _nexusEnergyBalances[msg.sender] -= cost;
        totalNexusEnergy -= cost; // Burn cost energy

        _triggerMutation(dimensionId, true); // Call internal helper
    }

    function _triggerMutation(uint256 dimensionId, bool consumeEnergyCost) private {
         Dimension storage dim = _dimensions[dimensionId];
         // Internal function assumes basic checks passed if called from public triggerMutation
         // If called from other internal functions (like resonate), it won't consume energy here

         // Success chance based on stability
         uint256 currentStabilityScore = calculateStabilityScore(dimensionId); // Percentage 0-100
         // Higher stability = higher chance of *positive* mutation or success
         // Lower stability = higher chance of *negative* mutation or failure
         uint256 mutationRandomness = uint256(keccak256(abi.encodePacked(dimensionId, block.timestamp, msg.sender, block.difficulty))); // Pseudo-randomness

         bool success = (mutationRandomness % 100 < (currentStabilityScore/2 + params.mutationSuccessStabilityThreshold/2)); // Example success chance scaling

         DimensionType oldType = dim.dimensionType;
         uint256 oldFrequency = dim.resonanceFrequency;
         uint256 oldStability = dim.stability;
         uint256 oldInternalEnergy = dim.internalEnergy;

         DimensionType newType = oldType;
         uint256 newFrequency = oldFrequency;
         uint256 newStability = oldStability;
         uint256 newInternalEnergy = oldInternalEnergy;

         if (success) {
             // Successful Mutation: Tend towards 'better' types, adjust properties positively
             newType = DimensionType(mutationRandomness % uint8(DimensionType.NexusPrime + 1)); // Can mutate to any type
             newFrequency = (oldFrequency + (mutationRandomness % 400) - 200) % 1000; // Shift frequency +/- 200
             newStability = oldStability + (oldStability * (mutationRandomness % 20) / 100); // Gain up to 20% stability
             newInternalEnergy = oldInternalEnergy + (oldInternalEnergy * (mutationRandomness % 15) / 100); // Gain up to 15% energy

             // Special case: NexusPrime is rare and perhaps cannot be mutated *from* easily, or is a final state
             if (oldType == DimensionType.NexusPrime && newType != DimensionType.NexusPrime) {
                 // Reduce chance of losing NexusPrime, or revert type
                 if (mutationRandomness % 100 < 90) newType = DimensionType.NexusPrime;
             }


         } else {
             // Failed/Negative Mutation: Tend towards 'worse' types, adjust properties negatively
             newType = DimensionType(mutationRandomness % uint8(DimensionType.Stable)); // Tend towards Void, Ephemeral, Chaotic
             if (newType > oldType && oldType != DimensionType.Void) newType = oldType; // Less likely to improve type on failure

             newFrequency = (oldFrequency + (mutationRandomness % 300)) % 1000; // Larger frequency shift
             newStability = oldStability * (mutationRandomness % 30 + 50) / 100; // Lose 50-80% stability!
             newInternalEnergy = oldInternalEnergy * (mutationRandomness % 20 + 70) / 100; // Lose 70-90% energy!

             if (newStability < 10) newStability = 10; // Minimum stability
             if (newInternalEnergy < 10) newInternalEnergy = 10; // Minimum energy
         }

         dim.dimensionType = newType;
         dim.resonanceFrequency = newFrequency;
         dim.stability = newStability;
         dim.internalEnergy = newInternalEnergy;

         dim.lastInteractionTime = uint64(block.timestamp);

         emit DimensionMutated(dimensionId, success, newType, newFrequency);
    }


    // --- Internal Dimension Burning ---
    // Used when dimensions are consumed (merged, split original)

    function _burnDimension(uint256 dimensionId) private {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) revert DimensionDoesNotExist(dimensionId); // Should not happen if called internally correctly

        // Refund any unclaimed energy to the owner before burning
        uint256 generated = getDimensionGeneratedEnergy(dimensionId);
        if (generated > 0) {
             _nexusEnergyBalances[dim.owner] += generated;
             totalNexusEnergy += generated; // Increase total supply
             emit NexusEnergyClaimed(dim.owner, dimensionId, generated); // Log the forced claim
        }


        // Remove from owner's list
        _removeOwnerDimension(dim.owner, dimensionId);

        // Mark as non-existent
        dim.exists = false; // Simpler than deleting the struct
        // Reset critical fields to prevent accidental use of old data
        dim.owner = address(0);
        dim.internalEnergy = 0;
        dim.stability = 0;
        // ID, creationTime, lastInteractionTime, lastClaimTime, type, frequency remain as historical data if needed, but `exists` flag is the primary check.

        emit DimensionBurned(dimensionId);
    }


    // --- View Functions ---

    function getNexusEnergyBalance(address user) external view returns (uint256) {
        return _nexusEnergyBalances[user];
    }

    function getDimensionEnergyGenerationRate(uint256 dimensionId) public view returns (uint256) {
         Dimension storage dim = _dimensions[dimensionId];
         if (!dim.exists) return 0; // Or revert? Returning 0 is safer for external calls
         // Example rate: Stability * parameter rate, with minimum
         uint256 rate = dim.stability * params.energyGenerationRatePerStability / 1000; // Scale by 1000 for finer control
         if (rate < 1) rate = 1; // Minimum generation
         // Apply type modifier?
         if (dim.dimensionType == DimensionType.Ephemeral) rate = rate * 150 / 100; // 50% boost
         if (dim.dimensionType == DimensionType.Stable) rate = rate * 120 / 100; // 20% boost
         if (dim.dimensionType == DimensionType.NexusPrime) rate = rate * 200 / 100; // 100% boost
         if (dim.dimensionType == DimensionType.Void) rate = rate * 50 / 100; // 50% penalty
         return rate;
    }

    function getDimensionGeneratedEnergy(uint256 dimensionId) public view returns (uint256) {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) return 0;
        uint256 timeElapsed = block.timestamp - dim.lastClaimTime;
        uint256 rate = getDimensionEnergyGenerationRate(dimensionId);
        return timeElapsed * rate; // Simplified: Linear generation over time
         // Could add stability decay over time if no interaction
         // uint256 timeSinceInteraction = block.timestamp - dim.lastInteractionTime;
         // uint256 stabilityLost = timeSinceInteraction * params.stabilityDecayRate;
         // int256 effectiveStability = int256(dim.stability) - int256(stabilityLost);
         // if (effectiveStability < 0) effectiveStability = 0;
         // uint256 rate = uint256(effectiveStability) * params.energyGenerationRatePerStability / 1000;
         // return timeElapsed * rate; // Rate based on decayed stability
    }

    function calculateStabilityScore(uint256 dimensionId) public view returns (uint256) {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) return 0;
        // Simple score based on raw stability, normalized to 0-100
        // Max possible stability could be defined or unbounded. Assume practical max for scoring.
        // Let's assume 10000 stability points is a good range for 100% score
        uint256 maxScoreStability = 10000;
        if (dim.stability >= maxScoreStability) return 100;
        return dim.stability * 100 / maxScoreStability; // Returns percentage 0-100
    }

     function predictResonanceEffect(uint256 dimensionId) external view returns (string memory) {
        Dimension storage dim = _dimensions[dimensionId];
        if (!dim.exists) return "Dimension does not exist.";

        // This is a *prediction* helper, doesn't need to match the actual effect exactly,
        // especially if effects have probabilities or hidden factors.
        // Provide hints based on type and frequency range.
        if (dim.dimensionType == DimensionType.Resonant && dim.resonanceFrequency > 800) {
             return "Likely Energy Amplification";
        } else if (dim.dimensionType == DimensionType.Chaotic && dim.stability < 300) {
             return "Potential for Fluctuation (Maybe Mutation)";
        } else if (dim.dimensionType == DimensionType.Stable && dim.stability > 700) {
             return "Stable Field Effect (Possible Owner Benefit)";
        } else if (dim.dimensionType == DimensionType.Ephemeral) {
             return "Volatile Effect Expected";
        } else if (dim.dimensionType == DimensionType.NexusPrime) {
             return "Rare & Powerful Effect Possible";
        } else {
             return "Standard Interaction Effect";
        }
    }

    function getDimensionLastClaimTime(uint256 dimensionId) external view returns (uint64) {
         if (!_dimensions[dimensionId].exists) return 0;
         return _dimensions[dimensionId].lastClaimTime;
    }

    // Internal helper view (could be external for debugging)
    function getDimensionOwnerIndex(uint256 dimensionId) external view returns (uint256) {
         if (!_dimensions[dimensionId].exists) revert DimensionDoesNotExist(dimensionId);
         return _dimensionOwnerIndex[dimensionId];
    }
}

// Helper contract for address.toString()
library Strings {
    bytes16 private constant alphabet = "0123456789abcdef";

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(length);
        uint256 ptr = length - 1;
        temp = value;
        while (temp != 0) {
            buffer[ptr--] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        return string(buffer);
    }

     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length; i > 0; i--) {
            buffer[i + 1] = alphabet[value % 16];
            value /= 16;
        }
        return string(buffer);
    }

     function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 length = 0;
        uint256 temp = value;
        while (temp != 0) {
            length++;
            temp >>= 4;
        }
        return toHexString(value, length);
    }

     function toString(address account) internal pure returns (string memory) {
        return toHexString(uint160(account), 20);
    }
}
```

**Explanation of Advanced/Creative Concepts:**

1.  **Stateful, Evolving Assets:** Dimensions are not just IDs with metadata; their core properties (`internalEnergy`, `stability`, `resonanceFrequency`, `dimensionType`) are stored on-chain and change dynamically based on user interactions and internal logic. This moves beyond static NFTs or simple token balances.
2.  **Internal Economy (Nexus Energy):** The contract manages its own fungible resource (`Nexus Energy`) that is distinct from standard tokens. Its value is tied directly to the ETH held within the contract, creating a closed loop where users deposit ETH to get energy and burn energy to get ETH back. This minimizes reliance on external ERC-20s for core mechanics and keeps the value system self-contained within the Nexus. Passive generation from dimensions adds another layer to this economy.
3.  **Complex Asset Transformations (Merge/Split/Mutate):** Instead of just minting/burning fixed assets, Dimensions can be combined (`mergeDimensions`) or broken apart (`splitDimension`), with their properties influencing the outcome. `triggerMutation` adds a layer of unpredictable, potentially disruptive change, similar to genetic algorithms or evolutionary simulations. These mechanics are non-standard for typical token contracts.
4.  **Parameterized & Dynamic Interactions:** The outcome of interactions (`depositEnergy`, `extractEssence`, etc.) isn't always a fixed change. `extractEssence` has a success chance tied to stability. `resonateWithDimension` triggers different effects based on the dimension's current type and frequency. This creates a deeper simulation layer. Contract parameters (`params`) allow the owner to tune the balance and economics of these interactions over time.
5.  **Pseudo-Randomness for Unpredictability:** Using `keccak256` with block variables and other dynamic data provides on-chain pseudo-randomness for effects like mutation success, frequency shifts, and initial dimension properties. While not cryptographically secure against sophisticated miners, it's sufficient for many game-like or generative mechanics on-chain where perfect unpredictability isn't critical for high-value security. (Note: For truly high-stakes randomness, Chainlink VRF or similar is recommended, but adds external dependency complexity).
6.  **Dimension as a Resource Generator:** Stable dimensions passively generate the critical `Nexus Energy` resource. This creates an incentive to maintain dimensions and adds a yield-farming-like element directly tied to the state of the custom asset.

This contract goes beyond typical token standards by making the digital assets dynamic participants in an internal ecosystem governed by specific interaction rules and transformation mechanics.

*Note: This code is complex and intended as a creative concept. It would require thorough testing, gas optimization, security audits, and careful consideration of economic balance if intended for production use. The complexity of state management for `_ownerDimensions` in `_safeTransferOwnership`, `_addOwnerDimension`, and `_removeOwnerDimension` needs rigorous testing.*