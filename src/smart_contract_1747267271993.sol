Okay, let's design a complex, unique smart contract. We'll create an "AstroGenesis Engine" â€“ a system for dynamic, evolving digital entities ("Celestials") that interact within epochs, consume and generate resources ("CosmicEssence"), and can be combined or evolved.

This contract will incorporate:
1.  **Dynamic State:** Celestial attributes change, and global rules evolve over epochs.
2.  **Resource Management:** An associated ERC20 token (`CosmicEssence`) is central to interactions (creation, evolution, generation).
3.  **Crafting/Genesis:** Combining existing Celestials (or using Essence) to create new, unique ones.
4.  **Evolution:** Transforming an existing Celestial into a higher form.
5.  **Staking/Yield:** Staking Celestials generates `CosmicEssence`.
6.  **Epoch System:** Time-based progression that can alter game mechanics (e.g., generation rates).
7.  **Complexity Scoring:** Celestials have a calculated complexity affecting mechanics.
8.  **Role-Based Access:** Admin functions for managing recipes and epochs.
9.  **Basic ERC721 Compliance:** Handling ownership, transfers, and approvals for Celestials. (Implementing minimal logic instead of inheriting OpenZeppelin to avoid direct duplication).

**Disclaimer:** This contract is complex and for demonstration purposes. Deploying such a system requires significant testing, gas optimization, and security audits. Interactions with external ERC20 tokens carry standard risks (approvals, transfers).

---

# Smart Contract: AstroGenesis Engine

## Outline & Function Summary

**Contract Name:** AstroGenesisEngine

**Description:**
A smart contract that manages a collection of dynamic, non-fungible digital entities called "Celestials". Celestials possess unique attributes, can be created through genesis or evolution processes requiring a fungible "CosmicEssence" token, and can be staked to generate more Essence over time, influenced by system epochs. This contract handles Celestial ownership (ERC721-like), attribute management, recipe definitions, epoch progression, and resource flow with the associated Essence token.

**Core Concepts:**
*   **Celestial:** A unique, dynamic NFT-like entity with attributes (`luminosity`, `stability`, `resonance`, etc.), a calculated `complexity`, and state (staked, owner, type).
*   **CosmicEssence:** An ERC20 token used as a resource for creation, evolution, and generated by staked Celestials. (Address provided at deployment).
*   **Epoch:** A time-based period managed by the contract owner. Rules (like Essence generation rates) can change per epoch.
*   **Genesis:** A process consuming input ingredients (Essence + optional other Celestials) to mint a *new* Celestial of a specific type.
*   **Evolution:** A process consuming Essence and transforming an *existing* Celestial into a different type or state (same ID, updated attributes/type).
*   **Staking:** Locking a Celestial to enable periodic Essence generation.
*   **Celestial Type:** A blueprint defining base attributes, generation rates, and associated recipes.
*   **Recipe:** Defines the inputs and outputs for Genesis or Evolution processes.

**Data Structures:**
*   `Attributes`: Struct holding core numeric properties of a Celestial.
*   `Celestial`: Struct holding ID, owner, type, attributes, state, and history info for each unique Celestial.
*   `CelestialType`: Struct defining properties for a category of Celestials.
*   `GenesisRecipe`: Struct defining inputs (Essence, required types) and output type for Genesis.
*   `EvolutionRecipe`: Struct defining input Celestial type, Essence cost, and output Celestial type for Evolution.

**Outline:**
1.  Pragma and Interfaces (IERC20)
2.  Errors
3.  Events
4.  Struct Definitions
5.  State Variables
6.  Modifiers
7.  Constructor
8.  Basic ERC721 Implementation (minimal, for ownership/transfer/approval)
9.  Admin Functions (Register types/recipes, manage epochs, manage essence pool)
10. Core User Interaction Functions (Genesis, Evolution, Staking, Harvesting, Transfers)
11. View Functions (Get data, calculate values)
12. Internal Helper Functions

**Function Summary (Public/External/View):**

1.  `constructor(address _essenceTokenAddress, uint256 initialEpochMultiplier)`: Deploys the contract, sets owner and Essence token address, initializes epoch.
2.  `owner()`: Returns contract owner (Admin).
3.  `registerCelestialType(uint256 typeId, string calldata name, Attributes memory baseAttributes, uint256 essenceGenerationRate, uint256 genesisCostEssence, uint256 evolutionCostEssence)`: Admin function to define a new Celestial type blueprint.
4.  `registerGenesisRecipe(uint256 recipeId, uint256[] calldata requiredInputTypes, uint256 requiredEssence, uint256 outputCelestialTypeId)`: Admin function to define a Genesis recipe.
5.  `registerEvolutionRecipe(uint256 recipeId, uint256 inputCelestialTypeId, uint256 requiredEssence, uint256 outputCelestialTypeId)`: Admin function to define an Evolution recipe.
6.  `progressEpoch(uint256 newEpochMultiplier)`: Admin function to advance the system to the next epoch, setting a new multiplier.
7.  `depositEssenceToPool(uint256 amount)`: Admin function to add Essence to the contract's balance (e.g., for future rewards or ecosystem use).
8.  `withdrawEssenceFromPool(uint256 amount)`: Admin function to withdraw Essence from the contract's balance.
9.  `mintGenesisCelestial(uint256 recipeId, uint256[] calldata inputCelestialIds)`: User initiates Genesis using a recipe, consuming inputs and Essence, minting a new Celestial.
10. `evolveCelestial(uint256 celestialId, uint256 recipeId)`: User initiates Evolution for a specific Celestial using a recipe, consuming Essence and updating the Celestial's type/attributes.
11. `harvestCosmicEssence(uint256[] calldata celestialIds)`: User claims accumulated Essence from their staked Celestials.
12. `stakeCelestial(uint256 celestialId)`: User stakes their Celestial.
13. `unstakeCelestial(uint256 celestialId)`: User unstakes their Celestial.
14. `transferFrom(address from, address to, uint256 tokenId)`: Basic ERC721 transfer function.
15. `safeTransferFrom(address from, address to, uint256 tokenId)`: Basic ERC721 safe transfer function.
16. `approve(address to, uint256 tokenId)`: Basic ERC721 approval function.
17. `setApprovalForAll(address operator, bool approved)`: Basic ERC721 operator approval function.
18. `balanceOf(address owner)`: Basic ERC721 getter for owner's token count.
19. `ownerOf(uint256 tokenId)`: Basic ERC721 getter for token owner.
20. `getApproved(uint256 tokenId)`: Basic ERC721 getter for approved address.
21. `isApprovedForAll(address owner, address operator)`: Basic ERC721 getter for operator approval status.
22. `getCelestial(uint256 celestialId)`: View function to get detailed info about a Celestial.
23. `getCelestialAttributes(uint256 celestialId)`: View function to get just the attributes of a Celestial.
24. `getCelestialTypeDetails(uint256 typeId)`: View function to get details of a Celestial type blueprint.
25. `getGenesisRecipeDetails(uint256 recipeId)`: View function to get details of a Genesis recipe.
26. `getEvolutionRecipeDetails(uint256 recipeId)`: View function to get details of an Evolution recipe.
27. `getCurrentEpoch()`: View function to get the current epoch number.
28. `getEpochMultiplier(uint256 epoch)`: View function to get the multiplier for a specific epoch.
29. `calculatePendingEssence(uint256 celestialId)`: View function to calculate harvestable Essence for a single Celestial.
30. `calculateCelestialComplexity(uint256 celestialId)`: View function to get the calculated complexity of a Celestial. (Or calculate it dynamically). Let's make it dynamic for simplicity.
31. `getTotalCelestials()`: View function for total number of Celestials minted.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

// Custom Errors
error NotOwner();
error NotApprovedOrOwner();
error AlreadyStaked();
error NotStaked();
error TransferNotAllowedWhileStaked();
error InvalidCelestialId();
error InvalidCelestialType();
error InvalidGenesisRecipe();
error InvalidEvolutionRecipe();
error InsufficientEssence();
error GenesisInputsMismatch();
error EvolutionInputMismatch();
error NoEssenceToHarvest();
error NothingToWithdraw();

// Events
event CelestialMinted(uint256 indexed tokenId, address indexed owner, uint256 celestialTypeId, uint256 creationEpoch);
event CelestialTransferred(address indexed from, address indexed to, uint256 indexed tokenId);
event CelestialEvolved(uint256 indexed tokenId, uint256 newTypeId, uint256 evolutionEpoch);
event CelestialStaked(uint256 indexed tokenId, address indexed owner, uint256 epoch);
event CelestialUnstaked(uint256 indexed tokenId, address indexed owner, uint256 epoch);
event EssenceHarvested(address indexed owner, uint256 amount, uint256 indexed epoch);
event EpochProgressed(uint256 indexed newEpoch, uint256 newMultiplier);
event CelestialTypeRegistered(uint256 indexed typeId);
event GenesisRecipeRegistered(uint256 indexed recipeId);
event EvolutionRecipeRegistered(uint256 indexed recipeId);
event EssenceDeposited(address indexed depositor, uint256 amount);
event EssenceWithdrawal(address indexed recipient, uint256 amount);
event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
event ApprovalForAll(address indexed owner, address indexed operator, bool approved);


contract AstroGenesisEngine {
    address private _owner;
    IERC20 public immutable essenceToken;

    struct Attributes {
        uint256 luminosity; // Affects essence generation, maybe evolution
        uint256 stability; // Affects essence generation, maybe complexity
        uint256 resonance; // Affects genesis outcomes, maybe complexity
        // Add more attributes as needed
    }

    struct Celestial {
        uint256 id;
        address owner; // ERC721 standard compliance helper
        uint256 celestialTypeId;
        uint256 creationEpoch;
        Attributes attributes;
        uint256 lastHarvestEpoch; // Last epoch essence was harvested
        bool isStaked;
    }

    struct CelestialType {
        string name;
        Attributes baseAttributes; // Starting attributes
        uint256 essenceGenerationRate; // Base essence/epoch generated when staked
        uint256 genesisCostEssence; // Base essence cost to create this type via genesis
        uint256 evolutionCostEssence; // Base essence cost to evolve *to* this type
        // Add more type-specific properties
    }

    struct GenesisRecipe {
        uint256[] requiredInputTypes; // Array of required Celestial Type IDs as ingredients
        uint256 requiredEssence; // Essence cost
        uint256 outputCelestialTypeId; // Resulting Celestial Type ID
        // Could add output attribute modifiers here
    }

    struct EvolutionRecipe {
        uint256 inputCelestialTypeId; // Celestial Type ID required to evolve
        uint256 requiredEssence; // Essence cost
        uint256 outputCelestialTypeId; // Resulting Celestial Type ID
        // Could add output attribute modifiers here
    }

    // --- State Variables ---
    mapping(uint256 => Celestial) public celestials; // tokenId => Celestial struct
    mapping(uint256 => address) private _tokenOwners; // ERC721: tokenId => owner
    mapping(address => uint256) private _balanceOf; // ERC721: owner => count
    mapping(uint256 => address) private _tokenApprovals; // ERC721: tokenId => approvedAddress
    mapping(address => mapping(address => bool)) private _operatorApprovals; // ERC721: owner => operator => approved

    uint256 private _nextTokenId; // Counter for unique Celestial IDs

    mapping(uint256 => CelestialType) public celestialTypes; // typeId => CelestialType struct
    uint256 private _nextCelestialTypeId = 1; // Start Type IDs from 1

    mapping(uint256 => GenesisRecipe) public genesisRecipes; // recipeId => GenesisRecipe struct
    uint256 private _nextGenesisRecipeId = 1; // Start Recipe IDs from 1

    mapping(uint256 => EvolutionRecipe) public evolutionRecipes; // recipeId => EvolutionRecipe struct
    uint256 private _nextEvolutionRecipeId = 1; // Start Recipe IDs from 1

    uint256 public currentEpoch;
    mapping(uint256 => uint256) public epochMultipliers; // epoch => essence generation multiplier


    // --- Modifiers ---
    modifier onlyOwner() {
        if (msg.sender != _owner) revert NotOwner();
        _;
    }

    modifier celestialExists(uint256 _celestialId) {
        if (_tokenOwners[_celestialId] == address(0) && _celestials[_celestialId].id == 0) revert InvalidCelestialId(); // Check existence
        _;
    }

    modifier onlyCelestialOwner(uint256 _celestialId) {
        if (_tokenOwners[_celestialId] != msg.sender) revert NotOwner(); // More specific error?
        _;
    }

    modifier onlyApprovedOrOwner(uint256 _celestialId) {
        if (_tokenOwners[_celestialId] != msg.sender && getApproved(_celestialId) != msg.sender && !isApprovedForAll(_tokenOwners[_celestialId], msg.sender)) {
            revert NotApprovedOrOwner();
        }
        _;
    }

    // --- Constructor ---
    constructor(address _essenceTokenAddress, uint256 initialEpochMultiplier) {
        _owner = msg.sender;
        essenceToken = IERC20(_essenceTokenAddress);
        currentEpoch = 1;
        epochMultipliers[currentEpoch] = initialEpochMultiplier;
        _nextTokenId = 1; // Celestial IDs start from 1
    }

    // --- Basic ERC721 Implementation ---
    // Note: This is a minimal implementation. A full ERC721 standard contract often
    // inherits from OpenZeppelin's ERC721 base, but we implement it here
    // to avoid direct library duplication as requested, focusing on core logic.

    function balanceOf(address owner) public view returns (uint256) {
        if (owner == address(0)) revert InvalidCelestialId(); // ERC721 spec requires non-zero address
        return _balanceOf[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _tokenOwners[tokenId];
        if (owner == address(0)) revert InvalidCelestialId();
        return owner;
    }

    function getApproved(uint256 tokenId) public view returns (address) {
        if (_tokenOwners[tokenId] == address(0)) revert InvalidCelestialId(); // Token must exist
        return _tokenApprovals[tokenId];
    }

    function isApprovedForAll(address owner, address operator) public view returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function approve(address to, uint256 tokenId) public onlyApprovedOrOwner(tokenId) celestialExists(tokenId) {
        if (ownerOf(tokenId) == to) revert InvalidCelestialId(); // Cannot approve self
        _tokenApprovals[tokenId] = to;
        emit Approval(_tokenOwners[tokenId], to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public {
        if (operator == msg.sender) revert InvalidCelestialId(); // Cannot approve self as operator
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(address from, address to, uint256 tokenId) public celestialExists(tokenId) {
         if (from != _tokenOwners[tokenId]) revert NotOwner(); // Must be current owner
         if (to == address(0)) revert InvalidCelestialId(); // Cannot transfer to zero address

         // Check authorization: sender is owner, approved address, or approved operator
         if (msg.sender != from && getApproved(tokenId) != msg.sender && !isApprovedForAll(from, msg.sender)) {
             revert NotApprovedOrOwner();
         }

         // Prevent transfer if staked
         if (celestials[tokenId].isStaked) revert TransferNotAllowedWhileStaked();

         _transfer(from, to, tokenId);
    }

     function safeTransferFrom(address from, address to, uint256 tokenId) public {
         safeTransferFrom(from, to, tokenId, "");
     }

     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public celestialExists(tokenId) {
         transferFrom(from, to, tokenId); // Perform standard transfer

         // Check if recipient is a contract and supports ERC721 received hook
         if (to.code.length > 0) {
             require(
                 _checkOnERC721Received(address(0), from, to, tokenId, data), // Use address(0) for operator as per spec when operator is the contract itself
                 "ERC721: transfer to non ERC721Receiver implementer"
             );
         }
     }

    // --- Admin Functions ---
    function registerCelestialType(
        uint256 typeId,
        string calldata name,
        Attributes memory baseAttributes,
        uint256 essenceGenerationRate,
        uint256 genesisCostEssence,
        uint256 evolutionCostEssence
    ) external onlyOwner {
        if (celestialTypes[typeId].baseAttributes.luminosity != 0 || typeId == 0) revert InvalidCelestialType(); // Check if ID is already used (using attribute check as a proxy) or is zero.

        celestialTypes[typeId] = CelestialType(
            name,
            baseAttributes,
            essenceGenerationRate,
            genesisCostEssence,
            evolutionCostEssence
        );
        emit CelestialTypeRegistered(typeId);
    }

    function registerGenesisRecipe(
        uint256 recipeId,
        uint256[] calldata requiredInputTypes,
        uint256 requiredEssence,
        uint256 outputCelestialTypeId
    ) external onlyOwner {
         if (genesisRecipes[recipeId].outputCelestialTypeId != 0 || recipeId == 0) revert InvalidGenesisRecipe(); // Check if ID is already used or is zero.
         if (celestialTypes[outputCelestialTypeId].baseAttributes.luminosity == 0) revert InvalidCelestialType(); // Output type must exist

        genesisRecipes[recipeId] = GenesisRecipe(
            requiredInputTypes,
            requiredEssence,
            outputCelestialTypeId
        );
        emit GenesisRecipeRegistered(recipeId);
    }

    function registerEvolutionRecipe(
        uint256 recipeId,
        uint256 inputCelestialTypeId,
        uint256 requiredEssence,
        uint256 outputCelestialTypeId
    ) external onlyOwner {
         if (evolutionRecipes[recipeId].outputCelestialTypeId != 0 || recipeId == 0) revert InvalidEvolutionRecipe(); // Check if ID is already used or is zero.
         if (celestialTypes[inputCelestialTypeId].baseAttributes.luminosity == 0 || celestialTypes[outputCelestialTypeId].baseAttributes.luminosity == 0) revert InvalidCelestialType(); // Input/Output types must exist

        evolutionRecipes[recipeId] = EvolutionRecipe(
            inputCelestialTypeId,
            requiredEssence,
            outputCelestialTypeId
        );
        emit EvolutionRecipeRegistered(recipeId);
    }

    function progressEpoch(uint256 newEpochMultiplier) external onlyOwner {
        currentEpoch++;
        epochMultipliers[currentEpoch] = newEpochMultiplier;
        // Future: Potentially trigger epoch-end events, recalculate state, etc.
        emit EpochProgressed(currentEpoch, newEpochMultiplier);
    }

    function depositEssenceToPool(uint256 amount) external onlyOwner {
        if (amount == 0) revert InsufficientEssence();
        // Owner transfers Essence to the contract address
        bool success = essenceToken.transferFrom(msg.sender, address(this), amount);
        if (!success) revert InsufficientEssence(); // More specific error if needed from token transfer failure
        emit EssenceDeposited(msg.sender, amount);
    }

    function withdrawEssenceFromPool(uint256 amount) external onlyOwner {
        if (amount == 0) revert NothingToWithdraw();
        if (essenceToken.balanceOf(address(this)) < amount) revert NothingToWithdraw();

        bool success = essenceToken.transfer(msg.sender, amount);
         if (!success) revert NothingToWithdraw(); // More specific error if needed
        emit EssenceWithdrawal(msg.sender, amount);
    }


    // --- Core User Interaction Functions ---

    function mintGenesisCelestial(uint256 recipeId, uint256[] calldata inputCelestialIds) external {
        GenesisRecipe storage recipe = genesisRecipes[recipeId];
        if (recipe.outputCelestialTypeId == 0) revert InvalidGenesisRecipe(); // Recipe must exist

        // 1. Check input Celestials
        if (recipe.requiredInputTypes.length != inputCelestialIds.length) revert GenesisInputsMismatch();

        mapping(uint256 => bool) processedInputs; // Prevent using same celestial twice in one genesis
        for (uint i = 0; i < inputCelestialIds.length; i++) {
            uint256 inputId = inputCelestialIds[i];
            if (_tokenOwners[inputId] != msg.sender) revert NotOwner(); // Must own the input
            if (celestials[inputId].isStaked) revert AlreadyStaked(); // Cannot use staked celestial
            if (celestials[inputId].celestialTypeId != recipe.requiredInputTypes[i]) revert GenesisInputsMismatch(); // Must match required type

            if (processedInputs[inputId]) revert GenesisInputsMismatch(); // Input already used
            processedInputs[inputId] = true;

            // Optionally burn or modify input celestials here
             _burn(inputId); // Example: Burn the input celestials
        }

        // 2. Check and transfer Essence cost
        if (essenceToken.balanceOf(msg.sender) < recipe.requiredEssence) revert InsufficientEssence();
        bool success = essenceToken.transferFrom(msg.sender, address(this), recipe.requiredEssence);
        if (!success) revert InsufficientEssence();

        // 3. Mint the new Celestial
        uint256 newCelestialId = _nextTokenId++;
        CelestialType storage outputType = celestialTypes[recipe.outputCelestialTypeId];
        if (outputType.baseAttributes.luminosity == 0) revert InvalidCelestialType(); // Output type must exist

        // Attributes calculation: Could be simple base + modifiers from inputs, or more complex
        Attributes memory finalAttributes = outputType.baseAttributes;
        // Add logic here to modify finalAttributes based on inputCelestialIds attributes
        // Example: finalAttributes.luminosity += celestials[inputId].attributes.luminosity / inputCelestialIds.length;

        celestials[newCelestialId] = Celestial(
            newCelestialId,
            msg.sender,
            recipe.outputCelestialTypeId,
            currentEpoch,
            finalAttributes,
            currentEpoch, // Reset harvest epoch
            false // Not staked initially
        );

        _mint(msg.sender, newCelestialId);

        emit CelestialMinted(newCelestialId, msg.sender, recipe.outputCelestialTypeId, currentEpoch);
    }

    function evolveCelestial(uint256 celestialId, uint256 recipeId) external onlyCelestialOwner(celestialId) celestialExists(celestialId) {
        EvolutionRecipe storage recipe = evolutionRecipes[recipeId];
        if (recipe.outputCelestialTypeId == 0) revert InvalidEvolutionRecipe(); // Recipe must exist

        // 1. Check Celestial requirements
        Celestial storage celestialToEvolve = celestials[celestialId];
        if (celestialToEvolve.isStaked) revert AlreadyStaked();
        if (celestialToEvolve.celestialTypeId != recipe.inputCelestialTypeId) revert EvolutionInputMismatch();

        // 2. Check and transfer Essence cost
        if (essenceToken.balanceOf(msg.sender) < recipe.requiredEssence) revert InsufficientEssence();
        bool success = essenceToken.transferFrom(msg.sender, address(this), recipe.requiredEssence);
        if (!success) revert InsufficientEssence();

        // 3. Evolve the Celestial (update state in place)
        CelestialType storage outputType = celestialTypes[recipe.outputCelestialTypeId];
        if (outputType.baseAttributes.luminosity == 0) revert InvalidCelestialType(); // Output type must exist

        // Attributes calculation: Could be simple replace, or merge/modify based on old attributes and output type
        celestialToEvolve.celestialTypeId = recipe.outputCelestialTypeId;
        celestialToEvolve.attributes = outputType.baseAttributes; // Simple replace
        // Add more complex attribute update logic here if needed
        celestialToEvolve.lastHarvestEpoch = currentEpoch; // Reset harvest epoch

        emit CelestialEvolved(celestialId, recipe.outputCelestialTypeId, currentEpoch);
    }

    function harvestCosmicEssence(uint256[] calldata celestialIds) external {
        uint256 totalEssenceToHarvest = 0;
        for (uint i = 0; i < celestialIds.length; i++) {
            uint256 celestialId = celestialIds[i];
            if (_tokenOwners[celestialId] != msg.sender) continue; // Skip if not owned by sender
            if (!celestials[celestialId].isStaked) continue; // Only harvest from staked

            uint256 pendingEssence = calculatePendingEssence(celestialId);
            if (pendingEssence > 0) {
                totalEssenceToHarvest += pendingEssence;
                celestials[celestialId].lastHarvestEpoch = currentEpoch; // Update last harvest epoch
            }
        }

        if (totalEssenceToHarvest == 0) revert NoEssenceToHarvest();

        // Transfer collected essence
        bool success = essenceToken.transfer(msg.sender, totalEssenceToHarvest);
        if (!success) revert NoEssenceToHarvest(); // Should not happen if balance check is sufficient, but safe fail

        emit EssenceHarvested(msg.sender, totalEssenceToHarvest, currentEpoch);
    }


    function stakeCelestial(uint256 celestialId) external onlyCelestialOwner(celestialId) celestialExists(celestialId) {
        if (celestials[celestialId].isStaked) revert AlreadyStaked();
        celestials[celestialId].isStaked = true;
        celestials[celestialId].lastHarvestEpoch = currentEpoch; // Start earning from this epoch
        emit CelestialStaked(celestialId, msg.sender, currentEpoch);
    }

    function unstakeCelestial(uint256 celestialId) external onlyCelestialOwner(celestialId) celestialExists(celestialId) {
        if (!celestials[celestialId].isStaked) revert NotStaked();

        // Optionally harvest pending essence on unstake
        uint256 pendingEssence = calculatePendingEssence(celestialId);
         if (pendingEssence > 0) {
             // Transfer collected essence
             bool success = essenceToken.transfer(msg.sender, pendingEssence);
              // If transfer fails, this is problematic. Consider implementing a claim function or
              // allowing unstake without harvest if transfer fails. For now, require success.
              if (!success) revert NoEssenceToHarvest(); // Revert if transfer fails on unstake

              celestials[celestialId].lastHarvestEpoch = currentEpoch; // Update only if harvest happened
         }

        celestials[celestialId].isStaked = false;
        emit CelestialUnstaked(celestialId, msg.sender, currentEpoch);
         if (pendingEssence > 0) {
             // Only emit harvest event if essence was successfully transferred
             emit EssenceHarvested(msg.sender, pendingEssence, currentEpoch);
         }
    }


    // --- View Functions ---

    function getCelestial(uint256 celestialId)
        public
        view
        celestialExists(celestialId)
        returns (
            uint256 id,
            address owner,
            uint256 celestialTypeId,
            uint256 creationEpoch,
            Attributes memory attributes,
            uint256 lastHarvestEpoch,
            bool isStaked,
            uint256 complexity // Include complexity here
        )
    {
        Celestial storage c = celestials[celestialId];
        return (
            c.id,
            _tokenOwners[celestialId], // Use _tokenOwners for current owner
            c.celestialTypeId,
            c.creationEpoch,
            c.attributes,
            c.lastHarvestEpoch,
            c.isStaked,
            calculateCelestialComplexity(celestialId) // Calculate on demand
        );
    }

    function getCelestialAttributes(uint256 celestialId) public view celestialExists(celestialId) returns (Attributes memory) {
        return celestials[celestialId].attributes;
    }

    function getCelestialTypeDetails(uint256 typeId) public view returns (CelestialType memory) {
        return celestialTypes[typeId]; // Returns zero-initialized struct if typeId doesn't exist
    }

     function getGenesisRecipeDetails(uint256 recipeId) public view returns (GenesisRecipe memory) {
        return genesisRecipes[recipeId]; // Returns zero-initialized struct if recipeId doesn't exist
    }

     function getEvolutionRecipeDetails(uint256 recipeId) public view returns (EvolutionRecipe memory) {
        return evolutionRecipes[recipeId]; // Returns zero-initialized struct if recipeId doesn't exist
    }


    function getCurrentEpoch() public view returns (uint256) {
        return currentEpoch;
    }

    function getEpochMultiplier(uint256 epoch) public view returns (uint256) {
        return epochMultipliers[epoch]; // Returns 0 if no multiplier set for epoch
    }

    function calculatePendingEssence(uint256 celestialId) public view celestialExists(celestialId) returns (uint256) {
        Celestial storage celestial = celestials[celestialId];
        if (!celestial.isStaked) {
            return 0;
        }

        CelestialType storage celestialType = celestialTypes[celestial.celestialTypeId];
        if (celestialType.baseAttributes.luminosity == 0) { // Check if type exists
            return 0;
        }

        uint256 epochsStaked = currentEpoch - celestial.lastHarvestEpoch;
        uint256 totalGenerated = 0;

        // Calculate generation epoch by epoch to apply multipliers
        for (uint256 epoch = celestial.lastHarvestEpoch + 1; epoch <= currentEpoch; epoch++) {
            uint256 multiplier = epochMultipliers[epoch];
             if (multiplier == 0) multiplier = 1; // Default multiplier is 1 if not set

            // Base generation rate * epoch multiplier * (1 + complexity bonus)
            // Complexity Bonus: Let's make it 1% per point of complexity over a base, capped.
            uint256 complexity = calculateCelestialComplexity(celestialId);
            uint256 complexityBonusPercent = complexity / 100; // Example: 100 complexity -> 1% bonus
            if (complexityBonusPercent > 50) complexityBonusPercent = 50; // Cap bonus at 50%

            uint256 epochGeneration = (celestialType.essenceGenerationRate * multiplier * (100 + complexityBonusPercent)) / 100;
             totalGenerated += epochGeneration;
        }

        return totalGenerated;
    }

    function calculateCelestialComplexity(uint256 celestialId) public view celestialExists(celestialId) returns (uint256) {
        Attributes memory attrs = celestials[celestialId].attributes;
        // Simple example complexity: sum of attributes
        return attrs.luminosity + attrs.stability + attrs.resonance;
    }

    function getTotalCelestials() public view returns (uint256) {
        return _nextTokenId - 1; // Since IDs start from 1
    }

    // --- Internal Helper Functions (ERC721 related) ---

    function _transfer(address from, address to, uint256 tokenId) internal {
        // Clear approvals
        _tokenApprovals[tokenId] = address(0);

        _balanceOf[from]--;
        _balanceOf[to]++;
        _tokenOwners[tokenId] = to;
        celestials[tokenId].owner = to; // Update owner in the Celestial struct as well

        emit CelestialTransferred(from, to, tokenId); // Use custom event for clarity alongside ERC721
         emit Transfer(from, to, tokenId); // ERC721 standard event
    }

    function _mint(address to, uint256 tokenId) internal {
        if (to == address(0)) revert InvalidCelestialId(); // Cannot mint to zero address
         if (_tokenOwners[tokenId] != address(0)) revert InvalidCelestialId(); // Token must not exist

        _tokenOwners[tokenId] = to;
        celestials[tokenId].owner = to; // Update owner in the Celestial struct
        _balanceOf[to]++;

        // Note: Celestial struct data (type, attributes, etc.) is set BEFORE calling _mint
        // by the minting function (e.g., mintGenesisCelestial)

         emit Transfer(address(0), to, tokenId); // ERC721 standard mint event
    }

     function _burn(uint256 tokenId) internal celestialExists(tokenId) {
        address owner = _tokenOwners[tokenId];

        // Clear approvals
        _tokenApprovals[tokenId] = address(0);
        delete _operatorApprovals[owner][msg.sender]; // Maybe clear operator approval for token owner

        _balanceOf[owner]--;
        delete _tokenOwners[tokenId];
        // Do NOT delete the Celestial struct itself immediately if its data is needed for history or views.
        // Instead, perhaps mark it as burned or transfer its 'ownership' to address(0).
        // For this example, we'll just nullify sensitive fields and mark as burned implicitly by owner=0.
        celestials[tokenId].owner = address(0); // Mark as burned
        celestials[tokenId].isStaked = false; // Unstake if burned

         emit Transfer(owner, address(0), tokenId); // ERC721 standard burn event
     }


    // --- Internal Helper Function (ERC721Receiver check) ---
    // Minimal implementation of the ERC721 safeTransferFrom check
    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {
        // Check if the recipient contract implements ERC721Receiver
        bytes memory callData = abi.encodeWithSelector(bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")), operator, from, to, tokenId, data);
        (bool success, bytes memory returnData) = to.call(callData);

        // Check success and return value (must be 0x150b7a02)
        return success && (returnData.length == 32 && abi.decode(returnData, (bytes4)) == 0x150b7a02);
    }

    // --- Minimal ERC721 Events (needed for compliance, despite custom ones) ---
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    // Approval and ApprovalForAll events are defined above with custom events
}
```