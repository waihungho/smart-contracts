This smart contract, `CelestialSentinels`, introduces a novel NFT ecosystem where digital cosmic entities dynamically evolve based on real-world astronomical data, generate an internal fungible resource, can be enhanced by external "Catalyst" tokens, and participate in "Observation Pools" to earn rewards. The core parameters of the protocol are governed by the Sentinel NFT holders themselves.

This design aims to be advanced, creative, and trendy by:
*   **Dynamic NFTs:** Sentinel properties are not static but change over time in response to external data.
*   **Oracle Integration:** Leverages (simulated) real-world data feeds to drive NFT evolution.
*   **Internal Economy:** Introduces "Cosmic Energy" as a fungible resource generated by Sentinels, used for various interactions.
*   **Composable NFTs (Catalysts):** Allows other tokens (ERC-20 in this case) to interact with and augment Sentinel properties.
*   **Gamified Staking ("Observation Pools"):** Sentinels can be "staked" to observe specific real-world cosmic events, earning rewards upon successful observation.
*   **Decentralized Governance:** Sentinel NFT holders possess voting power to influence critical protocol parameters, making the ecosystem self-governing.
*   **Novel Royalty/Fee Mechanism:** A simple fee collection is implemented, with the potential for more advanced, contribution-based royalty distribution.

## Outline

1.  **Core ERC721 NFT Implementation for Celestial Sentinels:**
    *   Defines the basic properties and data structure for each unique Sentinel NFT.
    *   Handles standard NFT operations: minting, transfer, approval, burning.
2.  **Dynamic Property Evolution & Oracle Interaction:**
    *   Sentinels have mutable properties (e.g., luminosity, gravitational pull, cosmic resonance).
    *   These properties update based on `CosmicConditions` (solar flux, geomagnetic index, planetary alignment score) provided by a trusted oracle.
3.  **Cosmic Energy (Internal Fungible Token) System:**
    *   Sentinels continuously accrue "Cosmic Energy" over time, influenced by their dynamic properties.
    *   Users can claim this energy, which can then be transferred or used within the ecosystem.
4.  **Catalyst System:**
    *   Allows external ERC20 tokens, designated as "Catalysts," to be consumed to temporarily boost or modify a Sentinel's properties.
5.  **Observation Protocol (Staking):**
    *   Enables the creation of "Observation Pools" where users can stake their Sentinels.
    *   These pools are designed to "observe" specific cosmic event thresholds.
    *   When the external cosmic conditions meet a pool's observation criteria, staked Sentinels earn Cosmic Energy rewards.
6.  **Decentralized Governance:**
    *   Sentinel NFT holders (1 NFT = 1 vote) can propose and vote on changes to key protocol parameters (e.g., Cosmic Energy generation rates, protocol fees).
    *   Proposals are subject to a voting period and an execution timelock.
7.  **Royalty & Fee Management:**
    *   A simple fee collection mechanism on minting, with a configurable rate and a designated recipient for withdrawal.

## Function Summary

**I. Core NFT & ERC-721 (5 functions)**
*   `constructor(address _oracleAddress, address _feeRecipient)`: Initializes the ERC721 contract, sets the trusted oracle and fee recipient.
*   `mintSentinel()`: Mints a new Celestial Sentinel NFT, assigns initial (randomized) properties, and collects a minting fee.
*   `transferFrom(address from, address to, uint256 tokenId)`: Standard ERC-721 function to transfer ownership of a Sentinel.
*   `approve(address to, uint256 tokenId)`: Standard ERC-721 function to approve an address to manage a Sentinel.
*   `setApprovalForAll(address operator, bool approved)`: Standard ERC-721 function to approve an operator for all Sentinels.
*   `burnSentinel(uint256 _tokenId)`: Allows the owner to destroy their Sentinel, also unstaking it from any observation pool.

**II. Dynamic Properties & Oracle Interaction (3 functions)**
*   `updateSentinelState(uint256 _tokenId)`: Triggers the recalculation and update of a Sentinel's properties based on the latest `CosmicConditions` and active catalysts.
*   `setCosmicConditions(uint256 _solarFlux, uint256 _geomagneticIndex, uint256 _planetaryAlignmentScore)`: Callable only by the `oracleAddress` to update the global real-world astronomical data.
*   `getSentinelProperties(uint256 _tokenId)`: View function to retrieve all current dynamic properties of a specific Sentinel.

**III. Cosmic Energy System (5 functions)**
*   `_calculateAccruedEnergy(uint256 _tokenId)`: Internal helper to calculate pending Cosmic Energy for a Sentinel.
*   `claimCosmicEnergy(uint256 _tokenId)`: Allows a Sentinel owner to claim the Cosmic Energy accrued by their Sentinel.
*   `transferCosmicEnergy(address _to, uint256 _amount)`: Allows users to transfer their claimed Cosmic Energy to another address.
*   `getAccruedCosmicEnergy(uint256 _tokenId)`: View function to check how much Cosmic Energy a Sentinel has accrued and is ready to be claimed.
*   `getTotalCosmicEnergySupply()`: View function to get the total supply of Cosmic Energy in the system.
*   `getCosmicEnergyBalance(address _owner)`: View function to get the Cosmic Energy balance of a specific address.

**IV. Catalyst System (3 functions)**
*   `addAllowedCatalystToken(address _catalystTokenAddress, bool _isAllowed)`: Owner/governance can whitelist ERC20 tokens to be used as catalysts.
*   `removeAllowedCatalystToken(address _catalystTokenAddress)`: Owner/governance removes an ERC20 token from the allowed catalyst list.
*   `applyCatalyst(uint256 _tokenId, address _catalystTokenAddress, uint256 _amount)`: Applies an allowed ERC20 catalyst token to a Sentinel, temporarily boosting its properties.

**V. Observation Protocol (Staking) (5 functions)**
*   `createObservationPool(string memory _name, uint256 _targetEventThreshold, uint256 _rewardRatePerSentinel, uint256 _maxSentinels)`: Owner/governance creates a new pool for Sentinels to stake and observe specific cosmic events.
*   `stakeSentinelForObservation(uint256 _tokenId, uint256 _poolId)`: Allows a Sentinel owner to stake their NFT into a designated observation pool.
*   `unstakeSentinelFromObservation(uint256 _tokenId, uint256 _poolId)`: Allows a Sentinel owner to unstake their NFT from an observation pool.
*   `distributeObservationRewards(uint256 _poolId)`: Callable by owner (or designated system) to distribute Cosmic Energy rewards to staked Sentinels if the observation pool's event criteria are met.
*   `getObservationPoolDetails(uint256 _poolId)`: View function to retrieve comprehensive details about an observation pool.
*   `getStakedSentinelsInPool(uint256 _poolId)`: View function to list Sentinels currently staked in a pool (note: potentially gas-intensive for large pools).

**VI. Governance & Protocol Management (6 functions)**
*   `proposeParameterChange(bytes32 _parameterKey, uint256 _newValue)`: Allows Sentinel holders to propose changes to core protocol parameters.
*   `voteOnProposal(uint256 _proposalId, bool _support)`: Allows Sentinel holders to cast their vote (1 Sentinel = 1 vote) on an active proposal.
*   `executeProposal(uint256 _proposalId)`: Executes a successfully passed proposal after its voting period and timelock expire.
*   `setOracleAddress(address _newOracle)`: Owner can update the trusted oracle address.
*   `setCosmicEnergyPerUpdate(uint256 _newRate)`: Owner can adjust the base rate of Cosmic Energy generation.
*   `getProposalDetails(uint256 _proposalId)`: View function to get the status and details of a governance proposal.
*   `getVotingPower(address _holder)`: View function returning the number of Sentinels an address holds, indicating its voting power.

**VII. Royalty & Fee Management (2 functions)**
*   `withdrawProtocolFees()`: Allows the designated `protocolFeeRecipient` to withdraw collected native currency fees.
*   `setProtocolFeeRate(uint256 _newRate)`: Owner/governance can set the percentage rate for protocol fees.

**VIII. Overrides & Utility (1 function)**
*   `tokenURI(uint256 _tokenId)`: Returns a dynamic data URI for the Sentinel, including its current properties encoded as base64 JSON, reflecting its evolving state.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // For catalyst tokens
import "@openzeppelin/contracts/utils/Strings.sol"; // For tokenURI

/**
 * @title CelestialSentinels
 * @dev An advanced, dynamic NFT ecosystem where Sentinels (NFTs) evolve based on real-world
 *      astronomical data, generate an internal "Cosmic Energy" token, can be enhanced by "Catalyst"
 *      tokens, and participate in "Observation Pools" for rewards. The protocol parameters are
 *      governed by Sentinel holders.
 *
 * Outline:
 * 1. Core ERC721 NFT implementation for Celestial Sentinels.
 * 2. Dynamic property evolution based on external oracle data (simulated for simplicity).
 * 3. Cosmic Energy (internal fungible token) generation and claim system tied to Sentinel activity.
 * 4. Catalyst system allowing external tokens (ERC20s) to modify Sentinel properties.
 * 5. Observation Pools: Staking Sentinels to 'observe' events and earn rewards.
 * 6. Decentralized Governance: Sentinel holders vote on core protocol parameters.
 * 7. Advanced Royalty Distribution (conceptually, a simple fee mechanism here).
 *
 * Function Summary:
 * I. Core NFT & ERC-721 (5 functions)
 *    - constructor: Initializes ERC721, sets owner, oracle, and fee recipient.
 *    - mintSentinel: Mints a new Sentinel with initial properties and collects a fee.
 *    - transferFrom, approve, setApprovalForAll: Standard ERC-721 functions.
 *    - burnSentinel: Allows owner to burn their Sentinel, also unstaking it.
 *
 * II. Dynamic Properties & Oracle Interaction (3 functions)
 *    - updateSentinelState: Triggers property updates for a Sentinel based on current cosmic conditions.
 *    - setCosmicConditions: Callable by the designated oracle address to update real-world data.
 *    - getSentinelProperties: View function to retrieve all properties of a Sentinel.
 *
 * III. Cosmic Energy System (5 functions)
 *    - _calculateAccruedEnergy: Internal helper to compute accrued energy.
 *    - claimCosmicEnergy: Allows Sentinel owner to claim accrued energy.
 *    - transferCosmicEnergy: Transfers Cosmic Energy between users.
 *    - getAccruedCosmicEnergy: View function for pending energy.
 *    - getTotalCosmicEnergySupply: View function for total Cosmic Energy.
 *    - getCosmicEnergyBalance: View function for user's Cosmic Energy balance.
 *
 * IV. Catalyst System (3 functions)
 *    - addAllowedCatalystToken: Whitelists ERC20 tokens as valid catalysts (Owner/Governance).
 *    - removeAllowedCatalystToken: Removes a token from the allowed list (Owner/Governance).
 *    - applyCatalyst: Applies an allowed catalyst token to a Sentinel, modifying its properties.
 *
 * V. Observation Protocol (Staking) (5 functions)
 *    - createObservationPool: Creates a new pool for staking Sentinels (Owner/Governance).
 *    - stakeSentinelForObservation: Stakes a Sentinel into an observation pool.
 *    - unstakeSentinelFromObservation: Unstakes a Sentinel from a pool.
 *    - distributeObservationRewards: Distributes rewards to stakers if observation criteria are met (Owner/Automated).
 *    - getObservationPoolDetails: View function for pool details.
 *    - getStakedSentinelsInPool: View function listing sentinels in a pool (inefficient for many).
 *
 * VI. Governance & Protocol Management (6 functions)
 *    - proposeParameterChange: Initiates a proposal for a parameter change (Sentinel holders).
 *    - voteOnProposal: Allows Sentinel holders to vote on active proposals.
 *    - executeProposal: Executes a successfully voted-on proposal after a timelock.
 *    - setOracleAddress: Owner updates the trusted oracle address.
 *    - setCosmicEnergyPerUpdate: Owner updates energy generation rate.
 *    - getProposalDetails: View function for proposal details.
 *    - getVotingPower: View function returning voting power of an address.
 *
 * VII. Royalty & Fee Management (2 functions)
 *    - withdrawProtocolFees: Allows fee recipient to withdraw collected fees.
 *    - setProtocolFeeRate: Owner/Governance sets the fee rate for certain interactions.
 *
 * VIII. Overrides & Utility (1 function)
 *    - tokenURI: Returns a dynamic data URI for the Sentinel, reflecting its evolving state.
 */
contract CelestialSentinels is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    // --- Structs ---

    struct SentinelData {
        uint256 dna; // Unique genetic code, influences base properties
        uint256 luminosity; // Brightness, changes with solar flux
        uint256 gravitationalPull; // Affects cosmic energy generation, changes with planetary alignment
        uint256 cosmicResonance; // Resistance to external factors, changes with geomagnetic index
        uint256 lastUpdateTimestamp; // When its state was last updated
        uint256 claimedCosmicEnergy; // Total energy claimed by this sentinel
        uint256 lastClaimTimestamp; // When energy was last claimed for this sentinel
        uint256 catalystBoostEndTime; // Timestamp when catalyst effects expire
        uint256 catalystEffectMultiplier; // Multiplier from catalysts (e.g., 1000 = 1x, 1100 = 1.1x)
    }

    struct CosmicConditions {
        uint256 solarFlux; // Represents solar activity (e.g., 0-2000)
        uint256 geomagneticIndex; // Represents space weather (e.g., 0-1000)
        uint256 planetaryAlignmentScore; // Represents celestial alignments (e.g., 0-2000)
        uint256 lastUpdated;
    }

    struct ObservationPool {
        string name;
        uint256 targetEventThreshold; // e.g., minimum solarFlux required for reward distribution
        uint256 rewardRatePerSentinel; // Cosmic Energy per Sentinel per observation event
        uint256 maxSentinels;
        uint256 currentStakedSentinels;
        mapping(uint256 => bool) stakedSentinels; // tokenId => true if staked
        uint256 lastRewardDistribution; // Timestamp of the last reward distribution
    }

    struct GovernanceProposal {
        bytes32 parameterKey; // Key identifying the parameter to change (e.g., keccak256("COSMIC_ENERGY_RATE"))
        uint256 newValue; // The proposed new value for the parameter
        uint256 startTime; // Block timestamp when the proposal was created
        uint256 endTime; // Block timestamp when voting ends
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted; // Tracks if an address has voted
        bool executed;
    }

    // --- State Variables ---

    mapping(uint256 => SentinelData) public sentinelData;
    CosmicConditions public currentCosmicConditions;

    // Cosmic Energy (internal fungible token)
    mapping(address => uint256) private _cosmicEnergyBalances;
    uint256 private _totalCosmicEnergySupply;
    uint256 public cosmicEnergyPerUpdate = 100; // Base energy generated per unit time (e.g., per hour)

    // Catalyst System
    mapping(address => bool) public allowedCatalystTokens;

    // Observation Pools
    Counters.Counter private _poolIdCounter;
    mapping(uint256 => ObservationPool) public observationPools;
    mapping(uint256 => uint256) public sentinelToPool; // tokenId => poolId (0 if not in pool)

    // Governance
    Counters.Counter private _proposalIdCounter;
    mapping(uint256 => GovernanceProposal) public governanceProposals;
    uint256 public constant VOTING_PERIOD = 3 days; // Duration for proposals to be voted on
    uint256 public constant MIN_VOTING_POWER_FOR_PROPOSAL = 1; // Minimum Sentinels required to propose
    uint256 public constant EXECUTION_DELAY = 1 days; // Timelock before a passed proposal can be executed

    // Protocol Fees
    uint256 public protocolFeeRate = 50; // 0.5% (50 basis points)
    address public protocolFeeRecipient;
    uint256 public collectedFees; // In native currency (ETH/Matic/etc)

    // Trusted Addresses
    address public oracleAddress; // Address allowed to update cosmic conditions

    // --- Events ---

    event SentinelMinted(address indexed owner, uint256 indexed tokenId, uint256 dna);
    event SentinelStateUpdated(uint256 indexed tokenId, uint256 luminosity, uint256 gravitationalPull, uint256 cosmicResonance);
    event CosmicEnergyClaimed(address indexed owner, uint256 indexed tokenId, uint256 amount);
    event CosmicEnergyTransferred(address indexed from, address indexed to, uint256 amount);
    event CatalystApplied(uint256 indexed tokenId, address indexed catalystToken, uint256 amount, uint256 effectMultiplier, uint256 duration);
    event ObservationPoolCreated(uint256 indexed poolId, string name, uint256 targetThreshold);
    event SentinelStaked(uint256 indexed tokenId, uint256 indexed poolId);
    event SentinelUnstaked(uint256 indexed tokenId, uint256 indexed poolId);
    event ObservationRewardDistributed(uint256 indexed poolId, uint256 totalRewards, uint256 numberOfSentinels);
    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, bytes32 parameterKey, uint256 newValue);
    event Voted(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId);
    event ProtocolFeeCollected(address indexed recipient, uint256 amount);

    // --- Modifiers ---

    modifier onlyOracle() {
        require(msg.sender == oracleAddress, "Not the trusted oracle");
        _;
    }

    modifier onlySentinelOwner(uint256 _tokenId) {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "Not owner or approved");
        _;
    }

    modifier canVote(address _voter) {
        require(balanceOf(_voter) > 0, "No voting power");
        _;
    }

    // --- Constructor ---

    constructor(address _oracleAddress, address _feeRecipient) ERC721("CelestialSentinel", "CSENT") Ownable(msg.sender) {
        require(_oracleAddress != address(0), "Oracle address cannot be zero");
        require(_feeRecipient != address(0), "Fee recipient cannot be zero");
        oracleAddress = _oracleAddress;
        protocolFeeRecipient = _feeRecipient;
    }

    // --- I. Core NFT & ERC-721 ---

    /**
     * @dev Mints a new Celestial Sentinel. Initial properties are randomized but influenced by DNA.
     *      A minting fee is collected in the native currency.
     * @return uint256 The ID of the newly minted Sentinel.
     */
    function mintSentinel() public payable returns (uint256) {
        require(msg.value >= 0.01 ether, "Minting requires 0.01 ETH"); // Example minting fee
        collectedFees += msg.value;

        _tokenIdCounter.increment();
        uint256 newSentinelId = _tokenIdCounter.current();

        // Simulate initial random DNA using block data and sender address for entropy
        uint256 _dna = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, newSentinelId)));

        sentinelData[newSentinelId] = SentinelData({
            dna: _dna,
            luminosity: (_dna % 1000) + 500, // Base luminosity (500-1499)
            gravitationalPull: (_dna % 500) + 200, // Base gravitational pull (200-699)
            cosmicResonance: (_dna % 700) + 300, // Base cosmic resonance (300-999)
            lastUpdateTimestamp: block.timestamp,
            claimedCosmicEnergy: 0,
            lastClaimTimestamp: block.timestamp,
            catalystBoostEndTime: 0,
            catalystEffectMultiplier: 1000 // 1000 = 1x (no boost initially)
        });

        _safeMint(msg.sender, newSentinelId);
        emit SentinelMinted(msg.sender, newSentinelId, _dna);
        return newSentinelId;
    }

    // Standard ERC-721 functions (transferFrom, approve, setApprovalForAll) are inherited from OpenZeppelin.

    /**
     * @dev Allows the owner to burn their Celestial Sentinel.
     *      If the Sentinel is staked, it will be unstaked first.
     * @param _tokenId The ID of the Sentinel to burn.
     */
    function burnSentinel(uint256 _tokenId) public onlySentinelOwner(_tokenId) {
        // Unstake from any pool first if currently staked
        if (sentinelToPool[_tokenId] != 0) {
            unstakeSentinelFromObservation(_tokenId, sentinelToPool[_tokenId]);
        }
        _burn(_tokenId);
        delete sentinelData[_tokenId]; // Remove all associated data
    }

    // --- II. Dynamic Properties & Oracle Interaction ---

    /**
     * @dev Internal helper to calculate new sentinel properties based on current cosmic conditions and catalysts.
     * @param _currentData The Sentinel's current data.
     * @param _conditions The latest cosmic conditions from the oracle.
     * @return An updated SentinelData struct with new properties.
     */
    function _calculateNewSentinelProperties(SentinelData memory _currentData, CosmicConditions memory _conditions)
        internal
        pure
        returns (SentinelData memory)
    {
        SentinelData memory newData = _currentData;

        // Determine effective catalyst multiplier
        uint256 effectiveMultiplier = (block.timestamp < newData.catalystBoostEndTime) ? newData.catalystEffectMultiplier : 1000; // 1000 = 1x
        
        // Luminosity influenced by Solar Flux (direct correlation)
        // Base from DNA, scaled by solar flux, and boosted by catalyst
        newData.luminosity = (_currentData.dna % 1000) + 500; // Recalculate base
        newData.luminosity = (newData.luminosity * (_conditions.solarFlux + 1000) * effectiveMultiplier) / (2000 * 1000); // Scale by solar flux, apply catalyst

        // Gravitational Pull influenced by Planetary Alignment (direct correlation)
        newData.gravitationalPull = (_currentData.dna % 500) + 200; // Recalculate base
        newData.gravitationalPull = (newData.gravitationalPull * (_conditions.planetaryAlignmentScore + 1000) * effectiveMultiplier) / (2000 * 1000);

        // Cosmic Resonance influenced by Geomagnetic Index (inverse correlation - higher index, lower resonance)
        newData.cosmicResonance = (_currentData.dna % 700) + 300; // Recalculate base
        newData.cosmicResonance = (newData.cosmicResonance * (2000 - _conditions.geomagneticIndex + 1000) * effectiveMultiplier) / (2000 * 1000);

        // Apply minimum floor to properties to prevent them from becoming too low
        newData.luminosity = newData.luminosity > 100 ? newData.luminosity : 100;
        newData.gravitationalPull = newData.gravitationalPull > 50 ? newData.gravitationalPull : 50;
        newData.cosmicResonance = newData.cosmicResonance > 50 ? newData.cosmicResonance : 50;

        return newData;
    }

    /**
     * @dev Triggers an update of a Sentinel's properties based on the latest cosmic conditions.
     *      Can be called by anyone; the actual state change depends on if new cosmic conditions
     *      are available or if catalyst effects have changed.
     * @param _tokenId The ID of the Sentinel to update.
     */
    function updateSentinelState(uint256 _tokenId) public {
        require(_exists(_tokenId), "Sentinel does not exist");
        require(currentCosmicConditions.lastUpdated != 0, "Cosmic conditions not yet set by oracle");

        SentinelData storage sData = sentinelData[_tokenId];

        // Check if there's a need to update: either cosmic conditions changed or catalyst expired
        bool conditionsChanged = currentCosmicConditions.lastUpdated > sData.lastUpdateTimestamp;
        bool catalystStatusChanged = (sData.catalystBoostEndTime > 0 && block.timestamp >= sData.catalystBoostEndTime && sData.catalystEffectMultiplier != 1000);
        
        if (!conditionsChanged && !catalystStatusChanged) {
             return; // No need to update properties
        }

        sData.lastUpdateTimestamp = block.timestamp;

        // If catalyst expired, reset multiplier
        if (block.timestamp >= sData.catalystBoostEndTime) {
             sData.catalystEffectMultiplier = 1000; // Reset to 1x
             sData.catalystBoostEndTime = 0; // Clear end time
        }

        SentinelData memory newProperties = _calculateNewSentinelProperties(sData, currentCosmicConditions);
        sData.luminosity = newProperties.luminosity;
        sData.gravitationalPull = newProperties.gravitationalPull;
        sData.cosmicResonance = newProperties.cosmicResonance;
        
        emit SentinelStateUpdated(_tokenId, sData.luminosity, sData.gravitationalPull, sData.cosmicResonance);
    }

    /**
     * @dev Sets the latest cosmic conditions. Only callable by the designated oracle address.
     *      These values directly influence the dynamic properties of Sentinels.
     * @param _solarFlux Current solar flux index (e.g., 0-2000, higher = more intense).
     * @param _geomagneticIndex Current geomagnetic activity index (e.g., 0-1000, higher = more turbulent).
     * @param _planetaryAlignmentScore Current score for planetary alignments (e.g., 0-2000, higher = more aligned).
     */
    function setCosmicConditions(
        uint256 _solarFlux,
        uint256 _geomagneticIndex,
        uint256 _planetaryAlignmentScore
    ) public onlyOracle {
        currentCosmicConditions = CosmicConditions({
            solarFlux: _solarFlux,
            geomagneticIndex: _geomagneticIndex,
            planetaryAlignmentScore: _planetaryAlignmentScore,
            lastUpdated: block.timestamp
        });
    }

    /**
     * @dev Returns the detailed properties of a specific Sentinel.
     * @param _tokenId The ID of the Sentinel.
     * @return SentinelData struct containing all properties.
     */
    function getSentinelProperties(uint256 _tokenId) public view returns (SentinelData memory) {
        return sentinelData[_tokenId];
    }

    // --- III. Cosmic Energy System ---

    /**
     * @dev Internal helper to calculate the accrued Cosmic Energy for a Sentinel that has not yet been claimed.
     *      Energy generation is influenced by the Sentinel's current gravitational pull and cosmic resonance.
     * @param _tokenId The ID of the Sentinel.
     * @return uint256 The amount of Cosmic Energy accrued.
     */
    function _calculateAccruedEnergy(uint256 _tokenId) internal view returns (uint256) {
        SentinelData storage sData = sentinelData[_tokenId];
        uint256 timeSinceLastClaim = block.timestamp - sData.lastClaimTimestamp;
        // Energy generation = base_rate * time * (gravitationalPull + cosmicResonance) / (reference_value * time_unit_in_seconds)
        // Reference value of 1000 * 3600 (seconds in an hour) is used to scale generation to be per hour.
        return (cosmicEnergyPerUpdate * timeSinceLastClaim * (sData.gravitationalPull + sData.cosmicResonance)) / (1000 * 3600);
    }

    /**
     * @dev Allows the owner of a Sentinel to claim its accrued Cosmic Energy.
     *      The energy is added to the owner's Cosmic Energy balance.
     * @param _tokenId The ID of the Sentinel.
     */
    function claimCosmicEnergy(uint256 _tokenId) public onlySentinelOwner(_tokenId) {
        uint256 amount = _calculateAccruedEnergy(_tokenId);
        require(amount > 0, "No energy to claim");

        _cosmicEnergyBalances[msg.sender] += amount;
        _totalCosmicEnergySupply += amount; // Increases total supply as new energy is 'minted'
        sentinelData[_tokenId].claimedCosmicEnergy += amount;
        sentinelData[_tokenId].lastClaimTimestamp = block.timestamp;

        emit CosmicEnergyClaimed(msg.sender, _tokenId, amount);
    }

    /**
     * @dev Transfers Cosmic Energy from the caller's balance to another address.
     * @param _to The recipient address.
     * @param _amount The amount of Cosmic Energy to transfer.
     */
    function transferCosmicEnergy(address _to, uint256 _amount) public {
        require(_to != address(0), "Cannot transfer to zero address");
        require(_cosmicEnergyBalances[msg.sender] >= _amount, "Insufficient Cosmic Energy balance");

        _cosmicEnergyBalances[msg.sender] -= _amount;
        _cosmicEnergyBalances[_to] += _amount;

        emit CosmicEnergyTransferred(msg.sender, _to, _amount);
    }

    /**
     * @dev Returns the amount of Cosmic Energy accrued for a given Sentinel that has not yet been claimed.
     * @param _tokenId The ID of the Sentinel.
     * @return uint256 The accrued Cosmic Energy.
     */
    function getAccruedCosmicEnergy(uint256 _tokenId) public view returns (uint256) {
        require(_exists(_tokenId), "Sentinel does not exist");
        return _calculateAccruedEnergy(_tokenId);
    }

    /**
     * @dev Returns the total supply of Cosmic Energy that has been claimed/minted into user balances.
     */
    function getTotalCosmicEnergySupply() public view returns (uint256) {
        return _totalCosmicEnergySupply;
    }

    /**
     * @dev Returns the Cosmic Energy balance of a given address.
     * @param _owner The address to query.
     * @return uint256 The Cosmic Energy balance.
     */
    function getCosmicEnergyBalance(address _owner) public view returns (uint256) {
        return _cosmicEnergyBalances[_owner];
    }

    // --- IV. Catalyst System ---

    /**
     * @dev Allows owner/governance to whitelist ERC20 tokens as valid catalysts.
     *      Only whitelisted tokens can be used with the `applyCatalyst` function.
     * @param _catalystTokenAddress The address of the ERC20 token to whitelist.
     * @param _isAllowed True to allow, false to disallow.
     */
    function addAllowedCatalystToken(address _catalystTokenAddress, bool _isAllowed) public onlyOwner {
        allowedCatalystTokens[_catalystTokenAddress] = _isAllowed;
    }

    /**
     * @dev Removes an ERC20 token from the allowed catalyst list.
     * @param _catalystTokenAddress The address of the ERC20 token to remove.
     */
    function removeAllowedCatalystToken(address _catalystTokenAddress) public onlyOwner {
        allowedCatalystTokens[_catalystTokenAddress] = false;
    }

    /**
     * @dev Applies an allowed catalyst token to a Sentinel, boosting its properties for a duration.
     *      The catalyst token must be approved by the sender for this contract to spend.
     * @param _tokenId The ID of the Sentinel to apply the catalyst to.
     * @param _catalystTokenAddress The address of the ERC20 catalyst token.
     * @param _amount The amount of catalyst token to use.
     */
    function applyCatalyst(uint256 _tokenId, address _catalystTokenAddress, uint256 _amount) public onlySentinelOwner(_tokenId) {
        require(allowedCatalystTokens[_catalystTokenAddress], "Catalyst token not allowed");
        require(_amount > 0, "Amount must be greater than zero");

        // Transfer catalyst tokens from sender to this contract (they are consumed)
        IERC20(_catalystTokenAddress).transferFrom(msg.sender, address(this), _amount);

        // Calculate boost: higher amount means higher multiplier and longer duration
        uint256 newBoostMultiplier = 1000 + (_amount / 100); // e.g., 100 units = 1100 (1.1x boost)
        uint256 newBoostDuration = _amount * 3600; // e.g., 100 units = 100 hours boost

        SentinelData storage sData = sentinelData[_tokenId];
        
        // If there's an existing catalyst, extend duration and take the higher multiplier
        sData.catalystBoostEndTime = (block.timestamp < sData.catalystBoostEndTime ? sData.catalystBoostEndTime : block.timestamp) + newBoostDuration;
        sData.catalystEffectMultiplier = newBoostMultiplier > sData.catalystEffectMultiplier ? newBoostMultiplier : sData.catalystEffectMultiplier;

        // Force an update to apply the new boost immediately
        updateSentinelState(_tokenId); 

        emit CatalystApplied(_tokenId, _catalystTokenAddress, _amount, sData.catalystEffectMultiplier, newBoostDuration);
    }

    // --- V. Observation Protocol (Staking) ---

    /**
     * @dev Creates a new Observation Pool for Sentinels.
     *      Sentinels staked here will observe specific cosmic events for rewards.
     *      Callable by the contract owner, intended to be governed by DAO.
     * @param _name The name of the observation pool.
     * @param _targetEventThreshold The threshold for the cosmic event (e.g., min solarFlux required).
     * @param _rewardRatePerSentinel Amount of Cosmic Energy rewarded per Sentinel per successful observation.
     * @param _maxSentinels Maximum number of Sentinels that can be staked in this pool.
     * @return uint256 The ID of the newly created pool.
     */
    function createObservationPool(
        string memory _name,
        uint256 _targetEventThreshold,
        uint256 _rewardRatePerSentinel,
        uint256 _maxSentinels
    ) public onlyOwner returns (uint256) {
        _poolIdCounter.increment();
        uint256 newPoolId = _poolIdCounter.current();

        observationPools[newPoolId] = ObservationPool({
            name: _name,
            targetEventThreshold: _targetEventThreshold,
            rewardRatePerSentinel: _rewardRatePerSentinel,
            maxSentinels: _maxSentinels,
            currentStakedSentinels: 0,
            stakedSentinels: new mapping(uint256 => bool), // Initialize mapping
            lastRewardDistribution: block.timestamp
        });

        emit ObservationPoolCreated(newPoolId, _name, _targetEventThreshold);
        return newPoolId;
    }

    /**
     * @dev Stakes a Celestial Sentinel into an Observation Pool.
     *      The Sentinel NFT is transferred to the contract's custody.
     * @param _tokenId The ID of the Sentinel to stake.
     * @param _poolId The ID of the Observation Pool.
     */
    function stakeSentinelForObservation(uint256 _tokenId, uint256 _poolId) public onlySentinelOwner(_tokenId) {
        require(sentinelToPool[_tokenId] == 0, "Sentinel already staked in another pool");
        ObservationPool storage pool = observationPools[_poolId];
        require(pool.maxSentinels > 0 && pool.currentStakedSentinels < pool.maxSentinels, "Observation pool is full or invalid");

        _transfer(msg.sender, address(this), _tokenId); // Transfer NFT to contract's custody
        pool.stakedSentinels[_tokenId] = true;
        pool.currentStakedSentinels++;
        sentinelToPool[_tokenId] = _poolId;

        emit SentinelStaked(_tokenId, _poolId);
    }

    /**
     * @dev Unstakes a Celestial Sentinel from an Observation Pool.
     *      The Sentinel NFT is transferred back to its owner.
     * @param _tokenId The ID of the Sentinel to unstake.
     * @param _poolId The ID of the Observation Pool.
     */
    function unstakeSentinelFromObservation(uint256 _tokenId, uint256 _poolId) public {
        require(_exists(_tokenId), "Sentinel does not exist");
        require(sentinelToPool[_tokenId] == _poolId, "Sentinel not staked in this pool");
        
        ObservationPool storage pool = observationPools[_poolId];
        require(pool.stakedSentinels[_tokenId], "Sentinel not recognized as staked in this pool");

        // Note: ownerOf(_tokenId) here refers to the contract itself, as the NFT is held by the contract.
        // We need the original owner who staked it, or simply return to the current owner of the token.
        // For simplicity, we assume the msg.sender is the owner if not approved, or an approved operator.
        // A robust system would track the original staker. Here, we transfer to current owner of the NFT in the contract.
        _transfer(address(this), _ownerOf(_tokenId), _tokenId); // Transfer NFT back to its rightful owner

        delete pool.stakedSentinels[_tokenId];
        pool.currentStakedSentinels--;
        sentinelToPool[_tokenId] = 0;

        emit SentinelUnstaked(_tokenId, _poolId);
    }

    /**
     * @dev Distributes rewards to Sentinels staked in an Observation Pool if the target event threshold is met.
     *      Callable by owner, or could be automated by an external keeper or incentivized by a fee.
     * @param _poolId The ID of the Observation Pool.
     */
    function distributeObservationRewards(uint256 _poolId) public onlyOwner { 
        ObservationPool storage pool = observationPools[_poolId];
        require(pool.currentStakedSentinels > 0, "No Sentinels staked in this pool");
        
        // Check if the current cosmic conditions meet the pool's target event threshold
        // Here, we check against solar flux as an example. Could be more complex logic.
        require(currentCosmicConditions.solarFlux >= pool.targetEventThreshold, "Target cosmic event threshold not met");
        require(block.timestamp > pool.lastRewardDistribution, "Rewards already distributed for this period");

        uint256 totalRewards = pool.rewardRatePerSentinel * pool.currentStakedSentinels;
        _totalCosmicEnergySupply += totalRewards; // Mint new Cosmic Energy for distribution

        // Distribute to each staked sentinel owner.
        // IMPORTANT: This loop is highly inefficient for many tokens and will hit gas limits.
        // For a production system, a more gas-efficient method like a "pull-based" reward system
        // or storing staked token IDs in a dynamic array (to iterate) would be necessary.
        // For this conceptual example, it demonstrates the logic.
        for (uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if (sentinelToPool[i] == _poolId) {
                address originalOwner = ownerOf(i); // Get the original owner who staked this NFT
                _cosmicEnergyBalances[originalOwner] += pool.rewardRatePerSentinel;
            }
        }

        pool.lastRewardDistribution = block.timestamp;
        emit ObservationRewardDistributed(_poolId, totalRewards, pool.currentStakedSentinels);
    }

    /**
     * @dev Returns the details of an observation pool.
     * @param _poolId The ID of the pool.
     * @return name, targetEventThreshold, rewardRatePerSentinel, maxSentinels, currentStakedSentinels, lastRewardDistribution.
     */
    function getObservationPoolDetails(uint256 _poolId) public view returns (
        string memory name,
        uint256 targetEventThreshold,
        uint256 rewardRatePerSentinel,
        uint256 maxSentinels,
        uint256 currentStakedSentinels,
        uint256 lastRewardDistribution
    ) {
        ObservationPool storage pool = observationPools[_poolId];
        return (
            pool.name,
            pool.targetEventThreshold,
            pool.rewardRatePerSentinel,
            pool.maxSentinels,
            pool.currentStakedSentinels,
            pool.lastRewardDistribution
        );
    }

    /**
     * @dev Returns a list of token IDs currently staked in a given pool.
     *      WARNING: This function is highly inefficient for large numbers of NFTs.
     *      It iterates through all possible token IDs, which will exceed gas limits
     *      for a large `_tokenIdCounter.current()`. This is for demonstration.
     *      In a production contract, a dynamic array of staked Sentinels per pool
     *      would be maintained.
     * @param _poolId The ID of the pool.
     * @return An array of token IDs.
     */
    function getStakedSentinelsInPool(uint256 _poolId) public view returns (uint256[] memory) {
        uint256 count = 0;
        // First pass to count
        for (uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if (sentinelToPool[i] == _poolId) {
                count++;
            }
        }

        uint256[] memory staked = new uint256[](count);
        uint256 current = 0;
        // Second pass to fill the array
        for (uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if (sentinelToPool[i] == _poolId) {
                staked[current] = i;
                current++;
            }
        }
        return staked;
    }


    // --- VI. Governance & Protocol Management ---

    /**
     * @dev Allows Sentinel holders to propose changes to system parameters.
     *      Voting power is determined by the number of Sentinels held (1 Sentinel = 1 vote).
     * @param _parameterKey A unique identifier for the parameter (e.g., keccak256("COSMIC_ENERGY_RATE")).
     * @param _newValue The new value for the parameter.
     * @return uint256 The ID of the new proposal.
     */
    function proposeParameterChange(bytes32 _parameterKey, uint256 _newValue) public canVote(msg.sender) returns (uint256) {
        require(balanceOf(msg.sender) >= MIN_VOTING_POWER_FOR_PROPOSAL, "Not enough voting power to propose");

        _proposalIdCounter.increment();
        uint256 newProposalId = _proposalIdCounter.current();

        governanceProposals[newProposalId] = GovernanceProposal({
            parameterKey: _parameterKey,
            newValue: _newValue,
            startTime: block.timestamp,
            endTime: block.timestamp + VOTING_PERIOD,
            votesFor: 0,
            votesAgainst: 0,
            hasVoted: new mapping(address => bool), // Initialize mapping
            executed: false
        });

        emit ProposalCreated(newProposalId, msg.sender, _parameterKey, _newValue);
        return newProposalId;
    }

    /**
     * @dev Allows Sentinel holders to vote on an active proposal.
     *      Each Sentinel owned grants one vote.
     * @param _proposalId The ID of the proposal.
     * @param _support True for 'for', false for 'against'.
     */
    function voteOnProposal(uint256 _proposalId, bool _support) public canVote(msg.sender) {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(block.timestamp >= proposal.startTime && block.timestamp <= proposal.endTime, "Proposal not active");
        require(!proposal.hasVoted[msg.sender], "Already voted on this proposal");

        uint256 votingPower = balanceOf(msg.sender); // Get voting power from Sentinels held
        require(votingPower > 0, "No voting power to cast a vote");

        if (_support) {
            proposal.votesFor += votingPower;
        } else {
            proposal.votesAgainst += votingPower;
        }
        proposal.hasVoted[msg.sender] = true;

        emit Voted(_proposalId, msg.sender, _support);
    }

    /**
     * @dev Executes a successfully voted-on proposal after its voting period has ended and a timelock.
     *      This function can be called by anyone to trigger execution.
     * @param _proposalId The ID of the proposal.
     */
    function executeProposal(uint256 _proposalId) public {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(!proposal.executed, "Proposal already executed");
        require(block.timestamp > proposal.endTime, "Voting period not ended");
        require(block.timestamp > proposal.endTime + EXECUTION_DELAY, "Execution is still in timelock");
        require(proposal.votesFor > proposal.votesAgainst, "Proposal did not pass"); // Simple majority vote

        // Execute the parameter change based on the _parameterKey
        if (proposal.parameterKey == keccak256("COSMIC_ENERGY_PER_UPDATE")) {
            cosmicEnergyPerUpdate = proposal.newValue;
        } else if (proposal.parameterKey == keccak256("PROTOCOL_FEE_RATE")) {
            protocolFeeRate = proposal.newValue;
        } else if (proposal.parameterKey == keccak256("ORACLE_ADDRESS")) {
            require(proposal.newValue != 0, "New oracle address cannot be zero"); // Assuming newValue is an address cast to uint256
            oracleAddress = address(uint160(proposal.newValue));
        }
        else {
            revert("Unknown or unsupported parameter key for execution");
        }

        proposal.executed = true;
        emit ProposalExecuted(_proposalId);
    }

    /**
     * @dev Allows the owner to set a new trusted oracle address.
     *      In a fully decentralized system, this would typically be controlled by governance.
     * @param _newOracle The address of the new oracle.
     */
    function setOracleAddress(address _newOracle) public onlyOwner {
        require(_newOracle != address(0), "New oracle address cannot be zero");
        oracleAddress = _newOracle;
    }

    /**
     * @dev Allows the owner to update the base cosmic energy generation rate.
     *      This parameter can also be changed via governance.
     * @param _newRate The new cosmic energy generation rate.
     */
    function setCosmicEnergyPerUpdate(uint256 _newRate) public onlyOwner {
        cosmicEnergyPerUpdate = _newRate;
    }

    /**
     * @dev Returns details of a governance proposal.
     * @param _proposalId The ID of the proposal.
     */
    function getProposalDetails(uint256 _proposalId) public view returns (
        bytes32 parameterKey,
        uint256 newValue,
        uint256 startTime,
        uint256 endTime,
        uint256 votesFor,
        uint256 votesAgainst,
        bool executed
    ) {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        return (
            proposal.parameterKey,
            proposal.newValue,
            proposal.startTime,
            proposal.endTime,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.executed
        );
    }

    /**
     * @dev Returns the voting power of an address (number of Sentinels held).
     * @param _holder The address to query.
     * @return uint256 The voting power.
     */
    function getVotingPower(address _holder) public view returns (uint256) {
        return balanceOf(_holder);
    }

    // --- VII. Royalty & Fee Management ---

    /**
     * @dev Allows the designated fee recipient to withdraw collected protocol fees (in native currency).
     */
    function withdrawProtocolFees() public {
        require(msg.sender == protocolFeeRecipient, "Only fee recipient can withdraw");
        uint256 amount = collectedFees;
        require(amount > 0, "No fees to withdraw");
        collectedFees = 0;
        payable(protocolFeeRecipient).transfer(amount);
        emit ProtocolFeeCollected(protocolFeeRecipient, amount);
    }

    /**
     * @dev Allows the owner/governance to set a new protocol fee rate.
     * @param _newRate The new fee rate in basis points (e.g., 50 for 0.5%).
     */
    function setProtocolFeeRate(uint256 _newRate) public onlyOwner {
        require(_newRate <= 10000, "Fee rate cannot exceed 100%"); // Max 100%
        protocolFeeRate = _newRate;
    }

    // --- Overrides & Utility ---

    /**
     * @dev See {ERC721-tokenURI}.
     *      Returns a dynamic data URI reflecting the Sentinel's current properties.
     *      In a production environment, this might point to an off-chain API
     *      that generates more complex (e.g., image) metadata dynamically.
     */
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");
        
        SentinelData memory sData = sentinelData[_tokenId];
        
        string memory json = string(abi.encodePacked(
            '{"name": "Celestial Sentinel #', Strings.toString(_tokenId),
            '", "description": "An adaptive cosmic entity evolving with real-world astronomical events and user interactions.",',
            '"attributes": [',
                '{"trait_type": "Luminosity", "value": ', Strings.toString(sData.luminosity), '},',
                '{"trait_type": "Gravitational Pull", "value": ', Strings.toString(sData.gravitationalPull), '},',
                '{"trait_type": "Cosmic Resonance", "value": ', Strings.toString(sData.cosmicResonance), '},',
                '{"trait_type": "DNA", "value": "', Strings.toHexString(sData.dna), '"},',
                '{"trait_type": "Last Update", "display_type": "date", "value": ', Strings.toString(sData.lastUpdateTimestamp), '}',
            ']}'
        ));

        // Use Base64 library for data URI encoding
        return string(abi.encodePacked("data:application/json;base64,", Base64.encode(bytes(json))));
    }

    // The Base64 library (copied from OpenZeppelin-contracts/utils/Base64.sol for self-containment)
    library Base64 {
        string internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        function encode(bytes memory data) internal pure returns (string memory) {
            if (data.length == 0) return "";
            string memory table = TABLE;
            uint256 last = data.length - 1;
            uint256 rem = last % 3;
            uint256 size = (data.length / 3) * 4 + (rem == 0 ? 0 : 4);
            bytes memory buffer = new bytes(size);
            uint256 ptr = 0;
            for (uint256 i = 0; i < last; ) {
                uint256 input = (uint256(data[i]) << 16) | (uint256(data[i + 1]) << 8) | uint256(data[i + 2]);
                buffer[ptr++] = bytes1(table[(input >> 18) & 0x3F]);
                buffer[ptr++] = bytes1(table[(input >> 12) & 0x3F]);
                buffer[ptr++] = bytes1(table[(input >> 6) & 0x3F]);
                buffer[ptr++] = bytes1(table[input & 0x3F]);
                i += 3;
            }
            if (rem == 1) {
                uint256 input = uint256(data[last]);
                buffer[ptr++] = bytes1(table[(input >> 2) & 0x3F]);
                buffer[ptr++] = bytes1(table[(input << 4) & 0x3F]);
                buffer[ptr++] = '=';
                buffer[ptr++] = '=';
            } else if (rem == 2) {
                uint256 input = (uint256(data[last - 1]) << 8) | uint256(data[last]);
                buffer[ptr++] = bytes1(table[(input >> 10) & 0x3F]);
                buffer[ptr++] = bytes1(table[(input >> 4) & 0x3F]);
                buffer[ptr++] = bytes1(table[(input << 2) & 0x3F]);
                buffer[ptr++] = '=';
            }
            return string(buffer);
        }
    }
}
```