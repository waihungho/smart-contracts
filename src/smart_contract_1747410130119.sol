Okay, let's design a smart contract that represents a collaborative digital canvas hosted on the blockchain. Users can claim "tiles" on this canvas as unique NFTs and paint pixels within their owned areas. This involves on-chain storage of pixel data (expensive, but truly decentralized) and various advanced features like dynamic NFT metadata (via linking to off-chain processing), painting fees, delegation, and admin controls.

To strictly adhere to the "don't duplicate any of open source" constraint (which is very challenging and makes code less secure/standardized than using libraries like OpenZeppelin, but we will follow it), we will implement a minimal ERC-721 skeleton and basic Ownable pattern manually.

---

**Outline and Function Summary**

This contract, `CryptoCanvas`, is an ERC-721 non-fungible token contract where each token represents a specific rectangular "tile" on a larger, shared pixel canvas. Owners of these tiles can change the color of the pixels within their tile's boundaries by paying a small fee.

The canvas state (pixel colors) is stored directly on-chain, making it immutable and verifiable. NFT metadata is dynamically generated by an external service that queries the on-chain pixel data for a given tile.

**Key Concepts:**

1.  **On-Chain Canvas:** A grid of pixels (defined by `canvasWidth` and `canvasHeight`) stored in a mapping, where each pixel's color is mapped by its linear index (`y * width + x`).
2.  **Tile NFTs:** Each ERC-721 token represents ownership of a specific rectangular region (`x1, y1` to `x2, y2`) on the canvas.
3.  **Claiming:** Users can claim unclaimed areas of the canvas by minting a new Tile NFT, paying a fee.
4.  **Painting:** Tile owners (or delegated painters) can update the color of pixels within their tile's bounds, paying a fee per pixel.
5.  **Dynamic Metadata:** The `tokenURI` links to an external service that reads the tile's on-chain pixel data to generate an image and metadata JSON reflecting the current state of the art.
6.  **Delegation & Locking:** Tile owners can delegate painting rights to another address or temporarily lock painting on their tile.
7.  **Admin Controls:** The contract owner can set fees, canvas dimensions (initially), and allowed colors.

**Function Summary:**

*   **ERC-721 Standard Functions (Manual Implementation):**
    1.  `balanceOf(address owner)`: Returns the number of tokens owned by an address.
    2.  `ownerOf(uint256 tokenId)`: Returns the owner of a specific token.
    3.  `safeTransferFrom(address from, address to, uint256 tokenId)`: Transfers token ownership safely.
    4.  `safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)`: Transfers token ownership safely with data.
    5.  `transferFrom(address from, address to, uint256 tokenId)`: Transfers token ownership (less safe, doesn't check receiver).
    6.  `approve(address to, uint256 tokenId)`: Approves another address to transfer a specific token.
    7.  `getApproved(uint256 tokenId)`: Returns the approved address for a token.
    8.  `setApprovalForAll(address operator, bool approved)`: Approves or revokes operator access for all tokens of sender.
    9.  `isApprovedForAll(address owner, address operator)`: Checks if an operator is approved for an owner.
    10. `supportsInterface(bytes4 interfaceId)`: Indicates if the contract supports a given interface (ERC721, ERC721Metadata, ERC165).
    11. `tokenURI(uint256 tokenId)`: Returns the metadata URI for a token.
    12. `totalSupply()`: Returns the total number of tokens minted.

*   **Canvas & Tile Management Functions:**
    13. `claimTile(uint256 x1, uint256 y1, uint256 x2, uint256 y2)`: Allows anyone to claim an unclaimed tile area by paying the claim fee, minting a new NFT for it.
    14. `getTileInfo(uint256 tokenId)`: Returns the coordinate boundaries of a specific tile NFT.
    15. `getPixelColor(uint256 x, uint256 y)`: Returns the color of a single pixel at given coordinates.
    16. `getCanvasDimensions()`: Returns the width and height of the canvas.
    17. `isAreaClaimed(uint256 x1, uint256 y1, uint256 x2, uint256 y2)`: Checks if any part of a given area is already claimed.
    18. `burnTile(uint256 tokenId)`: Allows the tile owner to burn their tile NFT, potentially clearing the pixels within it (implementation clears state but keeps pixels for history, marking tile info as invalid).

*   **Painting Functions:**
    19. `paintPixel(uint256 tokenId, uint256 x, uint256 y, bytes3 color)`: Allows the tile owner or delegate to paint a single pixel within the tile's bounds, paying the painting fee.
    20. `paintPixelsBatch(uint256 tokenId, uint256[] calldata xCoords, uint256[] calldata yCoords, bytes3[] calldata colors)`: Allows painting multiple pixels in a single transaction.
    21. `getTilePixelsColor(uint256 tokenId)`: Returns the colors of all pixels within a specific tile. (Useful for off-chain rendering).

*   **Delegation & Locking Functions:**
    22. `lockTilePainting(uint256 tokenId)`: Allows the tile owner to prevent anyone (including delegates and potentially themselves, depending on implementation) from painting on their tile.
    23. `unlockTilePainting(uint256 tokenId)`: Allows the tile owner to re-enable painting.
    24. `isPaintingLocked(uint256 tokenId)`: Checks if painting is currently locked for a tile.
    25. `delegatePainter(uint256 tokenId, address delegatee)`: Allows the tile owner to grant painting rights for that specific tile to another address.
    26. `revokePainterDelegation(uint256 tokenId)`: Allows the tile owner to remove any delegated painter for their tile.
    27. `getDelegatedPainter(uint256 tokenId)`: Returns the address currently delegated to paint on a tile, or address(0) if none.

*   **Admin & Utility Functions (onlyOwner):**
    28. `setPaintingFeePerPixel(uint256 newFee)`: Sets the fee charged per pixel painted.
    29. `setClaimFeePerTile(uint256 newFee)`: Sets the fee required to claim a new tile.
    30. `addAllowedColor(bytes3 color)`: Adds a color to the list of allowed colors for painting.
    31. `removeAllowedColor(bytes3 color)`: Removes a color from the allowed list.
    32. `getAllowedColors()`: Returns the list of colors that can be used for painting.
    33. `setBaseTokenURI(string memory baseURI)`: Sets the base URI for token metadata.
    34. `withdrawFees(address payable recipient)`: Allows the contract owner to withdraw collected fees.
    35. `pausePainting()`: Pauses all painting operations across all tiles.
    36. `unpausePainting()`: Unpauses painting operations.
    37. `isPaintingPaused()`: Checks if painting is globally paused.

*(Note: Implementing a complete, secure, and gas-efficient ERC721 and Ownable from scratch is a significant undertaking and less recommended than using audited libraries in a real-world scenario. This implementation is simplified to meet the "no open source library" constraint for the core features)*.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Outline and Function Summary above

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address approved);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

interface IERC721Metadata is IERC721 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

contract CryptoCanvas is IERC721Metadata {

    // --- State Variables ---

    // Ownable State
    address private _owner;

    // ERC721 State
    string private _name;
    string private _symbol;
    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    uint256 private _nextTokenId;
    string private _baseTokenURI;

    // Canvas State
    uint256 public canvasWidth;
    uint256 public canvasHeight;
    // Stores color (RGB) for each pixel index: y * width + x
    // Default color is black (bytes3(0)) if not set
    mapping(uint256 => bytes3) private canvasPixels;

    // Tile NFT State
    struct TileInfo {
        uint256 x1;
        uint256 y1;
        uint256 x2;
        uint256 y2;
        bool isValid; // Used after burning to indicate tile info is invalid but pixel data remains
    }
    mapping(uint256 => TileInfo) private tiles; // tokenId => TileInfo

    // Mapping to check if a pixel coordinate is part of *any* claimed tile
    // This is simplified. A more robust approach would involve a quadtree or similar for efficient lookup
    // For demonstration, we'll use a simple mapping per pixel. Very gas-intensive for large canvases.
    // Alternative: Store claimed areas in a list and iterate, but slow for `isAreaClaimed`.
    // Let's use the pixel mapping approach for simplicity despite gas cost implications for check.
    // Mapping pixel index to the tokenId that claimed it. 0 means unclaimed.
    mapping(uint256 => uint256) private pixelToTokenId;

    // Painting State
    uint256 public paintingFeePerPixel;
    uint256 public claimFeePerTile;
    mapping(uint256 => bool) private tilePaintingLocked; // tokenId => locked status
    mapping(uint256 => address) private tileDelegatedPainter; // tokenId => delegated address
    bytes3[] public allowedColors; // List of colors permitted for painting
    bool private _paintingPaused; // Global pause for painting

    // --- Events ---

    event TileClaimed(address indexed owner, uint256 indexed tokenId, uint256 x1, uint256 y1, uint256 x2, uint256 y2);
    event PixelsPainted(uint256 indexed tokenId, uint256[] xCoords, uint256[] yCoords, bytes3[] colors);
    event TilePaintingLocked(uint256 indexed tokenId, bool locked);
    event PainterDelegated(uint256 indexed tokenId, address indexed delegatee);
    event TileBurned(uint256 indexed tokenId);
    event FeeWithdrawn(address indexed recipient, uint256 amount);
    event PaintingPaused(bool paused);

    // --- Modifiers ---

    modifier onlyOwner() {
        require(msg.sender == _owner, "Not owner");
        _;
    }

    modifier whenNotPaintingPaused() {
        require(!_paintingPaused, "Painting is paused");
        _;
    }

    // --- Constructor ---

    constructor(string memory name_, string memory symbol_, uint256 width_, uint256 height_, uint256 initialClaimFee, uint256 initialPaintingFee) {
        _owner = msg.sender;
        _name = name_;
        _symbol = symbol_;
        canvasWidth = width_;
        canvasHeight = height_;
        claimFeePerTile = initialClaimFee;
        paintingFeePerPixel = initialPaintingFee;
        _nextTokenId = 1; // Token IDs start from 1

        // Add a few default allowed colors
        allowedColors.push(bytes3(0xFF0000)); // Red
        allowedColors.push(bytes3(0x00FF00)); // Green
        allowedColors.push(bytes3(0x0000FF)); // Blue
        allowedColors.push(bytes3(0x000000)); // Black (default)
        allowedColors.push(bytes3(0xFFFFFF)); // White
    }

    // --- ERC721 Standard Implementations (Manual) ---

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        // ERC165 (0x01ffc9a7)
        // ERC721 (0x80ac58cd)
        // ERC721Metadata (0x5b5e139f)
        return interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;
    }

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721: URI query for nonexistent token");
        // This base URI should point to an external service capable of
        // querying this contract's state (getTileInfo, getTilePixelsColor)
        // and generating the image and metadata JSON dynamically.
        // Example: ipfs://<cid>/token/<tokenId> or https://api.example.com/token/<tokenId>
        string memory base = _baseTokenURI;
        if (bytes(base).length == 0) {
            return "";
        }
        return string(abi.encodePacked(base, Strings.toString(tokenId)));
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        return owner;
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId); // Checks if token exists and gets owner
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "ERC721: approve caller is not owner nor approved for all");
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
         require(_exists(tokenId), "ERC721: approved query for nonexistent token");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != msg.sender, "ERC721: approve to caller");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, data);
    }

    // --- Internal ERC721 Helpers ---

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    function _burn(uint256 tokenId) internal {
        address owner = ownerOf(tokenId); // Checks token existence
        // Clear approvals
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    function _transfer(address from, address to, uint256 tokenId) internal {
        require(ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
        require(to != address(0), "ERC721: transfer to the zero address");

        // Clear approvals
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        // --- CryptoCanvas specific transfer logic ---
        // Optional: Clear delegation/lock on transfer
        delete tileDelegatedPainter[tokenId];
        delete tilePaintingLocked[tokenId];
        emit PainterDelegated(tokenId, address(0)); // Signal delegation cleared
        emit TilePaintingLocked(tokenId, false); // Signal lock cleared
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes calldata data) internal {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes calldata data) private returns (bool) {
        if (to.code.length > 0) { // Check if it's a contract
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {
                return retval == IERC721Receiver.onERC721Received.selector;
            } catch {
                revert("ERC721: transfer to non ERC721Receiver implementer");
            }
        }
        return true; // EOA is always safe
    }

    function _approve(address to, uint256 tokenId) internal {
         _tokenApprovals[tokenId] = to;
         emit Approval(ownerOf(tokenId), to, tokenId);
    }

    // Helper to get next token ID and increment
    function _getNextTokenId() internal returns (uint256) {
        uint256 id = _nextTokenId;
        _nextTokenId++;
        return id;
    }

    // --- Ownable Functions (Manual) ---

    function owner() public view returns (address) {
        return _owner;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _owner = newOwner;
    }

    // --- Canvas & Tile Management Functions ---

    function totalTokens() public view returns (uint256) {
        // This tracks the number of tokens ever minted, including burned ones.
        // For active tokens, use balanceOf(owner) or iterate owners.
        // A more accurate total supply of *valid* tiles would require iterating `tiles` and checking `isValid`.
        // Let's return the number of *minted* tokens, including burned.
        return _nextTokenId - 1;
    }

    function claimTile(uint256 x1, uint256 y1, uint256 x2, uint256 y2) public payable returns (uint256 tokenId) {
        require(msg.value >= claimFeePerTile, "CryptoCanvas: Insufficient claim fee");
        require(x1 <= x2 && y1 <= y2, "CryptoCanvas: Invalid coordinates order");
        require(x2 < canvasWidth && y2 < canvasHeight, "CryptoCanvas: Coordinates out of bounds");

        // Check if any part of the requested area is already claimed
        require(!isAreaClaimed(x1, y1, x2, y2), "CryptoCanvas: Area overlaps with an existing tile");

        tokenId = _getNextTokenId();

        // Mint the ERC721 token
        _mint(msg.sender, tokenId);

        // Store tile information
        tiles[tokenId] = TileInfo(x1, y1, x2, y2, true);

        // Mark pixels within the tile as claimed by this tokenId
        for (uint256 y = y1; y <= y2; ++y) {
            for (uint256 x = x1; x <= x2; ++x) {
                pixelToTokenId[y * canvasWidth + x] = tokenId;
            }
        }

        emit TileClaimed(msg.sender, tokenId, x1, y1, x2, y2);
    }

    function getTileInfo(uint256 tokenId) public view returns (uint256 x1, uint256 y1, uint256 x2, uint256 y2, bool isValid) {
        require(_exists(tokenId) || tiles[tokenId].isValid == false, "CryptoCanvas: Tile does not exist"); // Allow querying info for burned tiles
        TileInfo storage tile = tiles[tokenId];
        return (tile.x1, tile.y1, tile.x2, tile.y2, tile.isValid);
    }

    function getPixelColor(uint256 x, uint256 y) public view returns (bytes3) {
        require(x < canvasWidth && y < canvasHeight, "CryptoCanvas: Coordinates out of bounds");
        uint256 pixelIndex = y * canvasWidth + x;
        return canvasPixels[pixelIndex]; // Returns bytes3(0) (black) if not set
    }

     function getCanvasDimensions() public view returns (uint256 width, uint256 height) {
        return (canvasWidth, canvasHeight);
    }

    function isAreaClaimed(uint256 x1, uint256 y1, uint256 x2, uint256 y2) public view returns (bool) {
        // Check if any pixel in the range is already mapped to a token ID
         require(x1 <= x2 && y1 <= y2, "CryptoCanvas: Invalid coordinates order");
         require(x2 < canvasWidth && y2 < canvasHeight, "CryptoCanvas: Coordinates out of bounds");

        for (uint256 y = y1; y <= y2; ++y) {
            for (uint256 x = x1; x <= x2; ++x) {
                 if (pixelToTokenId[y * canvasWidth + x] != 0) {
                    return true; // Pixel is claimed
                 }
            }
        }
        return false; // No pixel in the range is claimed
    }

    function burnTile(uint256 tokenId) public {
        address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner, "CryptoCanvas: Not tile owner");

        // Burn the ERC721 token
        _burn(tokenId);

        // Mark the tile info as invalid, but keep pixelToTokenId mapping
        // This preserves the art history on the canvas while removing the NFT ownership
        tiles[tokenId].isValid = false;

        // Optionally, clear the pixels if desired, but this is expensive and removes history.
        // For this contract, we keep the pixels.

        // Clear painting lock and delegation
        delete tilePaintingLocked[tokenId];
        delete tileDelegatedPainter[tokenId];
        emit PainterDelegated(tokenId, address(0)); // Signal delegation cleared
        emit TilePaintingLocked(tokenId, false); // Signal lock cleared

        emit TileBurned(tokenId);
    }


    // --- Painting Functions ---

    function paintPixel(uint256 tokenId, uint256 x, uint256 y, bytes3 color) public payable whenNotPaintingPaused {
        address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner || msg.sender == tileDelegatedPainter[tokenId], "CryptoCanvas: Not tile owner or delegated painter");
        require(!tilePaintingLocked[tokenId], "CryptoCanvas: Tile painting is locked");
        require(_isValidColor(color), "CryptoCanvas: Invalid color");

        // Check if the pixel is within the tile's bounds
        TileInfo storage tile = tiles[tokenId];
        require(x >= tile.x1 && x <= tile.x2 && y >= tile.y1 && y <= tile.y2, "CryptoCanvas: Pixel not within tile bounds");

        // Check if the pixel is actually claimed by this tile (redundant with above, but safe)
        uint256 pixelIndex = y * canvasWidth + x;
        require(pixelToTokenId[pixelIndex] == tokenId, "CryptoCanvas: Pixel does not belong to this tile");


        require(msg.value >= paintingFeePerPixel, "CryptoCanvas: Insufficient painting fee");

        // Pay the fee
        // Fees accumulate in the contract balance until withdrawn by owner.

        // Update pixel color
        canvasPixels[pixelIndex] = color;

        // Emit event (simplified for single pixel, batch event is better)
        emit PixelsPainted(tokenId, new uint256[](1), new uint256[](1), new bytes3[](1)); // Simplified event

    }

    function paintPixelsBatch(uint256 tokenId, uint256[] calldata xCoords, uint256[] calldata yCoords, bytes3[] calldata colors) public payable whenNotPaintingPaused {
        address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner || msg.sender == tileDelegatedPainter[tokenId], "CryptoCanvas: Not tile owner or delegated painter");
        require(!tilePaintingLocked[tokenId], "CryptoCanvas: Tile painting is locked");
        require(xCoords.length == yCoords.length && xCoords.length == colors.length, "CryptoCanvas: Array length mismatch");
        require(xCoords.length > 0, "CryptoCanvas: No pixels to paint");

        TileInfo storage tile = tiles[tokenId];
        uint256 totalPixels = xCoords.length;
        uint256 requiredFee = totalPixels * paintingFeePerPixel;
        require(msg.value >= requiredFee, "CryptoCanvas: Insufficient painting fee for batch");

        for (uint256 i = 0; i < totalPixels; ++i) {
            uint256 x = xCoords[i];
            uint256 y = yCoords[i];
            bytes3 color = colors[i];

            // Check if pixel is within tile bounds
            require(x >= tile.x1 && x <= tile.x2 && y >= tile.y1 && y <= tile.y2, "CryptoCanvas: Pixel not within tile bounds in batch");

            // Check if pixel is claimed by this tile
            uint256 pixelIndex = y * canvasWidth + x;
            require(pixelToTokenId[pixelIndex] == tokenId, "CryptoCanvas: Pixel does not belong to this tile in batch");

            // Check if color is allowed
            require(_isValidColor(color), "CryptoCanvas: Invalid color in batch");

            // Update pixel color
            canvasPixels[pixelIndex] = color;
        }

        // Fees accumulate in the contract balance.

        emit PixelsPainted(tokenId, xCoords, yCoords, colors);
    }

    function getTilePixelsColor(uint256 tokenId) public view returns (bytes3[] memory) {
        require(_exists(tokenId) || tiles[tokenId].isValid == false, "CryptoCanvas: Tile does not exist"); // Allow querying burned tiles
        TileInfo storage tile = tiles[tokenId];

        uint256 tileWidth = tile.x2 - tile.x1 + 1;
        uint256 tileHeight = tile.y2 - tile.y1 + 1;
        bytes3[] memory colors = new bytes3[](tileWidth * tileHeight);
        uint256 colorIndex = 0;

        for (uint256 y = tile.y1; y <= tile.y2; ++y) {
            for (uint256 x = tile.x1; x <= tile.x2; ++x) {
                colors[colorIndex] = canvasPixels[y * canvasWidth + x];
                colorIndex++;
            }
        }

        return colors;
    }

    // --- Delegation & Locking Functions ---

    function lockTilePainting(uint256 tokenId) public {
        address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner, "CryptoCanvas: Not tile owner");
        tilePaintingLocked[tokenId] = true;
        emit TilePaintingLocked(tokenId, true);
    }

    function unlockTilePainting(uint256 tokenId) public {
         address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner, "CryptoCanvas: Not tile owner");
        tilePaintingLocked[tokenId] = false;
        emit TilePaintingLocked(tokenId, false);
    }

    function isPaintingLocked(uint256 tokenId) public view returns (bool) {
        require(_exists(tokenId) || tiles[tokenId].isValid == false, "CryptoCanvas: Tile does not exist");
        return tilePaintingLocked[tokenId];
    }

    function delegatePainter(uint256 tokenId, address delegatee) public {
         address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner, "CryptoCanvas: Not tile owner");
        require(delegatee != address(0), "CryptoCanvas: Delegatee cannot be zero address");
        require(delegatee != owner, "CryptoCanvas: Cannot delegate to owner"); // Owner always has rights

        tileDelegatedPainter[tokenId] = delegatee;
        emit PainterDelegated(tokenId, delegatee);
    }

    function revokePainterDelegation(uint256 tokenId) public {
         address owner = ownerOf(tokenId); // Checks token existence
        require(msg.sender == owner, "CryptoCanvas: Not tile owner");

        delete tileDelegatedPainter[tokenId];
        emit PainterDelegated(tokenId, address(0)); // Signal delegation revoked
    }

    function getDelegatedPainter(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId) || tiles[tokenId].isValid == false, "CryptoCanvas: Tile does not exist");
        return tileDelegatedPainter[tokenId];
    }


    // --- Admin & Utility Functions ---

    function setPaintingFeePerPixel(uint256 newFee) public onlyOwner {
        paintingFeePerPixel = newFee;
    }

    function setClaimFeePerTile(uint256 newFee) public onlyOwner {
        claimFeePerTile = newFee;
    }

    function addAllowedColor(bytes3 color) public onlyOwner {
        // Prevent adding duplicates
        for(uint i = 0; i < allowedColors.length; i++) {
            if (allowedColors[i] == color) {
                return;
            }
        }
        allowedColors.push(color);
    }

    function removeAllowedColor(bytes3 color) public onlyOwner {
        for(uint i = 0; i < allowedColors.length; i++) {
            if (allowedColors[i] == color) {
                // Simple removal by swapping with last and popping
                allowedColors[i] = allowedColors[allowedColors.length - 1];
                allowedColors.pop();
                return; // Assuming only one instance needs removal
            }
        }
        // Optionally revert if color not found: require(false, "Color not found");
    }

    function getAllowedColors() public view returns (bytes3[] memory) {
        return allowedColors;
    }

    function setBaseTokenURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    function withdrawFees(address payable recipient) public onlyOwner {
         // Use a reentrancy guard if complex interactions were involved,
         // but a simple send/call after checks is generally safe for withdrawals.
         // Since we are avoiding external libraries like ReentrancyGuard,
         // ensure transfer is the last operation.
        uint256 balance = address(this).balance;
        require(balance > 0, "CryptoCanvas: No fees to withdraw");
        require(recipient != address(0), "CryptoCanvas: Recipient cannot be zero address");

        (bool success, ) = recipient.call{value: balance}("");
        require(success, "CryptoCanvas: Fee withdrawal failed");

        emit FeeWithdrawn(recipient, balance);
    }

    function pausePainting() public onlyOwner {
        _paintingPaused = true;
        emit PaintingPaused(true);
    }

    function unpausePainting() public onlyOwner {
        _paintingPaused = false;
        emit PaintingPaused(false);
    }

    function isPaintingPaused() public view returns (bool) {
        return _paintingPaused;
    }

    // --- Internal Helper Functions ---

    // Checks if a given color is in the allowed list
    function _isValidColor(bytes3 color) internal view returns (bool) {
        for (uint i = 0; i < allowedColors.length; i++) {
            if (allowedColors[i] == color) {
                return true;
            }
        }
        return false;
    }

    // Minimal SafeMath-like functionality for toString (for tokenURI)
    library Strings {
        function toString(uint256 value) internal pure returns (string memory) {
            if (value == 0) {
                return "0";
            }
            uint256 temp = value;
            uint256 digits;
            while (temp != 0) {
                digits++;
                temp /= 10;
            }
            bytes memory buffer = new bytes(digits);
            while (value != 0) {
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + uint252(value % 10)));
                value /= 10;
            }
            return string(buffer);
        }
    }

    // Dummy ERC721Receiver interface for `safeTransferFrom`
    interface IERC721Receiver {
        function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
    }
}
```