Okay, here is a design for a complex, advanced, and creative smart contract.

**Concept:** Decentralized NFT Lending Marketplace with Fractionalization, Dynamic Pricing, and Buyout Mechanisms.

This contract allows users to:
1.  Deposit NFTs to be used as collateral or for fractionalization.
2.  List deposited NFTs as offers for peer-to-peer loans (setting desired terms).
3.  Lend tokens by funding these loan offers.
4.  Borrow tokens using their listed NFT as collateral once the offer is funded.
5.  Repay loans to reclaim their NFT.
6.  Liquidate defaulted loans (claiming the NFT under certain conditions or triggering a process).
7.  Request fractionalization of a deposited NFT, creating unique ERC-1155 shares representing ownership claims on the NFT or its potential income/buyout value.
8.  Manage basic selling of fractional shares via an internal pool.
9.  Claim a proportional share of certain platform fees or income generated by the NFT based on their fractional share holdings.
10. Propose and vote on buying out a fractionalized NFT to consolidate ownership.
11. Interact with dynamic pricing mechanisms for interest rates and platform fees based on internal platform metrics.

**Outline:**

1.  **State Variables & Data Structures:**
    *   Counters for unique IDs (Deposits, Loan Offers, Loans, Fractionalized NFTs, Buyout Proposals).
    *   Mappings to store details for each entity type (DepositedNFT, LoanOffer, Loan, FractionalizedNFT, BuyoutProposal).
    *   Mapping for tracking shares of fractionalized NFTs (acting as ERC-1155 balances).
    *   Mappings for supported NFT collections and loan tokens.
    *   State variables for dynamic pricing parameters.
    *   Platform fee balance.
    *   Access control (Owner/Admin).
    *   Paused state.
2.  **Enums:** Status types for deposits, loan offers, loans, fractionalized NFTs, buyout proposals.
3.  **Events:** Significant state changes (Deposit, Withdrawal, LoanOfferCreated, LoanFunded, Borrowed, Repaid, Liquidated, Fractionalized, SharesBought/Sold, BuyoutProposed, Voted, BuyoutExecuted, FeeClaimed, etc.).
4.  **Modifiers:** Access control, Paused state checks.
5.  **Access Control Functions:** Setting supported tokens, updating parameters, withdrawing fees, pausing.
6.  **Core NFT Deposit/Withdrawal:** Functions to handle NFT custody.
7.  **Lending/Borrowing Functions:**
    *   Creating loan offers.
    *   Funding loan offers.
    *   Executing borrow.
    *   Repaying loan.
    *   Claiming repayment (lender).
    *   Triggering liquidation.
    *   Canceling loan offer.
8.  **Fractionalization Functions:**
    *   Requesting/Creating fractionalized NFT and issuing shares.
    *   Buying/Selling shares via a simple internal pool.
    *   Claiming income from fractional shares.
9.  **Buyout Mechanism Functions:**
    *   Proposing a buyout.
    *   Voting on a buyout proposal.
    *   Executing a successful buyout.
    *   Claiming buyout funds.
10. **Dynamic Pricing Functions:** Internal view functions to calculate current rates/fees (explained as views, calculation logic would be complex).
11. **View Functions:** Getting status and details of deposits, loans, fractionalized NFTs, etc.
12. **Internal ERC-1155 Management:** Implementation of key ERC-1155 functions (`balanceOf`, `safeTransferFrom`, etc.) managing internal share balances.
13. **Receive/Fallback:** Handling ETH payments.

**Function Summary (>= 20):**

1.  `constructor()`: Initializes owner, counters, potentially sets initial parameters.
2.  `pause()`: Owner pauses contract operations (except admin/withdrawal).
3.  `unpause()`: Owner unpauses contract.
4.  `setSupportedNFTCollection(address nftContract, bool supported)`: Owner sets which NFT collections are allowed.
5.  `setSupportedLoanToken(address tokenContract, bool supported)`: Owner sets which ERC-20 tokens can be used for loans/fees/buyouts.
6.  `depositNFT(address nftContract, uint256 tokenId)`: User transfers an approved NFT to the contract. Stores NFT details and assigns a `depositedNFTId`. Requires ERC-721 approval.
7.  `withdrawNFT(uint256 depositedNFTId)`: User withdraws an *unused* or *repaid* deposited NFT.
8.  `listNFTSingleLoan(uint256 depositedNFTId, uint256 principalAmount, uint64 duration, address loanToken)`: Owner of a deposited NFT lists it for a single loan offer with specified terms.
9.  `cancelLoanOffer(uint256 loanOfferId)`: Owner cancels an un-funded loan offer.
10. `provideLoanLiquidity(uint256 loanOfferId)`: A lender provides the required `principalAmount` in `loanToken` to a loan offer. Requires ERC-20 approval.
11. `borrow(uint256 loanOfferId)`: The original offerer (borrower) takes out the loan after it's fully funded. Transfers principal to borrower.
12. `repayLoan(uint256 loanId)`: Borrower repays principal + calculated interest + platform fee. Reclaims NFT. Requires ERC-20 approval (or sends ETH).
13. `claimLoanRepayment(uint256 loanId)`: Lender claims their repaid principal and interest after a successful loan repayment.
14. `liquidateLoan(uint256 loanId)`: Allows anyone to trigger liquidation if a loan is overdue. The NFT is then marked for seizure (e.g., by owner/admin or via a subsequent auction/claim process, simplified here to owner control post-liquidation).
15. `createFractionalizedNFT(uint256 depositedNFTId, string memory sharesName, string memory sharesSymbol, uint256 totalShares, uint256 initialOwnerShares)`: Converts a deposited NFT into a fractionalized asset. Mints `totalShares` of a new internal ERC-1155 token type (unique to this fractionalized NFT), assigning `initialOwnerShares` to the owner. The rest might go to a pool or platform.
16. `listSharesForFixedPriceSale(uint256 fractionalizedNFTId, uint256 amount, uint256 pricePerShare, address priceToken)`: Owner/shareholder lists a specific amount of shares into an internal fixed-price pool.
17. `buySharesFromFixedPriceSale(uint256 fractionalizedNFTId, uint256 amount)`: User buys shares from the internal fixed-price pool. Requires payment in the specified `priceToken`. Requires ERC-20 approval (or sends ETH).
18. `claimFractionalIncome(uint256 fractionalizedNFTId)`: Fractional share holders claim their pro-rata share of any accumulated income for this fractionalized NFT (e.g., portion of platform fees associated with this NFT's loans/activities).
19. `proposeNFTBuyout(uint256 fractionalizedNFTId, uint256 offerAmount, address offerToken, uint64 votingDuration)`: A user proposes to buy the entire fractionalized NFT for a specific amount in a specific token. Starts a voting period. Requires escrowing the offer amount.
20. `voteOnBuyout(uint256 buyoutProposalId, bool approve)`: Fractional share holders cast their weighted vote (based on share balance) on a buyout proposal.
21. `executeBuyout(uint256 buyoutProposalId)`: Executes the buyout if the proposal succeeded (passed vote, funds escrowed, voting period ended). Transfers NFT to the proposer, distributes offer funds to share holders, burns shares.
22. `claimBuyoutFunds(uint256 buyoutProposalId)`: Fractional share holders claim their share of the successful buyout funds.
23. `getDynamicInterestRate(uint256 depositedNFTId)`: *View function* - Calculates the *current* dynamic interest rate based on predefined logic (e.g., platform loan token utilization, potentially NFT tier). *Implementation of complex dynamic logic within the contract's gas limits is challenging; this function would likely fetch simple, on-chain available data or rely on parameters set by admin/oracle.*
24. `getDynamicPlatformFee()`: *View function* - Calculates the *current* dynamic platform fee based on predefined logic (e.g., total platform volume, time-based tiers).
25. `withdrawPlatformFees(address token, uint256 amount)`: Owner/Admin withdraws accumulated platform fees in a specific token.
26. `getDepositedNFT(uint256 depositedNFTId)`: *View function* - Get details of a deposited NFT.
27. `getLoanOffer(uint256 loanOfferId)`: *View function* - Get details of a loan offer.
28. `getLoan(uint256 loanId)`: *View function* - Get details of an active or past loan.
29. `getFractionalizedNFT(uint256 fractionalizedNFTId)`: *View function* - Get details of a fractionalized NFT.
30. `balanceOf(address account, uint256 id)`: *View function (ERC-1155)* - Get balance of fractional shares for a specific fractionalized NFT ID.
31. `safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data)`: *Internal ERC-1155 implementation* - Transfer shares.
32. `receive()`: Fallback function to receive ETH for payments (loans, fees, buyouts, share purchases).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Interfaces (Simplified for clarity - full interfaces would be imported)
interface IERC721 {
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function approve(address to, uint256 tokenId) external;
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

interface IERC1155 {
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);

    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
    // Optional: ERC1155MetadataURI
    function uri(uint256 id) external view returns (string memory);
}

// Basic Ownable pattern
contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(msg.sender);
    }

    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function _checkOwner() internal view virtual {
        require(owner() == msg.sender, "Ownable: caller is not the owner");
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}


contract DecentralizedNFTLendingMarketplaceWithFractionalizationAndDynamicPricing is Ownable {

    // --- State Variables & Data Structures ---

    uint256 private _nextDepositId = 1;
    uint256 private _nextLoanOfferId = 1;
    uint256 private _nextLoanId = 1;
    uint256 private _nextFractionalizedNFTId = 1; // Use this as ERC-1155 ID for shares
    uint256 private _nextBuyoutProposalId = 1;

    enum DepositStatus { Active, UsedInLoan, UsedInFractionalization, Withdrawn }
    struct DepositedNFT {
        uint256 id;
        address originalOwner; // Who deposited it
        address nftContract;
        uint256 tokenId;
        DepositStatus status;
        uint256 loanOfferId; // 0 if not used in loan offer
        uint256 fractionalizedNFTId; // 0 if not fractionalized
    }
    mapping(uint256 => DepositedNFT) public depositedNFTs;
    mapping(address => uint256[]) private _userDeposits; // Track deposits by user


    enum LoanOfferStatus { Open, Funded, Cancelled, Taken }
    struct LoanOffer {
        uint256 id;
        uint256 depositedNFTId;
        uint256 principalAmount;
        uint64 duration; // In seconds
        address loanToken;
        LoanOfferStatus status;
        address offerer; // The borrower
        uint256 fundedAmount;
        address lender; // Single lender for P2P offer
        uint256 loanId; // 0 if not taken
    }
    mapping(uint256 => LoanOffer) public loanOffers;
    mapping(address => uint256[]) private _userLoanOffers; // Track offers by user


    enum LoanStatus { Active, Repaid, Liquidated }
    struct Loan {
        uint256 id;
        uint256 loanOfferId;
        uint256 principalAmount;
        uint256 interestAmount; // Calculated at borrow time
        uint64 duration;
        address loanToken;
        address borrower;
        address lender;
        uint66 startTime;
        uint66 endTime; // startTime + duration
        LoanStatus status;
        bool lenderClaimed;
    }
    mapping(uint256 => Loan) public loans;
    mapping(address => uint256[]) private _userLoans; // Track loans by user


    enum FractionalizedNFTStatus { Active, BuyoutProposed, BuyoutExecuted }
    struct FractionalizedNFT {
        uint256 id; // ERC-1155 token ID for shares
        uint256 depositedNFTId;
        address nftContract;
        uint256 tokenId;
        string sharesName;
        string sharesSymbol;
        uint256 totalShares;
        FractionalizedNFTStatus status;
        mapping(address => uint256) incomeClaimed; // Track claimed income per user
        uint256 totalIncomeGenerated; // Total income available for distribution
        // Simple fixed-price sale pool
        uint256 sharesForSalePool;
        uint256 pricePerSharePool;
        address priceTokenPool; // Token used for pool sales
    }
    mapping(uint256 => FractionalizedNFT) public fractionalizedNFTs;

    // Internal ERC-1155 balances for fractional shares
    mapping(address => mapping(uint256 => uint256)) private _shareBalances;
    mapping(address => mapping(address => bool)) private _operatorApprovals; // ERC-1155 operator approvals

    enum BuyoutStatus { Voting, Succeeded, Failed, Executed, Cancelled }
    struct BuyoutProposal {
        uint256 id;
        uint256 fractionalizedNFTId;
        address proposer;
        uint256 offerAmount;
        address offerToken;
        uint64 votingStartTime;
        uint64 votingEndTime;
        BuyoutStatus status;
        uint256 votesFor; // Weighted by shares
        uint256 votesAgainst; // Weighted by shares
        uint256 totalSharesAtSnapshot; // Total shares eligible to vote
        mapping(address => bool) hasVoted; // Track if an address has voted
        mapping(address => uint256) buyoutFundsClaimed; // Track claimed funds per share holder
    }
    mapping(uint256 => BuyoutProposal) public buyoutProposals;


    mapping(address => bool) public supportedNFTCollections;
    mapping(address => bool) public supportedLoanTokens; // Also used for priceTokenPool and offerToken

    // Dynamic pricing parameters (Simplified)
    // These would ideally be more complex, potentially using oracles or chained calculations
    uint256 public baseInterestRateBips = 500; // 5% in Basis Points (0.01%)
    uint256 public utilizationRateFactor = 100; // How much utilization affects rate
    uint256 public basePlatformFeeBips = 100; // 1%
    uint256 public volumeFactor = 5; // How much volume affects fee

    mapping(address => uint256) public platformFeeBalances; // Fees collected per token

    bool public paused = false;

    // --- Events ---

    event Paused(address account);
    event Unpaused(address account);
    event SupportedNFTCollectionSet(address indexed nftContract, bool supported);
    event SupportedLoanTokenSet(address indexed tokenContract, bool supported);
    event NFTDeposited(uint256 indexed depositId, address indexed originalOwner, address indexed nftContract, uint256 tokenId);
    event NFTWithdrawn(uint256 indexed depositId, address indexed originalOwner, address indexed nftContract, uint256 tokenId);
    event LoanOfferCreated(uint256 indexed offerId, uint256 indexed depositedNFTId, uint256 principalAmount, uint64 duration, address loanToken, address offerer);
    event LoanOfferCancelled(uint256 indexed offerId);
    event LoanOfferFunded(uint256 indexed offerId, address indexed lender, uint256 amount);
    event LoanBorrowed(uint256 indexed loanId, uint256 indexed offerId, address indexed borrower, address indexed lender, uint256 principalAmount, uint256 interestAmount, address loanToken);
    event LoanRepaid(uint256 indexed loanId, address indexed borrower, uint256 amountPaid);
    event LoanRepaymentClaimed(uint256 indexed loanId, address indexed lender, uint256 principalAmount, uint256 interestAmount);
    event LoanLiquidated(uint256 indexed loanId, address liquidator);
    event NFTFractionalized(uint256 indexed fractionalizedNFTId, uint256 indexed depositedNFTId, string sharesName, string sharesSymbol, uint256 totalShares);
    event SharesListedForSale(uint256 indexed fractionalizedNFTId, uint256 indexed amount, uint256 pricePerShare, address priceToken);
    event SharesBoughtFromSale(uint256 indexed fractionalizedNFTId, address indexed buyer, uint256 indexed amount, uint256 amountPaid);
    event FractionalIncomeClaimed(uint256 indexed fractionalizedNFTId, address indexed shareHolder, uint256 amount);
    event BuyoutProposed(uint256 indexed proposalId, uint256 indexed fractionalizedNFTId, address indexed proposer, uint256 offerAmount, address offerToken, uint64 votingEndTime);
    event VotedOnBuyout(uint256 indexed proposalId, address indexed voter, bool vote);
    event BuyoutExecuted(uint256 indexed proposalId, uint256 indexed fractionalizedNFTId, address indexed newOwner);
    event BuyoutFundsClaimed(uint256 indexed proposalId, address indexed shareHolder, uint256 amount);
    event PlatformFeesWithdrawn(address indexed token, address indexed to, uint256 amount);

    // ERC-1155 standard events (required for interface compliance)
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    // URI event is optional, not implemented here

    // --- Modifiers ---

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    // --- Access Control Functions ---

    /**
     * @notice Pauses contract operations. Only callable by owner.
     */
    function pause() external onlyOwner whenNotPaused {
        paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @notice Unpauses contract operations. Only callable by owner.
     */
    function unpause() external onlyOwner {
        require(paused, "Contract is not paused");
        paused = false;
        emit Unpaused(msg.sender);
    }

    /**
     * @notice Sets whether an NFT collection contract is supported. Only callable by owner.
     * @param nftContract The address of the NFT contract.
     * @param supported Boolean indicating if supported.
     */
    function setSupportedNFTCollection(address nftContract, bool supported) external onlyOwner {
        supportedNFTCollections[nftContract] = supported;
        emit SupportedNFTCollectionSet(nftContract, supported);
    }

    /**
     * @notice Sets whether an ERC-20 token is supported for loans, fees, and buyouts. Only callable by owner.
     * @param tokenContract The address of the ERC-20 token contract.
     * @param supported Boolean indicating if supported.
     */
    function setSupportedLoanToken(address tokenContract, bool supported) external onlyOwner {
        supportedLoanTokens[tokenContract] = supported;
        emit SupportedLoanTokenSet(tokenContract, supported);
    }

    /**
     * @notice Sets dynamic pricing parameters. Only callable by owner.
     * @param _baseInterestRateBips New base interest rate in basis points.
     * @param _utilizationRateFactor New utilization rate factor.
     * @param _basePlatformFeeBips New base platform fee in basis points.
     * @param _volumeFactor New volume factor.
     */
    function setDynamicPricingParameters(
        uint256 _baseInterestRateBips,
        uint256 _utilizationRateFactor,
        uint256 _basePlatformFeeBips,
        uint256 _volumeFactor
    ) external onlyOwner {
        baseInterestRateBips = _baseInterestRateBips;
        utilizationRateFactor = _utilizationRateFactor;
        basePlatformFeeBips = _basePlatformFeeBips;
        volumeFactor = _volumeFactor;
    }

    /**
     * @notice Owner withdraws collected platform fees for a specific token.
     * @param token The address of the fee token.
     * @param amount The amount to withdraw.
     */
    function withdrawPlatformFees(address token, uint256 amount) external onlyOwner {
        require(platformFeeBalances[token] >= amount, "Insufficient fee balance");
        platformFeeBalances[token] -= amount;
        bool success;
        if (token == address(0)) { // Assuming address(0) represents ETH
             (success, ) = payable(owner()).call{value: amount}("");
             require(success, "ETH transfer failed");
        } else {
             success = IERC20(token).transfer(owner(), amount);
             require(success, "Token transfer failed");
        }
        emit PlatformFeesWithdrawn(token, owner(), amount);
    }


    // --- Core NFT Deposit/Withdrawal ---

    /**
     * @notice Deposits an approved NFT into the contract.
     * @param nftContract The address of the NFT contract.
     * @param tokenId The token ID of the NFT.
     */
    function depositNFT(address nftContract, uint256 tokenId) external whenNotPaused {
        require(supportedNFTCollections[nftContract], "NFT collection not supported");
        require(IERC721(nftContract).ownerOf(tokenId) == msg.sender, "Caller is not the owner of the NFT");
        // Ensure the contract is approved to transfer the NFT
        require(IERC721(nftContract).isApprovedForAll(msg.sender, address(this)), "Requires NFT approval for all");

        uint256 depositId = _nextDepositId++;
        depositedNFTs[depositId] = DepositedNFT({
            id: depositId,
            originalOwner: msg.sender,
            nftContract: nftContract,
            tokenId: tokenId,
            status: DepositStatus.Active,
            loanOfferId: 0,
            fractionalizedNFTId: 0
        });
        _userDeposits[msg.sender].push(depositId);

        IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);

        emit NFTDeposited(depositId, msg.sender, nftContract, tokenId);
    }

    /**
     * @notice Withdraws an unused or repaid deposited NFT.
     * @param depositedNFTId The ID of the deposited NFT.
     */
    function withdrawNFT(uint256 depositedNFTId) external whenNotPaused {
        DepositedNFT storage deposit = depositedNFTs[depositedNFTId];
        require(deposit.originalOwner == msg.sender, "Not the original owner");
        require(deposit.status == DepositStatus.Active || deposit.status == DepositStatus.Withdrawn, "NFT is currently in use"); // Allow withdrawal after loan repayment sets status to Withdrawn
        require(deposit.status != DepositStatus.UsedInFractionalization, "NFT is fractionalized"); // Cannot withdraw if fractionalized

        deposit.status = DepositStatus.Withdrawn; // Mark as withdrawn immediately

        IERC721(deposit.nftContract).safeTransferFrom(address(this), deposit.originalOwner, deposit.tokenId);

        emit NFTWithdrawn(depositedNFTId, deposit.originalOwner, deposit.nftContract, deposit.tokenId);
    }


    // --- Lending/Borrowing Functions ---

    /**
     * @notice Creates a single loan offer for a deposited NFT.
     * @param depositedNFTId The ID of the deposited NFT.
     * @param principalAmount The amount of loan token requested.
     * @param duration The loan duration in seconds.
     * @param loanToken The address of the desired loan token (address(0) for ETH).
     */
    function listNFTSingleLoan(
        uint256 depositedNFTId,
        uint256 principalAmount,
        uint64 duration,
        address loanToken
    ) external whenNotPaused {
        DepositedNFT storage deposit = depositedNFTs[depositedNFTId];
        require(deposit.originalOwner == msg.sender, "Not the original owner of the deposit");
        require(deposit.status == DepositStatus.Active, "NFT is not active for listing");
        require(loanToken == address(0) || supportedLoanTokens[loanToken], "Loan token not supported");
        require(principalAmount > 0, "Principal must be greater than 0");
        require(duration > 0, "Duration must be greater than 0");

        deposit.status = DepositStatus.UsedInLoan;

        uint256 offerId = _nextLoanOfferId++;
        loanOffers[offerId] = LoanOffer({
            id: offerId,
            depositedNFTId: depositedNFTId,
            principalAmount: principalAmount,
            duration: duration,
            loanToken: loanToken,
            status: LoanOfferStatus.Open,
            offerer: msg.sender,
            fundedAmount: 0,
            lender: address(0), // P2P, single lender
            loanId: 0
        });
         _userLoanOffers[msg.sender].push(offerId);

        emit LoanOfferCreated(offerId, depositedNFTId, principalAmount, duration, loanToken, msg.sender);
    }

    /**
     * @notice Provides liquidity (funds) for a specific open loan offer. P2P model assumes one lender fills the offer.
     * @param loanOfferId The ID of the loan offer to fund.
     */
    function provideLoanLiquidity(uint256 loanOfferId) external payable whenNotPaused {
        LoanOffer storage offer = loanOffers[loanOfferId];
        require(offer.status == LoanOfferStatus.Open, "Loan offer is not open");
        require(offer.lender == address(0), "Loan offer is already funded"); // P2P single lender

        uint256 amountProvided = offer.loanToken == address(0) ? msg.value : offer.principalAmount;

        if (offer.loanToken != address(0)) {
             require(msg.value == 0, "ETH sent with ERC20 loan token");
             require(supportedLoanTokens[offer.loanToken], "Loan token not supported");
             require(IERC20(offer.loanToken).allowance(msg.sender, address(this)) >= amountProvided, "Requires token allowance");
             bool success = IERC20(offer.loanToken).transferFrom(msg.sender, address(this), amountProvided);
             require(success, "Token transfer failed");
        } else {
             require(msg.value == amountProvided, "Incorrect ETH amount sent");
        }

        offer.fundedAmount = amountProvided;
        offer.lender = msg.sender;
        offer.status = LoanOfferStatus.Funded;

        emit LoanOfferFunded(offerId, msg.sender, amountProvided);
    }

    /**
     * @notice Borrower finalizes a funded loan offer to start the loan term.
     * @param loanOfferId The ID of the funded loan offer.
     */
    function borrow(uint256 loanOfferId) external whenNotPaused {
        LoanOffer storage offer = loanOffers[loanOfferId];
        require(offer.offerer == msg.sender, "Only the offerer can borrow");
        require(offer.status == LoanOfferStatus.Funded, "Loan offer is not funded");
        require(offer.fundedAmount == offer.principalAmount, "Loan offer not fully funded");

        offer.status = LoanOfferStatus.Taken;

        // Calculate interest and fees dynamically at borrow time
        uint256 currentInterestRate = _calculateInterestRate(offer.depositedNFTId); // Bips per duration
        uint256 interestAmount = (offer.principalAmount * currentInterestRate) / 10000;
        uint256 totalRepaymentAmount = offer.principalAmount + interestAmount;

        uint256 platformFeeBips = _getDynamicPlatformFee(); // Bips
        uint256 platformFeeAmount = (totalRepaymentAmount * platformFeeBips) / 10000;
        totalRepaymentAmount += platformFeeAmount; // Fee added to repayment amount for borrower

        uint256 loanId = _nextLoanId++;
        uint66 startTime = uint66(block.timestamp);
        uint66 endTime = startTime + offer.duration;

        loans[loanId] = Loan({
            id: loanId,
            loanOfferId: loanOfferId,
            principalAmount: offer.principalAmount,
            interestAmount: interestAmount,
            duration: offer.duration, // Store original duration
            loanToken: offer.loanToken,
            borrower: msg.sender,
            lender: offer.lender,
            startTime: startTime,
            endTime: endTime,
            status: LoanStatus.Active,
            lenderClaimed: false
        });
        offer.loanId = loanId;
        _userLoans[msg.sender].push(loanId);
        _userLoans[offer.lender].push(loanId); // Lender also has this loan ID associated

        // Transfer principal to borrower
        bool success;
        if (offer.loanToken == address(0)) {
            (success, ) = payable(offer.offerer).call{value: offer.principalAmount}("");
            require(success, "ETH transfer to borrower failed");
        } else {
            success = IERC20(offer.loanToken).transfer(offer.offerer, offer.principalAmount);
            require(success, "Token transfer to borrower failed");
        }

        emit LoanBorrowed(loanId, loanOfferId, msg.sender, offer.lender, offer.principalAmount, interestAmount, offer.loanToken);
    }

    /**
     * @notice Borrower repays an active loan.
     * @param loanId The ID of the loan to repay.
     */
    function repayLoan(uint256 loanId) external payable whenNotPaused {
        Loan storage loan = loans[loanId];
        require(loan.borrower == msg.sender, "Not the borrower");
        require(loan.status == LoanStatus.Active, "Loan is not active");

        // Recalculate total repayment amount including fee (same as calculated at borrow)
        uint256 totalRepaymentAmount = loan.principalAmount + loan.interestAmount; // Interest amount already includes platform fee portion

        // Ensure correct amount is sent
        if (loan.loanToken == address(0)) {
            require(msg.value == totalRepaymentAmount, "Incorrect ETH amount sent for repayment");
        } else {
             require(msg.value == 0, "ETH sent with ERC20 repayment");
             require(IERC20(loan.loanToken).allowance(msg.sender, address(this)) >= totalRepaymentAmount, "Requires token allowance for repayment");
             bool success = IERC20(loan.loanToken).transferFrom(msg.sender, address(this), totalRepaymentAmount);
             require(success, "Token transfer failed for repayment");
        }

        loan.status = LoanStatus.Repaid;

        // Distribute repayment: Principal + Interest to Lender, Fee to Platform
        uint256 platformFeeAmount = _getDynamicPlatformFeeAmount(loan.principalAmount, loan.interestAmount); // Extract fee amount

        uint256 amountToLender = loan.principalAmount + loan.interestAmount - platformFeeAmount;
        uint256 amountToPlatform = platformFeeAmount;

        platformFeeBalances[loan.loanToken] += amountToPlatform;

        // Note: Lender must claim their portion separately using claimLoanRepayment
        // This prevents reentrancy issues if the lender is a malicious contract.
        // The funds stay in THIS contract until claimed.

        // Return NFT to borrower
        DepositedNFT storage deposit = depositedNFTs[loanOffers[loan.loanOfferId].depositedNFTId];
        deposit.status = DepositStatus.Withdrawn; // Mark deposit as available for withdrawal (or auto-withdraw)

        IERC721(deposit.nftContract).safeTransferFrom(address(this), loan.borrower, deposit.tokenId);

        emit LoanRepaid(loanId, msg.sender, totalRepaymentAmount);
    }

     /**
      * @notice Lender claims principal and interest after a loan is repaid.
      * @param loanId The ID of the loan.
      */
    function claimLoanRepayment(uint256 loanId) external whenNotPaused {
        Loan storage loan = loans[loanId];
        require(loan.lender == msg.sender, "Not the lender");
        require(loan.status == LoanStatus.Repaid, "Loan is not repaid");
        require(!loan.lenderClaimed, "Lender has already claimed repayment");

        // Calculate amount due to lender (total repayment - platform fee)
        uint256 platformFeeAmount = _getDynamicPlatformFeeAmount(loan.principalAmount, loan.interestAmount);
        uint256 amountToLender = loan.principalAmount + loan.interestAmount - platformFeeAmount;

        loan.lenderClaimed = true;

        bool success;
        if (loan.loanToken == address(0)) {
            (success, ) = payable(loan.lender).call{value: amountToLender}("");
            require(success, "ETH transfer to lender failed");
        } else {
            success = IERC20(loan.loanToken).transfer(loan.lender, amountToLender);
            require(success, "Token transfer to lender failed");
        }

        emit LoanRepaymentClaimed(loanId, msg.sender, loan.principalAmount, loan.interestAmount - platformFeeAmount); // Emitting lender interest
    }


    /**
     * @notice Triggers the liquidation process for an overdue loan.
     * Simplified: Transfers the collateral NFT to the contract owner/admin for manual resolution.
     * In a more complex system, this might trigger an auction, allow the lender to claim, etc.
     * @param loanId The ID of the loan to liquidate.
     */
    function liquidateLoan(uint256 loanId) external whenNotPaused {
        Loan storage loan = loans[loanId];
        require(loan.status == LoanStatus.Active, "Loan is not active");
        require(block.timestamp > loan.endTime, "Loan is not yet overdue");

        loan.status = LoanStatus.Liquidated;

        // Seize the collateral NFT
        DepositedNFT storage deposit = depositedNFTs[loanOffers[loan.loanOfferId].depositedNFTId];
        deposit.status = DepositStatus.Withdrawn; // Mark deposit as effectively withdrawn (by liquidator/owner)

        // Simplified: Transfer NFT to contract owner for disposition
        // A real system would have a more defined liquidation process (auction, lender claim, etc.)
        IERC721(deposit.nftContract).safeTransferFrom(address(this), owner(), deposit.tokenId);

        // The lender's principal + interest remains in the contract or is lost, depending on liquidation rules.
        // In this simplified version, the lender does NOT automatically get the NFT or their funds back via this call.
        // Manual intervention by owner is implied after liquidation.

        emit LoanLiquidated(loanId, msg.sender);
    }

    /**
     * @notice Allows the loan offerer to cancel their offer if it hasn't been funded.
     * @param loanOfferId The ID of the loan offer to cancel.
     */
    function cancelLoanOffer(uint256 loanOfferId) external whenNotPaused {
        LoanOffer storage offer = loanOffers[loanOfferId];
        require(offer.offerer == msg.sender, "Only the offerer can cancel");
        require(offer.status == LoanOfferStatus.Open, "Loan offer cannot be cancelled");

        offer.status = LoanOfferStatus.Cancelled;

        DepositedNFT storage deposit = depositedNFTs[offer.depositedNFTId];
        deposit.status = DepositStatus.Active; // Make deposited NFT available again

        emit LoanOfferCancelled(loanOfferId);
    }


    // --- Fractionalization Functions ---

    /**
     * @notice Creates a fractionalized asset from a deposited NFT and mints shares.
     * This contract acts as the minter/manager of these shares (ERC-1155).
     * @param depositedNFTId The ID of the deposited NFT.
     * @param sharesName The name for the shares (e.g., "BAYC #123 Shares").
     * @param sharesSymbol The symbol for the shares (e.g., "BAYCS123").
     * @param totalShares The total supply of fractional shares to mint.
     * @param initialOwnerShares How many shares to mint to the original depositor's address.
     */
    function createFractionalizedNFT(
        uint256 depositedNFTId,
        string memory sharesName,
        string memory sharesSymbol,
        uint256 totalShares,
        uint256 initialOwnerShares
    ) external whenNotPaused {
        DepositedNFT storage deposit = depositedNFTs[depositedNFTId];
        require(deposit.originalOwner == msg.sender, "Not the original owner");
        require(deposit.status == DepositStatus.Active, "NFT is not active for fractionalization");
        require(totalShares > 0, "Total shares must be greater than 0");
        require(initialOwnerShares <= totalShares, "Initial owner shares cannot exceed total shares");

        deposit.status = DepositStatus.UsedInFractionalization;

        uint256 fractionalizedNFTId = _nextFractionalizedNFTId++;
        fractionalizedNFTs[fractionalizedNFTId] = FractionalizedNFT({
            id: fractionalizedNFTId, // This ID is the ERC-1155 token ID for these shares
            depositedNFTId: depositedNFTId,
            nftContract: deposit.nftContract,
            tokenId: deposit.tokenId,
            sharesName: sharesName,
            sharesSymbol: sharesSymbol,
            totalShares: totalShares,
            status: FractionalizedNFTStatus.Active,
            totalIncomeGenerated: 0,
            sharesForSalePool: 0,
            pricePerSharePool: 0,
            priceTokenPool: address(0)
        });

        // Mint initial shares
        _mint(deposit.originalOwner, fractionalizedNFTId, initialOwnerShares, "");

        // Handle remaining shares (e.g., mint to contract, burn, or put in sale pool)
        // Example: Mint remaining to contract address (platform control or later sale/airdrop)
        uint256 remainingShares = totalShares - initialOwnerShares;
        if (remainingShares > 0) {
            // Option 1: Mint to contract address (manageable by owner)
            // _mint(address(this), fractionalizedNFTId, remainingShares, "");
            // Option 2: Simple - owner gets all or none of initial supply
            // For this example, owner gets only initialOwnerShares. Remaining are effectively unminted until handled by owner functions.
        }


        emit NFTFractionalized(fractionalizedNFTId, depositedNFTId, sharesName, sharesSymbol, totalShares);
    }

    /**
     * @notice Owner/Shareholder lists shares into a simple fixed-price sale pool.
     * @param fractionalizedNFTId The ID of the fractionalized NFT (ERC-1155 token ID).
     * @param amount The amount of shares to list.
     * @param pricePerShare The price per share in `priceToken`.
     * @param priceToken The token used for payment (address(0) for ETH).
     */
    function listSharesForFixedPriceSale(
        uint256 fractionalizedNFTId,
        uint256 amount,
        uint256 pricePerShare,
        address priceToken
    ) external whenNotPaused {
        FractionalizedNFT storage fNFT = fractionalizedNFTs[fractionalizedNFTId];
        require(fNFT.id != 0, "Fractionalized NFT not found");
        require(fNFT.sharesForSalePool == 0, "Sale pool already active"); // Simple: only one listing at a time
        require(pricePerShare > 0 && amount > 0, "Amount and price must be positive");
        require(priceToken == address(0) || supportedLoanTokens[priceToken], "Price token not supported");
        require(_shareBalances[msg.sender][fractionalizedNFTId] >= amount, "Insufficient shares");

        _transfer(msg.sender, address(this), fractionalizedNFTId, amount, ""); // Transfer shares to contract pool

        fNFT.sharesForSalePool = amount;
        fNFT.pricePerSharePool = pricePerShare;
        fNFT.priceTokenPool = priceToken;

        emit SharesListedForSale(fractionalizedNFTId, amount, pricePerShare, priceToken);
    }

    /**
     * @notice Buys shares from the simple fixed-price sale pool.
     * @param fractionalizedNFTId The ID of the fractionalized NFT (ERC-1155 token ID).
     * @param amount The amount of shares to buy.
     */
    function buySharesFromFixedPriceSale(uint256 fractionalizedNFTId, uint256 amount) external payable whenNotPaused {
        FractionalizedNFT storage fNFT = fractionalizedNFTs[fractionalizedNFTId];
        require(fNFT.id != 0, "Fractionalized NFT not found");
        require(fNFT.sharesForSalePool >= amount && amount > 0, "Insufficient shares in pool or invalid amount");

        uint256 totalCost = amount * fNFT.pricePerSharePool;

        if (fNFT.priceTokenPool == address(0)) {
            require(msg.value == totalCost, "Incorrect ETH amount sent");
        } else {
            require(msg.value == 0, "ETH sent with ERC20 purchase");
            require(supportedLoanTokens[fNFT.priceTokenPool], "Price token not supported");
            require(IERC20(fNFT.priceTokenPool).allowance(msg.sender, address(this)) >= totalCost, "Requires token allowance");
            bool success = IERC20(fNFT.priceTokenPool).transferFrom(msg.sender, address(this), totalCost);
            require(success, "Token transfer failed");

             // Transfer funds from contract pool to the seller of the shares (the contract itself or original lister)
             // In this simple pool, the contract holds the shares and receives funds. Owner can withdraw later.
             platformFeeBalances[fNFT.priceTokenPool] += totalCost; // Simplified: pool proceeds go to platform fees. In reality, would go to original lister.
        }

        fNFT.sharesForSalePool -= amount;
        _mint(msg.sender, fractionalizedNFTId, amount, ""); // Mint shares to buyer

        // If pool is empty, reset price/token/amount
        if (fNFT.sharesForSalePool == 0) {
            fNFT.pricePerSharePool = 0;
            fNFT.priceTokenPool = address(0);
        }

        emit SharesBoughtFromSale(fractionalizedNFTId, msg.sender, amount, totalCost);
    }


    /**
     * @notice Allows fractional share holders to claim their share of accumulated income.
     * Income accumulates from sources like a portion of platform fees generated by loans on this specific NFT (if applicable).
     * @param fractionalizedNFTId The ID of the fractionalized NFT.
     */
    function claimFractionalIncome(uint256 fractionalizedNFTId) external whenNotPaused {
        FractionalizedNFT storage fNFT = fractionalizedNFTs[fractionalizedNFTId];
        require(fNFT.id != 0, "Fractionalized NFT not found");
        uint256 shareHolderBalance = _shareBalances[msg.sender][fractionalizedNFTId];
        require(shareHolderBalance > 0, "Caller holds no shares");

        // Calculate income owed: (shareholder balance / total shares) * total income available for distribution
        // This calculation assumes income is tracked *per fractionalized NFT*
        // A more robust system needs complex income tracking per token type
        // Simplified: Assuming totalIncomeGenerated is the total income available for THIS NFT's shareholders
        uint256 incomeOwed = (fNFT.totalIncomeGenerated * shareHolderBalance) / fNFT.totalShares;

        // Subtract already claimed income
        uint256 alreadyClaimed = fNFT.incomeClaimed[msg.sender];
        uint256 amountToClaim = incomeOwed - alreadyClaimed;

        require(amountToClaim > 0, "No income to claim");

        fNFT.incomeClaimed[msg.sender] += amountToClaim;

        // Income is distributed in the same token it was received, or a base token like WETH/ETH
        // Simplified: Assume income is in ETH for this example
        bool success;
        (success, ) = payable(msg.sender).call{value: amountToClaim}("");
        require(success, "ETH transfer failed"); // If income was in ERC20, would need transfer call

        // Note: TotalIncomeGenerated needs to be reduced somehow after claims or tracked differently.
        // This simple model requires a process to deposit income into `totalIncomeGenerated`.

        emit FractionalIncomeClaimed(fractionalizedNFTId, msg.sender, amountToClaim);
    }


    // --- Buyout Mechanism Functions ---

    /**
     * @notice Proposes a buyout of a fractionalized NFT. Requires escrowing the offer amount.
     * @param fractionalizedNFTId The ID of the fractionalized NFT.
     * @param offerAmount The total amount offered for the NFT.
     * @param offerToken The token used for the offer (address(0) for ETH).
     * @param votingDuration The duration of the voting period in seconds.
     */
    function proposeNFTBuyout(
        uint256 fractionalizedNFTId,
        uint256 offerAmount,
        address offerToken,
        uint64 votingDuration
    ) external payable whenNotPaused {
        FractionalizedNFT storage fNFT = fractionalizedNFTs[fractionalizedNFTId];
        require(fNFT.id != 0, "Fractionalized NFT not found");
        require(fNFT.status == FractionalizedNFTStatus.Active, "Fractionalized NFT is not active for buyout");
        require(offerAmount > 0 && votingDuration > 0, "Invalid offer or duration");
        require(offerToken == address(0) || supportedLoanTokens[offerToken], "Offer token not supported");

        // Escrow the offer amount
        if (offerToken == address(0)) {
            require(msg.value == offerAmount, "Incorrect ETH amount sent for offer");
        } else {
             require(msg.value == 0, "ETH sent with ERC20 offer");
             require(IERC20(offerToken).allowance(msg.sender, address(this)) >= offerAmount, "Requires token allowance for offer");
             bool success = IERC20(offerToken).transferFrom(msg.sender, address(this), offerAmount);
             require(success, "Token transfer failed for offer");
        }

        fNFT.status = FractionalizedNFTStatus.BuyoutProposed;

        uint256 proposalId = _nextBuyoutProposalId++;
        uint64 votingStartTime = uint64(block.timestamp);
        uint64 votingEndTime = votingStartTime + votingDuration;

        buyoutProposals[proposalId] = BuyoutProposal({
            id: proposalId,
            fractionalizedNFTId: fractionalizedNFTId,
            proposer: msg.sender,
            offerAmount: offerAmount,
            offerToken: offerToken,
            votingStartTime: votingStartTime,
            votingEndTime: votingEndTime,
            status: BuyoutStatus.Voting,
            votesFor: 0,
            votesAgainst: 0,
            totalSharesAtSnapshot: fNFT.totalShares, // Snapshot total shares at proposal time
            hasVoted: new mapping(address => bool), // Reset voting status
            buyoutFundsClaimed: new mapping(address => uint256) // Reset claimed funds
        });

        emit BuyoutProposed(proposalId, fractionalizedNFTId, msg.sender, offerAmount, offerToken, votingEndTime);
    }

    /**
     * @notice Fractional share holders vote on a buyout proposal.
     * Vote weight is based on share balance at the time of the proposal snapshot (`totalSharesAtSnapshot`).
     * @param proposalId The ID of the buyout proposal.
     * @param approve True to vote for, False to vote against.
     */
    function voteOnBuyout(uint256 proposalId, bool approve) external whenNotPaused {
        BuyoutProposal storage proposal = buyoutProposals[proposalId];
        require(proposal.id != 0, "Buyout proposal not found");
        require(proposal.status == BuyoutStatus.Voting, "Proposal is not in voting state");
        require(block.timestamp >= proposal.votingStartTime && block.timestamp <= proposal.votingEndTime, "Voting period is closed");
        require(!proposal.hasVoted[msg.sender], "Already voted on this proposal");

        // Get voter's share balance at the time of proposal snapshot
        // This requires storing historical balances or using a snapshot mechanism
        // Simplified: Use current balance, but note this is susceptible to flash loans/transfers during voting.
        // A real system needs a proper snapshot.
        uint256 voterShares = _shareBalances[msg.sender][proposal.fractionalizedNFTId];
        require(voterShares > 0, "Caller holds no shares to vote");

        proposal.hasVoted[msg.sender] = true;
        if (approve) {
            proposal.votesFor += voterShares;
        } else {
            proposal.votesAgainst += voterShares;
        }

        emit VotedOnBuyout(proposalId, msg.sender, approve);
    }

    /**
     * @notice Executes a buyout proposal if it succeeded after the voting period ends.
     * Success condition: VotesFor > VotesAgainst and voting period is over.
     * Transfers NFT to proposer, distributes funds to share holders, burns shares.
     * @param proposalId The ID of the buyout proposal.
     */
    function executeBuyout(uint256 proposalId) external whenNotPaused {
        BuyoutProposal storage proposal = buyoutProposals[proposalId];
        require(proposal.id != 0, "Buyout proposal not found");
        require(proposal.status == BuyoutStatus.Voting, "Proposal is not in voting state");
        require(block.timestamp > proposal.votingEndTime, "Voting period is not over");

        // Check outcome (simple majority based on share weight)
        if (proposal.votesFor > proposal.votesAgainst) {
            proposal.status = BuyoutStatus.Succeeded;

            // Get the actual NFT
            FractionalizedNFT storage fNFT = fractionalizedNFTs[proposal.fractionalizedNFTId];
            DepositedNFT storage deposit = depositedNFTs[fNFT.depositedNFTId];

            // Transfer NFT to proposer
            IERC721(deposit.nftContract).safeTransferFrom(address(this), proposal.proposer, deposit.tokenId);

            fNFT.status = FractionalizedNFTStatus.BuyoutExecuted;
            deposit.status = DepositStatus.Withdrawn; // Mark underlying deposit as resolved/withdrawn

            // Funds remain in contract for shareholders to claim
            // Shares are effectively burned by marking the FractionalizedNFT status

            proposal.status = BuyoutStatus.Executed;
            emit BuyoutExecuted(proposalId, proposal.fractionalizedNFTId, proposal.proposer);

        } else {
            proposal.status = BuyoutStatus.Failed;

            // Return escrowed funds to proposer
            bool success;
            if (proposal.offerToken == address(0)) {
                 (success, ) = payable(proposal.proposer).call{value: proposal.offerAmount}("");
                 require(success, "ETH refund failed");
            } else {
                 success = IERC20(proposal.offerToken).transfer(proposal.proposer, proposal.offerAmount);
                 require(success, "Token refund failed");
            }

             // Revert fractionalized NFT status? Depends on desired behavior.
             // Let's mark it active again for simplicity.
             FractionalizedNFT storage fNFT = fractionalizedNFTs[proposal.fractionalizedNFTId];
             fNFT.status = FractionalizedNFTStatus.Active;
        }
    }

    /**
     * @notice Fractional share holders claim their share of funds from a successful buyout.
     * @param proposalId The ID of the executed buyout proposal.
     */
    function claimBuyoutFunds(uint256 proposalId) external whenNotPaused {
        BuyoutProposal storage proposal = buyoutProposals[proposalId];
        require(proposal.status == BuyoutStatus.Executed, "Buyout proposal was not successfully executed");

        uint256 shareHolderBalance = _shareBalances[msg.sender][proposal.fractionalizedNFTId];
        require(shareHolderBalance > 0, "Caller holds no shares related to this buyout"); // Check balance at time of claim

        // Calculate funds owed: (shareholder balance / total shares at snapshot) * total offer amount
        uint256 fundsOwed = (proposal.offerAmount * shareHolderBalance) / proposal.totalSharesAtSnapshot;

        // Subtract already claimed funds
        uint256 alreadyClaimed = proposal.buyoutFundsClaimed[msg.sender];
        uint256 amountToClaim = fundsOwed - alreadyClaimed;

        require(amountToClaim > 0, "No funds to claim");

        proposal.buyoutFundsClaimed[msg.sender] += amountToClaim;

        // Transfer funds
        bool success;
        if (proposal.offerToken == address(0)) {
             (success, ) = payable(msg.sender).call{value: amountToClaim}("");
             require(success, "ETH transfer failed");
        } else {
             success = IERC20(proposal.offerToken).transfer(msg.sender, amountToClaim);
             require(success, "Token transfer failed");
        }

        emit BuyoutFundsClaimed(proposalId, msg.sender, amountToClaim);
    }


    // --- Dynamic Pricing Functions (View) ---

    /**
     * @notice Internal view function to calculate the dynamic interest rate.
     * Simplified logic: Base rate + factor based on overall platform utilization for this token type.
     * A real-world scenario would need more complex inputs (oracles, collection rarity, demand curves).
     * @param depositedNFTId ID of the NFT involved (can be used for NFT-specific tiering, not implemented here).
     * @return The interest rate in basis points per the offer's duration.
     */
    function _calculateInterestRate(uint256 depositedNFTId) internal view returns (uint256) {
        // In a real system, this would consider:
        // 1. Utilization rate of the specific loan token across all loans
        // 2. Demand for loans against this specific NFT collection/tier
        // 3. External factors via oracle (e.g., market volatility, ETH price)

        // Simplified: Just return the base rate plus a small factor based on total active loans (as a proxy for utilization/demand)
        // This simple model doesn't track utilization per token type effectively.
        // A more complex state variable or external call is needed for true utilization.
        // Let's make it just return the base rate for this example's simplicity.
        // uint256 totalActiveLoansValue = 0; // This would need tracking
        // uint256 utilizationFactor = (totalActiveLoansValue * utilizationRateFactor) / 1e18; // Example calculation
        // return baseInterestRateBips + utilizationFactor;

        // Placeholder: returns a fixed rate per duration
        uint256 offerDuration = loanOffers[depositedNFTs[depositedNFTId].loanOfferId].duration; // Get duration from the linked offer
        // Example: calculate annual rate, then convert to per-duration. Annual 5% -> 500 bips.
        // Rate per second = (Annual Rate / 10000) / seconds_in_year. Rate per duration = Rate per second * duration.
        // base rate 500 bips = 5% ANNUAL. Seconds in year = 31536000
        uint256 annualRate = baseInterestRateBips;
        uint256 ratePerDuration = (annualRate * offerDuration) / 31536000; // Approx seconds in a year

        // Add some minor variance based on depositId (just to show it *could* use unique IDs)
        ratePerDuration += (depositedNFTId % 50); // Adds 0-49 bips based on ID

        return ratePerDuration; // Rate in basis points per offer duration
    }

     /**
      * @notice Internal view function to calculate the amount of platform fee for a given loan total amount.
      * @param principal The loan principal amount.
      * @param interest The calculated interest amount.
      * @return The platform fee amount.
      */
     function _getDynamicPlatformFeeAmount(uint256 principal, uint256 interest) internal view returns (uint256) {
         uint256 totalAmount = principal + interest;
         uint256 feeBips = _getDynamicPlatformFee();
         return (totalAmount * feeBips) / 10000;
     }


    /**
     * @notice Internal view function to calculate the dynamic platform fee rate.
     * Simplified logic: Base fee + factor based on total platform volume.
     * @return The platform fee rate in basis points.
     */
    function _getDynamicPlatformFee() internal view returns (uint256) {
         // In a real system, this would consider:
         // 1. Total platform volume (loans originated, trades, etc.)
         // 2. Specific activity related to the NFT (e.g., fractional trading volume)
         // 3. Governance parameters

         // Simplified: Just return the base fee plus a factor based on the total number of loans created (as a proxy for volume)
         uint256 volumeFactorAmount = (_nextLoanId * volumeFactor); // Simple factor based on loan count

         return basePlatformFeeBips + volumeFactorAmount; // Fee in basis points
    }


    // --- View Functions ---

    /**
     * @notice Get details of a deposited NFT.
     * @param depositedNFTId The ID of the deposited NFT.
     * @return DepositedNFT struct details.
     */
    function getDepositedNFT(uint256 depositedNFTId) external view returns (DepositedNFT memory) {
        return depositedNFTs[depositedNFTId];
    }

    /**
     * @notice Get details of a loan offer.
     * @param loanOfferId The ID of the loan offer.
     * @return LoanOffer struct details.
     */
    function getLoanOffer(uint256 loanOfferId) external view returns (LoanOffer memory) {
        return loanOffers[loanOfferId];
    }

    /**
     * @notice Get details of a loan.
     * @param loanId The ID of the loan.
     * @return Loan struct details.
     */
    function getLoan(uint256 loanId) external view returns (Loan memory) {
        return loans[loanId];
    }

    /**
     * @notice Get details of a fractionalized NFT.
     * @param fractionalizedNFTId The ID of the fractionalized NFT.
     * @return FractionalizedNFT struct details (excluding nested mappings).
     */
    function getFractionalizedNFT(uint256 fractionalizedNFTId) external view returns (
        uint256 id,
        uint256 depositedNFTId,
        address nftContract,
        uint256 tokenId,
        string memory sharesName,
        string memory sharesSymbol,
        uint256 totalShares,
        FractionalizedNFTStatus status,
        uint256 totalIncomeGenerated,
        uint256 sharesForSalePool,
        uint256 pricePerSharePool,
        address priceTokenPool
    ) {
        FractionalizedNFT storage fNFT = fractionalizedNFTs[fractionalizedNFTId];
        return (
            fNFT.id,
            fNFT.depositedNFTId,
            fNFT.nftContract,
            fNFT.tokenId,
            fNFT.sharesName,
            fNFT.sharesSymbol,
            fNFT.totalShares,
            fNFT.status,
            fNFT.totalIncomeGenerated,
            fNFT.sharesForSalePool,
            fNFT.pricePerSharePool,
            fNFT.priceTokenPool
        );
    }

    /**
     * @notice Get details of a buyout proposal.
     * @param proposalId The ID of the buyout proposal.
     * @return BuyoutProposal struct details (excluding nested mappings).
     */
     function getBuyoutProposal(uint256 proposalId) external view returns (
         uint256 id,
         uint256 fractionalizedNFTId,
         address proposer,
         uint256 offerAmount,
         address offerToken,
         uint64 votingStartTime,
         uint64 votingEndTime,
         BuyoutStatus status,
         uint256 votesFor,
         uint256 votesAgainst,
         uint256 totalSharesAtSnapshot
     ) {
         BuyoutProposal storage proposal = buyoutProposals[proposalId];
         return (
             proposal.id,
             proposal.fractionalizedNFTId,
             proposal.proposer,
             proposal.offerAmount,
             proposal.offerToken,
             proposal.votingStartTime,
             proposal.votingEndTime,
             proposal.status,
             proposal.votesFor,
             proposal.votesAgainst,
             proposal.totalSharesAtSnapshot
         );
     }

    /**
     * @notice Get the list of deposit IDs for a user.
     * @param user The user's address.
     * @return An array of deposit IDs.
     */
    function getUserDeposits(address user) external view returns (uint256[] memory) {
        return _userDeposits[user];
    }

    /**
     * @notice Get the list of loan IDs (either as borrower or lender) for a user.
     * @param user The user's address.
     * @return An array of loan IDs.
     */
    function getUserLoans(address user) external view returns (uint256[] memory) {
         return _userLoans[user];
    }

    // --- Internal ERC-1155 Management (Partial Implementation) ---
    // This contract acts as the issuer and manager of the fractional shares.
    // It doesn't inherit a full ERC-1155 implementation to keep logic contained,
    // but implements the key functions needed to manage balances and transfers internally.

    /**
     * @notice Gets the balance of the specified account's fractional shares.
     * Corresponds to ERC-1155 `balanceOf`.
     * @param account The account whose balance is to be retrieved.
     * @param id The ID of the fractionalized NFT (ERC-1155 token ID).
     * @return The balance of fractional shares held by `account`.
     */
    function balanceOf(address account, uint256 id) public view returns (uint256) {
        require(id < _nextFractionalizedNFTId, "Invalid fractional NFT ID"); // Check if ID was ever created
        return _shareBalances[account][id];
    }

    /**
     * @notice Gets the balance of multiple accounts for multiple fractional share IDs.
     * Corresponds to ERC-1155 `balanceOfBatch`.
     * @param accounts The accounts whose balances are to be retrieved.
     * @param ids The IDs of the fractionalized NFTs (ERC-1155 token IDs).
     * @return An array of balances.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) public view returns (uint256[] memory) {
        require(accounts.length == ids.length, "Accounts and IDs mismatch");
        uint256[] memory batchBalances = new uint256[](accounts.length);
        for (uint256 i = 0; i < accounts.length; i++) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }
        return batchBalances;
    }

    /**
     * @notice Enables or disables a third party operator to manage all of `msg.sender`'s shares.
     * Corresponds to ERC-1155 `setApprovalForAll`.
     * @param operator The address to approve.
     * @param approved True to approve, False to disallow.
     */
    function setApprovalForAll(address operator, bool approved) public {
        require(msg.sender != operator, "Self approval not allowed");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /**
     * @notice Checks if a third party operator is approved to manage all of an account's shares.
     * Corresponds to ERC-1155 `isApprovedForAll`.
     * @param account The account holding the shares.
     * @param operator The potential operator.
     * @return True if the operator is approved.
     */
    function isApprovedForAll(address account, address operator) public view returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @notice Transfers fractional shares from one account to another.
     * Corresponds to ERC-1155 `safeTransferFrom`.
     * @param from The sender address.
     * @param to The recipient address.
     * @param id The ID of the fractionalized NFT (ERC-1155 token ID).
     * @param amount The amount of shares to transfer.
     * @param data Arbitrary data (unused in this implementation).
     */
    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) public virtual whenNotPaused {
        require(from != address(0) && to != address(0), "Transfer to/from zero address");
        require(msg.sender == from || isApprovedForAll(from, msg.sender), "ERC1155: caller is not token owner nor approved");
        require(_shareBalances[from][id] >= amount, "Insufficient balance");
        require(id < _nextFractionalizedNFTId, "Invalid fractional NFT ID"); // Check if ID was ever created

        _transfer(from, to, id, amount, data);
    }

    /**
     * @notice Transfers multiple types of fractional shares in a single call.
     * Corresponds to ERC-1155 `safeBatchTransferFrom`.
     * @param from The sender address.
     * @param to The recipient address.
     * @param ids The IDs of the fractionalized NFTs (ERC-1155 token IDs).
     * @param amounts The amounts of shares to transfer (must match ids length).
     * @param data Arbitrary data (unused in this implementation).
     */
    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) public virtual whenNotPaused {
        require(from != address(0) && to != address(0), "Transfer to/from zero address");
        require(msg.sender == from || isApprovedForAll(from, msg.sender), "ERC1155: caller is not token owner nor approved");
        require(ids.length == amounts.length, "IDs and amounts mismatch");

        for (uint256 i = 0; i < ids.length; i++) {
             require(_shareBalances[from][ids[i]] >= amounts[i], "Insufficient balance for batch transfer");
             require(ids[i] < _nextFractionalizedNFTId, "Invalid fractional NFT ID in batch"); // Check if ID was ever created
        }

        _batchTransfer(from, to, ids, amounts, data);
    }

    /**
     * @notice Internal function for transferring shares and emitting event.
     * @param from The sender address.
     * @param to The recipient address.
     * @param id The ID of the fractionalized NFT (ERC-1155 token ID).
     * @param amount The amount of shares to transfer.
     * @param data Arbitrary data.
     */
    function _transfer(address from, address to, uint256 id, uint256 amount, bytes memory data) internal {
        _shareBalances[from][id] -= amount;
        _shareBalances[to][id] += amount;
        emit TransferSingle(msg.sender, from, to, id, amount);
        // Optional: ERC1155Receiver check if 'to' is a contract
        // _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);
    }

     /**
      * @notice Internal function for batch transferring shares and emitting event.
      * @param from The sender address.
      * @param to The recipient address.
      * @param ids The IDs of the fractionalized NFTs (ERC-1155 token IDs).
      * @param amounts The amounts of shares to transfer.
      * @param data Arbitrary data.
      */
    function _batchTransfer(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {
        for (uint256 i = 0; i < ids.length; i++) {
            _shareBalances[from][ids[i]] -= amounts[i];
            _shareBalances[to][ids[i]] += amounts[i];
        }
        emit TransferBatch(msg.sender, from, to, ids, amounts);
        // Optional: ERC1155Receiver check if 'to' is a contract
        // _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, amounts, data);
    }

    /**
     * @notice Internal function for minting shares and emitting event.
     * @param to The recipient address.
     * @param id The ID of the fractionalized NFT (ERC-1155 token ID).
     * @param amount The amount of shares to mint.
     * @param data Arbitrary data.
     */
    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal {
        require(to != address(0), "Mint to zero address");
        _shareBalances[to][id] += amount;
        emit TransferSingle(msg.sender, address(0), to, id, amount); // Minting event has from=0x0
        // Optional: ERC1155Receiver check if 'to' is a contract
        // _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, amount, data);
    }

     /**
      * @notice Internal function for batch minting shares and emitting event.
      * @param to The recipient address.
      * @param ids The IDs of the fractionalized NFTs (ERC-1155 token IDs).
      * @param amounts The amounts of shares to mint.
      * @param data Arbitrary data.
      */
     function _batchMint(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal {
         require(to != address(0), "Batch mint to zero address");
         require(ids.length == amounts.length, "IDs and amounts mismatch");

         for (uint256 i = 0; i < ids.length; i++) {
             _shareBalances[to][ids[i]] += amounts[i];
         }
         emit TransferBatch(msg.sender, address(0), to, ids, amounts); // Minting event has from=0x0
         // Optional: ERC1155Receiver check if 'to' is a contract
         // _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), to, ids, amounts, data);
     }

     // --- Receive/Fallback ---

    receive() external payable {}
    fallback() external payable {}

    // Note: _doSafeTransferAcceptanceCheck and _doSafeBatchTransferAcceptanceCheck
    // from a standard ERC1155 implementation would be needed for full compliance
    // if transferring to contracts that implement ERC1155Receiver.
    // They are omitted here for brevity and focus on core logic.

}
```