Okay, here is a Solidity smart contract design incorporating several advanced and creative concepts: dynamic NFT state, resource management (Attunement), a timed global event mechanism (Nexus), and parameter governance via a council.

It avoids being a direct copy of a single open-source contract by combining these elements in a specific game-like context.

---

**EtherealEchoes Smart Contract**

This contract manages a collection of unique digital entities called "Echoes" (ERC-721 NFTs). Echoes possess dynamic properties like Energy and Resonance, which change over time and through interactions. The contract also incorporates a global resource pool ("Attunement"), a timed global event ("Nexus Activation"), and a limited governance mechanism allowing a council to propose and vote on certain system parameters.

**Concepts Utilized:**

1.  **Dynamic NFTs:** Token properties (`energy`, `resonance`) change over time and based on contract interactions, not just ownership or static metadata. The `tokenURI` can reflect this state off-chain.
2.  **On-Chain Resource Management:** The `attunementPool` acts as a shared resource, consumed and generated by specific actions.
3.  **Timed/Event-Driven State Changes:** The Nexus activation provides a periodic global state boost based on a cooldown. Echo state (energy/resonance) calculation incorporates time elapsed since last interaction and Nexus activation.
4.  **Limited Parameter Governance:** A designated council can propose and vote on changes to specific, predefined system parameters.
5.  **Modular Interaction:** Functions are designed around specific interactions (Recharge, Boost, Craft, Attune) that affect Echo state and global resources.
6.  **Implicit Decay/Recharge:** Decay of properties is calculated *at the time of interaction or query*, rather than requiring constant on-chain updates, saving gas.

**Outline:**

1.  **Libraries & Interfaces:** Import ERC721, Ownable.
2.  **Error Handling:** Custom errors for clarity and gas efficiency.
3.  **Structs:** Define structures for Echo properties and Governance proposals.
4.  **Events:** Announce key state changes and actions.
5.  **State Variables:** Store core contract data, mappings for Echo states, global resources, governance data, and system parameters.
6.  **Modifiers:** Custom access control and validation.
7.  **Core ERC721 Functions:** Override or implement required ERC721 methods (`balanceOf`, `ownerOf`, etc.).
8.  **Echo Management Functions:** Minting, viewing properties, internal state calculation logic.
9.  **Interaction Functions:** `rechargeEnergy`, `boostResonance`, `attuneToEcho`, `craftItem`.
10. **System Functions:** `activateNexus`, `depositToTreasury`, `withdrawTreasury`.
11. **Governance Functions:** Add/Remove council, Create proposal, Vote, Execute proposal.
12. **Query Functions:** View global state, parameters, proposal details, council status.

**Function Summary (Public/External):**

1.  `constructor(address initialOwner)`: Initializes the contract, sets owner, initial parameters.
2.  `mintEcho(address owner_, string memory tokenURI_)`: Creates a new Echo NFT for `owner_`. (Owner-only minting for control).
3.  `getEchoProperties(uint256 tokenId)`: Returns the *current*, calculated dynamic properties (Energy, Resonance) of an Echo, considering time-based changes.
4.  `rechargeEnergy(uint256 tokenId)`: Allows Echo owner to boost its Energy, consuming Attunement from the global pool.
5.  `boostResonance(uint256 tokenId)`: Allows Echo owner to boost its Resonance, subject to a cooldown per Echo. Consumes Attunement.
6.  `attuneToEcho(uint256 tokenId)`: A general interaction function. Could grant a small Attunement amount to the caller, or consume some from the owner, depending on design. *Let's make it consume caller's ETH to add to AttunementPool and potentially give a minor Echo boost.*
7.  `craftItem(uint256 echoId1, uint256 echoId2)`: Placeholder for a crafting mechanism requiring two Echoes. Burns Attunement. (Could burn Echoes or create new ones).
8.  `activateNexus()`: Can be called by anyone (maybe with a fee, added to treasury/attunement?) to trigger the global Nexus boost event if the cooldown has passed. Updates global nexus activation time.
9.  `depositToTreasury()`: Payable function allowing anyone to send ETH to the contract treasury.
10. `withdrawTreasury(address payable recipient, uint256 amount)`: Owner function to withdraw from the treasury.
11. `setBaseURI(string memory baseURI_)`: Owner sets the base URI for token metadata.
12. `addCouncilMember(address member)`: Owner adds an address to the council.
13. `removeCouncilMember(address member)`: Owner removes an address from the council.
14. `createParameterProposal(uint256 parameterId, uint256 newValue)`: Council member proposes changing a specific system parameter.
15. `voteOnProposal(uint256 proposalId, bool voteFor)`: Council member votes on a proposal.
16. `executeProposal(uint256 proposalId)`: Anyone can call to execute a successful proposal (meets vote threshold, not executed).
17. `getAttunementPool()`: Returns the current amount of Attunement in the global pool.
18. `getSystemParameters()`: Returns all current system parameter values.
19. `getProposal(uint256 proposalId)`: Returns details of a specific proposal.
20. `isCouncilMember(address account)`: Checks if an address is a council member.
21. `tokenURI(uint256 tokenId)`: Returns the metadata URI for an Echo, based on the base URI and tokenId. (Required ERC721).
22. `balanceOf(address owner)`: Returns number of tokens owned by an address. (Required ERC721).
23. `ownerOf(uint256 tokenId)`: Returns owner of a token ID. (Required ERC721).
24. `approve(address to, uint256 tokenId)`: Approves address `to` to transfer `tokenId`. (Required ERC721).
25. `getApproved(uint256 tokenId)`: Returns approved address for `tokenId`. (Required ERC721).
26. `setApprovalForAll(address operator, bool approved)`: Sets approval for an operator for all tokens. (Required ERC721).
27. `isApprovedForAll(address owner, address operator)`: Checks if operator is approved for all tokens of owner. (Required ERC721).
28. `transferFrom(address from, address to, uint256 tokenId)`: Transfers token from `from` to `to`. (Required ERC721).
29. `safeTransferFrom(address from, address to, uint256 tokenId)`: Safe transfer, checking recipient. (Required ERC721).
30. `safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)`: Safe transfer with data. (Required ERC721).
31. `supportsInterface(bytes4 interfaceId)`: Interface detection. (Required ERC721).

*(Note: Several internal functions like `_calculateCurrentEnergy`, `_updateEchoState`, `_applyNexusBoost`, etc., will be needed to support the public functions, bringing the total function count including internal logic well over 20 distinct pieces of logic).*

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

// --- Outline ---
// 1. Libraries & Interfaces
// 2. Error Handling
// 3. Structs
// 4. Events
// 5. State Variables
// 6. Modifiers
// 7. Core ERC721 Overrides
// 8. Internal State Calculation Helpers
// 9. Echo Management Functions
// 10. Interaction Functions
// 11. System Functions
// 12. Governance Functions
// 13. Query Functions

// --- Function Summary (Public/External) ---
// 1. constructor: Initializes contract, owner, initial parameters.
// 2. mintEcho: Creates a new Echo NFT (Owner-only).
// 3. getEchoProperties: Views calculated dynamic properties (Energy, Resonance).
// 4. rechargeEnergy: Boosts Echo Energy, consumes Attunement.
// 5. boostResonance: Boosts Echo Resonance (cooldown), consumes Attunement.
// 6. attuneToEcho: Interact with Echo, adds ETH to AttunementPool, minor boost.
// 7. craftItem: Placeholder for crafting (uses Echoes, consumes Attunement).
// 8. activateNexus: Triggers global Nexus boost (timed cooldown).
// 9. depositToTreasury: Anyone can send ETH to treasury.
// 10. withdrawTreasury: Owner withdraws from treasury.
// 11. setBaseURI: Owner sets metadata base URI.
// 12. addCouncilMember: Owner adds council member.
// 13. removeCouncilMember: Owner removes council member.
// 14. createParameterProposal: Council proposes parameter change.
// 15. voteOnProposal: Council votes on proposal.
// 16. executeProposal: Anyone executes successful proposal.
// 17. getAttunementPool: Views global Attunement.
// 18. getSystemParameters: Views current system parameters.
// 19. getProposal: Views proposal details.
// 20. isCouncilMember: Checks council status.
// 21-31: Standard ERC721 functions (balanceOf, ownerOf, transferFrom, approve, etc.).

contract EtherealEchoes is ERC721, Ownable {
    using Counters for Counters.Counter;
    using Strings for uint256;
    using Math for uint256;

    // --- 2. Error Handling ---
    error InvalidTokenId();
    error NotEchoOwnerOrApproved();
    error InsufficientAttunement(uint256 required, uint256 available);
    error AttunementPoolEmpty();
    error ResonanceBoostCooldownActive(uint256 remainingTime);
    error NexusCooldownActive(uint256 remainingTime);
    error NotEnoughETHForAttunementInteraction();
    error CouncilMemberOnly();
    error InvalidParameterId();
    error ProposalDoesNotExist();
    error ProposalAlreadyExecuted();
    error AlreadyVoted();
    error ProposalNotApproved();
    error ProposalThresholdNotMet();
    error NotEnoughCouncilVotes(uint256 required, uint256 current);

    // --- 3. Structs ---
    struct EchoProperties {
        uint256 energy;           // Current energy level (dynamic)
        uint256 resonance;        // Current resonance level (dynamic)
        uint256 genesisTimestamp; // Timestamp when Echo was minted
        uint256 lastUpdateTime;   // Timestamp when energy/resonance were last updated (or interacted with)
        uint256 lastResonanceBoost; // Timestamp of last resonance boost action
        uint256 baseResonanceFactor; // A base value influencing resonance (pseudo-random/assigned)
    }

    // Enum for parameters that can be governed
    enum GovernanceParameter {
        ENERGY_RECHARGE_RATE,
        RESONANCE_BOOST_AMOUNT,
        ATTUNEMENT_COST_RECHARGE,
        ATTUNEMENT_COST_RESONANCE,
        ATTUNEMENT_CRAFTING_COST,
        NEXUS_COOLDOWN_DURATION,
        NEXUS_ENERGY_BOOST,
        NEXUS_RESONANCE_BOOST_FACTOR,
        COUNCIL_PROPOSAL_THRESHOLD // Percentage of council members needed to approve
    }

    struct Proposal {
        uint256 id;
        GovernanceParameter parameterId;
        uint256 newValue;
        address creator;
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted;
        bool executed;
    }

    // --- 4. Events ---
    event EchoMinted(uint256 indexed tokenId, address indexed owner, string tokenURI);
    event EchoStateUpdated(uint256 indexed tokenId, uint256 energy, uint256 resonance);
    event AttunementPoolChanged(uint256 newAttunement);
    event ResonanceBoosted(uint256 indexed tokenId, uint256 newResonance);
    event EnergyRecharged(uint256 indexed tokenId, uint256 newEnergy);
    event NexusActivated(uint256 indexed timestamp, uint256 energyBoost, uint256 resonanceBoostFactor);
    event ItemCrafted(address indexed owner, uint256 indexed echoId1, uint256 indexed echoId2);
    event TreasuryDeposited(address indexed sender, uint256 amount);
    event TreasuryWithdrawal(address indexed recipient, uint256 amount);
    event BaseURIUpdated(string baseURI);
    event CouncilMemberAdded(address indexed member);
    event CouncilMemberRemoved(address indexed member);
    event ProposalCreated(uint256 indexed proposalId, address indexed creator, GovernanceParameter parameterId, uint256 newValue);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool voteFor);
    event ProposalExecuted(uint256 indexed proposalId, GovernanceParameter parameterId, uint256 newValue);
    event ParameterChanged(GovernanceParameter parameterId, uint256 newValue);

    // --- 5. State Variables ---
    Counters.Counter private _tokenIdCounter;

    mapping(uint256 => EchoProperties) private _echoProperties;

    uint256 private _attunementPool;
    uint256 private _nexusLastActivation; // Timestamp of the last nexus activation

    // Governance
    mapping(address => bool) private _isCouncilMember;
    address[] private _councilMembers; // Keep track of members for counting votes

    uint256 private _proposalCounter;
    mapping(uint256 => Proposal) private _proposals;

    address payable private _treasuryAddress;

    // System Parameters (adjustable via governance)
    uint256 public energyRechargeRatePerMinute; // Energy gained per minute when recharging
    uint256 public resonanceBoostAmount;      // Fixed amount resonance boosts by
    uint256 public attunementCostRecharge;    // Attunement consumed to recharge energy
    uint256 public attunementCostResonance;   // Attunement consumed to boost resonance
    uint256 public attunementCraftingCost;    // Attunement consumed during crafting
    uint256 public nexusCooldownDuration;     // Time between nexus activations (in seconds)
    uint256 public nexusEnergyBoost;          // Energy boost applied to Echoes during nexus activation
    uint256 public nexusResonanceBoostFactor; // Factor influencing resonance gain during nexus
    uint256 public councilProposalThreshold;  // % (0-100) of council votes needed for proposal approval

    uint256 public constant TIME_UNIT = 60; // 1 minute for calculations

    string private _baseTokenURI;

    // --- 6. Modifiers ---
    modifier onlyEchoOwnerOrApproved(uint256 tokenId) {
        if (_msgSender() != ownerOf(tokenId) && !getApproved(tokenId).isContract() && !isApprovedForAll(ownerOf(tokenId), _msgSender())) {
             revert NotEchoOwnerOrApproved();
        }
        _;
    }

    modifier onlyCouncilMember() {
        if (!_isCouncilMember[_msgSender()]) {
            revert CouncilMemberOnly();
        }
        _;
    }

    // --- 7. Core ERC721 Overrides ---

    constructor(address initialOwner) ERC721("EtherealEchoes", "ECHO") Ownable(initialOwner) {
        _treasuryAddress = payable(address(this)); // Treasury is the contract itself initially

        // Set initial default parameters
        energyRechargeRatePerMinute = 10; // Example: 10 energy per minute of recharge
        resonanceBoostAmount = 50;       // Example: +50 resonance per boost
        attunementCostRecharge = 5;      // Example: 5 attunement to recharge
        attunementCostResonance = 10;    // Example: 10 attunement to boost resonance
        attunementCraftingCost = 20;     // Example: 20 attunement for crafting
        nexusCooldownDuration = 1 days;  // Example: Nexus every day
        nexusEnergyBoost = 100;          // Example: +100 energy from nexus
        nexusResonanceBoostFactor = 10;  // Example: Resonance += baseFactor * this
        councilProposalThreshold = 60;   // Example: 60% of council must vote yes

        _nexusLastActivation = block.timestamp; // Initialize nexus timer
    }

    // Overrides required by ERC721
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);
        // Append token ID to base URI. Off-chain service handles dynamic metadata based on state.
        return bytes(_baseTokenURI).length > 0
            ? string(abi.encodePacked(_baseTokenURI, tokenId.toString()))
            : ""; // Or revert if baseURI is mandatory
    }

    // ERC721 standard functions are inherited and work with internal mappings.
    // We override _update to potentially add state update logic on transfer if needed,
    // but for this design, state is calculated on read/interaction.
    function _update(address to, uint256 tokenId, address auth) internal override returns (address) {
        address from = ERC721._update(to, tokenId, auth);
        // Optional: if you wanted state to decay/update on transfer, call _updateEchoState here
        // For this design, decay is calculated on interaction/query.
        return from;
    }

    // --- 8. Internal State Calculation Helpers ---

    // Calculates current energy considering time elapsed and nexus boosts
    function _calculateCurrentEnergy(uint256 tokenId) internal view returns (uint256) {
        EchoProperties storage props = _echoProperties[tokenId];
        uint256 timeElapsedSinceUpdate = block.timestamp - props.lastUpdateTime;

        // Energy decay (example: 1 energy per hour)
        uint256 decayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 10 : 1; // Simple decay example
        uint256 potentialDecay = (timeElapsedSinceUpdate / 60) * decayRatePerMinute;
        uint256 currentEnergy = props.energy > potentialDecay ? props.energy - potentialDecay : 0;

        // Apply Nexus Boost if Nexus activated since last update *and* echo hasn't received boost yet for this cycle
        // A more robust system might track boost per nexus activation. This is a simplified example.
        // Let's assume Nexus boost is a one-time application per activation cycle
        // This requires tracking if a token got the *current* nexus boost. Adding a mapping for this.
        // mapping(uint256 => uint256) private _echoLastNexusBoostCycle; // cycle = nexusLastActivation
        // If we added _echoLastNexusBoostCycle:
        // if (_nexusLastActivation > props.lastUpdateTime && _echoLastNexusBoostCycle[tokenId] < _nexusLastActivation) {
        //     currentEnergy = currentEnergy + nexusEnergyBoost;
        //     // Need to update _echoLastNexusBoostCycle in a state-changing function, not here (view function limitation)
        // }

        // Simplified: Nexus boost is *factored into* the potential recharge from interaction
        // Or maybe it's a temporary multiplier. Let's keep calculation simpler for now.
        // The current design implies recharge/boost are manual actions consuming Attunement.
        // Nexus boost will be applied *when* state is explicitly updated *if* it happened since last update.
        // The state-changing functions (`rechargeEnergy`, `boostResonance`, etc.) will call
        // an internal `_applyPassiveChanges` before applying the requested change.

        return currentEnergy; // The actual update happens in _updateEchoState
    }

     // Calculates current resonance considering time elapsed and nexus boosts
    function _calculateCurrentResonance(uint256 tokenId) internal view returns (uint256) {
        EchoProperties storage props = _echoProperties[tokenId];
         uint256 timeElapsedSinceUpdate = block.timestamp - props.lastUpdateTime;

        // Resonance decay (example: slower decay than energy)
        uint256 decayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 20 : 1; // Even slower decay
        uint256 potentialDecay = (timeElapsedSinceUpdate / 60) * decayRatePerMinute;
        uint256 currentResonance = props.resonance > potentialDecay ? props.resonance - potentialDecay : 0;

        // Similar logic for Nexus resonance boost application as energy.
        // Applied in _applyPassiveChanges before state update.

        return currentResonance; // The actual update happens in _updateEchoState
    }


    // Applies passive changes (decay, scheduled boosts like Nexus) before an explicit state update
    function _applyPassiveChanges(uint256 tokenId) internal {
        EchoProperties storage props = _echoProperties[tokenId];
        uint256 now = block.timestamp;
        uint256 timeElapsedSinceUpdate = now - props.lastUpdateTime;

        // Apply Decay
        uint256 energyDecayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 10 : 1;
        uint256 resonanceDecayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 20 : 1;
        uint256 potentialEnergyDecay = (timeElapsedSinceUpdate / 60) * energyDecayRatePerMinute;
        uint256 potentialResonanceDecay = (timeElapsedSinceUpdate / 60) * resonanceDecayRatePerMinute;

        props.energy = props.energy > potentialEnergyDecay ? props.energy - potentialEnergyDecay : 0;
        props.resonance = props.resonance > potentialResonanceDecay ? props.resonance - potentialResonanceDecay : 0;

        // Apply Nexus Boost if applicable (simplified one-time boost per activation)
        // This requires tracking if the boost for the *current* activation has been applied.
        // Let's add a mapping: mapping(uint256 => uint256) private _lastNexusCycleApplied; // tokenId -> timestamp of nexus activation applied
        // Need to add this mapping to state variables.

        // For now, let's apply the boost if the Nexus was activated *after* the echo's last update time.
        // This is simpler but means multiple interactions within one cycle don't re-apply the boost.
        // A better system would track the last *cycle* ID applied.
        if (_nexusLastActivation > props.lastUpdateTime) {
             // Only apply boost if it hasn't been applied for this specific nexus activation event
             // (This simplified logic has a potential edge case if nexus is activated right before update)
             // A robust solution would track a nexus 'cycle' ID.
             // Example simple check: if the token was last updated before the nexus event
            // And its last resonance boost was also before the nexus event (less reliable)
            // A dedicated mapping `_lastNexusAppliedTimestamp[tokenId]` is needed for robust check.
            // Let's skip perfect Nexus tracking for simplicity in this example, and assume interactions handle it.
            // *Correction:* The Nexus boost is a global event that *changes parameters* slightly,
            // or *grants a boost to all tokens when called*. Let's make `activateNexus` grant a boost to all currently existing tokens.
            // This requires iterating through all tokens, which is *very* gas-intensive and not scalable.
            // *Alternative:* Nexus activation simply updates `_nexusLastActivation`. The `_calculateCurrentEnergy/Resonance`
            // functions *implicitly* factor this in IF they calculated boosts based on time elapsed since `_nexusLastActivation`.
            // Let's go back to the calculation-on-read/interaction logic. If `_nexusLastActivation > props.lastUpdateTime`,
            // the boost should be applied *once* during the next state update.
             // Need to track which Nexus activation cycle was the last one applied to the token.
             // Let's add `uint256 lastNexusActivationApplied;` to `EchoProperties`.

             if (_nexusLastActivation > props.lastNexusActivationApplied) {
                 props.energy += nexusEnergyBoost;
                 // Resonance boost related to base factor and nexus factor
                 props.resonance += props.baseResonanceFactor * nexusResonanceBoostFactor / 100; // Apply boost as a percentage of base factor
                 props.lastNexusActivationApplied = _nexusLastActivation; // Mark boost as applied for this cycle
                 emit EchoStateUpdated(tokenId, props.energy, props.resonance); // Event for the passive update
             }
        }


        // Update the last update time *after* applying passive changes
        props.lastUpdateTime = now;
         // The state variables (props.energy, props.resonance) now hold the state as of `now`.
         // Future calculations will use `now` as the starting point.
    }


    // --- 9. Echo Management Functions ---

    function mintEcho(address owner_, string memory tokenURI_) public onlyOwner {
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();

        _safeMint(owner_, tokenId);
        _setTokenURI(tokenId, tokenURI_); // Store the initial token URI

        // Initialize dynamic properties
        _echoProperties[tokenId] = EchoProperties({
            energy: 100, // Starting energy
            resonance: 50, // Starting resonance
            genesisTimestamp: block.timestamp,
            lastUpdateTime: block.timestamp,
            lastResonanceBoost: 0, // No boost yet
            baseResonanceFactor: uint256(keccak256(abi.encodePacked(tokenId, block.timestamp, block.difficulty))) % 100 + 1, // Pseudo-random factor 1-100
            lastNexusActivationApplied: _nexusLastActivation // Echo starts with boost status of current cycle
        });

        emit EchoMinted(tokenId, owner_, tokenURI_);
        emit EchoStateUpdated(tokenId, _echoProperties[tokenId].energy, _echoProperties[tokenId].resonance);
    }

    function getEchoProperties(uint256 tokenId) public view returns (
        uint256 energy,
        uint256 resonance,
        uint256 genesisTimestamp,
        uint256 lastUpdateTime,
        uint256 lastResonanceBoost,
        uint256 baseResonanceFactor,
        uint256 lastNexusActivationApplied
    ) {
        _requireOwned(tokenId); // Ensure token exists/is valid

        EchoProperties storage props = _echoProperties[tokenId];
        uint256 now = block.timestamp;
        uint256 timeElapsedSinceUpdate = now - props.lastUpdateTime;

        // Calculate current values based on last known state and time elapsed
        uint256 currentEnergy = props.energy;
        uint256 currentResonance = props.resonance;

        // Apply Decay Calculation
        uint256 energyDecayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 10 : 1;
        uint256 resonanceDecayRatePerMinute = energyRechargeRatePerMinute > 0 ? energyRechargeRatePerMinute / 20 : 1;
        uint256 potentialEnergyDecay = (timeElapsedSinceUpdate / 60) * energyDecayRatePerMinute;
        uint256 potentialResonanceDecay = (timeElapsedSinceUpdate / 60) * resonanceDecayRatePerMinute;

        currentEnergy = currentEnergy > potentialEnergyDecay ? currentEnergy - potentialEnergyDecay : 0;
        currentResonance = currentResonance > potentialResonanceDecay ? currentResonance - potentialResonanceDecay : 0;

        // Apply Nexus Boost Calculation if due (Only in view, state is updated in interaction funcs)
        // This view calculation *shows* the effect if Nexus activated since last update,
        // but doesn't persist the state change. The actual state update happens in _applyPassiveChanges
        // within state-changing functions.
         if (_nexusLastActivation > props.lastNexusActivationApplied) {
             currentEnergy += nexusEnergyBoost;
             currentResonance += props.baseResonanceFactor * nexusResonanceBoostFactor / 100;
         }


        return (
            currentEnergy,
            currentResonance,
            props.genesisTimestamp,
            props.lastUpdateTime, // Note: This is the last *actual* state update time, not `now`.
            props.lastResonanceBoost,
            props.baseResonanceFactor,
            props.lastNexusActivationApplied // Note: This is the last Nexus event timestamp applied
        );
    }

    // --- 10. Interaction Functions ---

    function rechargeEnergy(uint256 tokenId) public onlyEchoOwnerOrApproved(tokenId) {
        _requireOwned(tokenId); // Redundant due to modifier, but good practice
        if (_attunementPool < attunementCostRecharge) {
            revert InsufficientAttunement(attunementCostRecharge, _attunementPool);
        }

        _applyPassiveChanges(tokenId); // Apply time-based changes first
        EchoProperties storage props = _echoProperties[tokenId];

        _attunementPool -= attunementCostRecharge;
        emit AttunementPoolChanged(_attunementPool);

        // Add energy based on rate (e.g., add TIME_UNIT amount)
        props.energy += energyRechargeRatePerMinute; // Add one unit of recharge value

        // Update state and timestamp
        props.lastUpdateTime = block.timestamp;
        emit EnergyRecharged(tokenId, props.energy);
        emit EchoStateUpdated(tokenId, props.energy, props.resonance);
    }

    function boostResonance(uint256 tokenId) public onlyEchoOwnerOrApproved(tokenId) {
         _requireOwned(tokenId); // Redundant due to modifier

        uint256 cooldownEnd = _echoProperties[tokenId].lastResonanceBoost + nexusCooldownDuration; // Using nexus cooldown duration for resonance boost
        if (block.timestamp < cooldownEnd) {
            revert ResonanceBoostCooldownActive(cooldownEnd - block.timestamp);
        }

        if (_attunementPool < attunementCostResonance) {
            revert InsufficientAttunement(attunementCostResonance, _attunementPool);
        }

        _applyPassiveChanges(tokenId); // Apply time-based changes first
        EchoProperties storage props = _echoProperties[tokenId];

        _attunementPool -= attunementCostResonance;
        emit AttunementPoolChanged(_attunementPool);

        // Add resonance
        props.resonance += resonanceBoostAmount;

        // Update state and timestamps
        props.lastResonanceBoost = block.timestamp;
        props.lastUpdateTime = block.timestamp;
        emit ResonanceBoosted(tokenId, props.resonance);
        emit EchoStateUpdated(tokenId, props.energy, props.resonance);
    }

    // Example interaction that adds to the Attunement pool
    // Could be a "sacrifice" or "offering"
    function attuneToEcho(uint256 tokenId) public payable onlyEchoOwnerOrApproved(tokenId) {
        _requireOwned(tokenId); // Redundant due to modifier

        uint256 attunementGainPerEth = 100; // Example: gain 100 attunement per 1 ETH
        if (msg.value == 0) {
            revert NotEnoughETHForAttunementInteraction();
        }

        _applyPassiveChanges(tokenId); // Apply time-based changes first
        EchoProperties storage props = _echoProperties[tokenId];

        uint256 gainedAttunement = msg.value * attunementGainPerEth / 1 ether; // Convert ETH to Attunement points

        _attunementPool += gainedAttunement;
        emit AttunementPoolChanged(_attunementPool);
        emit TreasuryDeposited(msg.sender, msg.value); // ETH goes to the treasury

        // Optional: give a small energy/resonance boost for the interaction
        props.energy += gainedAttunement / 10;
        props.resonance += gainedAttunement / 20;

        // Update state and timestamp
        props.lastUpdateTime = block.timestamp;
         emit EchoStateUpdated(tokenId, props.energy, props.resonance);
    }

    // Placeholder for a crafting function
    // Requires owning two specific Echoes and consumes Attunement
    // This version is just a stub that burns Attunement and emits an event.
    // A real version would likely burn tokens or mint a new one.
    function craftItem(uint256 echoId1, uint256 echoId2) public {
        _requireOwned(echoId1); // Caller must own echoId1
        _requireOwned(echoId2); // Caller must own echoId2
        if (ownerOf(echoId1) != _msgSender() || ownerOf(echoId2) != _msgSender()) {
             revert NotEchoOwnerOrApproved(); // Should be covered by _requireOwned, but explicit check
        }
        if (echoId1 == echoId2) revert InvalidTokenId(); // Cannot craft with itself

        if (_attunementPool < attunementCraftingCost) {
             revert InsufficientAttunement(attunementCraftingCost, _attunementPool);
        }

        // Apply passive changes to components before consuming Attunement
        _applyPassiveChanges(echoId1);
        _applyPassiveChanges(echoId2);

        _attunementPool -= attunementCraftingCost;
        emit AttunementPoolChanged(_attunementPool);

        // Crafting logic here:
        // - Burn Echoes: `_burn(echoId1); _burn(echoId2);`
        // - Mint new Echo/Item NFT: `_safeMint(...);`
        // - Modify properties of existing Echoes
        // For this example, just emit the event.
        emit ItemCrafted(_msgSender(), echoId1, echoId2);
    }


    // --- 11. System Functions ---

    function activateNexus() public {
        if (block.timestamp < _nexusLastActivation + nexusCooldownDuration) {
            revert NexusCooldownActive((_nexusLastActivation + nexusCooldownDuration) - block.timestamp);
        }

        // Update global activation time
        _nexusLastActivation = block.timestamp;

        // Note: The actual boost application happens implicitly when Echo state is updated
        // via interactions (which call _applyPassiveChanges) or queried via getEchoProperties.
        // This avoids an expensive loop over all tokens in this function.

        emit NexusActivated(_nexusLastActivation, nexusEnergyBoost, nexusResonanceBoostFactor);
    }

    function depositToTreasury() public payable {
        emit TreasuryDeposited(msg.sender, msg.value);
    }

    function withdrawTreasury(address payable recipient, uint256 amount) public onlyOwner {
        if (address(this).balance < amount) {
             // Should use a custom error like InsufficientTreasuryFunds, but sticking to list size
             revert InsufficientAttunement(amount, address(this).balance); // Reusing error for example
        }
        (bool success,) = recipient.call{value: amount}("");
        require(success, "Withdrawal failed");
        emit TreasuryWithdrawal(recipient, amount);
    }

    function setBaseURI(string memory baseURI_) public onlyOwner {
        _baseTokenURI = baseURI_;
        emit BaseURIUpdated(baseURI_);
    }

    // --- 12. Governance Functions ---

    function addCouncilMember(address member) public onlyOwner {
        if (!_isCouncilMember[member]) {
            _isCouncilMember[member] = true;
            _councilMembers.push(member);
            emit CouncilMemberAdded(member);
        }
    }

    function removeCouncilMember(address member) public onlyOwner {
         if (_isCouncilMember[member]) {
            _isCouncilMember[member] = false;
            // Find and remove from the array (gas inefficient for large arrays)
            for (uint i = 0; i < _councilMembers.length; i++) {
                if (_councilMembers[i] == member) {
                    _councilMembers[i] = _councilMembers[_councilMembers.length - 1];
                    _councilMembers.pop();
                    break;
                }
            }
            emit CouncilMemberRemoved(member);
        }
    }

    // Internal helper to get total council members
    function _councilMemberCount() internal view returns (uint256) {
        return _councilMembers.length;
    }

    function createParameterProposal(GovernanceParameter parameterId, uint256 newValue) public onlyCouncilMember {
        // Basic validation: Ensure the parameter ID is valid within the enum range
        if (uint256(parameterId) > uint256(GovernanceParameter.COUNCIL_PROPOSAL_THRESHOLD)) {
            revert InvalidParameterId();
        }

        uint256 proposalId = _proposalCounter.current();
        _proposals[proposalId] = Proposal({
            id: proposalId,
            parameterId: parameterId,
            newValue: newValue,
            creator: _msgSender(),
            votesFor: 0,
            votesAgainst: 0,
            // hasVoted mapping initialized empty
            executed: false
        });
        _proposalCounter.increment();

        emit ProposalCreated(proposalId, _msgSender(), parameterId, newValue);
    }

    function voteOnProposal(uint256 proposalId, bool voteFor) public onlyCouncilMember {
        Proposal storage proposal = _proposals[proposalId];
        if (proposal.id == 0 && proposalId != 0) { // Check if proposal exists (id 0 is default empty struct, handle edge case)
             revert ProposalDoesNotExist();
        }
         if (proposal.id == 0 && proposalId == 0 && _proposalCounter.current() == 0) {
              revert ProposalDoesNotExist(); // Handle case where ID 0 is actually the first proposal
         }
        if (proposal.executed) {
            revert ProposalAlreadyExecuted();
        }
        if (proposal.hasVoted[_msgSender()]) {
            revert AlreadyVoted();
        }

        proposal.hasVoted[_msgSender()] = true;
        if (voteFor) {
            proposal.votesFor++;
        } else {
            proposal.votesAgainst++;
        }

        emit VoteCast(proposalId, _msgSender(), voteFor);
    }

    function executeProposal(uint256 proposalId) public { // Anyone can call to trigger execution check
        Proposal storage proposal = _proposals[proposalId];
         if (proposal.id == 0 && proposalId != 0) {
             revert ProposalDoesNotExist();
        }
         if (proposal.id == 0 && proposalId == 0 && _proposalCounter.current() == 0) {
              revert ProposalDoesNotExist();
         }
        if (proposal.executed) {
            revert ProposalAlreadyExecuted();
        }

        uint256 totalCouncilMembers = _councilMemberCount();
        if (totalCouncilMembers == 0) {
             // If no council members, perhaps only owner can change params or proposals aren't possible
             // For now, require at least one member to vote positively if council exists
             if (proposal.votesFor == 0) revert ProposalNotApproved();
        } else {
             // Check if votesFor meets the threshold percentage of *current* council members
             uint256 requiredVotes = (totalCouncilMembers * councilProposalThreshold) / 100;
             if (proposal.votesFor < requiredVotes) {
                 revert NotEnoughCouncilVotes(requiredVotes, proposal.votesFor);
             }
        }


        // Execute the parameter change
        _setParameter(proposal.parameterId, proposal.newValue);

        proposal.executed = true;

        emit ProposalExecuted(proposalId, proposal.parameterId, proposal.newValue);
        emit ParameterChanged(proposal.parameterId, proposal.newValue);
    }

    // Internal function to change parameters based on executed proposal or owner call
    function _setParameter(GovernanceParameter parameterId, uint256 newValue) internal {
        // Owner can bypass governance for initial setup or emergency
        // In a real DAO, this might be removed or limited.
        require(msg.sender == owner() || _proposals[_proposalCounter.current()-1].executed, "Not authorized to set parameter");

        // Apply the new value based on the parameter ID
        // Consider bounds checking for new values (e.g., percentage <= 100)
        // This requires manual mapping from enum to state variable.
        // A more advanced pattern might use abi.encodeWithSelector to call setters dynamically.
        // For this example, a simple switch/if-else structure:
        if (parameterId == GovernanceParameter.ENERGY_RECHARGE_RATE) {
            energyRechargeRatePerMinute = newValue;
        } else if (parameterId == GovernanceParameter.RESONANCE_BOOST_AMOUNT) {
            resonanceBoostAmount = newValue;
        } else if (parameterId == GovernanceParameter.ATTUNEMENT_COST_RECHARGE) {
            attunementCostRecharge = newValue;
        } else if (parameterId == GovernanceParameter.ATTUNEMENT_COST_RESONANCE) {
            attunementCostResonance = newValue;
        } else if (parameterId == GovernanceParameter.ATTUNEMENT_CRAFTING_COST) {
             attunementCraftingCost = newValue;
        } else if (parameterId == GovernanceParameter.NEXUS_COOLDOWN_DURATION) {
             nexusCooldownDuration = newValue;
        } else if (parameterId == GovernanceParameter.NEXUS_ENERGY_BOOST) {
             nexusEnergyBoost = newValue;
        } else if (parameterId == GovernanceParameter.NEXUS_RESONANCE_BOOST_FACTOR) {
             nexusResonanceBoostFactor = newValue;
        } else if (parameterId == GovernanceParameter.COUNCIL_PROPOSAL_THRESHOLD) {
             if (newValue > 100) revert InvalidParameterId(); // Threshold must be 0-100
             councilProposalThreshold = newValue;
        } else {
            revert InvalidParameterId(); // Should not happen if called from executeProposal with valid enum
        }

         // Note: ParameterChanged event is emitted in executeProposal
    }

    // Owner can also directly set parameters (useful for initial setup or emergencies)
    // In a production DAO, this might be restricted or require a timelock.
    function ownerSetSystemParameter(GovernanceParameter parameterId, uint256 newValue) public onlyOwner {
         if (uint256(parameterId) > uint256(GovernanceParameter.COUNCIL_PROPOSAL_THRESHOLD)) {
            revert InvalidParameterId();
        }
        _setParameter(parameterId, newValue);
        emit ParameterChanged(parameterId, newValue); // Emit event directly
    }


    // --- 13. Query Functions ---

    function getAttunementPool() public view returns (uint256) {
        return _attunementPool;
    }

    function getSystemParameters() public view returns (
        uint256 _energyRechargeRatePerMinute,
        uint256 _resonanceBoostAmount,
        uint256 _attunementCostRecharge,
        uint256 _attunementCostResonance,
        uint256 _attunementCraftingCost,
        uint256 _nexusCooldownDuration,
        uint256 _nexusEnergyBoost,
        uint256 _nexusResonanceBoostFactor,
        uint256 _councilProposalThreshold,
        uint256 _nexusLastActivationTimestamp
    ) {
        return (
            energyRechargeRatePerMinute,
            resonanceBoostAmount,
            attunementCostRecharge,
            attunementCostResonance,
            attunementCraftingCost,
            nexusCooldownDuration,
            nexusEnergyBoost,
            nexusResonanceBoostFactor,
            councilProposalThreshold,
            _nexusLastActivation
        );
    }

    function getProposal(uint256 proposalId) public view returns (
        uint256 id,
        GovernanceParameter parameterId,
        uint256 newValue,
        address creator,
        uint256 votesFor,
        uint256 votesAgainst,
        bool executed
    ) {
         Proposal storage proposal = _proposals[proposalId];
         if (proposal.id == 0 && proposalId != 0) {
             revert ProposalDoesNotExist();
        }
         if (proposal.id == 0 && proposalId == 0 && _proposalCounter.current() == 0) {
              revert ProposalDoesNotExist();
         }

        return (
            proposal.id,
            proposal.parameterId,
            proposal.newValue,
            proposal.creator,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.executed
        );
    }

    function isCouncilMember(address account) public view returns (bool) {
        return _isCouncilMember[account];
    }

    function getCouncilMembers() public view returns (address[] memory) {
        return _councilMembers;
    }

    function getNextTokenId() public view returns (uint256) {
        return _tokenIdCounter.current();
    }
}
```