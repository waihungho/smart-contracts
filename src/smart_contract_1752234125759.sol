Okay, let's create a smart contract that incorporates several interesting and advanced concepts: dynamic state, time-based mechanics, on-chain randomness (using Chainlink VRF), custom tokenomics for an internal "essence" token generated by interaction, and programmable state mutations.

We'll call it `QuantumEcho`. The core idea is that users interact with "Echoes", which are dynamic entities within the contract. These Echoes have a "Resonance" that decays over time but increases with interaction. Interactions also have a chance of triggering a "Quantum Jump" via VRF, causing a significant, random change in the Echo's state and Resonance. Users can "Harvest" "Quantum Essence" from Echoes based on their current Resonance, and this Essence can be used for various purposes within or outside the contract (like creating new Echoes or trading).

**Outline and Function Summary**

This contract manages dynamic "Echo" entities and an internal "Quantum Essence" token.

1.  **Libraries & Interfaces:** Chainlink VRF (for randomness), standard interfaces for ERC-20 events/basic functions (implemented internally).
2.  **Errors:** Custom errors for specific failure conditions.
3.  **Events:** Signal significant actions like Echo creation, interaction, harvesting, quantum jumps, and token transfers/approvals.
4.  **Structs:**
    *   `Echo`: Represents a single dynamic entity with properties like ID, Resonance, last interaction time, creation time, mutable attributes, and last interactor.
    *   `UserData`: Tracks user-specific data like total interactions and total harvested Essence.
5.  **State Variables:**
    *   Contract owner, pausable state.
    *   Chainlink VRF configuration (coordinator, keyhash, subId).
    *   Mappings for `Echo` data (`id => Echo`), `UserData` (`address => UserData`).
    *   `nextEchoId`: Counter for new Echoes.
    *   Configurable parameters: `creationFee`, `decayRate`, `interactionBoost`, `harvestRate`, `quantumJumpProbability`, `resonanceLowerBound`, `resonanceUpperBound`.
    *   VRF Request mapping: `requestId => echoId`.
    *   Internal ERC-20 State: `_balances`, `_allowances`, `_totalSupply`, token metadata (`name`, `symbol`, `decimals`).
6.  **Modifiers:** `onlyOwner`, `whenNotPaused`, `nonReentrant` (if applicable, though not strictly needed for this design).
7.  **Core Logic:**
    *   **`calculateCurrentResonance(uint256 echoId)` (View):** Calculates the real-time Resonance of an Echo based on its last updated state, accounting for time decay.
    *   **`createEcho()` (Payable):** Allows anyone to create a new Echo by paying a fee. Initializes the Echo's state.
    *   **`interactWithEcho(uint256 echoId)`:** Allows a user to interact with an existing Echo. Boosts its Resonance, updates last interaction time, records the interactor, and triggers a VRF request for a potential Quantum Jump.
    *   **`rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords)` (Internal/VRF Callback):** Processes the random result from Chainlink VRF. Applies a random change to the target Echo's Resonance and potentially mutates its attribute based on the random number.
    *   **`harvestEssence(uint256 echoId)`:** Allows a user to harvest Quantum Essence from an Echo based on its current Resonance. Mints Essence tokens to the user and potentially reduces the Echo's Resonance.
8.  **Essence Token (Internal ERC-20 implementation):**
    *   **`_mint(address account, uint256 amount)` (Internal):** Mints Essence tokens.
    *   **`_transfer(address sender, address recipient, uint256 amount)` (Internal):** Handles token transfers.
    *   **`_approve(address owner, address spender, uint256 amount)` (Internal):** Handles token approvals.
    *   **`balanceOf(address account)` (View):** Returns the Essence balance of an address.
    *   **`transfer(address recipient, uint256 amount)`:** Transfers Essence from the caller to a recipient.
    *   **`approve(address spender, uint256 amount)`:** Approves a spender to transfer Essence on behalf of the caller.
    *   **`transferFrom(address sender, address recipient, uint256 amount)`:** Transfers Essence from a sender to a recipient using an allowance.
    *   **`totalSupply()` (View):** Returns the total supply of Essence.
    *   **`allowance(address owner, address spender)` (View):** Returns the remaining allowance for a spender.
9.  **Admin Functions:**
    *   `setVRFConfig`: Set Chainlink VRF parameters.
    *   `setConfigParameters`: Set various game parameters (decay, boost, rates, probabilities).
    *   `withdrawLink`: Withdraw LINK tokens (used for VRF fees).
    *   `withdrawEther`: Withdraw accidental Ether sent to the contract.
    *   `pause`/`unpause`: Pause core contract interactions.
10. **View/Query Functions:**
    *   `getEchoState`: Get all data for a specific Echo.
    *   `getUserData`: Get user-specific data.
    *   `getCreationFee`: Get the current fee to create an Echo.
    *   `getDecayRate`, `getInteractionBoost`, `getHarvestRate`, etc.: Get current contract parameters.
    *   `getVRFSubscriptionId`, `getVRFKeyHash`: Get VRF config.
    *   `getNextEchoId`: Get the ID for the next new Echo.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@chainlink/contracts/src/v0.8/VrfConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Used implicitly by solc >= 0.8, explicit for clarity or older versions
import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // To interact with LINK

// --- Outline and Function Summary ---
// This contract implements dynamic "Echo" entities and an internal "Quantum Essence" token.
// Echoes have Resonance that changes based on time decay, user interaction, and random "Quantum Jumps"
// triggered by Chainlink VRF. Users can harvest Quantum Essence from Echoes based on their Resonance.

// 1. Libraries & Interfaces: Uses Chainlink VRF, ERC20 basic interfaces.
// 2. Errors: Custom errors for specific failure conditions.
// 3. Events: Signals key state changes and token actions.
// 4. Structs: Echo (dynamic entity state), UserData (user metrics).
// 5. State Variables: Owner, pausable state, VRF config, Echo/User data, parameters, next ID, VRF request mapping, internal ERC-20 state.
// 6. Modifiers: onlyOwner, whenNotPaused.
// 7. Core Logic:
//    - calculateCurrentResonance(uint256 echoId): View function to get real-time Resonance.
//    - createEcho(): Payable function to create a new Echo.
//    - interactWithEcho(uint256 echoId): Boosts Resonance, updates time, triggers VRF.
//    - rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords): VRF callback to apply random jump effect.
//    - harvestEssence(uint256 echoId): Mints Quantum Essence based on Echo Resonance.
// 8. Essence Token (Internal ERC-20): Basic implementation for balance, transfer, approve, transferFrom, totalSupply, allowance.
// 9. Admin Functions: Set VRF/game parameters, withdraw funds, pause/unpause.
// 10. View/Query Functions: Get Echo/User data, current parameters, VRF config, next ID.

// --- End of Summary ---


// Custom Errors
error QuantumEcho__InvalidEchoId();
error QuantumEcho__InsufficientFee(uint256 requiredFee);
error QuantumEcho__InsufficientEssenceBalance(uint256 required, uint256 has);
error QuantumEcho__InsufficientEssenceAllowance(uint256 required, uint256 has);
error QuantumEcho__TransferFailed(); // Generic transfer error
error QuantumEcho__MustBeVRFCoordinator(); // For VRF callback security


contract QuantumEcho is Ownable, Pausable, VRFConsumerBaseV2 {
    using SafeMath for uint256; // Though implicitly used, good practice

    // --- Events ---
    event EchoCreated(uint256 indexed echoId, address indexed creator, uint256 initialResonance, uint256 creationFee);
    event EchoInteracted(uint256 indexed echoId, address indexed interactor, uint256 oldResonance, uint256 newResonance, uint256 requestId);
    event QuantumJumpOccurred(uint256 indexed echoId, uint256 indexed requestId, uint256 randomWord, int256 resonanceChange, uint256 newAttributeValue);
    event EssenceHarvested(uint256 indexed echoId, address indexed harvester, uint256 amountHarvested, uint256 remainingEchoResonance);
    event ParametersUpdated();
    event VRFConfigUpdated();

    // ERC20 standard events (for the internal token)
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // --- Structs ---

    struct Echo {
        uint256 id;
        address creator;
        uint256 baseResonance; // Resonance value last updated by interaction or jump
        uint64 lastInteractionTimestamp; // Use uint64 for timestamp
        address lastInteractor;
        uint256 mutableAttribute; // A value that can be changed by Quantum Jumps
        uint256 creationBlock; // For potential future mechanics
    }

    struct UserData {
        uint256 totalInteractions;
        uint256 totalEssenceHarvested;
    }

    // --- State Variables ---

    // Chainlink VRF Configuration
    VRFCoordinatorV2Interface immutable private i_vrfCoordinator;
    uint64 private s_subscriptionId;
    bytes32 private s_keyHash; // Rinkeby gas lane: 0xd89b2bf150e3b9e1344661fd589b9dfa1352fa1e0899eb6bd03a4cb4b4cffbbe
    uint32 private s_callbackGasLimit = 100000; // Example gas limit for the callback
    uint16 private s_requestConfirmations = 3; // Number of block confirmations

    // VRF Request Tracking: request ID => echo ID
    mapping(uint256 => uint256) private s_vrfRequests;

    // Echo Data
    mapping(uint256 => Echo) private s_echoes;
    uint256 private s_nextEchoId = 1; // Start Echo IDs from 1

    // User Data
    mapping(address => UserData) private s_userData;

    // Configurable Parameters (Admin set)
    uint256 public s_creationFee = 0.01 ether; // Fee to create a new Echo (in Ether)
    uint256 public s_decayRatePerSecond = 1e10; // Resonance decay per second (scaled)
    uint256 public s_interactionBoost = 100e18; // Flat Resonance boost on interaction (scaled)
    uint256 public s_harvestRate = 1e17; // Essence minted per point of Resonance harvested (scaled)
    uint256 public s_quantumJumpProbability = 20; // Percentage chance (0-100)
    uint256 public s_resonanceLowerBound = 0; // Minimum resonance
    uint256 public s_resonanceUpperBound = 1000e18; // Maximum resonance (scaled)
    uint256 public s_mutableAttributeRange = 100; // Range for random attribute change (0 to this value)

    // Internal Quantum Essence Token State (Minimal ERC20)
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string public name = "Quantum Essence";
    string public symbol = "QE";
    uint8 public decimals = 18;

    // --- Constructor ---

    constructor(
        address vrfCoordinator, // Chainlink VRF Coordinator address
        bytes32 keyHash,
        uint64 subscriptionId
    ) Ownable(msg.sender) Pausable(false) VRFConsumerBaseV2(vrfCoordinator) {
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinator);
        s_keyHash = keyHash;
        s_subscriptionId = subscriptionId;
    }

    // --- VRF Callback ---
    // Called by Chainlink VRF Coordinator when randomness is ready

    function rawFulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) internal override {
        // Validate that this call came from the VRF coordinator
        // VRFConsumerBaseV2 handles this check implicitly via `onlyVRFCoordinator`
        // However, it's good practice to be aware of the check being done.

        uint256 echoId = s_vrfRequests[requestId];
        if (echoId == 0) {
            // This request wasn't for an Echo jump, or it's already processed/invalid.
            // Should not happen with correct mapping management, but safety first.
            return;
        }

        // Remove the mapping to prevent processing the same request twice
        delete s_vrfRequests[requestId];

        // We expect at least one random word
        if (randomWords.length == 0) {
            // This is an unexpected scenario, log or handle appropriately
            return;
        }

        uint256 randomNumber = randomWords[0]; // Use the first random word

        Echo storage echo = s_echoes[echoId];
        // Re-validate echo existence, though mapping check should suffice
        if (echo.id == 0) {
             // Echo was deleted between request and fulfill? Highly unlikely but possible.
             return;
        }

        // Determine if a Quantum Jump occurs based on probability
        if ((randomNumber % 100) < s_quantumJumpProbability) {
            // Calculate resonance change: can be positive or negative
            // Use a portion of the random number for the change amount and sign
            // Let's make the change range based on the current resonance or a fixed value
            int256 resonanceChange;
            uint256 changeAmount = (randomNumber / 100) % (echo.baseResonance / 10 + 1e18); // Example: change up to 10% of base Resonance + fixed amount
            if ((randomNumber / 1000) % 2 == 0) { // Roughly 50% chance for positive/negative
                resonanceChange = int256(changeAmount);
            } else {
                resonanceChange = -int256(changeAmount);
            }

            // Apply resonance change, ensuring it stays within bounds
            uint256 newBaseResonance = uint256(int256(echo.baseResonance) + resonanceChange);
             if (newBaseResonance > s_resonanceUpperBound) newBaseResonance = s_resonanceUpperBound;
             if (newBaseResonance < s_resonanceLowerBound) newBaseResonance = s_resonanceLowerBound; // Safe against underflow due to type casting and checking

            echo.baseResonance = newBaseResonance;

            // Mutate attribute based on another part of the random number
            echo.mutableAttribute = (randomNumber / 10000) % (s_mutableAttributeRange + 1);

            // Update last interaction timestamp to reset decay after jump
            echo.lastInteractionTimestamp = uint64(block.timestamp); // Jump resets decay

            emit QuantumJumpOccurred(echoId, requestId, randomNumber, resonanceChange, echo.mutableAttribute);
        }
        // If jump doesn't occur, the resonance and timestamp are already updated by interactWithEcho
    }


    // --- Core Logic ---

    /**
     * @notice Calculates the current dynamic resonance of an Echo including decay.
     * @param echoId The ID of the Echo.
     * @return The current resonance of the Echo.
     */
    function calculateCurrentResonance(uint256 echoId) public view returns (uint256) {
        Echo storage echo = s_echoes[echoId];
        if (echo.id == 0) {
            revert QuantumEcho__InvalidEchoId();
        }

        uint256 timeElapsed = block.timestamp - echo.lastInteractionTimestamp;
        uint256 decayAmount = timeElapsed.mul(s_decayRatePerSecond);

        // Prevent underflow and ensure resonance doesn't go below the lower bound
        uint256 currentResonance = echo.baseResonance > decayAmount ? echo.baseResonance.sub(decayAmount) : 0;
        if (currentResonance < s_resonanceLowerBound) {
             currentResonance = s_resonanceLowerBound;
        }

        return currentResonance;
    }

    /**
     * @notice Creates a new Quantum Echo. Requires payment of a fee.
     */
    function createEcho() external payable whenNotPaused {
        if (msg.value < s_creationFee) {
            revert QuantumEcho__InsufficientFee(s_creationFee);
        }

        uint256 newId = s_nextEchoId;
        s_echoes[newId] = Echo({
            id: newId,
            creator: msg.sender,
            baseResonance: s_interactionBoost, // Start with some initial boost/resonance
            lastInteractionTimestamp: uint64(block.timestamp),
            lastInteractor: address(0), // No interactor yet
            mutableAttribute: 0, // Initial attribute value
            creationBlock: block.number
        });

        s_nextEchoId++;

        // Update creator's user data (optional, but fits the theme)
        s_userData[msg.sender].totalInteractions++; // Creation counts as first interaction

        emit EchoCreated(newId, msg.sender, s_interactionBoost, msg.value);
    }

    /**
     * @notice Interacts with an existing Echo. Boosts Resonance and can trigger a Quantum Jump.
     * @param echoId The ID of the Echo to interact with.
     */
    function interactWithEcho(uint256 echoId) external whenNotPaused {
        Echo storage echo = s_echoes[echoId];
        if (echo.id == 0) {
            revert QuantumEcho__InvalidEchoId();
        }

        uint256 oldResonance = calculateCurrentResonance(echoId);

        // Apply decay up to the current interaction time
        uint256 timeElapsed = block.timestamp - echo.lastInteractionTimestamp;
        uint256 decayAmount = timeElapsed.mul(s_decayRatePerSecond);
        uint256 resonanceAfterDecay = echo.baseResonance > decayAmount ? echo.baseResonance.sub(decayAmount) : 0;

        // Apply interaction boost and update base resonance
        echo.baseResonance = resonanceAfterDecay.add(s_interactionBoost);
        if (echo.baseResonance > s_resonanceUpperBound) {
             echo.baseResonance = s_resonanceUpperBound;
        }
         if (echo.baseResonance < s_resonanceLowerBound) {
             echo.baseResonance = s_resonanceLowerBound;
        }


        // Update interaction timestamp and last interactor
        echo.lastInteractionTimestamp = uint64(block.timestamp);
        echo.lastInteractor = msg.sender;

        // Update user data
        s_userData[msg.sender].totalInteractions++;

        uint256 newResonance = echo.baseResonance; // This is the *new base* before any potential jump

        emit EchoInteracted(echoId, msg.sender, oldResonance, newResonance, 0); // 0 for request ID initially

        // Request randomness for a potential Quantum Jump
        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            s_keyHash,
            s_subscriptionId,
            s_requestConfirmations,
            s_callbackGasLimit,
            1 // Request just 1 random word
        );

        s_vrfRequests[requestId] = echoId; // Map request ID back to Echo ID

        // Emit event again with requestId this time? Or add requestId to the first event?
        // Let's stick with the first event for interaction and a separate one for the jump result.
        // A separate event signals the *result* of the randomness request.
    }

    /**
     * @notice Allows harvesting Quantum Essence from an Echo based on its current Resonance.
     * Mints Essence tokens and reduces the Echo's Resonance.
     * @param echoId The ID of the Echo to harvest from.
     */
    function harvestEssence(uint256 echoId) external whenNotPaused {
        Echo storage echo = s_echoes[echoId];
        if (echo.id == 0) {
            revert QuantumEcho__InvalidEchoId();
        }

        // Calculate current resonance including decay
        uint256 currentResonance = calculateCurrentResonance(echoId);

        // Calculate harvestable amount
        // Amount = min(currentResonance, a maximum harvestable per call?) * harvestRate
        // Let's keep it simple: harvestable = currentResonance * harvestRate
        uint256 amountToHarvest = currentResonance.mul(s_harvestRate) / (10**decimals); // Adjust for harvest rate scale vs token decimals

        if (amountToHarvest == 0) {
            // No essence to harvest or resonance is too low
             // Consider adding a specific error or just let the transaction succeed with 0 harvest.
             // Succeeding with 0 is fine and consumes gas, which is a cost.
        } else {
             // Mint Essence tokens to the harvester
            _mint(msg.sender, amountToHarvest);

            // Reduce the Echo's base resonance by the harvested amount (or a fraction?)
            // Reducing by current resonance makes it a one-shot harvest per interaction peak.
            // Let's reduce the *base* resonance by the *calculated current* resonance. This incentivizes harvesting at peak.
            // Ensure it doesn't go below the lower bound.
            echo.baseResonance = echo.baseResonance > currentResonance ? echo.baseResonance.sub(currentResonance) : 0;
            if (echo.baseResonance < s_resonanceLowerBound) {
                 echo.baseResonance = s_resonanceLowerBound;
            }

            // Update user data
            s_userData[msg.sender].totalEssenceHarvested = s_userData[msg.sender].totalEssenceHarvested.add(amountToHarvest);
        }

        // Update last interaction timestamp? Harvesting could also reset decay. Let's say yes.
        echo.lastInteractionTimestamp = uint64(block.timestamp); // Harvesting also counts as interaction/update

        emit EssenceHarvested(echoId, msg.sender, amountToHarvest, calculateCurrentResonance(echoId)); // Emit final resonance after harvest/decay reset
    }

    // --- Internal Quantum Essence Token Implementation (Minimal ERC20-like) ---
    // Note: This is a minimal implementation for this contract's specific token.
    // It doesn't include all ERC20 optional features or security hardening of a full library.

    function _mint(address account, uint256 amount) internal {
        require(account != address(0), "QE: mint to the zero address");
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount); // ERC20 standard mint event
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "QE: transfer from the zero address");
        require(recipient != address(0), "QE: transfer to the zero address");

        uint256 senderBalance = _balances[sender];
        if (senderBalance < amount) {
            revert QuantumEcho__InsufficientEssenceBalance(amount, senderBalance);
        }

        _balances[sender] = senderBalance.sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal {
        require(owner != address(0), "QE: approve from the zero address");
        require(spender != address(0), "QE: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    // --- External ERC20 Functions ---

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) external returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        if (currentAllowance < amount) {
            revert QuantumEcho__InsufficientEssenceAllowance(amount, currentAllowance);
        }
        _approve(sender, msg.sender, currentAllowance.sub(amount)); // Decrease allowance first
        _transfer(sender, recipient, amount);
        return true;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }


    // --- Admin Functions ---

    /**
     * @notice Sets the configuration for Chainlink VRF.
     * @param keyHash_ The key hash to use for VRF requests.
     * @param subscriptionId_ The subscription ID linked to this contract.
     * @param callbackGasLimit_ The gas limit for the VRF callback function.
     * @param requestConfirmations_ The number of block confirmations to wait for.
     */
    function setVRFConfig(
        bytes32 keyHash_,
        uint64 subscriptionId_,
        uint32 callbackGasLimit_,
        uint16 requestConfirmations_
    ) external onlyOwner {
        s_keyHash = keyHash_;
        s_subscriptionId = subscriptionId_;
        s_callbackGasLimit = callbackGasLimit_;
        s_requestConfirmations = requestConfirmations_;
        emit VRFConfigUpdated();
    }

    /**
     * @notice Sets various game/economic parameters of the contract.
     * All parameters should be scaled appropriately (e.g., 1e18 for values meant to be whole numbers).
     * @param creationFee_ Fee to create an Echo (in Ether).
     * @param decayRatePerSecond_ Rate at which Resonance decays per second.
     * @param interactionBoost_ Amount Resonance increases on interaction.
     * @param harvestRate_ Rate of Essence minted per unit of Resonance harvested.
     * @param quantumJumpProbability_ Percentage chance (0-100) of a Quantum Jump on interaction.
     * @param resonanceLowerBound_ Minimum allowed Resonance.
     * @param resonanceUpperBound_ Maximum allowed Resonance.
     * @param mutableAttributeRange_ Max value for mutable attribute changes (0 to this value).
     */
    function setConfigParameters(
        uint256 creationFee_,
        uint256 decayRatePerSecond_,
        uint256 interactionBoost_,
        uint256 harvestRate_,
        uint256 quantumJumpProbability_,
        uint256 resonanceLowerBound_,
        uint256 resonanceUpperBound_,
        uint256 mutableAttributeRange_
    ) external onlyOwner {
        require(quantumJumpProbability_ <= 100, "Probability must be <= 100");
        require(resonanceLowerBound_ <= resonanceUpperBound_, "Lower bound must be <= Upper bound");

        s_creationFee = creationFee_;
        s_decayRatePerSecond = decayRatePerSecond_;
        s_interactionBoost = interactionBoost_;
        s_harvestRate = harvestRate_;
        s_quantumJumpProbability = quantumJumpProbability_;
        s_resonanceLowerBound = resonanceLowerBound_;
        s_resonanceUpperBound = resonanceUpperBound_;
        s_mutableAttributeRange = mutableAttributeRange_;
        emit ParametersUpdated();
    }

    /**
     * @notice Allows the owner to withdraw LINK tokens held by the contract (e.g., excess from subscription).
     * @param to The address to send LINK to.
     * @param amount The amount of LINK to withdraw.
     */
    function withdrawLink(address to, uint256 amount) external onlyOwner {
        // Assuming LINK is an ERC20 token, replace with actual LINK token address
        // For testing, you might use a mock ERC20 or comment this out if not deploying with real LINK
        // This requires the LINK token address to be known and possibly passed in constructor or set by owner.
        // For demonstration, we'll use a placeholder/example interface call.
        // In a real scenario, you'd need the LINK token contract address.
        // Example Placeholder (requires IERC20 import):
        // IERC20 linkToken = IERC20(0x...'); // Replace with actual LINK token address on network
        // require(linkToken.transfer(to, amount), "LINK withdrawal failed");

        // --- Dummy Implementation (replace with actual IERC20 transfer) ---
        // This part needs a real IERC20 transfer call using the actual LINK token address.
        // For the sake of a complete, compilable example *without* needing a specific LINK address,
        // we'll simulate it or require the user to add the actual LINK transfer.
        // IMPORTANT: Replace the line below with actual LINK transfer logic in production.
        revert("Replace this revert with actual LINK token transfer logic using the LINK token address.");
        // Example:
        // require(IERC20(LINK_TOKEN_ADDRESS).transfer(to, amount), "LINK withdrawal failed");
        // --------------------------------------------------------------
    }

    /**
     * @notice Allows the owner to withdraw any Ether sent to the contract beyond the creation fee.
     * @param to The address to send Ether to.
     */
    function withdrawEther(address to) external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No Ether to withdraw");
        (bool success, ) = payable(to).call{value: balance}("");
        if (!success) {
            revert QuantumEcho__TransferFailed(); // Use a more specific error if possible
        }
    }

    /**
     * @notice Pauses core contract interactions (create, interact, harvest).
     */
    function pauseContract() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpauses core contract interactions.
     */
    function unpauseContract() external onlyOwner {
        _unpause();
    }

    // --- View/Query Functions (Total: 20+ functions) ---

    // Admin functions (Already listed above, contribute to count)
    // 1. setVRFConfig
    // 2. setConfigParameters
    // 3. withdrawLink
    // 4. withdrawEther
    // 5. pauseContract
    // 6. unpauseContract

    // Core Logic functions (Already listed above, contribute to count)
    // 7. calculateCurrentResonance (public view)
    // 8. createEcho (payable external)
    // 9. interactWithEcho (external)
    // 10. harvestEssence (external)

    // Internal VRF callback (internal, doesn't count towards external function count typically)
    // rawFulfillRandomWords

    // Internal Essence token functions (internal, don't count)
    // _mint, _transfer, _approve

    // External Essence token functions (ERC20 interface - contribute to count)
    // 11. balanceOf (public view)
    // 12. transfer (external)
    // 13. allowance (public view)
    // 14. approve (external)
    // 15. transferFrom (external)
    // 16. totalSupply (public view)

    // Additional View/Query Functions

    /**
     * @notice Gets the full state data for a specific Echo.
     * @param echoId The ID of the Echo.
     * @return The Echo struct data.
     */
    function getEchoState(uint256 echoId) external view returns (Echo memory) {
        if (s_echoes[echoId].id == 0) {
            revert QuantumEcho__InvalidEchoId();
        }
        return s_echoes[echoId];
    }

    /**
     * @notice Gets the data for a specific user.
     * @param user The address of the user.
     * @return The UserData struct data.
     */
    function getUserData(address user) external view returns (UserData memory) {
        return s_userData[user]; // Returns zero-initialized struct if user has no data
    }

    /**
     * @notice Gets the current fee required to create a new Echo.
     * @return The creation fee in Wei.
     */
    function getCreationFee() external view returns (uint256) {
        return s_creationFee;
    }

    /**
     * @notice Gets the current resonance decay rate per second.
     * @return The decay rate (scaled).
     */
    function getDecayRatePerSecond() external view returns (uint256) {
        return s_decayRatePerSecond;
    }

    /**
     * @notice Gets the current resonance boost applied on interaction.
     * @return The interaction boost amount (scaled).
     */
    function getInteractionBoost() external view returns (uint256) {
        return s_interactionBoost;
    }

    /**
     * @notice Gets the current rate for harvesting Essence from Resonance.
     * @return The harvest rate (scaled).
     */
    function getHarvestRate() external view returns (uint256) {
        return s_harvestRate;
    }

    /**
     * @notice Gets the current probability of a Quantum Jump occurring on interaction.
     * @return The probability percentage (0-100).
     */
    function getQuantumJumpProbability() external view returns (uint256) {
        return s_quantumJumpProbability;
    }

    /**
     * @notice Gets the lower bound for Echo Resonance.
     * @return The lower bound (scaled).
     */
    function getResonanceLowerBound() external view returns (uint256) {
        return s_resonanceLowerBound;
    }

     /**
     * @notice Gets the upper bound for Echo Resonance.
     * @return The upper bound (scaled).
     */
    function getResonanceUpperBound() external view returns (uint256) {
        return s_resonanceUpperBound;
    }

     /**
     * @notice Gets the maximum value for the mutable attribute range.
     * @return The range value (0 to this value).
     */
    function getMutableAttributeRange() external view returns (uint256) {
        return s_mutableAttributeRange;
    }

    /**
     * @notice Gets the current VRF Subscription ID.
     * @return The subscription ID.
     */
    function getVRFSubscriptionId() external view returns (uint64) {
        return s_subscriptionId;
    }

    /**
     * @notice Gets the current VRF Key Hash.
     * @return The key hash.
     */
    function getVRFKeyHash() external view returns (bytes32) {
        return s_keyHash;
    }

    /**
     * @notice Gets the ID that will be assigned to the next created Echo.
     * @return The next Echo ID.
     */
    function getNextEchoId() external view returns (uint256) {
        return s_nextEchoId;
    }

    // --- Total External/Public Functions Count Check ---
    // Admin: 6
    // Core Logic: 4 (calculateCurrentResonance is public view, create, interact, harvest)
    // Essence Token: 6 (balanceOf, transfer, allowance, approve, transferFrom, totalSupply)
    // Additional Views: 10 (getEchoState, getUserData, getCreationFee, getDecayRate..., getVRF..., getNextEchoId)
    // Total = 6 + 4 + 6 + 10 = 26 functions. This meets the requirement of at least 20 functions.

}
```

**Explanation of Advanced/Creative Concepts:**

1.  **Dynamic State (`Echo` struct):** Echoes are not static tokens or data points. Their primary value (`baseResonance`) and calculated real-time value (`currentResonance`) change based on time and interactions. This creates a dynamic, evolving state for each on-chain entity.
2.  **Time-Based Mechanics (Decay):** The `s_decayRatePerSecond` introduces a constant drain on Resonance. This incentivizes users to interact regularly to maintain or boost an Echo's value, preventing stagnation.
3.  **Interaction Memory:** The `lastInteractionTimestamp` and `lastInteractor` track recent activity, directly influencing the decay calculation and potentially providing historical context. `UserData` tracks cumulative interaction success (`totalEssenceHarvested`).
4.  **On-Chain Randomness (Chainlink VRF):** The `interactWithEcho` function requests random words. The `rawFulfillRandomWords` callback uses this randomness to probabilistically trigger `QuantumJumpOccurred`. This jump causes unpredictable, significant changes (`resonanceChange`, `mutableAttribute`), adding an element of chance and surprise to the Echo's evolution. It moves beyond simple game randomness to affect the core state and "value" (Resonance) of the on-chain asset itself.
5.  **Custom Tokenomics (Internal ERC-20 `Quantum Essence`):** Instead of relying on external tokens, the contract mints its own `QE` token. This token is *only* generated via the `harvestEssence` function, directly tying token supply to user interaction and the dynamic state (Resonance) of the Echoes. This creates an internal economy governed by the contract's rules.
6.  **Programmable State Mutation:** The `QuantumJumpOccurred` event signifies a non-linear change in the Echo's state driven by randomness, affecting both a core metric (`baseResonance`) and a separate attribute (`mutableAttribute`). This allows for complex, unpredictable evolution of the on-chain entities.
7.  **Configurable Parameters:** Many core mechanics (decay rate, boost, harvest rate, probabilities, bounds, fees) are set by the owner. This allows for tuning the game/economy of the contract after deployment, making it more adaptable than fixed-parameter contracts.

This contract avoids simply replicating standard ERC-20/721 or common patterns like simple vaults or standard DAOs. Its complexity lies in the intertwined dynamic state, time mechanics, randomness, and custom token generation loop centered around the `Echo` entities.