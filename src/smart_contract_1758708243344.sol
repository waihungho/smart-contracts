Here's a smart contract written in Solidity, incorporating advanced concepts like ZK-proofs for verifiable AI computation, a reputation system, dynamic NFT-like AI Agents, and a basic DAO for governance and dispute resolution. It aims to be creative and trendy, focusing on the emerging intersection of AI and blockchain, while avoiding direct duplication of existing open-source projects by combining these features in a novel way within a single contract.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

// Dummy ZK Verifier Interface
// In a real application, this would be a separately deployed ZK-SNARK verifier contract
// generated by tools like Circom, Gnark, or from a dedicated ZK-rollup.
interface IZKVerifier {
    /**
     * @dev Verifies a ZK-SNARK proof.
     * @param _proof The serialized ZK-SNARK proof bytes.
     * @param _publicInputs The public inputs to the ZK circuit. These typically include
     *                      hashes of the AI model, input data, and the computed output result
     *                      that the proof commits to. The ZK circuit ensures the output was
     *                      correctly derived from the input using the specified model.
     * @return bool True if the proof is valid, false otherwise.
     */
    function verify(bytes calldata _proof, bytes calldata _publicInputs) external view returns (bool);
}

/**
 * @title AZAN (AI-Powered & ZK-Verifiable Autonomous Agent Network)
 * @dev This contract orchestrates a decentralized network of AI Agents that perform tasks
 *      with verifiable computation via ZK-SNARKs. It includes an NFT-like system for
 *      managing AI Agents, a reputation system, a task marketplace, and a basic DAO
 *      for governance and dispute resolution.
 *
 *      Key Concepts:
 *      - AI Agents as Dynamic NFTs: Each AI Agent is an ERC721 token with associated metadata
 *        and a mutable reputation score.
 *      - ZK-Verifiable Computation: AI Agents submit task results accompanied by ZK-SNARK proofs,
 *        verifying the integrity and correctness of their off-chain AI model execution.
 *      - Reputation System: Agents gain or lose reputation based on task performance and dispute outcomes,
 *        influencing their eligibility for tasks and voting power in the DAO.
 *      - Decentralized Task Marketplace: Users can propose tasks, agents can bid, and results are verified.
 *      - DAO Governance: A basic DAO mechanism allows eligible agents to vote on protocol parameters
 *        and dispute resolutions.
 */
contract AZAN is Ownable, Pausable, ERC721 {
    using Counters for Counters.Counter;

    // Outline:
    // I. Core & Setup: Manages contract ownership, pausing, and external contract addresses (ZK Verifier, Reward Token).
    // II. AI Model & Agent Management: Handles registration of AI models and the lifecycle of AI Agent NFTs (minting, metadata updates, status changes).
    // III. Task Lifecycle Management: Covers proposing tasks, agents bidding, selection, submitting ZK-verified results, and task cancellations.
    // IV. Reputation, Rewards & Penalties: Manages claiming rewards/bonds, and DAO-initiated adjustments to agent reputation (bonuses, penalties).
    // V. Dispute Resolution: Provides a mechanism for challenging ZK-verified task results and a DAO-led voting process to resolve such disputes.
    // VI. DAO Governance: Implements a basic framework for proposing and executing system parameter changes or actions via agent-weighted voting.

    // Function Summary:
    // 1.  constructor(): Initializes contract owner and ERC721 base for AI Agent NFTs.
    // 2.  setExternalContracts(address _zkVerifierAddress, address _rewardTokenAddress): Sets the addresses for the external ZK Verifier and the ERC20 Reward Token contracts. Callable once by owner.
    // 3.  pause(): Pauses core contract functionality in emergencies (inherited from Pausable).
    // 4.  unpause(): Resumes contract functionality (inherited from Pausable).
    // 5.  transferOwnership(): Transfers contract administrative ownership (inherited from Ownable).
    // 6.  registerAIModel(bytes32 _modelIpfsHash, string[] calldata _skillTags): Registers a new AI model, identified by its IPFS hash and descriptive skill tags, making it available for agents.
    // 7.  mintAIAgent(uint256 _modelId, string calldata _tokenUri): Mints a new AI Agent NFT, linking it to a registered AI model and assigning initial metadata.
    // 8.  updateAIAgentMetadata(uint256 _agentId, string calldata _newMetadataUri): Allows an AI Agent's owner to update its public profile metadata URI.
    // 9.  updateAgentModelVersion(uint256 _agentId, uint256 _newModelId): Enables an AI Agent's owner to switch or upgrade the underlying AI model their agent uses.
    // 10. transferAIAgent(address _from, address _to, uint256 _agentId): Transfers ownership of an AI Agent NFT, applying specific AZAN logic like setting agent status to 'Unavailable'.
    // 11. setAgentServiceStatus(uint256 _agentId, bool _isAvailable): Allows an AI Agent owner to declare their agent 'Available' or 'Unavailable' for tasks.
    // 12. proposeTask(string calldata _description, bytes calldata _inputSchema, bytes calldata _outputSchema, uint256 _rewardAmount, uint256 _taskBond, uint256 _deadline): A user proposes a new task, specifying requirements, reward, bond, and deadline.
    // 13. bidForTask(uint256 _taskId, uint256 _agentId, uint256 _estimatedCompletionTime): An 'Available' AI Agent bids on a proposed task, committing to an estimated completion time.
    // 14. selectAgentForTask(uint256 _taskId, uint256 _agentId): The task proposer chooses an AI Agent from the bids and assigns the task.
    // 15. submitTaskResultWithZKProof(uint256 _taskId, bytes32 _resultHash, bytes calldata _proof, bytes calldata _publicInputs): The assigned AI Agent submits the task's output result hash along with a ZK-SNARK proof for computational integrity verification.
    // 16. rejectTaskResult(uint256 _taskId, string calldata _reason): The task proposer can reject a *submitted but not yet ZK-verified* result due to obvious non-compliance.
    // 17. cancelProposedTask(uint256 _taskId): A task proposer can cancel their task if no agent has been assigned, refunding their bond and reward.
    // 18. claimAIAgentReward(uint256 _taskId): The owner of a successfully ZK-verified AI Agent claims their reward after a dispute period.
    // 19. claimTaskProposerBond(uint256 _taskId): The task proposer claims their bond back after the task is fully completed and verified.
    // 20. penalizeAIAgent(uint256 _agentId, int256 _reputationLoss): A DAO function to reduce an AI Agent's reputation, typically following a dispute resolution.
    // 21. awardBonusToAgent(uint256 _agentId, uint256 _reputationGain): A DAO function to award a reputation bonus to an AI Agent for outstanding performance or DAO decision.
    // 22. initiateResultDispute(uint256 _taskId, string calldata _reason): Any user can initiate a dispute against a ZK-verified task result, challenging its content or interpretation, requiring a bond.
    // 23. voteOnDisputeOutcome(uint256 _disputeId, bool _supportDisputer): Eligible AI Agent owners (based on reputation) vote on an active dispute.
    // 24. resolveDispute(uint256 _disputeId): Executes the outcome of a dispute vote once the voting period ends, applying penalties or refunds.
    // 25. proposeSystemParameterChange(string calldata _description, bytes calldata _callData, address _targetContract): Eligible AI Agent owners propose changes to contract parameters or actions, encoded as a function call.
    // 26. voteOnGovernanceProposal(uint256 _proposalId, bool _support): Eligible AI Agent owners vote on an active governance proposal.
    // 27. executeGovernanceProposal(uint256 _proposalId): Executes a passed governance proposal once its voting period concludes.

    // I. Core & Setup
    IZKVerifier private _zkVerifier;
    IERC20 private _rewardToken;

    // Governance parameters (can be changed via DAO proposals)
    uint256 public constant MIN_REPUTATION_FOR_DAO_VOTE = 1000; // Minimum reputation an agent needs to participate in DAO voting
    uint256 public constant DISPUTE_BOND_PERCENTAGE = 5; // Percentage of task reward required as a bond to initiate a dispute
    uint256 public constant PROPOSAL_VOTING_PERIOD = 3 days; // Duration for voting on DAO proposals and disputes
    uint256 public constant TASK_REWARD_CLAIM_PERIOD = 7 days; // Grace period after ZK verification for disputes before rewards can be claimed

    // Counters for unique IDs across different entities
    Counters.Counter private _modelIdCounter;
    Counters.Counter private _taskIdCounter;
    Counters.Counter private _disputeIdCounter;
    Counters.Counter private _proposalIdCounter;

    // Enums for clarity and state management
    enum AIAgentStatus {
        Available,     // Ready to take on tasks
        Unavailable,   // Temporarily not taking tasks (e.g., during transfer, maintenance)
        Retired        // Permanently out of service
    }

    enum TaskStatus {
        Proposed,          // Task created, waiting for bids (initial state after proposal)
        Bidding,           // Actively receiving bids from agents
        Assigned,          // An agent has been selected and assigned
        ResultSubmitted,   // Agent has submitted a result, awaiting ZK verification
        ZKVerified,        // Result has passed ZK verification
        Rejected,          // Proposer rejected the result before ZK verification (agent can resubmit)
        Disputed,          // Task result is under dispute
        Completed,         // Reward claimed, task fully finalized
        Canceled           // Task canceled by proposer
    }

    enum DisputeStatus {
        Pending,           // Dispute initiated, awaiting voting (brief phase)
        Voting,            // Active voting by DAO members
        Resolved           // Voting concluded, outcome executed
    }

    enum ProposalStatus {
        Pending,           // Proposal initiated, awaiting voting (brief phase)
        Active,            // Active voting by DAO members
        Succeeded,         // Proposal passed voting
        Failed,            // Proposal failed voting
        Executed           // Passed proposal has been executed
    }

    // Structs to hold data for each entity
    struct AIModel {
        bytes32 modelIpfsHash; // IPFS hash pointing to the AI model's definition/weights/code
        string[] skillTags;    // Descriptive tags like "NLP", "Computer Vision", "Prediction"
        address registeredBy;  // Address that registered this model
        uint256 registrationTime; // Timestamp of registration
    }

    struct AIAgent {
        uint256 modelId;       // Link to the AIModel (from `aiModels` mapping) this agent utilizes
        int256 reputation;     // A mutable score reflecting the agent's performance and trustworthiness
        AIAgentStatus status;  // Current operational status of the agent
        string metadataUri;    // URI for agent's public profile, potentially including a dynamic NFT image
    }

    struct Task {
        string description;      // Detailed description of the task
        bytes inputSchema;       // ABI-encoded schema for the expected input data format
        bytes outputSchema;      // ABI-encoded schema for the expected output data format
        address proposer;        // Address of the user who proposed the task
        uint256 rewardAmount;    // Amount of reward token for successful completion
        uint256 taskBond;        // Bond deposited by the proposer, refunded on success
        uint256 deadline;        // Absolute timestamp by which the task must be completed
        uint256 assignedAgentId; // ID of the AI Agent assigned to this task (0 if none)
        bytes32 resultHash;      // Cryptographic hash of the verified task result
        uint256 completionTime;  // Timestamp when ZK proof was successfully verified
        TaskStatus status;       // Current status of the task
        mapping(uint256 => Bid) bids; // Mapping from agent ID to their bid details
        uint256[] activeBids;    // Array of agent IDs that have placed bids on this task
    }

    struct Bid {
        uint256 agentId;                 // ID of the AI Agent placing the bid
        uint256 estimatedCompletionTime; // Estimated time (in seconds) from assignment to completion
        uint256 bidTime;                 // Timestamp when the bid was placed
    }

    struct Dispute {
        uint256 taskId;                 // ID of the task under dispute
        address initiator;              // Address that initiated the dispute
        string reason;                  // Detailed reason for the dispute
        uint256 bondAmount;             // Bond deposited by the initiator
        DisputeStatus status;           // Current status of the dispute
        uint256 voteStartTime;          // Timestamp when voting began for this dispute
        uint256 votesForDisputer;       // Total reputation points supporting the disputer
        uint256 votesAgainstDisputer;   // Total reputation points supporting the assigned agent
        bool resolvedOutcome;           // True if the dispute was upheld (disputer won), false otherwise
    }

    struct GovernanceProposal {
        string description;             // Description of the proposed governance action
        bytes callData;                 // ABI-encoded data of the function call to execute if passed
        address targetContract;         // Address of the contract to call (e.g., `address(this)` for self-modification)
        ProposalStatus status;          // Current status of the proposal
        uint256 voteStartTime;          // Timestamp when voting began
        uint256 votesFor;               // Total reputation points in favor
        uint256 votesAgainst;           // Total reputation points against
        uint256 totalVotersReputation;  // Sum of reputation of all voting agents (to calculate turnout/quorum implicitly)
    }

    // Mappings to store entities by their unique IDs
    mapping(uint256 => AIModel) public aiModels;
    mapping(uint256 => AIAgent) public aiAgents; // ERC721 tokenId maps to AIAgent data
    mapping(uint256 => Task) public tasks;
    mapping(uint256 => Dispute) public disputes;
    mapping(uint256 => GovernanceProposal) public proposals;

    // Events for transparency and off-chain monitoring
    event ExternalContractsSet(address zkVerifier, address rewardToken);
    event AIModelRegistered(uint256 indexed modelId, bytes32 indexed modelIpfsHash, address indexed registeredBy);
    event AIAgentMinted(uint256 indexed agentId, address indexed owner, uint256 indexed modelId);
    event AIAgentMetadataUpdated(uint256 indexed agentId, string newMetadataUri);
    event AIAgentModelVersionUpdated(uint256 indexed agentId, uint256 oldModelId, uint256 newModelId);
    event AIAgentStatusChanged(uint256 indexed agentId, AIAgentStatus newStatus);
    event TaskProposed(uint256 indexed taskId, address indexed proposer, uint256 rewardAmount, uint256 deadline);
    event TaskBid(uint256 indexed taskId, uint256 indexed agentId, uint256 estimatedCompletionTime);
    event TaskAgentSelected(uint256 indexed taskId, uint256 indexed agentId);
    event TaskResultSubmitted(uint256 indexed taskId, uint256 indexed agentId, bytes32 resultHash);
    event TaskZKVerified(uint256 indexed taskId, uint256 indexed agentId, bytes32 resultHash);
    event TaskRejected(uint256 indexed taskId, address indexed proposer, string reason);
    event TaskCanceled(uint256 indexed taskId, address indexed proposer);
    event AIAgentRewardClaimed(uint256 indexed taskId, uint256 indexed agentId, uint256 rewardAmount);
    event TaskProposerBondClaimed(uint256 indexed taskId, address indexed proposer, uint256 bondAmount);
    event AIAgentPenalized(uint256 indexed agentId, int256 reputationLoss);
    event AIAgentBonusAwarded(uint256 indexed agentId, uint256 reputationGain);
    event ResultDisputeInitiated(uint256 indexed disputeId, uint256 indexed taskId, address indexed initiator);
    event DisputeVoted(uint256 indexed disputeId, address indexed voter, bool supportDisputer);
    event DisputeResolved(uint256 indexed disputeId, uint256 indexed taskId, bool outcome);
    event GovernanceProposalProposed(uint256 indexed proposalId, string description, address indexed proposer);
    event GovernanceProposalVoted(uint256 indexed proposalId, address indexed voter, bool support);
    event GovernanceProposalExecuted(uint256 indexed proposalId);


    constructor() ERC721("AZAN AI Agent", "AZAN-AGENT") Ownable(msg.sender) {
        // Initializes the contract owner and the ERC721 token (for AI Agents).
    }

    // --- Modifiers for access control and state checks ---
    modifier onlyAIAgentOwner(uint256 _agentId) {
        require(_exists(_agentId), "AZAN: Agent does not exist");
        require(ownerOf(_agentId) == msg.sender, "AZAN: Not agent owner");
        _;
    }

    modifier onlyTaskProposer(uint256 _taskId) {
        require(tasks[_taskId].proposer != address(0), "AZAN: Task does not exist");
        require(tasks[_taskId].proposer == msg.sender, "AZAN: Not task proposer");
        _;
    }

    modifier onlyDAO() {
        // This modifier is used for functions that should conceptually be controlled by the DAO.
        // For simplicity in this example, it delegates control to the contract's `owner()`.
        // In a fully decentralized system, `owner()` would typically be a DAO's timelock or governor contract.
        require(msg.sender == owner(), "AZAN: Only DAO/Owner can call this function");
        _;
    }

    // --- I. Core & Setup Functions ---

    /**
     * @dev Sets the addresses for external ZK Verifier and Reward Token contracts.
     *      This function can only be called once by the contract owner, usually during deployment setup.
     * @param _zkVerifierAddress The address of the ZK-SNARK verifier contract.
     * @param _rewardTokenAddress The address of the ERC20 token used for rewards and bonds.
     */
    function setExternalContracts(address _zkVerifierAddress, address _rewardTokenAddress) external onlyOwner {
        require(address(_zkVerifier) == address(0), "AZAN: ZK Verifier already set");
        require(address(_rewardToken) == address(0), "AZAN: Reward Token already set");
        require(_zkVerifierAddress != address(0), "AZAN: ZK Verifier cannot be zero address");
        require(_rewardTokenAddress != address(0), "AZAN: Reward Token cannot be zero address");

        _zkVerifier = IZKVerifier(_zkVerifierAddress);
        _rewardToken = IERC20(_rewardTokenAddress);

        emit ExternalContractsSet(_zkVerifierAddress, _rewardTokenAddress);
    }
    // (Functions `pause()`, `unpause()`, `transferOwnership()` are inherited from OpenZeppelin contracts.)


    // --- II. AI Model & Agent Management Functions ---

    /**
     * @dev Registers a new AI model, identified by its IPFS hash and skill tags.
     *      Any user can register a model, making it available for AI Agents to adopt.
     * @param _modelIpfsHash The IPFS hash pointing to the AI model's definition, weights, or code.
     * @param _skillTags An array of strings describing the model's capabilities (e.g., "NLP", "Image Recognition", "Financial Prediction").
     * @return The unique ID of the newly registered AI model.
     */
    function registerAIModel(bytes32 _modelIpfsHash, string[] calldata _skillTags) external returns (uint256) {
        require(_modelIpfsHash != bytes32(0), "AZAN: Model IPFS hash cannot be empty");
        // Additional validation (e.g., on _skillTags content or length) can be added here.

        _modelIdCounter.increment();
        uint256 newModelId = _modelIdCounter.current();
        
        aiModels[newModelId] = AIModel({
            modelIpfsHash: _modelIpfsHash,
            skillTags: _skillTags,
            registeredBy: msg.sender,
            registrationTime: block.timestamp
        });

        emit AIModelRegistered(newModelId, _modelIpfsHash, msg.sender);
        return newModelId;
    }

    /**
     * @dev Mints a new AI Agent NFT, associating it with a previously registered AI model.
     *      The minter becomes the owner of the AI Agent NFT.
     * @param _modelId The ID of the registered AI model that this agent will primarily use.
     * @param _tokenUri A URI pointing to the agent's initial metadata (e.g., visual representation, description, initial configurations).
     * @return The unique ID (tokenId) of the newly minted AI Agent NFT.
     */
    function mintAIAgent(uint256 _modelId, string calldata _tokenUri) external whenNotPaused returns (uint256) {
        require(aiModels[_modelId].registrationTime > 0, "AZAN: Model not registered");

        _tokenIdCounter.increment(); // Utilizes ERC721's internal token ID counter
        uint256 newAgentId = _tokenIdCounter.current();
        
        _safeMint(msg.sender, newAgentId);
        _setTokenURI(newAgentId, _tokenUri); // Sets the ERC721 token URI

        aiAgents[newAgentId] = AIAgent({
            modelId: _modelId,
            reputation: 0, // Agents start with zero reputation
            status: AIAgentStatus.Available, // Initially available for tasks
            metadataUri: _tokenUri // Stores the initial metadata URI
        });

        emit AIAgentMinted(newAgentId, msg.sender, _modelId);
        return newAgentId;
    }

    /**
     * @dev Allows the owner of an AI Agent NFT to update its public metadata URI.
     *      This can be used to reflect changes in the agent's capabilities, status, or visual representation.
     * @param _agentId The ID of the AI Agent NFT to update.
     * @param _newMetadataUri The new URI for the agent's public metadata.
     */
    function updateAIAgentMetadata(uint256 _agentId, string calldata _newMetadataUri) external onlyAIAgentOwner(_agentId) {
        aiAgents[_agentId].metadataUri = _newMetadataUri;
        _setTokenURI(_agentId, _newMetadataUri); // Also updates the ERC721 token URI for consistency

        emit AIAgentMetadataUpdated(_agentId, _newMetadataUri);
    }

    /**
     * @dev Allows an AI Agent owner to update which registered AI model their agent currently uses.
     *      This facilitates upgrading agents to newer model versions or switching their core capabilities.
     * @param _agentId The ID of the AI Agent NFT.
     * @param _newModelId The ID of the new registered AI model to associate with the agent.
     */
    function updateAgentModelVersion(uint256 _agentId, uint256 _newModelId) external onlyAIAgentOwner(_agentId) {
        require(aiModels[_newModelId].registrationTime > 0, "AZAN: New model not registered");
        uint256 oldModelId = aiAgents[_agentId].modelId;
        aiAgents[_agentId].modelId = _newModelId;

        emit AIAgentModelVersionUpdated(_agentId, oldModelId, _newModelId);
    }

    /**
     * @dev Transfers ownership of an AI Agent NFT. This function wraps the standard ERC721 transfer
     *      and adds AZAN-specific logic: the agent's status is automatically set to 'Unavailable'
     *      upon transfer, requiring the new owner to explicitly make it 'Available' again.
     * @param _from The current owner of the AI Agent NFT.
     * @param _to The new owner of the AI Agent NFT.
     * @param _agentId The ID of the AI Agent NFT to transfer.
     */
    function transferAIAgent(address _from, address _to, uint256 _agentId) public whenNotPaused {
        require(_isApprovedOrOwner(msg.sender, _agentId), "AZAN: Caller is not token owner or approved");
        require(aiAgents[_agentId].status != AIAgentStatus.Retired, "AZAN: Cannot transfer a retired agent");
        require(_from == ownerOf(_agentId), "AZAN: _from address does not own this agent");
        require(_to != address(0), "AZAN: Cannot transfer to the zero address");

        // Set agent to unavailable upon transfer; new owner must explicitly set to available
        aiAgents[_agentId].status = AIAgentStatus.Unavailable;
        emit AIAgentStatusChanged(_agentId, AIAgentStatus.Unavailable);
        
        _transfer(_from, _to, _agentId); // Calls the internal ERC721 transfer function
    }

    /**
     * @dev Sets an AI Agent's availability status. Only callable by the agent's owner.
     *      An agent must be 'Available' to bid on new tasks.
     * @param _agentId The ID of the AI Agent NFT.
     * @param _isAvailable True to set status to Available, False to set to Unavailable.
     */
    function setAgentServiceStatus(uint256 _agentId, bool _isAvailable) external onlyAIAgentOwner(_agentId) {
        require(aiAgents[_agentId].status != AIAgentStatus.Retired, "AZAN: Retired agents cannot change status");
        AIAgentStatus newStatus = _isAvailable ? AIAgentStatus.Available : AIAgentStatus.Unavailable;
        require(aiAgents[_agentId].status != newStatus, "AZAN: Agent already in this status");
        aiAgents[_agentId].status = newStatus;

        emit AIAgentStatusChanged(_agentId, newStatus);
    }


    // --- III. Task Lifecycle Management Functions ---

    /**
     * @dev Allows any user to propose a new task for AI Agents to perform.
     *      The proposer must provide a reward for the successful agent and a bond,
     *      both in the configured reward token. These are held by the contract.
     * @param _description A clear description of the task requirements.
     * @param _inputSchema ABI-encoded schema defining the expected input data format for the AI model.
     * @param _outputSchema ABI-encoded schema defining the expected output data format from the AI model.
     * @param _rewardAmount The amount of reward token to be paid to the successful AI Agent.
     * @param _taskBond The bond required from the proposer, in reward tokens. This is refunded upon successful task completion.
     * @param _deadline The absolute timestamp by which the task must be fully completed and ZK-verified.
     * @return The unique ID of the newly proposed task.
     */
    function proposeTask(
        string calldata _description,
        bytes calldata _inputSchema,
        bytes calldata _outputSchema,
        uint256 _rewardAmount,
        uint256 _taskBond,
        uint256 _deadline
    ) external whenNotPaused returns (uint256) {
        require(address(_rewardToken) != address(0), "AZAN: Reward token contract not set");
        require(_rewardAmount > 0, "AZAN: Reward must be greater than zero");
        require(_taskBond > 0, "AZAN: Task bond must be greater than zero");
        require(_deadline > block.timestamp, "AZAN: Deadline must be in the future");
        
        // Transfer reward and bond tokens from the proposer to this contract.
        // Requires the proposer to have previously approved this contract to spend these tokens.
        require(_rewardToken.transferFrom(msg.sender, address(this), _rewardAmount), "AZAN: Reward token transfer failed. Check approval and balance.");
        require(_rewardToken.transferFrom(msg.sender, address(this), _taskBond), "AZAN: Task bond transfer failed. Check approval and balance.");

        _taskIdCounter.increment();
        uint256 newTaskId = _taskIdCounter.current();

        tasks[newTaskId] = Task({
            description: _description,
            inputSchema: _inputSchema,
            outputSchema: _outputSchema,
            proposer: msg.sender,
            rewardAmount: _rewardAmount,
            taskBond: _taskBond,
            deadline: _deadline,
            assignedAgentId: 0, // No agent assigned initially
            resultHash: bytes32(0),
            completionTime: 0,
            status: TaskStatus.Bidding, // Task immediately enters bidding phase
            activeBids: new uint256[](0)
        });

        emit TaskProposed(newTaskId, msg.sender, _rewardAmount, _deadline);
        return newTaskId;
    }

    /**
     * @dev Allows an 'Available' AI Agent to place a bid on a proposed task.
     *      Agents commit to an estimated completion time for the task.
     * @param _taskId The ID of the task to bid on.
     * @param _agentId The ID of the AI Agent NFT placing the bid.
     * @param _estimatedCompletionTime The agent's estimated time (in seconds, relative to assignment) to complete the task.
     */
    function bidForTask(uint256 _taskId, uint256 _agentId, uint256 _estimatedCompletionTime) external onlyAIAgentOwner(_agentId) whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.Bidding, "AZAN: Task is not in bidding phase");
        require(task.deadline > block.timestamp, "AZAN: Task deadline passed, no new bids allowed");
        require(aiAgents[_agentId].status == AIAgentStatus.Available, "AZAN: Agent not available for tasks");
        require(aiAgents[_agentId].reputation >= 0, "AZAN: Agent reputation too low for bidding"); // Basic reputation check for eligibility

        // Ensure the agent has not already bid on this task
        require(task.bids[_agentId].bidTime == 0, "AZAN: Agent already bid on this task");

        task.bids[_agentId] = Bid({
            agentId: _agentId,
            estimatedCompletionTime: _estimatedCompletionTime,
            bidTime: block.timestamp
        });
        task.activeBids.push(_agentId); // Add agent to the list of active bidders

        emit TaskBid(_taskId, _agentId, _estimatedCompletionTime);
    }

    /**
     * @dev The task proposer selects an AI Agent from the placed bids and assigns the task to it.
     *      This moves the task from 'Bidding' to 'Assigned' status.
     * @param _taskId The ID of the task.
     * @param _agentId The ID of the AI Agent selected to perform the task.
     */
    function selectAgentForTask(uint256 _taskId, uint256 _agentId) external onlyTaskProposer(_taskId) whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.status == TaskStatus.Bidding, "AZAN: Task not in bidding phase");
        require(task.deadline > block.timestamp, "AZAN: Task deadline passed, cannot assign agent"); 
        require(task.bids[_agentId].bidTime > 0, "AZAN: Agent did not bid on this task");
        require(aiAgents[_agentId].status == AIAgentStatus.Available, "AZAN: Selected agent is not available");

        task.assignedAgentId = _agentId;
        task.status = TaskStatus.Assigned;

        emit TaskAgentSelected(_taskId, _agentId);
    }

    /**
     * @dev The assigned AI Agent submits the task result along with a ZK-SNARK proof.
     *      This is a core advanced function: the ZK proof verifies that the result was
     *      computed correctly by the agent's AI model from the given inputs, without
     *      revealing the inputs or the full model logic on-chain.
     * @param _taskId The ID of the task for which the result is being submitted.
     * @param _resultHash A cryptographic hash of the task's final output result. This hash must be one of the public inputs verified by the ZK proof.
     * @param _proof The serialized ZK-SNARK proof bytes.
     * @param _publicInputs The public inputs for the ZK circuit. These *must* include the `_resultHash`
     *                      and a commitment to the AI model used (e.g., hash of its IPFS hash)
     *                      to allow the `IZKVerifier` to confirm the correct model was used and produced this result.
     */
    function submitTaskResultWithZKProof(
        uint256 _taskId,
        bytes32 _resultHash,
        bytes calldata _proof,
        bytes calldata _publicInputs
    ) external whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.Assigned || task.status == TaskStatus.Rejected, "AZAN: Task not assigned or previously rejected for resubmission");
        require(task.assignedAgentId > 0, "AZAN: Task has no assigned agent");
        require(ownerOf(task.assignedAgentId) == msg.sender, "AZAN: Only the assigned agent's owner can submit result");
        require(block.timestamp <= task.deadline, "AZAN: Task submission deadline passed");
        require(address(_zkVerifier) != address(0), "AZAN: ZK Verifier contract not set");

        // Verify ZK-SNARK proof using the external verifier contract
        bool verified = _zkVerifier.verify(_proof, _publicInputs);
        require(verified, "AZAN: ZK proof verification failed");

        // The `_publicInputs` format is critical. It must encode commitments to:
        // 1. The `_resultHash` submitted.
        // 2. The IPFS hash of the AI model (`aiModels[aiAgents[task.assignedAgentId].modelId].modelIpfsHash`).
        // 3. A hash of the task's input parameters/schema (from `task.inputSchema`).
        // The `verify` function of `IZKVerifier` implicitly checks these based on its circuit definition.
        // E.g., a conceptual check: `require(_publicInputsMatchExpectedHashes(modelIpfsHash, inputHash, _resultHash, _publicInputs), "Public inputs mismatch");`

        task.resultHash = _resultHash;
        task.completionTime = block.timestamp;
        task.status = TaskStatus.ZKVerified; // Mark task as ZK-verified
        aiAgents[task.assignedAgentId].reputation += 100; // Reward reputation for successful verification

        emit TaskResultSubmitted(_taskId, task.assignedAgentId, _resultHash);
        emit TaskZKVerified(_taskId, task.assignedAgentId, _resultHash);
    }

    /**
     * @dev Allows the task proposer to reject a submitted result *before* it undergoes ZK verification.
     *      This is for initial quality control (e.g., wrong format, obvious non-compliance).
     *      The assigned agent receives a small reputation penalty, but can resubmit if within deadline.
     * @param _taskId The ID of the task.
     * @param _reason A string explaining the reason for rejection.
     */
    function rejectTaskResult(uint256 _taskId, string calldata _reason) external onlyTaskProposer(_taskId) whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.Assigned, "AZAN: Task not in 'Assigned' state (result must be submitted for rejection)");
        require(task.assignedAgentId > 0, "AZAN: Task has no assigned agent");
        
        // Penalize agent slightly for requiring rejection
        aiAgents[task.assignedAgentId].reputation -= 50;
        // Task remains in 'Assigned' status, allowing the agent to resubmit or the proposer to cancel/re-assign.
        task.status = TaskStatus.Rejected; // Mark as rejected, agent might need to re-submit
        
        emit TaskRejected(_taskId, msg.sender, _reason);
    }

    /**
     * @dev Allows the task proposer to cancel their task if no AI Agent has been assigned yet.
     *      The proposer's deposited bond and reward amount are fully refunded.
     * @param _taskId The ID of the task to cancel.
     */
    function cancelProposedTask(uint256 _taskId) external onlyTaskProposer(_taskId) whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.Bidding || task.status == TaskStatus.Proposed || task.status == TaskStatus.Rejected, "AZAN: Task cannot be canceled in its current state");
        require(task.assignedAgentId == 0, "AZAN: Task already assigned, cannot cancel directly"); // Or if rejected, agent needs to resubmit

        task.status = TaskStatus.Canceled;
        
        // Refund proposer's bond and reward amount (since no agent completed it)
        require(_rewardToken.transfer(msg.sender, task.taskBond), "AZAN: Bond refund failed");
        require(_rewardToken.transfer(msg.sender, task.rewardAmount), "AZAN: Reward refund failed");

        emit TaskCanceled(_taskId, msg.sender);
    }


    // --- IV. Reputation, Rewards & Penalties Functions ---

    /**
     * @dev Allows the owner of an AI Agent to claim the reward for a successfully ZK-verified task.
     *      Rewards can only be claimed after `TASK_REWARD_CLAIM_PERIOD` has passed since verification,
     *      allowing time for any potential disputes to be initiated and resolved.
     * @param _taskId The ID of the task for which to claim the reward.
     */
    function claimAIAgentReward(uint256 _taskId) external whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.ZKVerified, "AZAN: Task not ZK-verified for reward claim");
        require(ownerOf(task.assignedAgentId) == msg.sender, "AZAN: Not the owner of the assigned agent");
        require(block.timestamp >= task.completionTime + TASK_REWARD_CLAIM_PERIOD, "AZAN: Reward not yet claimable (dispute period active)");
        
        // Ensure no active dispute exists for this task
        for (uint256 i = 1; i <= _disputeIdCounter.current(); i++) {
            if (disputes[i].taskId == _taskId && (disputes[i].status == DisputeStatus.Pending || disputes[i].status == DisputeStatus.Voting)) {
                revert("AZAN: Cannot claim reward while an active dispute exists for this task");
            }
        }

        task.status = TaskStatus.Completed; // Mark task as fully completed
        require(_rewardToken.transfer(msg.sender, task.rewardAmount), "AZAN: Reward token transfer failed");

        emit AIAgentRewardClaimed(_taskId, task.assignedAgentId, task.rewardAmount);
    }

    /**
     * @dev Allows the task proposer to claim their deposited bond back after a task has been
     *      successfully completed (i.e., the agent has claimed its reward).
     * @param _taskId The ID of the task for which to claim the bond.
     */
    function claimTaskProposerBond(uint256 _taskId) external onlyTaskProposer(_taskId) whenNotPaused {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.Completed, "AZAN: Task not completed for bond claim (reward must be claimed first)");
        require(task.taskBond > 0, "AZAN: Bond already claimed or zero"); // Ensure bond exists and not double claimed

        uint256 bondToRefund = task.taskBond;
        task.taskBond = 0; // Set bond to zero to prevent multiple claims
        require(_rewardToken.transfer(msg.sender, bondToRefund), "AZAN: Bond token refund failed");

        emit TaskProposerBondClaimed(_taskId, msg.sender, bondToRefund);
    }

    /**
     * @dev DAO function to penalize an AI Agent by reducing its reputation score.
     *      This is typically called as an outcome of a dispute resolution or a direct DAO vote
     *      for gross misconduct. Callable only by the DAO (simulated by `owner()`).
     * @param _agentId The ID of the AI Agent to penalize.
     * @param _reputationLoss The positive amount of reputation points to deduct.
     */
    function penalizeAIAgent(uint256 _agentId, int256 _reputationLoss) public onlyDAO whenNotPaused {
        require(_exists(_agentId), "AZAN: Agent does not exist");
        require(_reputationLoss > 0, "AZAN: Reputation loss must be a positive value");
        
        aiAgents[_agentId].reputation -= _reputationLoss;
        emit AIAgentPenalized(_agentId, _reputationLoss);
    }

    /**
     * @dev DAO function to award a reputation bonus to an AI Agent.
     *      This could be for exceptional performance, contribution to the network,
     *      or as part of a specific governance decision. Callable only by the DAO.
     * @param _agentId The ID of the AI Agent to award a bonus to.
     * @param _reputationGain The positive amount of reputation points to add.
     */
    function awardBonusToAgent(uint256 _agentId, uint256 _reputationGain) external onlyDAO whenNotPaused {
        require(_exists(_agentId), "AZAN: Agent does not exist");
        require(_reputationGain > 0, "AZAN: Reputation gain must be a positive value");
        
        aiAgents[_agentId].reputation += int256(_reputationGain);
        emit AIAgentBonusAwarded(_agentId, _reputationGain);
    }


    // --- V. Dispute Resolution Functions ---

    /**
     * @dev Allows any user to initiate a dispute against a ZK-verified task result.
     *      This mechanism allows challenging the *semantic correctness* or *compliance*
     *      of a result, even if its computation was cryptographically proven correct by ZK-SNARKs.
     *      A bond, calculated as a percentage of the task's reward, is required from the disputer.
     * @param _taskId The ID of the task whose result is being disputed.
     * @param _reason A detailed string explaining the grounds for the dispute.
     * @return The unique ID of the newly initiated dispute.
     */
    function initiateResultDispute(uint256 _taskId, string calldata _reason) external whenNotPaused returns (uint256) {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        require(task.status == TaskStatus.ZKVerified, "AZAN: Only ZK-verified tasks can be disputed");
        require(block.timestamp < task.completionTime + TASK_REWARD_CLAIM_PERIOD, "AZAN: Dispute period has ended for this task");
        
        // Ensure no active dispute already exists for this task
        for (uint256 i = 1; i <= _disputeIdCounter.current(); i++) {
            if (disputes[i].taskId == _taskId && (disputes[i].status == DisputeStatus.Pending || disputes[i].status == DisputeStatus.Voting)) {
                revert("AZAN: An active dispute already exists for this task");
            }
        }

        uint256 disputeBond = (task.rewardAmount * DISPUTE_BOND_PERCENTAGE) / 100;
        require(disputeBond > 0, "AZAN: Dispute bond must be greater than zero");
        // Transfer the dispute bond from the initiator to this contract. Requires prior approval.
        require(_rewardToken.transferFrom(msg.sender, address(this), disputeBond), "AZAN: Dispute bond transfer failed. Check approval.");

        _disputeIdCounter.increment();
        uint256 newDisputeId = _disputeIdCounter.current();

        disputes[newDisputeId] = Dispute({
            taskId: _taskId,
            initiator: msg.sender,
            reason: _reason,
            bondAmount: disputeBond,
            status: DisputeStatus.Voting, // Dispute immediately enters voting phase
            voteStartTime: block.timestamp,
            votesForDisputer: 0,
            votesAgainstDisputer: 0,
            resolvedOutcome: false
        });

        task.status = TaskStatus.Disputed; // Mark the task as being disputed
        emit ResultDisputeInitiated(newDisputeId, _taskId, msg.sender);
        return newDisputeId;
    }

    /**
     * @dev Allows eligible AI Agent owners (based on reputation) to vote on an active dispute.
     *      Voting power is weighted by the agent's current reputation score.
     * @param _disputeId The ID of the dispute to vote on.
     * @param _supportDisputer True if the voter believes the disputer is correct (and the agent's result is flawed).
     *                         False if the voter believes the assigned agent's result is valid.
     */
    function voteOnDisputeOutcome(uint256 _disputeId, bool _supportDisputer) external whenNotPaused {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.taskId > 0, "AZAN: Dispute does not exist");
        require(dispute.status == DisputeStatus.Voting, "AZAN: Dispute not in active voting phase");
        require(block.timestamp < dispute.voteStartTime + PROPOSAL_VOTING_PERIOD, "AZAN: Voting period has ended for this dispute");
        
        // Find an eligible AI Agent owned by `msg.sender` for voting.
        uint256 voterAgentId = 0; 
        for(uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if(_exists(i) && ownerOf(i) == msg.sender && aiAgents[i].reputation >= MIN_REPUTATION_FOR_DAO_VOTE) {
                voterAgentId = i;
                break;
            }
        }
        require(voterAgentId > 0, "AZAN: Caller does not own an eligible AI Agent for voting");
        
        int256 reputation = aiAgents[voterAgentId].reputation;
        require(reputation > 0, "AZAN: Agent must have positive reputation to vote");

        // In a real DAO, mechanisms to prevent double-voting (e.g., a mapping `mapping(uint256 => mapping(address => bool)) hasVoted;`)
        // would be essential. For this example, it's omitted for conciseness.

        if (_supportDisputer) {
            dispute.votesForDisputer += uint256(reputation);
        } else {
            dispute.votesAgainstDisputer += uint256(reputation);
        }

        emit DisputeVoted(_disputeId, msg.sender, _supportDisputer);
    }

    /**
     * @dev Executes the outcome of a dispute once its voting period has concluded.
     *      Can be called by anyone after the voting period, and it applies the consequences.
     * @param _disputeId The ID of the dispute to resolve.
     */
    function resolveDispute(uint256 _disputeId) external whenNotPaused {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.taskId > 0, "AZAN: Dispute does not exist");
        require(dispute.status == DisputeStatus.Voting, "AZAN: Dispute not in active voting phase");
        require(block.timestamp >= dispute.voteStartTime + PROPOSAL_VOTING_PERIOD, "AZAN: Voting period has not ended yet");

        Task storage task = tasks[dispute.taskId];
        uint256 agentId = task.assignedAgentId;
        
        if (dispute.votesForDisputer > dispute.votesAgainstDisputer) {
            // Disputer wins: Agent is penalized, and the disputer's bond is refunded.
            dispute.resolvedOutcome = true;
            // Penalize the assigned agent significantly (e.g., halve their reputation)
            penalizeAIAgent(agentId, aiAgents[agentId].reputation / 2); 
            
            // Refund the disputer's bond
            require(_rewardToken.transfer(dispute.initiator, dispute.bondAmount), "AZAN: Disputer bond refund failed");
            
            // The task's reward amount (still held by the contract) is now forfeited by the agent.
            // This forfeited reward could be transferred to a DAO treasury or burned.
            // For simplicity, it remains in the contract's balance.
            task.status = TaskStatus.Rejected; // Mark the task result as invalid
        } else {
            // Agent wins (or tie): Agent's reputation is unaffected.
            // The disputer's bond is forfeited and remains in the contract (e.g., to DAO treasury).
            dispute.resolvedOutcome = false;
            
            // If the agent wins, the task status is reverted to ZKVerified,
            // allowing the agent owner to claim their reward once the claim period passes.
            task.status = TaskStatus.ZKVerified; 
        }

        dispute.status = DisputeStatus.Resolved;
        emit DisputeResolved(_disputeId, dispute.taskId, dispute.resolvedOutcome);
    }


    // --- VI. DAO Governance Functions ---

    /**
     * @dev Allows an eligible AI Agent owner to propose a system parameter change or a direct action.
     *      Proposals are encoded as a `_callData` (function signature + arguments) to be executed on a `_targetContract`.
     *      The `_targetContract` can be `address(this)` for modifying parameters within AZAN itself.
     * @param _description A clear description of the proposed governance action.
     * @param _callData The ABI-encoded function call to execute if the proposal passes.
     * @param _targetContract The address of the contract on which `_callData` should be executed.
     * @return The unique ID of the newly created governance proposal.
     */
    function proposeSystemParameterChange(
        string calldata _description,
        bytes calldata _callData,
        address _targetContract
    ) external whenNotPaused returns (uint256) {
        // Check if `msg.sender` owns an eligible AI Agent to make a proposal
        uint256 proposerAgentId = 0;
        for(uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if(_exists(i) && ownerOf(i) == msg.sender && aiAgents[i].reputation >= MIN_REPUTATION_FOR_DAO_VOTE) {
                proposerAgentId = i;
                break;
            }
        }
        require(proposerAgentId > 0, "AZAN: Caller does not own an eligible AI Agent to propose");
        require(_targetContract != address(0), "AZAN: Target contract cannot be zero address");
        require(_callData.length > 0, "AZAN: Call data cannot be empty");

        _proposalIdCounter.increment();
        uint256 newProposalId = _proposalIdCounter.current();

        proposals[newProposalId] = GovernanceProposal({
            description: _description,
            callData: _callData,
            targetContract: _targetContract,
            status: ProposalStatus.Active, // Proposal immediately enters active voting phase
            voteStartTime: block.timestamp,
            votesFor: 0,
            votesAgainst: 0,
            totalVotersReputation: 0
        });

        emit GovernanceProposalProposed(newProposalId, _description, msg.sender);
        return newProposalId;
    }

    /**
     * @dev Allows eligible AI Agent owners to vote on an active governance proposal.
     *      Voting power is weighted by the agent's current reputation.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _support True to vote in favor of the proposal, False to vote against it.
     */
    function voteOnGovernanceProposal(uint256 _proposalId, bool _support) external whenNotPaused {
        GovernanceProposal storage proposal = proposals[_proposalId];
        require(proposal.description.length > 0, "AZAN: Proposal does not exist");
        require(proposal.status == ProposalStatus.Active, "AZAN: Proposal not in active voting phase");
        require(block.timestamp < proposal.voteStartTime + PROPOSAL_VOTING_PERIOD, "AZAN: Voting period has ended for this proposal");

        // Find an eligible AI Agent owned by `msg.sender` for voting.
        uint256 voterAgentId = 0;
        for(uint256 i = 1; i <= _tokenIdCounter.current(); i++) {
            if(_exists(i) && ownerOf(i) == msg.sender && aiAgents[i].reputation >= MIN_REPUTATION_FOR_DAO_VOTE) {
                voterAgentId = i;
                break;
            }
        }
        require(voterAgentId > 0, "AZAN: Caller does not own an eligible AI Agent for voting");
        int256 reputation = aiAgents[voterAgentId].reputation;
        require(reputation > 0, "AZAN: Agent must have positive reputation to vote");

        // For a more robust DAO, implement a `hasVoted` mapping to prevent multiple votes per agent/address.

        if (_support) {
            proposal.votesFor += uint256(reputation);
        } else {
            proposal.votesAgainst += uint256(reputation);
        }
        proposal.totalVotersReputation += uint256(reputation);

        emit GovernanceProposalVoted(_proposalId, msg.sender, _support);
    }

    /**
     * @dev Executes a passed governance proposal once its voting period has ended.
     *      Callable by anyone, this function checks the voting outcome and, if successful,
     *      performs the proposed action using a low-level call.
     * @param _proposalId The ID of the proposal to execute.
     */
    function executeGovernanceProposal(uint256 _proposalId) external whenNotPaused {
        GovernanceProposal storage proposal = proposals[_proposalId];
        require(proposal.description.length > 0, "AZAN: Proposal does not exist");
        require(proposal.status == ProposalStatus.Active, "AZAN: Proposal not in active voting phase");
        require(block.timestamp >= proposal.voteStartTime + PROPOSAL_VOTING_PERIOD, "AZAN: Voting period has not ended yet");
        
        // Check if the proposal passed based on simple majority of reputation points
        if (proposal.votesFor > proposal.votesAgainst && proposal.totalVotersReputation > 0) {
            proposal.status = ProposalStatus.Succeeded;
            // Execute the proposed action using a low-level call to the target contract
            (bool success, ) = proposal.targetContract.call(proposal.callData);
            require(success, "AZAN: Proposal execution failed");
            proposal.status = ProposalStatus.Executed;
            emit GovernanceProposalExecuted(_proposalId);
        } else {
            proposal.status = ProposalStatus.Failed;
        }
    }


    // --- View Functions (for inspecting contract state, not counted in the 20+ functions requirement) ---

    /**
     * @dev Retrieves details of a registered AI model.
     * @param _modelId The ID of the AI model.
     * @return modelIpfsHash The IPFS hash of the model.
     * @return skillTags The array of skill tags.
     * @return registeredBy The address that registered the model.
     * @return registrationTime The timestamp of registration.
     */
    function getAIModel(uint256 _modelId) external view returns (bytes32 modelIpfsHash, string[] memory skillTags, address registeredBy, uint256 registrationTime) {
        AIModel storage model = aiModels[_modelId];
        require(model.registrationTime > 0, "AZAN: Model not registered");
        return (model.modelIpfsHash, model.skillTags, model.registeredBy, model.registrationTime);
    }

    /**
     * @dev Retrieves details of an AI Agent.
     * @param _agentId The ID of the AI Agent NFT.
     * @return modelId The ID of the AI model used by the agent.
     * @return currentOwner The current owner's address of the agent NFT.
     * @return reputation The agent's current reputation score.
     * @return status The agent's current service status.
     * @return metadataUri The URI for the agent's public metadata.
     */
    function getAIAgent(uint256 _agentId) external view returns (uint256 modelId, address currentOwner, int256 reputation, AIAgentStatus status, string memory metadataUri) {
        AIAgent storage agent = aiAgents[_agentId];
        require(_exists(_agentId), "AZAN: Agent does not exist");
        return (agent.modelId, ownerOf(_agentId), agent.reputation, agent.status, agent.metadataUri);
    }

    /**
     * @dev Retrieves details of a task.
     * @param _taskId The ID of the task.
     * @return description The task description.
     * @return proposer The address of the task proposer.
     * @return rewardAmount The reward amount for the task.
     * @return taskBond The task bond amount.
     * @return deadline The task deadline.
     * @return assignedAgentId The ID of the assigned agent (0 if none).
     * @return resultHash The hash of the verified result.
     * @return completionTime The timestamp of ZK verification.
     * @return status The current status of the task.
     * @return activeBids An array of agent IDs that have bid on this task.
     */
    function getTask(uint256 _taskId) external view returns (
        string memory description,
        address proposer,
        uint256 rewardAmount,
        uint256 taskBond,
        uint256 deadline,
        uint256 assignedAgentId,
        bytes32 resultHash,
        uint256 completionTime,
        TaskStatus status,
        uint256[] memory activeBids
    ) {
        Task storage task = tasks[_taskId];
        require(task.proposer != address(0), "AZAN: Task does not exist");
        return (
            task.description,
            task.proposer,
            task.rewardAmount,
            task.taskBond,
            task.deadline,
            task.assignedAgentId,
            task.resultHash,
            task.completionTime,
            task.status,
            task.activeBids
        );
    }

    /**
     * @dev Retrieves details of a dispute.
     * @param _disputeId The ID of the dispute.
     * @return taskId The ID of the task under dispute.
     * @return initiator The address that initiated the dispute.
     * @return reason The reason for the dispute.
     * @return bondAmount The bond amount provided by the initiator.
     * @return status The current status of the dispute.
     * @return voteStartTime The timestamp when voting started.
     * @return votesForDisputer Total reputation votes for the disputer.
     * @return votesAgainstDisputer Total reputation votes against the disputer.
     * @return resolvedOutcome The final outcome (true if disputer won, false otherwise).
     */
    function getDispute(uint256 _disputeId) external view returns (
        uint256 taskId,
        address initiator,
        string memory reason,
        uint256 bondAmount,
        DisputeStatus status,
        uint256 voteStartTime,
        uint256 votesForDisputer,
        uint256 votesAgainstDisputer,
        bool resolvedOutcome
    ) {
        Dispute storage dispute = disputes[_disputeId];
        require(dispute.taskId > 0, "AZAN: Dispute does not exist");
        return (
            dispute.taskId,
            dispute.initiator,
            dispute.reason,
            dispute.bondAmount,
            dispute.status,
            dispute.voteStartTime,
            dispute.votesForDisputer,
            dispute.votesAgainstDisputer,
            dispute.resolvedOutcome
        );
    }

    /**
     * @dev Retrieves details of a governance proposal.
     * @param _proposalId The ID of the proposal.
     * @return description The description of the proposal.
     * @return targetContract The target contract for the proposal's execution.
     * @return status The current status of the proposal.
     * @return voteStartTime The timestamp when voting started.
     * @return votesFor Total reputation votes in favor.
     * @return votesAgainst Total reputation votes against.
     * @return totalVotersReputation Sum of reputation of all agents who voted.
     */
    function getProposal(uint256 _proposalId) external view returns (
        string memory description,
        address targetContract,
        ProposalStatus status,
        uint256 voteStartTime,
        uint256 votesFor,
        uint256 votesAgainst,
        uint256 totalVotersReputation
    ) {
        GovernanceProposal storage proposal = proposals[_proposalId];
        require(proposal.description.length > 0, "AZAN: Proposal does not exist");
        return (
            proposal.description,
            proposal.targetContract,
            proposal.status,
            proposal.voteStartTime,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.totalVotersReputation
        );
    }
}
```