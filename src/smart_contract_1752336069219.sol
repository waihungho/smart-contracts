Okay, let's create a smart contract concept that is somewhat advanced, creative, and involves dynamic state changes not typically found in standard token or NFT contracts.

We'll design a contract simulating a decentralized network of "Synthetix Nodes" that process virtual resources. Nodes have dynamic states, decay over time, and require maintenance. Users own nodes and manage internal resource balances generated by these nodes. The network's global state (like resource scarcity) can influence node output.

This concept involves:
1.  **Stateful Non-Token Assets:** Nodes are not standard ERC721s but internal structs with complex state (health, efficiency, decay, resource buffers).
2.  **Internal Resource Economy:** Resources (Energy, Data, Compute) are managed *within* the contract for each user, not as ERC20 tokens (though withdrawal/deposit could be added later).
3.  **Time-Based Dynamics:** Node processing and decay depend on the time elapsed.
4.  **Interconnected Mechanics:** Node health affects output; resources are needed for maintenance and upgrades; global state affects local processing.
5.  **Discovery/Research:** Mechanics to unlock new node types or resource conversion methods.

It's *not* a direct copy of a standard DeFi protocol, NFT marketplace, or DAO template.

---

## Smart Contract: SynthetixNodeNetwork

**Outline:**

1.  **Contract Description:** A system for users to own and manage virtual "Synthetix Nodes" that generate and consume virtual resources within a simulated network.
2.  **Core Concepts:** Nodes (stateful assets), Resources (internal balances), Decay, Maintenance, Upgrades, Resource Conversion, Exploration, Global Epochs & Events.
3.  **Key State Variables:** Node data, user resource balances, resource type parameters, node type parameters, conversion recipes, upgrade recipes, global epoch info, admin addresses.
4.  **Permissions:** Owner (admin) for setting parameters, adding types; Users for interacting with their nodes and resources.
5.  **Error Handling:** Custom errors for clarity.
6.  **Events:** To signal key state changes.
7.  **Functions:** Detailed below.

**Function Summary:**

*   **Admin (Owner-only):**
    *   `addResourceType`: Define a new type of virtual resource.
    *   `updateResourceTypeParams`: Adjust global parameters for a resource (e.g., base generation rate, scarcity factor).
    *   `addNodeType`: Define a new blueprint for a node type with its base stats and resource interactions.
    *   `updateNodeTypeParams`: Adjust parameters for an existing node type.
    *   `addConversionRecipe`: Define how resources can be converted (input A + input B -> output C).
    *   `addUpgradeRecipe`: Define resource costs and stat improvements for upgrading a node type.
    *   `triggerGlobalEvent`: Simulate a network-wide event that temporarily alters parameters.
    *   `setEpochAdvanceInterval`: Set the time duration required between global epoch advancements.
    *   `withdrawAdminFees`: If fees were collected (not implemented in this basic version, but good practice).

*   **User Interaction (Node Management):**
    *   `acquireNode`: Mint or claim a new node instance based on contract rules (e.g., cost, limit).
    *   `processNode`: The core interaction. Calculates resource generation/consumption and node decay based on time since last processing.
    *   `upgradeNode`: Improve a node's stats using internal resources based on defined recipes.
    *   `performNodeMaintenance`: Spend internal resources to restore a node's health/reduce decay.
    *   `deactivateNode`: Temporarily pause a node's processing and decay.
    *   `activateNode`: Resume a paused node.
    *   `transferNodeOwnership`: Transfer ownership of a node to another address (custom internal transfer).

*   **User Interaction (Resource Management & Discovery):**
    *   `convertResources`: Use internal resources according to a defined recipe.
    *   `exploreForNodeBlueprint`: Spend resources to potentially discover a new node type blueprint (simplified probability).
    *   `researchConversionRecipe`: Spend resources to potentially discover a new resource conversion recipe (simplified probability).

*   **Network & Epoch Advancement:**
    *   `triggerEpochAdvance`: Allows anyone to advance the global epoch after a set interval, potentially changing global parameters.

*   **View Functions (Read-only):**
    *   `getEpochInfo`: Get the current epoch number and start time.
    *   `getUserNodes`: List all node IDs owned by a user.
    *   `getNodeState`: Get detailed state of a specific node.
    *   `getUserResourceBalance`: Get a user's balance for a specific resource type.
    *   `getGlobalResourceSupply`: Get the total aggregated supply of a resource across all user balances.
    *   `getResourceParams`: Get parameters for a specific resource type.
    *   `getNodeTypeParams`: Get parameters for a specific node type.
    *   `getConversionRecipe`: Get details of a specific conversion recipe.
    *   `getUpgradeRecipe`: Get details of a specific upgrade recipe.
    *   `getAcquisitionCost`: Get the current cost to acquire a new node.
    *   `calculatePendingResourceChanges`: Estimate the resource changes and decay for a node if processed *now*.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Useful for calculations
import "@openzeppelin/contracts/utils/ReentrancyGuard.h"; // Good practice

// --- Outline ---
// 1. Contract Description: A system for users to own and manage virtual "Synthetix Nodes" that generate and consume virtual resources within a simulated network.
// 2. Core Concepts: Nodes (stateful assets), Resources (internal balances), Decay, Maintenance, Upgrades, Resource Conversion, Exploration, Global Epochs & Events.
// 3. Key State Variables: Node data, user resource balances, resource type parameters, node type parameters, conversion recipes, upgrade recipes, global epoch info, admin addresses.
// 4. Permissions: Owner (admin) for setting parameters, adding types; Users for interacting with their nodes and resources.
// 5. Error Handling: Custom errors for clarity.
// 6. Events: To signal key state changes.
// 7. Functions: Detailed below.

// --- Function Summary ---
// Admin (Owner-only):
// - addResourceType: Define a new type of virtual resource.
// - updateResourceTypeParams: Adjust global parameters for a resource.
// - addNodeType: Define a new blueprint for a node type.
// - updateNodeTypeParams: Adjust parameters for an existing node type.
// - addConversionRecipe: Define how resources can be converted.
// - addUpgradeRecipe: Define resource costs and stat improvements for upgrading a node type.
// - triggerGlobalEvent: Simulate a network-wide event.
// - setEpochAdvanceInterval: Set interval for global epoch advancement.
// - withdrawAdminFees: (Placeholder for future fee mechanism).
// User Interaction (Node Management):
// - acquireNode: Mint or claim a new node instance.
// - processNode: Calculates resource generation/consumption and node decay.
// - upgradeNode: Improve a node's stats using internal resources.
// - performNodeMaintenance: Spend resources to restore node health.
// - deactivateNode: Temporarily pause a node.
// - activateNode: Resume a paused node.
// - transferNodeOwnership: Transfer ownership of a node.
// User Interaction (Resource Management & Discovery):
// - convertResources: Use internal resources according to a recipe.
// - exploreForNodeBlueprint: Spend resources for a chance to discover a new node type.
// - researchConversionRecipe: Spend resources for a chance to discover a new recipe.
// Network & Epoch Advancement:
// - triggerEpochAdvance: Advance the global epoch.
// View Functions (Read-only):
// - getEpochInfo: Get current epoch number and start time.
// - getUserNodes: List node IDs owned by a user.
// - getNodeState: Get detailed state of a node.
// - getUserResourceBalance: Get user's balance for a resource type.
// - getGlobalResourceSupply: Get total supply of a resource across all users.
// - getResourceParams: Get parameters for a resource type.
// - getNodeTypeParams: Get parameters for a node type.
// - getConversionRecipe: Get details of a recipe.
// - getUpgradeRecipe: Get details of an upgrade recipe.
// - getAcquisitionCost: Get cost to acquire a node.
// - calculatePendingResourceChanges: Estimate resource changes for processing a node.

contract SynthetixNodeNetwork is Ownable, ReentrancyGuard {
    using SafeMath for uint256; // Use SafeMath for calculations

    // --- Enums ---
    enum NodeState { Active, Deactivated, Decaying }

    // --- Structs ---

    struct ResourceType {
        uint256 id;
        string name;
        uint256 baseGenerationRate; // Per unit of time/processing
        uint256 scarcityFactor;     // Multiplier based on global supply (inverse relationship)
        // Add other resource-specific parameters as needed
    }

    struct ResourceAmount {
        uint256 resourceTypeId;
        uint256 amount;
    }

    struct NodeType {
        uint256 id;
        string name;
        uint256 baseEfficiency;       // Base output multiplier
        uint256 baseDecayRate;        // How fast health/efficiency decreases
        ResourceAmount[] productionRates; // Resources produced per processing cycle
        ResourceAmount[] consumptionRates; // Resources consumed per processing cycle
        uint256 baseAcquisitionCost; // Cost to acquire this node type
    }

    struct Node {
        uint256 id;
        uint256 nodeTypeId;
        address owner;
        NodeState state;
        uint256 lastProcessedTime;
        uint256 health;               // 1-100, affects efficiency & decay
        uint256 efficiencyMultiplier; // Current multiplier based on health, upgrades, etc.
        uint256 decayRateMultiplier;  // Current multiplier based on health, environment, etc.
        uint256 level;                // Upgrade level
        // Add other node-specific dynamic state
    }

    struct ConversionRecipe {
        uint256 id;
        ResourceAmount[] inputs;
        ResourceAmount[] outputs;
        uint256 researchCost; // Cost to potentially unlock this recipe via research
    }

    struct UpgradeRecipe {
        uint256 id;
        uint256 nodeTypeId;
        uint256 targetLevel;
        ResourceAmount[] costs;
        uint256 efficiencyBoost; // Percentage increase
        uint256 decayReduction;  // Percentage decrease
    }

    struct GlobalEpochInfo {
        uint256 epochNumber;
        uint256 startTime;
        uint256 epochDuration; // How long an epoch lasts
        // Add epoch-specific global multipliers or events
    }

    // --- State Variables ---

    uint256 private _nextNodeId = 1;
    uint256 private _nextResourceTypeId = 1;
    uint256 private _nextNodeTypeId = 1;
    uint256 private _nextConversionRecipeId = 1;
    uint256 private _nextUpgradeRecipeId = 1;

    mapping(uint256 => Node) public nodes;
    mapping(address => uint256[]) private _userNodeIds;
    mapping(address => mapping(uint256 => uint256)) private _userResourceBalances; // user => resourceTypeId => balance

    mapping(uint256 => ResourceType) public resourceTypes;
    mapping(uint256 => NodeType) public nodeTypes;
    mapping(uint256 => ConversionRecipe) public conversionRecipes;
    mapping(uint256 => UpgradeRecipe) public upgradeRecipes;

    // Tracks discovered/unlocked recipes/blueprints per user
    mapping(address => mapping(uint256 => bool)) private _unlockedConversionRecipes; // user => recipeId => unlocked
    mapping(address => mapping(uint256 => bool)) private _unlockedNodeBlueprints;    // user => nodeTypeId => unlocked

    GlobalEpochInfo public currentEpoch;
    uint256 public epochAdvanceInterval; // Minimum time between epoch advances

    uint256 public acquisitionBaseCost; // Base cost multiplier for acquiring nodes

    // --- Events ---

    event ResourceTypeAdded(uint256 indexed resourceTypeId, string name);
    event NodeTypeAdded(uint256 indexed nodeTypeId, string name);
    event ConversionRecipeAdded(uint256 indexed recipeId);
    event UpgradeRecipeAdded(uint256 indexed recipeId);

    event NodeAcquired(uint256 indexed nodeId, address indexed owner, uint256 indexed nodeTypeId);
    event NodeProcessed(uint256 indexed nodeId, address indexed owner, uint256 resourcesGenerated, uint256 resourcesConsumed);
    event NodeUpgraded(uint256 indexed nodeId, address indexed owner, uint256 newLevel);
    event NodeMaintenancePerformed(uint256 indexed nodeId, address indexed owner);
    event NodeStateChanged(uint256 indexed nodeId, NodeState newState);
    event NodeOwnershipTransferred(uint256 indexed nodeId, address indexed from, address indexed to);

    event ResourcesConverted(address indexed owner, uint256 indexed recipeId);
    event ResourceBalanceUpdated(address indexed owner, uint256 indexed resourceTypeId, uint256 newBalance);

    event NodeBlueprintDiscovered(address indexed owner, uint256 indexed nodeTypeId);
    event ConversionRecipeDiscovered(address indexed owner, uint256 indexed recipeId);

    event EpochAdvanced(uint256 indexed newEpochNumber, uint256 startTime);
    event GlobalEventTriggered(uint256 indexed eventId, string description);

    // --- Custom Errors ---

    error InvalidResourceType(uint256 resourceTypeId);
    error InvalidNodeType(uint256 nodeTypeId);
    error InvalidNode(uint256 nodeId);
    error InvalidConversionRecipe(uint256 recipeId);
    error InvalidUpgradeRecipe(uint256 recipeId);
    error NotNodeOwner(uint256 nodeId, address caller);
    error NodeNotActive(uint256 nodeId);
    error NodeNotDeactivated(uint256 nodeId);
    error InsufficientResources(uint256 resourceTypeId, uint256 required, uint256 available);
    error RecipeNotUnlocked(uint256 recipeId);
    error BlueprintNotUnlocked(uint256 nodeTypeId);
    error NodeAlreadyAtLevel(uint256 nodeId, uint256 level);
    error NoUpgradeAvailable(uint256 nodeId, uint256 targetLevel);
    error EpochAdvanceTooSoon(uint256 nextAdvanceTime);
    error DiscoveryFailed(); // For exploration/research functions


    // --- Constructor ---

    constructor(uint256 initialEpochDuration, uint256 _epochAdvanceInterval, uint256 _acquisitionBaseCost) Ownable(msg.sender) {
        currentEpoch = GlobalEpochInfo({
            epochNumber: 1,
            startTime: block.timestamp,
            epochDuration: initialEpochDuration
            // Initialize other epoch-specific fields if any
        });
        epochAdvanceInterval = _epochAdvanceInterval;
        acquisitionBaseCost = _acquisitionBaseCost;
    }

    // --- Admin Functions (Owner-only) ---

    function addResourceType(string memory _name, uint256 _baseGenerationRate, uint256 _scarcityFactor) external onlyOwner {
        uint256 newId = _nextResourceTypeId++;
        resourceTypes[newId] = ResourceType({
            id: newId,
            name: _name,
            baseGenerationRate: _baseGenerationRate,
            scarcityFactor: _scarcityFactor
            // Initialize other parameters
        });
        emit ResourceTypeAdded(newId, _name);
    }

    function updateResourceTypeParams(uint256 _resourceTypeId, uint256 _baseGenerationRate, uint256 _scarcityFactor) external onlyOwner {
        ResourceType storage rt = resourceTypes[_resourceTypeId];
        if (rt.id == 0) revert InvalidResourceType(_resourceTypeId);
        rt.baseGenerationRate = _baseGenerationRate;
        rt.scarcityFactor = _scarcityFactor;
        // Update other parameters
    }

    function addNodeType(string memory _name, uint256 _baseEfficiency, uint256 _baseDecayRate, ResourceAmount[] memory _productionRates, ResourceAmount[] memory _consumptionRates, uint256 _baseAcquisitionCost) external onlyOwner {
        uint256 newId = _nextNodeTypeId++;
        nodeTypes[newId] = NodeType({
            id: newId,
            name: _name,
            baseEfficiency: _baseEfficiency,
            baseDecayRate: _baseDecayRate,
            productionRates: _productionRates,
            consumptionRates: _consumptionRates,
            baseAcquisitionCost: _baseAcquisitionCost
        });
        emit NodeTypeAdded(newId, _name);
    }

     function updateNodeTypeParams(uint256 _nodeTypeId, uint256 _baseEfficiency, uint256 _baseDecayRate, ResourceAmount[] memory _productionRates, ResourceAmount[] memory _consumptionRates, uint256 _baseAcquisitionCost) external onlyOwner {
        NodeType storage nt = nodeTypes[_nodeTypeId];
        if (nt.id == 0) revert InvalidNodeType(_nodeTypeId);
        nt.baseEfficiency = _baseEfficiency;
        nt.baseDecayRate = _baseDecayRate;
        nt.productionRates = _productionRates; // Note: This overwrites existing rates
        nt.consumptionRates = _consumptionRates; // Note: This overwrites existing rates
        nt.baseAcquisitionCost = _baseAcquisitionCost;
    }


    function addConversionRecipe(ResourceAmount[] memory _inputs, ResourceAmount[] memory _outputs, uint256 _researchCost) external onlyOwner {
        uint256 newId = _nextConversionRecipeId++;
        conversionRecipes[newId] = ConversionRecipe({
            id: newId,
            inputs: _inputs,
            outputs: _outputs,
            researchCost: _researchCost
        });
        emit ConversionRecipeAdded(newId);
    }

    function addUpgradeRecipe(uint256 _nodeTypeId, uint256 _targetLevel, ResourceAmount[] memory _costs, uint256 _efficiencyBoost, uint256 _decayReduction) external onlyOwner {
         if (nodeTypes[_nodeTypeId].id == 0) revert InvalidNodeType(_nodeTypeId);
        uint256 newId = _nextUpgradeRecipeId++;
        upgradeRecipes[newId] = UpgradeRecipe({
            id: newId,
            nodeTypeId: _nodeTypeId,
            targetLevel: _targetLevel,
            costs: _costs,
            efficiencyBoost: _efficiencyBoost,
            decayReduction: _decayReduction
        });
        emit UpgradeRecipeAdded(newId);
    }

    function triggerGlobalEvent(uint256 eventId, string memory description) external onlyOwner {
        // Implement logic for global events (e.g., temporary multipliers, state changes)
        // This could involve updating state variables that affect node processing calculations
        emit GlobalEventTriggered(eventId, description);
    }

    function setEpochAdvanceInterval(uint256 _interval) external onlyOwner {
        epochAdvanceInterval = _interval;
    }

     function withdrawAdminFees(address _tokenAddress, uint256 _amount) external onlyOwner {
        // Placeholder for potential future fee withdrawal logic
        // e.g.,IERC20(_tokenAddress).transfer(owner(), _amount);
     }


    // --- User Interaction (Node Management) ---

    function acquireNode(uint256 _nodeTypeId) external nonReentrant {
        NodeType storage nt = nodeTypes[_nodeTypeId];
        if (nt.id == 0) revert InvalidNodeType(_nodeTypeId);

        // Check if blueprint is unlocked for user (if discovery is required)
        // if (!_unlockedNodeBlueprints[msg.sender][_nodeTypeId]) revert BlueprintNotUnlocked(_nodeTypeId); // Uncomment if discovery is mandatory

        // Implement cost logic (e.g., use internal resources, require external token payment)
        // For this example, let's assume a base cost multiplier and maybe resource cost
        uint256 cost = nt.baseAcquisitionCost.mul(acquisitionBaseCost).div(1000); // Example cost calculation
        // Deduct resources/tokens here if needed

        uint256 newNodeId = _nextNodeId++;
        nodes[newNodeId] = Node({
            id: newNodeId,
            nodeTypeId: _nodeTypeId,
            owner: msg.sender,
            state: NodeState.Active,
            lastProcessedTime: block.timestamp,
            health: 100, // Start with full health
            efficiencyMultiplier: nt.baseEfficiency, // Start with base efficiency
            decayRateMultiplier: nt.baseDecayRate,   // Start with base decay rate
            level: 1 // Start at level 1
            // Initialize other state variables
        });

        _userNodeIds[msg.sender].push(newNodeId);

        emit NodeAcquired(newNodeId, msg.sender, _nodeTypeId);
    }

    function processNode(uint256 _nodeId) external nonReentrant {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);
        if (node.state != NodeState.Active) revert NodeNotActive(_nodeId);

        // Calculate time elapsed
        uint256 timeElapsed = block.timestamp.sub(node.lastProcessedTime);
        node.lastProcessedTime = block.timestamp;

        // Apply decay based on time elapsed and decay rate
        _applyDecay(node, timeElapsed);

        // Calculate resources generated/consumed
        (uint256 totalGenerated, uint256 totalConsumed) = _calculateAndApplyResourceChanges(node, timeElapsed);

        // Node might become Decaying if health drops too low after processing
        if (node.health == 0) {
            node.state = NodeState.Decaying;
            emit NodeStateChanged(_nodeId, NodeState.Decaying);
        }

        emit NodeProcessed(_nodeId, msg.sender, totalGenerated, totalConsumed);
    }

    function upgradeNode(uint256 _nodeId, uint256 _targetLevel) external nonReentrant {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);
        if (node.level >= _targetLevel) revert NodeAlreadyAtLevel(_nodeId, node.level);

        UpgradeRecipe memory recipe;
        bool foundRecipe = false;
        // Find the correct upgrade recipe for this node type and target level
        for (uint256 i = 1; i < _nextUpgradeRecipeId; i++) { // Iterate through recipes
            UpgradeRecipe memory currentRecipe = upgradeRecipes[i];
            if (currentRecipe.id != 0 && currentRecipe.nodeTypeId == node.nodeTypeId && currentRecipe.targetLevel == _targetLevel) {
                recipe = currentRecipe;
                foundRecipe = true;
                break;
            }
        }

        if (!foundRecipe) revert NoUpgradeAvailable(_nodeId, _targetLevel);

        // Check and deduct costs
        _deductResources(msg.sender, recipe.costs);

        // Apply upgrades
        node.level = _targetLevel;
        node.efficiencyMultiplier = node.efficiencyMultiplier.add(recipe.efficiencyBoost); // Assuming boost is percentage points
        node.decayRateMultiplier = node.decayRateMultiplier.sub(recipe.decayReduction); // Assuming reduction is percentage points
         if (node.decayRateMultiplier > nodeTypes[node.nodeTypeId].baseDecayRate) { // Prevent decay rate from becoming negative or increasing past base
             node.decayRateMultiplier = nodeTypes[node.nodeTypeId].baseDecayRate; // Cap at base or handle specifically
         }


        emit NodeUpgraded(_nodeId, msg.sender, _targetLevel);
    }

    function performNodeMaintenance(uint256 _nodeId) external nonReentrant {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);
        if (node.state == NodeState.Deactivated) revert NodeNotActive(_nodeId); // Cannot maintain if deactivated

        // Define maintenance cost (could be fixed or scale with node type/level)
        ResourceAmount[] memory maintenanceCost = new ResourceAmount[](1);
        maintenanceCost[0] = ResourceAmount({resourceTypeId: 1, amount: 50}); // Example: 50 units of Resource Type 1 (Energy)

        // Check and deduct costs
        _deductResources(msg.sender, maintenanceCost);

        // Apply maintenance effect (e.g., restore health, reset decay timer)
        node.health = 100; // Restore health to full
        if (node.state == NodeState.Decaying) {
             node.state = NodeState.Active; // If it was decaying, activate it
             emit NodeStateChanged(_nodeId, NodeState.Active);
        }
        // Optionally, reset lastProcessedTime to prevent immediate reprocessing for gains
        // node.lastProcessedTime = block.timestamp; // Decide if maintenance resets time

        emit NodeMaintenancePerformed(_nodeId, msg.sender);
    }


    function deactivateNode(uint256 _nodeId) external {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);
        if (node.state == NodeState.Deactivated) revert NodeStateChanged(_nodeId, node.state); // Already deactivated

        // Process before deactivating to capture pending changes
        if (node.state == NodeState.Active) {
           processNode(_nodeId); // Use internal call or _processNode logic directly
        }
        // Note: If processing happens, lastProcessedTime is updated to block.timestamp
        // If node was Decaying, processing might not change resources but still updates time and applies final decay.

        node.state = NodeState.Deactivated;
        emit NodeStateChanged(_nodeId, NodeState.Deactivated);
    }

    function activateNode(uint256 _nodeId) external {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);
        if (node.state != NodeState.Deactivated) revert NodeNotDeactivated(_nodeId);

        node.state = NodeState.Active;
        // When reactivated, lastProcessedTime is already the time it was deactivated or last processed.
        // The next processNode call will calculate based on time since then.
        emit NodeStateChanged(_nodeId, NodeState.Active);
    }

    function transferNodeOwnership(uint256 _nodeId, address _to) external {
        Node storage node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender);

        address from = msg.sender;
        address to = _to;

        // Remove node from sender's list (inefficient for large lists, but simple example)
        uint256[] storage senderNodes = _userNodeIds[from];
        for (uint256 i = 0; i < senderNodes.length; i++) {
            if (senderNodes[i] == _nodeId) {
                senderNodes[i] = senderNodes[senderNodes.length - 1];
                senderNodes.pop();
                break;
            }
        }

        // Add node to receiver's list
        _userNodeIds[to].push(_nodeId);

        node.owner = to;
        emit NodeOwnershipTransferred(_nodeId, from, to);
    }


    // --- User Interaction (Resource Management & Discovery) ---

    function convertResources(uint256 _recipeId) external nonReentrant {
        ConversionRecipe memory recipe = conversionRecipes[_recipeId];
        if (recipe.id == 0) revert InvalidConversionRecipe(_recipeId);
        if (!_unlockedConversionRecipes[msg.sender][_recipeId]) revert RecipeNotUnlocked(_recipeId);

        // Check and deduct inputs
        _deductResources(msg.sender, recipe.inputs);

        // Add outputs
        _addResources(msg.sender, recipe.outputs);

        emit ResourcesConverted(msg.sender, _recipeId);
    }

    // Simplified discovery mechanic: burn resources for a *chance*
    // WARNING: On-chain randomness is hard. This uses block data which is manipulable.
    // A real dApp might use an oracle for randomness.
    function exploreForNodeBlueprint(uint256 _nodeTypeIdToDiscover) external nonReentrant {
         // Check if the blueprint is already unlocked
        if (_unlockedNodeBlueprints[msg.sender][_nodeTypeIdToDiscover]) {
             // Optionally refund cost or provide alternative reward
             return; // Already unlocked, success without cost? Or fail? Decide game logic.
        }

        // Define exploration cost (e.g., requires a specific resource)
        ResourceAmount[] memory explorationCost = new ResourceAmount[](1);
        explorationCost[0] = ResourceAmount({resourceTypeId: 2, amount: 100}); // Example: 100 units of Resource Type 2 (Data)

        // Check and deduct costs
        _deductResources(msg.sender, explorationCost);

        // Simplified probability check based on block hash
        uint256 randomness = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, block.number)));
        uint256 chance = 20; // 20% chance (adjust complexity based on game design)

        if (randomness % 100 < chance) {
            // Success! Unlock the blueprint
            _unlockedNodeBlueprints[msg.sender][_nodeTypeIdToDiscover] = true;
            emit NodeBlueprintDiscovered(msg.sender, _nodeTypeIdToDiscover);
        } else {
            // Failure
            revert DiscoveryFailed(); // Revert to signal failure and potentially refund costs depending on design
            // Or simply emit a Failure event and keep costs
        }
    }

     // Simplified research mechanic similar to exploration
    function researchConversionRecipe(uint256 _recipeIdToDiscover) external nonReentrant {
         // Check if the recipe is already unlocked
        if (_unlockedConversionRecipes[msg.sender][_recipeIdToDiscover]) {
             // Optionally refund cost or provide alternative reward
             return; // Already unlocked
        }

        ConversionRecipe memory recipeToFind = conversionRecipes[_recipeIdToDiscover];
        if (recipeToFind.id == 0) revert InvalidConversionRecipe(_recipeIdToDiscover);

        // Check and deduct research cost defined in the recipe
        ResourceAmount[] memory researchCost = new ResourceAmount[](1);
         // Assuming research cost is defined for the recipe itself or use a generic cost
        researchCost[0] = ResourceAmount({resourceTypeId: 3, amount: recipeToFind.researchCost}); // Example: Use Resource Type 3 (Compute)

        _deductResources(msg.sender, researchCost);

         // Simplified probability check
        uint256 randomness = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, block.number, _recipeIdToDiscover)));
        uint256 chance = 30; // 30% chance

        if (randomness % 100 < chance) {
            // Success! Unlock the recipe
            _unlockedConversionRecipes[msg.sender][_recipeIdToDiscover] = true;
            emit ConversionRecipeDiscovered(msg.sender, _recipeIdToDiscover);
        } else {
            // Failure
            revert DiscoveryFailed(); // Revert or handle failure differently
        }
    }


    // --- Network & Epoch Advancement ---

    function triggerEpochAdvance() external nonReentrant {
        if (block.timestamp < currentEpoch.startTime.add(epochAdvanceInterval)) {
            revert EpochAdvanceTooSoon(currentEpoch.startTime.add(epochAdvanceInterval));
        }

        currentEpoch.epochNumber = currentEpoch.epochNumber.add(1);
        currentEpoch.startTime = block.timestamp;
        // Implement logic to update global parameters based on the new epoch
        // This could involve reading from storage variables modified by triggerGlobalEvent,
        // or calculating new scarcity factors based on global resource supplies, etc.

        emit EpochAdvanced(currentEpoch.epochNumber, currentEpoch.startTime);
    }

    // --- View Functions (Read-only) ---

    function getEpochInfo() external view returns (uint256 epochNumber, uint256 startTime, uint256 epochDuration) {
        return (currentEpoch.epochNumber, currentEpoch.startTime, currentEpoch.epochDuration);
    }

    function getUserNodes(address _user) external view returns (uint256[] memory) {
        return _userNodeIds[_user];
    }

    function getNodeState(uint256 _nodeId) external view returns (Node memory) {
        return nodes[_nodeId];
    }

    function getUserResourceBalance(address _user, uint256 _resourceTypeId) external view returns (uint256) {
        return _userResourceBalances[_user][_resourceTypeId];
    }

    function getGlobalResourceSupply(uint256 _resourceTypeId) external view returns (uint256) {
        // To implement this efficiently, you would need a state variable that sums up
        // balances across all users whenever resources are added or removed.
        // For simplicity in this example, we'll return 0 or require iterating (which is gas intensive).
        // Proper implementation needs state variable updates in _addResources and _deductResources.
        // uint256 total = 0;
        // Iterate through all users and sum balances - Highly NOT recommended for production
        // return total;
         return 0; // Placeholder - requires tracking global supply in state variables
    }

    function getResourceParams(uint256 _resourceTypeId) external view returns (ResourceType memory) {
        ResourceType memory rt = resourceTypes[_resourceTypeId];
        if (rt.id == 0) revert InvalidResourceType(_resourceTypeId);
        return rt;
    }

    function getNodeTypeParams(uint256 _nodeTypeId) external view returns (NodeType memory) {
        NodeType memory nt = nodeTypes[_nodeTypeId];
        if (nt.id == 0) revert InvalidNodeType(_nodeTypeId);
        return nt;
    }

     function getConversionRecipe(uint256 _recipeId) external view returns (ConversionRecipe memory) {
        ConversionRecipe memory recipe = conversionRecipes[_recipeId];
        if (recipe.id == 0) revert InvalidConversionRecipe(_recipeId);
        return recipe;
    }

    function getUpgradeRecipe(uint256 _recipeId) external view returns (UpgradeRecipe memory) {
        UpgradeRecipe memory recipe = upgradeRecipes[_recipeId];
        if (recipe.id == 0) revert InvalidUpgradeRecipe(_recipeId);
        return recipe;
    }

    function getAcquisitionCost(uint256 _nodeTypeId) external view returns (uint256) {
        NodeType memory nt = nodeTypes[_nodeTypeId];
        if (nt.id == 0) revert InvalidNodeType(_nodeTypeId);
         return nt.baseAcquisitionCost.mul(acquisitionBaseCost).div(1000); // Match calculation in acquireNode
    }

    // Helper view function to estimate resource changes without state modification
    function calculatePendingResourceChanges(uint256 _nodeId) external view returns (ResourceAmount[] memory generated, ResourceAmount[] memory consumed, uint256 healthDecayAmount) {
         Node memory node = nodes[_nodeId];
        if (node.owner != msg.sender) revert NotNodeOwner(_nodeId, msg.sender); // Or allow anyone to check? Let's restrict for now.
        if (node.state == NodeState.Deactivated) {
            // No changes if deactivated
             return (new ResourceAmount[](0), new ResourceAmount[](0), 0);
        }

        uint256 timeElapsed = block.timestamp.sub(node.lastProcessedTime);
        NodeType memory nodeType = nodeTypes[node.nodeTypeId];

         // Calculate decay
        uint256 decayRate = nodeType.baseDecayRate.mul(node.decayRateMultiplier).div(100);
        healthDecayAmount = timeElapsed.mul(decayRate).div(3600); // Example: decay per hour
        if (healthDecayAmount > node.health) healthDecayAmount = node.health; // Can't decay more than current health

        // Calculate potential resource changes based on *current* state and elapsed time
        generated = new ResourceAmount[](nodeType.productionRates.length);
        consumed = new ResourceAmount[](nodeType.consumptionRates.length);

        // Apply base efficiency, health multiplier (simplified)
        uint256 effectiveEfficiency = nodeType.baseEfficiency.mul(node.efficiencyMultiplier).div(10000); // Assuming multipliers are percents * 100

        // Simplified health effect on efficiency (e.g., linear from 100% at 100 health to 0% at 0 health)
        uint256 healthEffect = node.health; // Use health directly as a 0-100 multiplier
        effectiveEfficiency = effectiveEfficiency.mul(healthEffect).div(100); // Reduce efficiency based on health

        // Apply epoch/global event multipliers (placeholder)
        // effectiveEfficiency = effectiveEfficiency.mul(currentEpoch.epochMultiplier).div(100); // Example

        // Apply scarcity factor (example: higher scarcity = higher production, lower consumption)
        // Requires access to global resource supply (see comment in getGlobalResourceSupply)
        // uint256 scarcityMultiplier = _calculateScarcityMultiplier(...);

        for (uint256 i = 0; i < nodeType.productionRates.length; i++) {
            uint256 resourceTypeId = nodeType.productionRates[i].resourceTypeId;
            // uint256 baseRate = resourceTypes[resourceTypeId].baseGenerationRate; // Example: use resource type base rate
            uint256 baseRate = nodeType.productionRates[i].amount; // Use node type defined rate

            uint256 amount = timeElapsed.mul(baseRate).mul(effectiveEfficiency).div(3600); // Example: amount per hour * efficiency
             // amount = amount.mul(scarcityMultiplier).div(10000); // Apply scarcity (requires implementation)

            generated[i] = ResourceAmount({resourceTypeId: resourceTypeId, amount: amount});
        }

         for (uint256 i = 0; i < nodeType.consumptionRates.length; i++) {
            uint256 resourceTypeId = nodeType.consumptionRates[i].resourceTypeId;
             uint256 baseRate = nodeType.consumptionRates[i].amount; // Use node type defined rate

            uint256 amount = timeElapsed.mul(baseRate).mul(effectiveEfficiency).div(3600); // Example: amount per hour * efficiency
            // amount = amount.mul(scarcityMultiplier).div(10000); // Apply scarcity (requires implementation)

            consumed[i] = ResourceAmount({resourceTypeId: resourceTypeId, amount: amount});
        }

        return (generated, consumed, healthDecayAmount);
    }


    // --- Internal Helper Functions ---

     // Applies decay to node health
    function _applyDecay(Node storage _node, uint256 _timeElapsed) internal {
        NodeType memory nodeType = nodeTypes[_node.nodeTypeId];

        uint256 effectiveDecayRate = nodeType.baseDecayRate.mul(_node.decayRateMultiplier).div(100); // Apply node-specific multiplier

        // Add global event/epoch influence on decay (placeholder)
        // effectiveDecayRate = effectiveDecayRate.mul(currentEpoch.decayFactor).div(100); // Example

        uint256 decayAmount = _timeElapsed.mul(effectiveDecayRate).div(3600); // Example: decay amount per hour
        _node.health = _node.health.sub(decayAmount > _node.health ? _node.health : decayAmount); // Ensure health doesn't go below zero
    }

    // Calculates and applies resource changes to user balance
    function _calculateAndApplyResourceChanges(Node storage _node, uint256 _timeElapsed) internal returns (uint256 totalGenerated, uint256 totalConsumed) {
        NodeType memory nodeType = nodeTypes[_node.nodeTypeId];
        address owner = _node.owner;

        // Apply base efficiency, health multiplier (simplified)
        uint256 effectiveEfficiency = nodeType.baseEfficiency.mul(_node.efficiencyMultiplier).div(10000); // Assuming multipliers are percents * 100

        // Simplified health effect on efficiency (e.g., linear from 100% at 100 health to 0% at 0 health)
        uint256 healthEffect = _node.health; // Use health directly as a 0-100 multiplier
        effectiveEfficiency = effectiveEfficiency.mul(healthEffect).div(100); // Reduce efficiency based on health

         // Apply epoch/global event multipliers (placeholder)
        // effectiveEfficiency = effectiveEfficiency.mul(currentEpoch.epochMultiplier).div(100); // Example

        // Apply scarcity factor (example: higher scarcity = higher production, lower consumption)
        // Requires access to global resource supply (see comment in getGlobalResourceSupply)
        // uint256 scarcityMultiplier = _calculateScarcityMultiplier(...); // Requires implementation

        totalGenerated = 0;
        for (uint256 i = 0; i < nodeType.productionRates.length; i++) {
            uint256 resourceTypeId = nodeType.productionRates[i].resourceTypeId;
            // uint256 baseRate = resourceTypes[resourceTypeId].baseGenerationRate; // Example: use resource type base rate
            uint256 baseRate = nodeType.productionRates[i].amount; // Use node type defined rate

            uint256 amount = _timeElapsed.mul(baseRate).mul(effectiveEfficiency).div(3600); // Example: amount per hour * efficiency
             // amount = amount.mul(scarcityMultiplier).div(10000); // Apply scarcity (requires implementation)

            _userResourceBalances[owner][resourceTypeId] = _userResourceBalances[owner][resourceTypeId].add(amount);
            totalGenerated = totalGenerated.add(amount); // Simple sum, might not be meaningful for mixed types
            emit ResourceBalanceUpdated(owner, resourceTypeId, _userResourceBalances[owner][resourceTypeId]);
        }

        totalConsumed = 0;
         for (uint256 i = 0; i < nodeType.consumptionRates.length; i++) {
            uint256 resourceTypeId = nodeType.consumptionRates[i].resourceTypeId;
             uint256 baseRate = nodeType.consumptionRates[i].amount; // Use node type defined rate

            uint256 amount = _timeElapsed.mul(baseRate).mul(effectiveEfficiency).div(3600); // Example: amount per hour * efficiency
            // amount = amount.mul(scarcityMultiplier).div(10000); // Apply scarcity (requires implementation)

            // Ensure user has enough resources to be consumed
            if (_userResourceBalances[owner][resourceTypeId] < amount) {
                // Handle insufficient resources for consumption
                // Option 1: Cap consumption at available amount and penalize node (e.g., health loss)
                 amount = _userResourceBalances[owner][resourceTypeId]; // Consume only what's available
                 _applyPenalty(_node); // Apply penalty
                 // Option 2: Revert the transaction (stricter)
                 // revert InsufficientResources(resourceTypeId, amount, _userResourceBalances[owner][resourceTypeId]);
            }
            _userResourceBalances[owner][resourceTypeId] = _userResourceBalances[owner][resourceTypeId].sub(amount);
            totalConsumed = totalConsumed.add(amount); // Simple sum, might not be meaningful for mixed types
            emit ResourceBalanceUpdated(owner, resourceTypeId, _userResourceBalances[owner][resourceTypeId]);
        }
        return (totalGenerated, totalConsumed);
    }

     // Helper to deduct multiple resources
    function _deductResources(address _user, ResourceAmount[] memory _costs) internal {
        for (uint256 i = 0; i < _costs.length; i++) {
            uint256 resourceTypeId = _costs[i].resourceTypeId;
            uint256 amount = _costs[i].amount;
            if (_userResourceBalances[_user][resourceTypeId] < amount) {
                revert InsufficientResources(resourceTypeId, amount, _userResourceBalances[_user][resourceTypeId]);
            }
        }
         for (uint256 i = 0; i < _costs.length; i++) {
            uint256 resourceTypeId = _costs[i].resourceTypeId;
            uint256 amount = _costs[i].amount;
            _userResourceBalances[_user][resourceTypeId] = _userResourceBalances[_user][resourceTypeId].sub(amount);
             emit ResourceBalanceUpdated(_user, resourceTypeId, _userResourceBalances[_user][resourceTypeId]);
        }
    }

     // Helper to add multiple resources
    function _addResources(address _user, ResourceAmount[] memory _gains) internal {
        for (uint256 i = 0; i < _gains.length; i++) {
            uint256 resourceTypeId = _gains[i].resourceTypeId;
            uint256 amount = _gains[i].amount;
             _userResourceBalances[_user][resourceTypeId] = _userResourceBalances[_user][resourceTypeId].add(amount);
             emit ResourceBalanceUpdated(_user, resourceTypeId, _userResourceBalances[_user][resourceTypeId]);
        }
    }

     // Example penalty function for insufficient resources or low health
    function _applyPenalty(Node storage _node) internal {
        // Example: Lose health if consumption fails
        _node.health = _node.health.sub(5 > _node.health ? _node.health : 5); // Lose 5 health
         if (_node.health == 0) {
            _node.state = NodeState.Decaying;
            emit NodeStateChanged(_node.id, NodeState.Decaying);
        }
        // Could also temporarily reduce efficiency, etc.
    }

     // Placeholder for calculating scarcity multiplier
    // This would require tracking global resource totals and potentially using an oracle
    // or complex on-chain logic to determine scarcity based on supply vs. demand.
    function _calculateScarcityMultiplier(uint256 _resourceTypeId) internal view returns (uint256) {
        // Example: Higher multiplier if global supply is low
        // uint256 globalSupply = getGlobalResourceSupply(_resourceTypeId); // Needs implementation
        // uint256 baseScarcity = resourceTypes[_resourceTypeId].scarcityFactor;
        // uint256 multiplier = baseScarcity.mul(1e18).div(globalSupply + 1e18); // Example inverse relationship
        // return multiplier;
         return 10000; // Return 100% (100 * 100) as a placeholder
    }
}
```

**Explanation of Advanced/Creative Concepts:**

1.  **Stateful Nodes (Non-ERC721):** Nodes are `struct` instances within the contract's storage, not external tokens. Their ownership is tracked internally. This allows for more complex, mutable state (`health`, `level`, `state`, `lastProcessedTime`, `efficiencyMultiplier`, `decayRateMultiplier`) directly tied to the node entity. Transferring involves updating internal mappings. This differs from standard ERC721s which are primarily identifiers pointing to external metadata, with contract state usually limited to ownership and approvals.
2.  **Internal Resource Economy:** Resources are `uint256` balances tracked per user *within* the contract (`_userResourceBalances`). All resource generation, consumption, and conversion happen internally. This avoids the overhead and complexity of creating separate ERC20 tokens for each resource type and keeps the core simulation logic self-contained. Users interact with these balances through the contract's functions.
3.  **Time-Based Continuous Simulation (`processNode`):** The core mechanic relies on `lastProcessedTime`. When `processNode` is called, the contract calculates resource changes and decay based on the *actual time elapsed* since the last interaction. This simulates continuous operation, rather than discrete, event-only updates. This requires careful handling of time and potential edge cases.
4.  **Dynamic Node Attributes & Interdependencies:** Node `health` isn't static; it decays (`_applyDecay`) and can be restored (`performNodeMaintenance`). `health` directly impacts `efficiencyMultiplier`, creating an interdependency where neglecting maintenance reduces output. Upgrades (`upgradeNode`) also dynamically modify node attributes.
5.  **Resource Conversion (`convertResources`):** Introduces a simple crafting/processing mechanic, allowing users to transform basic resources into more advanced ones based on recipes. This adds depth to the internal economy.
6.  **Discovery/Research (`exploreForNodeBlueprint`, `researchConversionRecipe`):** Adds an element of progression and chance. Users spend resources for a possibility of unlocking new capabilities (acquiring new node types or using new conversion recipes). This provides long-term goals and variability. *Note on Randomness:* The implementation uses a simplified, potentially manipulable form of on-chain "randomness" for concept demonstration. A production system would require a secure oracle.
7.  **Global Epochs & Events (`triggerEpochAdvance`, `triggerGlobalEvent`):** The network has a global state that advances in epochs. Epochs (potentially triggered by anyone after an interval) and admin-triggered global events can modify parameters (like resource scarcity factors, decay rates) that affect *all* nodes dynamically. This adds a layer of external influence on the simulation.
8.  **Decay and Maintenance:** The explicit mechanics of node decay (`health` reduction over time) and the requirement for maintenance (spending resources to restore health) create a resource sink and ongoing user engagement loops, preventing assets from being purely passive generators.
9.  **Complex Calculations:** Functions like `processNode` and `calculatePendingResourceChanges` involve fetching multiple parameters (node state, node type, resource type, global epoch), calculating time differences, applying multipliers (efficiency, health, decay, potentially scarcity/epoch), and handling resource additions/deductions. This is more complex than simple balance transfers or state flips.

This contract provides a framework for a persistent, dynamic simulation game or resource management dApp, moving beyond basic token standards by incorporating stateful assets and an internal economic simulation loop driven by time and user interaction.