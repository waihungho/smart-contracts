Okay, this is an exciting challenge! Let's design a smart contract called **ChronoForge**, focusing on time-dependent digital assets, a self-sustaining internal economy, and a simplified future-pact system. It aims to create dynamic NFTs that evolve and interact with a unique resource, powered by user engagement over time.

---

## ChronoForge Smart Contract

**Outline:**

ChronoForge is a sophisticated Solidity smart contract that introduces a new paradigm for digital assets, combining elements of NFTs, DeFi staking, time-locked mechanics, internal resource management, and a simplified oracle-driven future-pact system.

1.  **Chrono NFTs (Temporal Assets):** ERC-721 tokens (`Chrono`) that are "forged" by staking a base token for a specific duration. These NFTs possess dynamic attributes that unlock or evolve over time.
2.  **Temporal Essence (Internal Resource):** A non-transferable, accruable internal resource generated by active `Chrono` NFTs and staking activity. It's used to "upgrade" `Chrono` attributes or participate in certain contract functions.
3.  **Future Pacts:** A system where users can create "pacts" based on future verifiable events. These pacts require `Chrono` NFTs and potentially `Temporal Essence` to forge, and their outcome is determined by an `Oracle` (initially controlled by governance).
4.  **Entropy Pool:** A unique resource sink where users can voluntarily deposit/burn `Chrono` NFTs or `Temporal Essence` for long-term, small, and potentially time-gated rewards, adding a deflationary/re-distribution mechanism.
5.  **Governance:** Basic proposal and voting system for key contract parameters, enabling community evolution.
6.  **Pausability & Re-entrancy Guard:** Standard security features.

**Function Summary (22 Functions):**

**I. Core Chrono (Temporal NFT) Management:**
1.  `forgeChrono(uint256 _stakeAmount, uint256 _maturityDuration)`: Initiates the forging process by staking tokens for a specific period. Mints a pending `Chrono` NFT.
2.  `claimMaturedChrono(uint256 _chronoId)`: Allows the forger to claim their `Chrono` NFT after its maturity duration has passed.
3.  `burnChrono(uint256 _chronoId)`: Allows the `Chrono` owner to irrevocably burn their `Chrono` NFT.
4.  `getChronoDetails(uint256 _chronoId)`: Retrieves comprehensive details of a `Chrono` NFT.
5.  `getChronoOwner(uint256 _chronoId)`: Standard ERC-721 function to get the owner of a `Chrono`.
6.  `transferFrom(address _from, address _to, uint256 _tokenId)`: Standard ERC-721 token transfer.
7.  `approve(address _to, uint256 _tokenId)`: Standard ERC-721 approval.
8.  `setApprovalForAll(address _operator, bool _approved)`: Standard ERC-721 operator approval.
9.  `balanceOf(address _owner)`: Standard ERC-721 balance query.

**II. Temporal Essence & Chrono Evolution:**
10. `claimTemporalEssence()`: Allows users to claim accumulated `Temporal Essence` generated by their active `Chrono` NFTs and staked amounts.
11. `getAvailableEssence(address _user)`: Checks the `Temporal Essence` balance for a user.
12. `upgradeChronoWithEssence(uint256 _chronoId, uint256 _essenceCost)`: Consumes `Temporal Essence` to unlock or enhance an attribute on a specific `Chrono` NFT.
13. `getChronoAttributeStatus(uint256 _chronoId, string memory _attributeName)`: Checks the status or value of a specific attribute on a `Chrono`.

**III. Future Pacts & Oracle Integration:**
14. `forgeFuturePact(bytes32 _conditionHash, uint256 _oracleId, uint256 _pledgeAmount, uint256 _chronoId)`: Allows users to create a pact based on a future condition, pledging tokens and a `Chrono` NFT.
15. `fulfillFuturePact(uint256 _pactId, bool _outcome)`: (Oracle/Governance controlled) Fulfills a `FuturePact` by setting its outcome.
16. `claimPactOutcome(uint256 _pactId)`: Allows `FuturePact` creators to claim their rewards or get back their stake based on the fulfilled outcome.

**IV. Entropy Pool:**
17. `depositIntoEntropyPool(uint256 _chronoId)`: Allows burning a `Chrono` NFT into the Entropy Pool for a long-term benefit or lottery entry.
18. `depositEssenceIntoEntropyPool(uint256 _amount)`: Allows burning `Temporal Essence` into the Entropy Pool.

**V. Governance & Administration:**
19. `proposeParameterChange(address _target, bytes memory _calldata, string memory _description)`: Allows a user with sufficient `Chrono` power to propose changes to contract parameters.
20. `voteOnProposal(uint256 _proposalId, bool _support)`: Allows `Chrono` holders to vote on active proposals.
21. `executeProposal(uint256 _proposalId)`: Executes a successfully voted-on proposal.
22. `setChronoBaseURI(string memory _newBaseURI)`: Sets the base URI for Chrono NFT metadata (Owner/Governance).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol"; // For tokenURI

// Custom Errors
error ChronoForge__InvalidMaturityDuration();
error ChronoForge__StakeAmountTooLow();
error ChronoForge__ChronoNotMatured(uint256 maturityTime);
error ChronoForge__ChronoAlreadyClaimed();
error ChronoForge__NotChronoForger();
error ChronoForge__EssenceNotEnough();
error ChronoForge__AttributeAlreadyUnlocked();
error ChronoForge__PactAlreadyFulfilled();
error ChronoForge__PactNotFulfilled();
error ChronoForge__PactAlreadyDisputed();
error ChronoForge__NotPactCreator();
error ChronoForge__InvalidOutcome();
error ChronoForge__OracleNotSet();
error ChronoForge__UnauthorizedOracle();
error ChronoForge__ProposalAlreadyExecuted();
error ChronoForge__ProposalNotActive();
error ChronoForge__VoteTooLate();
error ChronoForge__AlreadyVoted();
error ChronoForge__ProposalFailed();
error ChronoForge__InsufficientVotingPower();
error ChronoForge__ChronoAlreadyInEntropyPool();
error ChronoForge__ChronoNotInEntropyPool();
error ChronoForge__NoEssenceToClaim();


/// @title ChronoForge
/// @dev A sophisticated smart contract for time-dependent NFTs (Chronos),
///      an internal Temporal Essence economy, Future Pacts, and an Entropy Pool.
contract ChronoForge is ERC721, Ownable, Pausable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using Strings for uint256;

    // --- State Variables ---

    // Chrono NFT configuration
    string private _chronoBaseURI;
    Counters.Counter private _nextChronoId;
    uint256 public MIN_STAKE_AMOUNT = 1 ether; // Minimum ETH stake to forge a Chrono
    uint256 public MIN_MATURITY_DURATION = 1 days; // Minimum time for a Chrono to mature
    uint256 public MAX_MATURITY_DURATION = 365 days; // Maximum time for a Chrono to mature
    uint256 public FORGE_FEE_PERCENT = 50; // 0.5% of stake, scaled by 10000

    // Temporal Essence configuration
    uint256 public ESSENCE_ACCRUAL_RATE_PER_DAY = 1000; // 1000 units of essence per day per ether staked
    uint256 public ESSENCE_UPGRADE_BASE_COST = 10000; // Base cost for upgrading Chrono attribute

    // Future Pacts configuration
    Counters.Counter private _nextPactId;
    address public temporalOracleAddress; // Address of the contract or account authorized to fulfill pacts

    // Governance configuration
    Counters.Counter private _nextProposalId;
    uint256 public GOVERNANCE_VOTING_PERIOD = 7 days; // How long proposals are active
    uint256 public PROPOSAL_THRESHOLD_CHRONOS = 1; // Number of Chronos needed to propose
    uint256 public QUORUM_PERCENT = 50; // 50% of total Chronos needed for quorum, scaled by 100

    // --- Structs ---

    /// @dev Represents a Chrono NFT
    struct Chrono {
        uint256 tokenId;
        address forger;
        uint256 forgingTime;
        uint256 maturityTime; // When the Chrono can be claimed and becomes fully active
        uint256 stakeAmount; // The amount of base tokens (ETH) staked to forge this Chrono
        bool claimed; // True if the Chrono NFT has been claimed by the forger
        mapping(bytes32 => uint256) attributes; // Dynamic attributes that can be unlocked/upgraded (key -> value)
        bool inEntropyPool; // True if Chrono has been deposited into Entropy Pool
    }

    /// @dev Represents a Future Pact
    struct FuturePact {
        uint256 pactId;
        address creator;
        bytes32 conditionHash; // A unique hash representing the pact's condition
        uint256 oracleId; // Identifier for the oracle data
        uint256 creationTime;
        uint256 pledgeAmount; // Amount of ETH pledged
        uint256 chronoId; // The Chrono NFT used for this pact
        bool isFulfilled;
        bool outcome; // True for success, False for failure
        bool isDisputed; // If the pact outcome is under dispute
        bool claimed; // If the pledge has been claimed
    }

    /// @dev Represents a Governance Proposal
    struct GovernanceProposal {
        uint256 proposalId;
        address proposer;
        address target; // The contract address to call
        bytes calldata; // The data for the function call
        string description;
        uint256 startTime;
        uint256 votesFor;
        uint256 votesAgainst;
        mapping(address => bool) hasVoted; // User voting status
        bool executed;
        bool active; // True if voting is open
    }

    // --- Mappings ---

    mapping(uint256 => Chrono) public idToChrono;
    mapping(address => uint256) public userTemporalEssenceBalances;
    mapping(uint256 => uint256) public chronoEssenceAccrualCheckpoint; // last time essence was claimed or chrono was active
    mapping(uint256 => FuturePact) public pacts;
    mapping(uint256 => GovernanceProposal) public proposals;
    mapping(uint256 => uint256) public chronoToEntropyPoolDepositTime; // When a Chrono was deposited

    // --- Events ---

    event ChronoForged(uint256 indexed chronoId, address indexed forger, uint256 stakeAmount, uint256 maturityTime);
    event ChronoClaimed(uint256 indexed chronoId, address indexed forger);
    event ChronoBurned(uint256 indexed chronoId, address indexed owner);
    event TemporalEssenceClaimed(address indexed user, uint256 amount);
    event ChronoUpgraded(uint256 indexed chronoId, bytes32 indexed attributeHash, uint256 essenceCost);
    event FuturePactForged(uint256 indexed pactId, address indexed creator, uint256 indexed chronoId, bytes32 conditionHash, uint256 pledgeAmount);
    event FuturePactFulfilled(uint256 indexed pactId, bool outcome);
    event FuturePactOutcomeClaimed(uint256 indexed pactId, address indexed claimant, uint256 amount);
    event FuturePactDisputed(uint256 indexed pactId, address indexed disputer);
    event DepositedIntoEntropyPool(uint256 indexed chronoId, address indexed depositor, uint256 depositTime);
    event EssenceDepositedIntoEntropyPool(address indexed depositor, uint256 amount);
    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string description);
    event Voted(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId, bool success);

    // --- Modifiers ---

    modifier onlyOracle() {
        if (msg.sender != temporalOracleAddress) {
            revert ChronoForge__UnauthorizedOracle();
        }
        _;
    }

    modifier onlyChronoOwner(uint256 _chronoId) {
        if (ownerOf(_chronoId) != msg.sender) {
            revert ERC721IncorrectOwner(msg.sender, _chronoId);
        }
        _;
    }

    // --- Constructor ---

    constructor(address _initialTemporalOracleAddress) ERC721("ChronoForge Chrono", "CHRONO") Ownable(msg.sender) {
        temporalOracleAddress = _initialTemporalOracleAddress;
        _chronoBaseURI = "ipfs://QmbQyF8Ym7H6jZ7L4k3b5X9wP2x1V0aC0dE2iG1h0qZ9r/"; // Placeholder
    }

    // --- External / Public Functions ---

    /// @dev Pauses contract operations. Only owner can call.
    function pause() public onlyOwner {
        _pause();
    }

    /// @dev Unpauses contract operations. Only owner can call.
    function unpause() public onlyOwner {
        _unpause();
    }

    // I. Core Chrono (Temporal NFT) Management

    /// @notice Forges a new Chrono NFT by staking ETH for a specified duration.
    /// @dev The staked ETH is locked until the Chrono is claimed after its maturity.
    /// @param _stakeAmount The amount of ETH to stake.
    /// @param _maturityDuration The duration (in seconds) until the Chrono matures.
    function forgeChrono(uint256 _stakeAmount, uint256 _maturityDuration)
        public
        payable
        nonReentrant
        whenNotPaused
    {
        if (_stakeAmount < MIN_STAKE_AMOUNT) {
            revert ChronoForge__StakeAmountTooLow();
        }
        if (_maturityDuration < MIN_MATURITY_DURATION || _maturityDuration > MAX_MATURITY_DURATION) {
            revert ChronoForge__InvalidMaturityDuration();
        }
        if (msg.value < _stakeAmount) {
            revert ChronoForge__StakeAmountTooLow(); // Using same error for insufficient ETH sent
        }

        uint256 chronoId = _nextChronoId.current();
        _nextChronoId.increment();

        uint256 forgingTime = block.timestamp;
        uint256 maturityTime = forgingTime + _maturityDuration;

        // Apply forge fee to the staked amount
        uint256 forgeFee = (_stakeAmount * FORGE_FEE_PERCENT) / 10000;
        uint256 netStake = _stakeAmount - forgeFee;

        // Transfer fee to owner/treasury (or burn, depending on design)
        (bool success, ) = payable(owner()).call{value: forgeFee}("");
        require(success, "Failed to transfer forge fee");

        idToChrono[chronoId] = Chrono({
            tokenId: chronoId,
            forger: msg.sender,
            forgingTime: forgingTime,
            maturityTime: maturityTime,
            stakeAmount: netStake, // Store net stake after fee
            claimed: false,
            inEntropyPool: false
        });

        // Initialize essence accrual checkpoint for future claiming
        chronoEssenceAccrualCheckpoint[chronoId] = forgingTime;

        emit ChronoForged(chronoId, msg.sender, _stakeAmount, maturityTime);
    }

    /// @notice Allows the original forger to claim their matured Chrono NFT and the staked ETH.
    /// @param _chronoId The ID of the Chrono to claim.
    function claimMaturedChrono(uint256 _chronoId) public nonReentrant whenNotPaused {
        Chrono storage chrono = idToChrono[_chronoId];

        if (chrono.forger == address(0)) {
            revert ERC721NonexistentToken(_chronoId);
        }
        if (msg.sender != chrono.forger) {
            revert ChronoForge__NotChronoForger();
        }
        if (chrono.claimed) {
            revert ChronoForge__ChronoAlreadyClaimed();
        }
        if (block.timestamp < chrono.maturityTime) {
            revert ChronoForge__ChronoNotMatured(chrono.maturityTime);
        }

        chrono.claimed = true;
        _safeMint(chrono.forger, _chronoId);

        // Transfer back the original stake amount (net of fee)
        (bool success, ) = payable(chrono.forger).call{value: chrono.stakeAmount}("");
        require(success, "Failed to send back stake");

        emit ChronoClaimed(_chronoId, chrono.forger);
    }

    /// @notice Allows the Chrono owner to burn their Chrono NFT.
    /// @dev Burning can be used for participation in Entropy Pool or simply to destroy.
    /// @param _chronoId The ID of the Chrono to burn.
    function burnChrono(uint256 _chronoId) public onlyChronoOwner(_chronoId) whenNotPaused {
        Chrono storage chrono = idToChrono[_chronoId];
        if (chrono.inEntropyPool) {
            revert ChronoForge__ChronoAlreadyInEntropyPool();
        }
        _burn(_chronoId);
        // Optionally, remove from idToChrono mapping if desired, but for struct properties,
        // it's often fine to leave it, just mark as burned/inactive.
        // For simplicity in this example, we just use the ERC721 _burn.
        emit ChronoBurned(_chronoId, msg.sender);
    }

    /// @notice Retrieves detailed information about a Chrono NFT.
    /// @param _chronoId The ID of the Chrono.
    /// @return The Chrono struct details.
    function getChronoDetails(uint256 _chronoId)
        public
        view
        returns (
            uint256 tokenId,
            address forger,
            uint256 forgingTime,
            uint256 maturityTime,
            uint256 stakeAmount,
            bool claimed,
            bool inEntropyPool
        )
    {
        Chrono storage chrono = idToChrono[_chronoId];
        if (chrono.forger == address(0) && !_exists(_chronoId)) {
            revert ERC721NonexistentToken(_chronoId);
        }
        return (
            chrono.tokenId,
            chrono.forger,
            chrono.forgingTime,
            chrono.maturityTime,
            chrono.stakeAmount,
            chrono.claimed,
            chrono.inEntropyPool
        );
    }

    /// @inheritdoc IERC721
    function getChronoOwner(uint256 _chronoId) public view returns (address) {
        return ownerOf(_chronoId);
    }

    /// @inheritdoc IERC721
    function transferFrom(address _from, address _to, uint256 _tokenId) public override whenNotPaused {
        super.transferFrom(_from, _to, _tokenId);
    }

    /// @inheritdoc IERC721
    function approve(address _to, uint256 _tokenId) public override whenNotPaused {
        super.approve(_to, _tokenId);
    }

    /// @inheritdoc IERC721
    function setApprovalForAll(address _operator, bool _approved) public override whenNotPaused {
        super.setApprovalForAll(_operator, _approved);
    }

    /// @inheritdoc IERC721
    function balanceOf(address _owner) public view override returns (uint256) {
        return super.balanceOf(_owner);
    }

    // II. Temporal Essence & Chrono Evolution

    /// @notice Allows users to claim accumulated Temporal Essence.
    /// @dev Essence accrues from their active (claimed) Chronos and potential long-term stakes.
    function claimTemporalEssence() public nonReentrant whenNotPaused {
        uint256 totalEssenceToClaim = 0;
        uint256 _balanceOf = balanceOf(msg.sender);

        // Accrue from claimed Chronos
        for (uint256 i = 0; i < _balanceOf; i++) {
            // This loop implies iterating owned tokens; in a real contract,
            // you'd need a more efficient way or require specific _chronoId.
            // For this example, let's assume direct lookup for owned Chronos.
            // This iteration is a simplification and not gas efficient for many NFTs.
            // A better way would be for the user to pass owned chronoIds.
            uint256 chronoId = _tokenOfOwnerByIndex(msg.sender, i);
            Chrono storage chrono = idToChrono[chronoId];

            if (chrono.claimed && !chrono.inEntropyPool) {
                uint256 lastCheckpoint = chronoEssenceAccrualCheckpoint[chronoId];
                if (block.timestamp > lastCheckpoint) {
                    uint256 daysActive = (block.timestamp - lastCheckpoint) / 1 days;
                    totalEssenceToClaim += (chrono.stakeAmount * ESSENCE_ACCRUAL_RATE_PER_DAY * daysActive) / 1 ether; // scaled by 1 ether
                    chronoEssenceAccrualCheckpoint[chronoId] = block.timestamp; // Update checkpoint
                }
            }
        }

        if (totalEssenceToClaim == 0) {
            revert ChronoForge__NoEssenceToClaim();
        }

        userTemporalEssenceBalances[msg.sender] += totalEssenceToClaim;
        emit TemporalEssenceClaimed(msg.sender, totalEssenceToClaim);
    }

    /// @notice Returns the available Temporal Essence balance for a user.
    /// @param _user The address of the user.
    /// @return The Temporal Essence balance.
    function getAvailableEssence(address _user) public view returns (uint256) {
        return userTemporalEssenceBalances[_user];
    }

    /// @notice Consumes Temporal Essence to unlock or enhance an attribute on a specific Chrono NFT.
    /// @dev Attributes are key-value pairs stored directly in the Chrono struct.
    /// @param _chronoId The ID of the Chrono to upgrade.
    /// @param _essenceCost The amount of Temporal Essence to spend.
    function upgradeChronoWithEssence(uint256 _chronoId, uint256 _essenceCost)
        public
        onlyChronoOwner(_chronoId)
        whenNotPaused
    {
        Chrono storage chrono = idToChrono[_chronoId];

        // Ensure Chrono is claimed and not in entropy pool
        if (!chrono.claimed || chrono.inEntropyPool) {
            revert ERC721NonexistentToken(_chronoId); // Using non-existent as general error for unusable Chrono
        }

        if (userTemporalEssenceBalances[msg.sender] < _essenceCost) {
            revert ChronoForge__EssenceNotEnough();
        }

        userTemporalEssenceBalances[msg.sender] -= _essenceCost;

        // Example: Unlock a "Power" attribute based on essence spent
        bytes32 attributeKey = keccak256(abi.encodePacked("Power"));
        chrono.attributes[attributeKey] += _essenceCost; // Add to existing power or initialize

        emit ChronoUpgraded(_chronoId, attributeKey, _essenceCost);
    }

    /// @notice Checks the status or value of a specific attribute on a Chrono.
    /// @param _chronoId The ID of the Chrono.
    /// @param _attributeName The name of the attribute (e.g., "Power", "Resilience").
    /// @return The value of the attribute.
    function getChronoAttributeStatus(uint256 _chronoId, string memory _attributeName)
        public
        view
        returns (uint256)
    {
        Chrono storage chrono = idToChrono[_chronoId];
        if (chrono.forger == address(0)) {
            revert ERC721NonexistentToken(_chronoId);
        }
        bytes32 attributeKey = keccak256(abi.encodePacked(_attributeName));
        return chrono.attributes[attributeKey];
    }

    // III. Future Pacts & Oracle Integration

    /// @notice Allows users to create a Future Pact based on a future condition.
    /// @dev Pledges ETH and a Chrono NFT. The Chrono remains locked with the pact until fulfillment.
    /// @param _conditionHash A unique hash identifying the specific event/condition.
    /// @param _oracleId An identifier for the oracle that will fulfill this pact.
    /// @param _pledgeAmount The amount of ETH to pledge.
    /// @param _chronoId The Chrono NFT to associate with this pact.
    function forgeFuturePact(bytes32 _conditionHash, uint256 _oracleId, uint256 _pledgeAmount, uint256 _chronoId)
        public
        payable
        nonReentrant
        onlyChronoOwner(_chronoId)
        whenNotPaused
    {
        if (msg.value < _pledgeAmount) {
            revert ChronoForge__StakeAmountTooLow(); // Reuse error
        }

        // Ensure Chrono is claimed and not in entropy pool
        Chrono storage chrono = idToChrono[_chronoId];
        if (!chrono.claimed || chrono.inEntropyPool) {
            revert ERC721NonexistentToken(_chronoId); // Using non-existent as general error for unusable Chrono
        }

        uint256 pactId = _nextPactId.current();
        _nextPactId.increment();

        pacts[pactId] = FuturePact({
            pactId: pactId,
            creator: msg.sender,
            conditionHash: _conditionHash,
            oracleId: _oracleId,
            creationTime: block.timestamp,
            pledgeAmount: _pledgeAmount,
            chronoId: _chronoId,
            isFulfilled: false,
            outcome: false, // Default to false
            isDisputed: false,
            claimed: false
        });

        // Transfer Chrono to contract (this requires approval first)
        _transfer(msg.sender, address(this), _chronoId);

        emit FuturePactForged(pactId, msg.sender, _chronoId, _conditionHash, _pledgeAmount);
    }

    /// @notice Allows the designated oracle (or governance) to fulfill a Future Pact.
    /// @param _pactId The ID of the pact to fulfill.
    /// @param _outcome The true outcome of the pact (true for success, false for failure).
    function fulfillFuturePact(uint256 _pactId, bool _outcome) public onlyOracle whenNotPaused {
        FuturePact storage pact = pacts[_pactId];

        if (pact.creator == address(0)) {
            revert ERC721NonexistentToken(_pactId); // Reuse error for non-existent pact
        }
        if (pact.isFulfilled) {
            revert ChronoForge__PactAlreadyFulfilled();
        }
        if (pact.isDisputed) {
            revert ChronoForge__PactAlreadyDisputed();
        }

        pact.isFulfilled = true;
        pact.outcome = _outcome;

        emit FuturePactFulfilled(_pactId, _outcome);
    }

    /// @notice Allows the Future Pact creator to claim their outcome based on the fulfillment.
    /// @param _pactId The ID of the pact to claim.
    function claimPactOutcome(uint256 _pactId) public nonReentrant whenNotPaused {
        FuturePact storage pact = pacts[_pactId];

        if (pact.creator == address(0)) {
            revert ERC721NonexistentToken(_pactId); // Reuse error
        }
        if (msg.sender != pact.creator) {
            revert ChronoForge__NotPactCreator();
        }
        if (!pact.isFulfilled) {
            revert ChronoForge__PactNotFulfilled();
        }
        if (pact.isDisputed) {
            revert ChronoForge__PactAlreadyDisputed();
        }
        if (pact.claimed) {
            revert ChronoForge__ChronoAlreadyClaimed(); // Reuse error
        }

        pact.claimed = true;
        uint256 amountToTransfer = 0;

        // Example: If outcome is true, creator gets back 2x pledge (simple win condition)
        // If false, they lose the pledge.
        if (pact.outcome) {
            amountToTransfer = pact.pledgeAmount * 2; // Simple success reward
        } else {
            amountToTransfer = 0; // Lost pledge
        }

        // Return Chrono NFT to creator
        _transfer(address(this), pact.creator, pact.chronoId);

        // Transfer funds
        if (amountToTransfer > 0) {
            (bool success, ) = payable(pact.creator).call{value: amountToTransfer}("");
            require(success, "Failed to send pact reward");
        }

        emit FuturePactOutcomeClaimed(_pactId, msg.sender, amountToTransfer);
    }

    // IV. Entropy Pool

    /// @notice Allows burning a Chrono NFT by depositing it into the Entropy Pool.
    /// @dev Chronos in the Entropy Pool accrue special long-term benefits or participate in lotteries.
    /// @param _chronoId The ID of the Chrono to deposit.
    function depositIntoEntropyPool(uint256 _chronoId) public onlyChronoOwner(_chronoId) whenNotPaused {
        Chrono storage chrono = idToChrono[_chronoId];
        if (!chrono.claimed) {
            revert ERC721NonexistentToken(_chronoId); // Not a usable Chrono
        }
        if (chrono.inEntropyPool) {
            revert ChronoForge__ChronoAlreadyInEntropyPool();
        }

        // Transfer Chrono to contract (burning it from circulation in terms of direct ownership)
        _transfer(msg.sender, address(this), _chronoId);
        chrono.inEntropyPool = true;
        chronoToEntropyPoolDepositTime[_chronoId] = block.timestamp;

        // Note: _burn(_chronoId) could be used here directly to destroy the token,
        // but keeping it with the contract allows for future "redemption" concepts
        // or a visible pool of burned tokens, depending on desired mechanics.
        // For this example, it's transferred to contract address, making it "burned" for the user.

        emit DepositedIntoEntropyPool(_chronoId, msg.sender, block.timestamp);
    }

    /// @notice Allows burning Temporal Essence by depositing it into the Entropy Pool.
    /// @dev This reduces the total circulating Essence and can be linked to other rewards.
    /// @param _amount The amount of Temporal Essence to deposit.
    function depositEssenceIntoEntropyPool(uint256 _amount) public whenNotPaused {
        if (userTemporalEssenceBalances[msg.sender] < _amount) {
            revert ChronoForge__EssenceNotEnough();
        }
        userTemporalEssenceBalances[msg.sender] -= _amount;
        // The essence is effectively burned here, reducing the supply.
        // Could increment an entropy pool balance or a lottery counter.
        emit EssenceDepositedIntoEntropyPool(msg.sender, _amount);
    }

    // V. Governance & Administration

    /// @notice Allows a user to propose a change to contract parameters.
    /// @dev Requires a minimum number of Chronos owned to propose.
    /// @param _target The address of the contract to call (e.g., this contract).
    /// @param _calldata The encoded function call including function signature and arguments.
    /// @param _description A human-readable description of the proposal.
    function proposeParameterChange(address _target, bytes memory _calldata, string memory _description)
        public
        whenNotPaused
    {
        if (balanceOf(msg.sender) < PROPOSAL_THRESHOLD_CHRONOS) {
            revert ChronoForge__InsufficientVotingPower();
        }

        uint256 proposalId = _nextProposalId.current();
        _nextProposalId.increment();

        proposals[proposalId] = GovernanceProposal({
            proposalId: proposalId,
            proposer: msg.sender,
            target: _target,
            calldata: _calldata,
            description: _description,
            startTime: block.timestamp,
            votesFor: 0,
            votesAgainst: 0,
            executed: false,
            active: true
        });

        emit ProposalCreated(proposalId, msg.sender, _description);
    }

    /// @notice Allows Chrono holders to vote on an active proposal.
    /// @param _proposalId The ID of the proposal to vote on.
    /// @param _support True for 'for', false for 'against'.
    function voteOnProposal(uint256 _proposalId, bool _support) public whenNotPaused {
        GovernanceProposal storage proposal = proposals[_proposalId];

        if (!proposal.active) {
            revert ChronoForge__ProposalNotActive();
        }
        if (block.timestamp > proposal.startTime + GOVERNANCE_VOTING_PERIOD) {
            revert ChronoForge__VoteTooLate();
        }
        if (proposal.hasVoted[msg.sender]) {
            revert ChronoForge__AlreadyVoted();
        }
        uint256 voterChronoBalance = balanceOf(msg.sender);
        if (voterChronoBalance == 0) {
            revert ChronoForge__InsufficientVotingPower();
        }

        proposal.hasVoted[msg.sender] = true;
        if (_support) {
            proposal.votesFor += voterChronoBalance;
        } else {
            proposal.votesAgainst += voterChronoBalance;
        }

        emit Voted(_proposalId, msg.sender, _support);
    }

    /// @notice Executes a successfully voted-on proposal.
    /// @dev Can only be called after voting period ends and if quorum/majority reached.
    /// @param _proposalId The ID of the proposal to execute.
    function executeProposal(uint256 _proposalId) public nonReentrant whenNotPaused {
        GovernanceProposal storage proposal = proposals[_proposalId];

        if (proposal.executed) {
            revert ChronoForge__ProposalAlreadyExecuted();
        }
        if (!proposal.active) {
            revert ChronoForge__ProposalNotActive();
        }
        if (block.timestamp <= proposal.startTime + GOVERNANCE_VOTING_PERIOD) {
            revert ChronoForge__VoteTooLate(); // Voting period not over yet
        }

        proposal.active = false; // Mark proposal as no longer active for voting

        uint256 totalChronos = ERC721.totalSupply(); // Assuming total supply represents voting power
        uint256 quorum = (totalChronos * QUORUM_PERCENT) / 100;

        if (proposal.votesFor + proposal.votesAgainst < quorum) {
            revert ChronoForge__ProposalFailed(); // Quorum not reached
        }
        if (proposal.votesFor <= proposal.votesAgainst) {
            revert ChronoForge__ProposalFailed(); // Majority not reached
        }

        // Execute the proposal's calldata on the target contract
        (bool success, ) = proposal.target.call(proposal.calldata);
        proposal.executed = true;

        emit ProposalExecuted(_proposalId, success);
        require(success, "Proposal execution failed");
    }

    /// @notice Sets the base URI for Chrono NFT metadata.
    /// @dev Can only be called by the contract owner or via governance.
    /// @param _newBaseURI The new base URI string.
    function setChronoBaseURI(string memory _newBaseURI) public onlyOwner {
        _chronoBaseURI = _newBaseURI;
    }

    /// @notice Sets the address of the Temporal Oracle contract/account.
    /// @dev Can only be called by the contract owner or via governance.
    /// @param _newTemporalOracleAddress The new oracle address.
    function setTemporalOracleAddress(address _newTemporalOracleAddress) public onlyOwner {
        if (_newTemporalOracleAddress == address(0)) {
            revert ChronoForge__OracleNotSet();
        }
        temporalOracleAddress = _newTemporalOracleAddress;
    }


    // --- Internal/Private Functions ---

    /// @dev ERC721 `_baseURI` override.
    function _baseURI() internal view override returns (string memory) {
        return _chronoBaseURI;
    }

    /// @dev ERC721 `tokenURI` override.
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (!_exists(tokenId)) {
            revert ERC721NonexistentToken(tokenId);
        }
        return string(abi.encodePacked(_baseURI(), tokenId.toString(), ".json"));
    }

    // Helper to get token by index (for essence accrual loop) - note this is O(n)
    // and would be inefficient for a large number of tokens.
    // For a real-world high-scale application, a different approach to
    // essence accrual (e.g., pulling on demand for a specific Chrono, or
    // requiring users to pass in array of Chronos they own) would be needed.
    function _tokenOfOwnerByIndex(address owner_, uint256 index) internal view returns (uint256) {
        uint256 count = 0;
        for (uint256 i = 0; i < _nextChronoId.current(); i++) {
            if (_exists(i) && super.ownerOf(i) == owner_) {
                if (count == index) {
                    return i;
                }
                count++;
            }
        }
        revert("ERC721Enumerable: owner index out of bounds");
    }

    /// @dev Fallback function to prevent accidental ETH transfers.
    receive() external payable {
        revert("ChronoForge: Direct ETH deposits not allowed. Use forgeChrono.");
    }
}
```