Okay, this sounds like a fun challenge! Let's design a smart contract that models abstract, non-fungible "Quantum Fluctuation States" (QFS) which can be generated, cultivated, entangled, and "collapsed" with probabilistic outcomes influenced by internal parameters, external data, and user interaction.

It will incorporate concepts like:
*   **Probabilistic Outcomes:** Results of actions (like 'collapse') are not fixed but depend on weighted probabilities influenced by state properties and external factors.
*   **Complex State Management:** QFS units have multiple evolving properties (amplitude, phase, dimension, status) and can interact ('entangle').
*   **On-Chain Simulation/Evolution:** The states evolve based on interactions and time (represented by block number/timestamp).
*   **External Influence:** An authorized entity can push external data that affects internal probabilities (like an oracle).
*   **Resource Management:** Actions may cost an internal resource (like 'Energy'), and successful outcomes yield this resource.
*   **Non-Fungible Features:** The QFS units are like NFTs but represent complex, dynamic states rather than static items.

---

**Smart Contract Outline & Function Summary**

**Contract Name:** `QuantumFluctuations`

**Description:**
This contract manages abstract, non-fungible "Quantum Fluctuation States" (QFS). Users can generate new states, cultivate their properties, attempt to entangle them, and observe (collapse) them. The outcomes of observations and interactions are probabilistic and influenced by the state's internal properties, dimensional affiliations, contract parameters, and external data inputs. The contract also manages an internal "Energy" token, yielded from successful state collapses and used for certain actions.

**Key Concepts:**
*   **QuantumStateUnit (QFS):** A non-fungible asset representing a dynamic state with properties like amplitude, phase, dimension, and status (Superposition, Entangled, Collapsed, Inert).
*   **Energy:** An internal fungible token generated by collapsing states.
*   **Superposition:** The initial, active state where cultivation and entanglement are possible.
*   **Entangled:** Two or more states linked, potentially influencing each other's collapse.
*   **Collapsed:** The terminal state resulting from observation, where a probabilistic outcome occurs and the state becomes Inert.
*   **Inert:** A collapsed state that can no longer be interacted with but might be redeemed for yield.
*   **Dimensions:** Different contexts or planes influencing state behavior and collapse probabilities.
*   **External Influence:** Data pushed into the contract by an oracle or authorized source, temporarily shifting outcome probabilities.

**Function Summary:**

*(Functions marked with `(View)` are read-only and do not consume gas on execution beyond RPC call costs)*
*(Functions marked with `(Owner)` can only be called by the contract owner)*
*(Functions marked with `(Auth)` can only be called by specifically authorized addresses, e.g., an oracle)*

**State Management (NFT-like):**
1.  `generateFluctuationState()`: Creates a new QFS in 'Superposition' for the caller. May require a cost (e.g., Ether or Energy).
2.  `observeFluctuationState(uint256 stateId)`: Attempts to 'collapse' a state from 'Superposition' or 'Entangled' to 'Collapsed'. Triggers a probabilistic outcome.
3.  `transferFluctuationState(address to, uint256 stateId)`: Transfers ownership of an *active* (Superposition/Entangled) QFS state (standard ERC721 transfer).
4.  `approveFluctuationState(address approved, uint256 stateId)`: Approves another address to transfer a specific QFS (standard ERC721 approve).
5.  `setApprovalForAll(address operator, bool approved)`: Sets approval for an operator to manage all of caller's QFS states (standard ERC721 setApprovalForAll).
6.  `getApproved(uint256 stateId)`: Returns the approved address for a specific QFS (View, standard ERC721 getApproved).
7.  `isApprovedForAll(address owner, address operator)`: Returns if operator is approved for owner's states (View, standard ERC721 isApprovedForAll).
8.  `ownerOf(uint256 stateId)`: Returns the owner of a QFS state (View, standard ERC721 ownerOf).
9.  `balanceOf(address owner)`: Returns the count of QFS states owned by an address (View, standard ERC721 balanceOf).
10. `burnFluctuationState(uint256 stateId)`: Allows the owner of a QFS state to permanently remove it, regardless of status.

**Advanced State Interaction:**
11. `cultivateFluctuation(uint256 stateId)`: Spends Energy or waits for a time lock to improve the properties (amplitude/phase) of a QFS in 'Superposition'.
12. `attemptEntangleStates(uint256 stateId1, uint256 stateId2)`: Attempts to link two QFS states in 'Superposition'. Probabilistic success. Changes status to 'Entangled'. Requires ownership of both.
13. `dissolveEntanglement(uint256 stateId)`: Attempts to break an entanglement involving the specified state. Probabilistic success.
14. `shiftDimension(uint256 stateId, uint8 targetDimension)`: Attempts to move an active QFS state to a different dimension. Probabilistic success.
15. `redeemCollapsedState(uint256 stateId)`: Allows the owner of a 'Collapsed' QFS state to claim any yielded Energy. The state transitions to 'Inert' afterwards.

**Querying State & Parameters:**
16. `getFluctuationState(uint256 stateId)`: Returns detailed information about a specific QFS state (View).
17. `getFluctuationStatesByOwner(address owner)`: Returns an array of state IDs owned by an address (View).
18. `getTotalFluctuationStates()`: Returns the total number of QFS states ever generated (View).
19. `queryEntanglementStatus(uint256 stateId)`: Returns the state ID it's entangled with, or 0 if not entangled (View).
20. `predictCollapseOutcome(uint256 stateId)`: Provides a weighted probability distribution of potential outcomes for a given state based on current parameters (View). (Note: Cannot reveal the *actual* future outcome).
21. `getDimensionalParameters(uint8 dimensionId)`: Returns the parameters specific to a given dimension (View).
22. `getCurrentInfluence()`: Returns the current external influence data affecting probabilities (View).

**Energy Token Management (Internal):**
23. `claimEnergy()`: Allows a user to claim any accumulated Energy balance they have from successful collapses or other yields.
24. `getEnergyBalance(address owner)`: Returns the Energy balance for an address (View).
25. `getTotalEnergySupply()`: Returns the total amount of Energy minted (View).
26. `transferEnergy(address to, uint256 amount)`: Transfers internal Energy balance from caller to another address. (Note: This is an internal transfer function within the contract's economy, *not* an external ERC20 transfer).

**Parameter & Control (Owner/Authorized):**
27. `updateGenerationParameters(...)`: (Owner) Sets parameters for generating new states (cost, initial properties range).
28. `updateCollapseParameters(...)`: (Owner) Sets parameters for state collapse (base probabilities, influence scaling factors).
29. `updateEntanglementParameters(...)`: (Owner) Sets parameters for entanglement success rate and effects.
30. `updateCultivationParameters(...)`: (Owner) Sets parameters for cultivation cost and effect on state properties.
31. `updateDimensionalParameters(...)`: (Owner) Sets parameters specific to each dimension (e.g., modifiers to collapse probabilities within that dimension).
32. `setOracleAddress(address _oracle)`: (Owner) Sets the authorized address for pushing external influence.
33. `pushExternalInfluence(uint256 influenceData)`: (Auth) Pushes new external influence data that affects probabilistic outcomes.
34. `pauseContract()`: (Owner) Pauses certain sensitive contract functions.
35. `unpauseContract()`: (Owner) Unpauses the contract.
36. `withdrawProtocolYield(address tokenAddress, uint256 amount)`: (Owner) Allows withdrawing any non-Energy tokens that might accumulate in the contract (e.g., if generation required ETH).
37. `transferOwnership(address newOwner)`: (Owner) Transfers contract ownership.
38. `renounceOwnership()`: (Owner) Renounces contract ownership.

*(Total: 38 functions)*

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/math/Math.sol"; // For min/max if needed, or just basic arithmetic
import "@openzeppelin/contracts/interfaces/ERC165.sol"; // For ERC721 support interfaces
import "@openzeppelin/contracts/token/ERC721/IERC721.sol"; // Interface we adhere to for QFS
import "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol"; // Interface for enumeration (optional but good)
import "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol"; // Interface for metadata (optional)

// Note: Full ERC721 implementation details like tokenURI, tokenByIndex, etc., are omitted for brevity
// as the focus is on the unique mechanics, but the core transfer/ownership functions are included
// to demonstrate the non-fungible aspect.

/**
 * @title QuantumFluctuations
 * @dev A smart contract managing abstract, non-fungible Quantum Fluctuation States (QFS).
 * States can be generated, cultivated, entangled, and observed with probabilistic outcomes.
 * Features an internal Energy token economy and external influence via an oracle.
 *
 * Outline:
 * - Error definitions
 * - Events
 * - Enums for State Status
 * - Structs for QuantumStateUnit, Parameters
 * - State Variables (mappings, counters, parameters, oracle)
 * - Constructor
 * - Modifiers
 * - Internal Libraries/Helpers (Entropy, Probability)
 * - Internal Token Logic (_mintEnergy, _burnEnergy, _transferEnergy)
 * - ERC721 Interface Implementation (Partial - core ownership/transfer)
 * - Core State Management (generate, observe, burn, redeem)
 * - Advanced State Interaction (cultivate, attemptEntangle, dissolveEntanglement, shiftDimension)
 * - Querying State & Parameters (getters for states, parameters, influence, predictions)
 * - Energy Token Management (claimEnergy, getters)
 * - Parameter & Control (Owner functions to update params, set oracle, pause/unpause, withdraw)
 * - Ownership (Ownable)
 * - Pausability (Pausable)
 */
contract QuantumFluctuations is Ownable, Pausable, IERC721, IERC165 { // Implementing core ERC721/ERC165 interfaces
    using Counters for Counters.Counter;

    // --- Errors ---
    error InvalidStateId();
    error StateNotActive(); // Not Superposition or Entangled
    error StateNotSuperposition();
    error StateNotEntangled();
    error StateNotCollapsed();
    error SelfEntanglement();
    error AlreadyEntangled(uint256 stateId);
    error NotOwnerOfState(uint256 stateId);
    error NotOwnerOfBothStates(uint256 stateId1, uint256 stateId2);
    error NotAuthorizedOracle();
    error InsufficientEnergy(uint256 required, uint256 available);
    error InvalidDimension(uint8 dimensionId);
    error NoYieldToClaim();

    // --- Events ---
    event StateGenerated(uint256 indexed stateId, address indexed owner, uint8 dimension, uint256 initialAmplitude, uint256 initialPhase);
    event StateCultivated(uint256 indexed stateId, address indexed cultivator, uint256 newAmplitude, uint256 newPhase);
    event StatesEntangled(uint256 indexed stateId1, uint256 indexed stateId2);
    event EntanglementDissolved(uint256 indexed stateId1, uint256 indexed stateId2);
    event DimensionShifted(uint256 indexed stateId, uint8 oldDimension, uint8 newDimension);
    event StateCollapsed(uint256 indexed stateId, address indexed observer, string outcomeType, uint256 outcomeValue); // outcomeValue could be Energy yielded
    event StateBurned(uint256 indexed stateId, address indexed burner);
    event EnergyYieldClaimed(address indexed owner, uint256 amount);
    event ExternalInfluencePushed(uint256 influenceData, address indexed oracle);

    // --- Enums ---
    enum StateStatus {
        Superposition, // Default state, can be cultivated, entangled, observed
        Entangled,     // Linked with another state, can be dissolved, observed
        Collapsed,     // Observation attempted, outcome determined, waiting for redemption
        Inert          // Terminal state after redemption, cannot be interacted with
    }

    // --- Structs ---
    struct QuantumStateUnit {
        uint256 id;
        address owner;
        StateStatus status;
        uint8 dimension;
        uint256 amplitude; // Represents 'potential', higher amplitude might affect outcomes
        uint256 phase;     // Represents 'state vector', phase difference might affect entanglement/collapse
        uint256 creationBlock; // For age-based logic if desired
        uint256 lastInteractionBlock; // For decay or time-based effects
        uint256 entangledWith; // Stores the ID of the entangled state (0 if not entangled)
        uint256 pendingYield; // Energy waiting to be claimed upon redemption
    }

    // Struct for general parameters affecting state behavior
    struct SimulationParameters {
        uint256 baseGenerateCostEnergy;
        uint256 minInitialAmplitude;
        uint256 maxInitialAmplitude;
        uint256 minInitialPhase;
        uint256 maxInitialPhase;

        uint256 observeEnergyCost;
        // Probabilities for collapse outcomes (scaled up, e.g., 1000 = 100%)
        uint256 collapseProb_YieldEnergy;
        uint256 collapseProb_BecomeInert; // Default failure state
        // uint256 collapseProb_BreakEntanglement; // If entangled
        // uint256 collapseProb_DimensionalShift; // Random shift

        uint256 energyYieldPerAmplitudeUnit; // How much energy amplitude contributes on collapse
        uint256 energyYieldBase;             // Base energy yield on successful collapse

        uint256 cultivateEnergyCost;
        uint256 cultivateAmplitudeIncrease;
        uint256 cultivatePhaseChangeRange; // e.g., +/- 100

        uint256 entanglementAttemptCostEnergy;
        uint256 baseEntangleSuccessRate; // Scaled up
        uint256 phaseDifferenceInfluenceOnEntangle; // How phase diff affects success rate

        uint256 dissolveEntanglementCostEnergy;
        uint256 baseDissolveSuccessRate; // Scaled up

        uint256 shiftDimensionCostEnergy;
        uint256 baseShiftSuccessRate; // Scaled up

        uint256 externalInfluenceScalingFactor; // How much external influence affects probabilities
        uint256 decayRatePerBlock; // How amplitude/phase might decay over time (scaled)
        uint8 totalDimensions; // Total number of dimensions available (>= 1)
    }

    // Parameters specific to each dimension (e.g., modify probabilities, yields)
    struct DimensionParameters {
        int256 collapseProbModifier_YieldEnergy;
        int256 energyYieldModifier;
        // Add other dimension-specific modifiers here
    }

    // --- State Variables ---
    Counters.Counter private _stateIds; // Counter for unique QFS IDs

    mapping(uint256 => QuantumStateUnit) private _states;
    mapping(address => uint256[]) private _ownerStates; // List of state IDs owned by an address (simplified)
    mapping(address => uint256) private _ownerStateCount; // For balanceOf

    // ERC721 transfer/approval mappings (simplified standard)
    mapping(uint256 => address) private _stateApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    mapping(address => uint256) private _energyBalances; // Internal Energy token balances
    uint256 private _totalEnergySupply;

    SimulationParameters public simParams;
    mapping(uint8 => DimensionParameters) public dimParams; // Parameters per dimension

    address public oracleAddress; // Address authorized to push external influence
    uint256 private _currentExternalInfluence; // Data from the oracle

    // --- Constructor ---
    constructor(address _oracle) Ownable(msg.sender) {
        // Initialize basic parameters (these should be set properly by the owner later)
        simParams = SimulationParameters({
            baseGenerateCostEnergy: 10,
            minInitialAmplitude: 100,
            maxInitialAmplitude: 500,
            minInitialPhase: 0,
            maxInitialPhase: 360, // Degrees

            observeEnergyCost: 5,
            collapseProb_YieldEnergy: 700, // 70%
            collapseProb_BecomeInert: 300, // 30%
            // collapseProb_BreakEntanglement: 0, // Placeholder
            // collapseProb_DimensionalShift: 0, // Placeholder

            energyYieldPerAmplitudeUnit: 1, // 1 Energy per amplitude point on yield
            energyYieldBase: 50,           // Base yield

            cultivateEnergyCost: 20,
            cultivateAmplitudeIncrease: 50,
            cultivatePhaseChangeRange: 30, // +/-

            entanglementAttemptCostEnergy: 30,
            baseEntangleSuccessRate: 600, // 60%
            phaseDifferenceInfluenceOnEntangle: 5, // Scaling factor

            dissolveEntanglementCostEnergy: 15,
            baseDissolveSuccessRate: 700, // 70%

            shiftDimensionCostEnergy: 25,
            baseShiftSuccessRate: 500, // 50%

            externalInfluenceScalingFactor: 1,
            decayRatePerBlock: 0, // No decay initially
            totalDimensions: 3 // Example: 3 dimensions (0, 1, 2)
        });

        // Initialize default dimension parameters
        dimParams[0] = DimensionParameters({
            collapseProbModifier_YieldEnergy: 0,
            energyYieldModifier: 0
        });
         dimParams[1] = DimensionParameters({
            collapseProbModifier_YieldEnergy: 100, // Dim 1 is +10% yield chance
            energyYieldModifier: 20 // Dim 1 adds 20 base energy
        });
        dimParams[2] = DimensionParameters({
            collapseProbModifier_YieldEnergy: -50, // Dim 2 is -5% yield chance
            energyYieldModifier: -10 // Dim 2 subtracts 10 base energy
        });


        oracleAddress = _oracle;
        _currentExternalInfluence = 0; // Initial influence
    }

    // --- Modifiers ---
    modifier onlyOracle() {
        if (msg.sender != oracleAddress) {
            revert NotAuthorizedOracle();
        }
        _;
    }

    modifier onlyStateOwner(uint256 stateId) {
        if (_states[stateId].owner != msg.sender) {
            revert NotOwnerOfState(stateId);
        }
        _;
    }

     modifier onlyStateOwnerOrApproved(uint256 stateId) {
        address owner = _states[stateId].owner;
        if (msg.sender != owner && _stateApprovals[stateId] != msg.sender && !(_operatorApprovals[owner][msg.sender])) {
             revert NotOwnerOfState(stateId); // More generic error here
        }
        _;
    }


    // --- Internal Libraries/Helpers ---

    /**
     * @dev Generates a pseudo-random seed using various chain/tx data.
     * Note: This is NOT cryptographically secure randomness and is susceptible to miner manipulation
     * or front-running, especially for high-value outcomes. For real-world critical applications,
     * consider decentralized oracle networks for randomness.
     */
    function _generateEntropy(uint256 mix) internal view returns (uint256) {
        uint256 blockSeed = uint256(blockhash(block.number - 1)); // Use previous block hash
        uint256 combinedSeed = blockSeed ^ uint256(keccak256(abi.encodePacked(
            block.timestamp,
            msg.sender,
            tx.origin,
            tx.gasprice,
            block.difficulty, // deprecated on PoS, use block.randao
            _stateIds.current(),
            mix // External mix-in data
        )));
        return combinedSeed;
    }

    /**
     * @dev Calculates a probabilistic outcome based on weighted options and entropy.
     * @param weights Array of weights for each outcome. Sum of weights determines the range.
     * @param entropy Seed for the random number generation.
     * @return The index of the selected outcome.
     */
    function _selectOutcome(uint256[] memory weights, uint256 entropy) internal pure returns (uint256) {
        uint256 totalWeight = 0;
        for (uint i = 0; i < weights.length; i++) {
            totalWeight += weights[i];
        }
        if (totalWeight == 0) return 0; // Should not happen with valid weights

        uint256 randomNumber = uint256(keccak256(abi.encodePacked(entropy))) % totalWeight;

        uint256 cumulativeWeight = 0;
        for (uint i = 0; i < weights.length; i++) {
            cumulativeWeight += weights[i];
            if (randomNumber < cumulativeWeight) {
                return i;
            }
        }
        return weights.length - 1; // Fallback, should not be reached
    }

    /**
     * @dev Checks if a state ID is valid (exists).
     */
    function _stateExists(uint256 stateId) internal view returns (bool) {
        return stateId > 0 && stateId <= _stateIds.current();
    }

    /**
     * @dev Checks if a state is in Superposition or Entangled.
     */
    function _isStateActive(uint256 stateId) internal view returns (bool) {
        StateStatus status = _states[stateId].status;
        return status == StateStatus.Superposition || status == StateStatus.Entangled;
    }

     /**
      * @dev Adds a state ID to the owner's list (simplified, potentially inefficient for many states).
      * A linked list or more sophisticated mapping might be better for large numbers of states.
      */
    function _addStateToOwner(address owner, uint256 stateId) internal {
         _ownerStates[owner].push(stateId);
         _ownerStateCount[owner]++;
    }

     /**
      * @dev Removes a state ID from the owner's list (simplified, potentially inefficient).
      * Finds the state ID and swaps with the last element, then pops.
      */
    function _removeStateFromOwner(address owner, uint256 stateId) internal {
        uint256[] storage ownerStates = _ownerStates[owner];
        uint256 lastIndex = ownerStates.length - 1;
        for (uint i = 0; i < ownerStates.length; i++) {
            if (ownerStates[i] == stateId) {
                ownerStates[i] = ownerStates[lastIndex];
                ownerStates.pop();
                _ownerStateCount[owner]--;
                 // Clear approval when ownership changes or state is removed
                delete _stateApprovals[stateId];
                return;
            }
        }
        // Should not reach here if stateId is valid and owned
    }

    // --- Internal Energy Token Logic ---

    /**
     * @dev Mints Energy and adds it to a recipient's balance.
     */
    function _mintEnergy(address recipient, uint256 amount) internal {
        _totalEnergySupply += amount;
        _energyBalances[recipient] += amount;
    }

    /**
     * @dev Burns Energy from a holder's balance.
     */
    function _burnEnergy(address holder, uint256 amount) internal {
        if (_energyBalances[holder] < amount) {
            revert InsufficientEnergy(amount, _energyBalances[holder]);
        }
        _energyBalances[holder] -= amount;
        _totalEnergySupply -= amount;
    }

    /**
     * @dev Transfers Energy internally between users.
     */
    function _transferEnergy(address from, address to, uint256 amount) internal {
         if (_energyBalances[from] < amount) {
            revert InsufficientEnergy(amount, _energyBalances[from]);
        }
        _energyBalances[from] -= amount;
        _energyBalances[to] += amount;
    }


    // --- ERC721 Interface Implementation (Partial) ---
    // We implement the core functions required for ownership tracking
    // and basic transfers to make QFS states act like NFTs.

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC721).interfaceId ||
               interfaceId == type(IERC165).interfaceId;
               // Could add ERC721Enumerable and ERC721Metadata if implementing those
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _ownerStateCount[owner];
    }

    function ownerOf(uint256 stateId) public view virtual override returns (address) {
        if (!_stateExists(stateId)) {
             revert InvalidStateId(); // Or ERC721 specific error
        }
        address owner = _states[stateId].owner;
        require(owner != address(0), "ERC721: owner query for nonexistent token"); // Should not happen with _stateExists check
        return owner;
    }

    function transferFrom(address from, address to, uint256 stateId) public payable virtual override {
        require(_isApprovedOrOwner(msg.sender, stateId), "ERC721: transfer caller is not owner nor approved");
        require(from != address(0), "ERC721: transfer from the zero address");
        require(to != address(0), "ERC721: transfer to the zero address");
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
         // Only active states can be freely transferred like NFTs
        if (!_isStateActive(stateId)) {
            revert StateNotActive();
        }
        require(ownerOf(stateId) == from, "ERC721: transfer of token that is not own");


        // Internal transfer logic
        _transferFluctuationStateInternal(from, to, stateId);
    }

    function safeTransferFrom(address from, address to, uint256 stateId) public payable virtual override {
         safeTransferFrom(from, to, stateId, "");
    }

    function safeTransferFrom(address from, address to, uint256 stateId, bytes calldata data) public payable virtual override {
        require(_isApprovedOrOwner(msg.sender, stateId), "ERC721: transfer caller is not owner nor approved");
        require(from != address(0), "ERC721: transfer from the zero address");
        require(to != address(0), "ERC721: transfer to the zero address");
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
          // Only active states can be freely transferred like NFTs
         if (!_isStateActive(stateId)) {
             revert StateNotActive();
         }
         require(ownerOf(stateId) == from, "ERC721: transfer of token that is not own");

        _transferFluctuationStateInternal(from, to, stateId);
        require(_checkOnERC721Received(from, to, stateId, data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    function approve(address to, uint256 stateId) public virtual override {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        address owner = ownerOf(stateId);
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "ERC721: approve caller is not owner nor approved for all");
        require(to != owner, "ERC721: approval to current owner");

        _stateApprovals[stateId] = to;
        emit Approval(owner, to, stateId);
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != msg.sender, "ERC721: approve to caller");
        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function getApproved(uint256 stateId) public view virtual override returns (address) {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        return _stateApprovals[stateId];
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @dev Internal transfer logic, handling owner updates and events.
     * Not exposed publicly to force use of transferFrom/safeTransferFrom which include checks.
     */
    function _transferFluctuationStateInternal(address from, address to, uint256 stateId) internal {
        // Update owner tracking
        _removeStateFromOwner(from, stateId);
        _addStateToOwner(to, stateId);
        _states[stateId].owner = to;

         // Clear approvals for the transferred state
        delete _stateApprovals[stateId];

        emit Transfer(from, to, stateId);
    }

     /**
      * @dev Internal function to check if a given address is owner or approved for a state ID.
      */
    function _isApprovedOrOwner(address spender, uint256 stateId) internal view returns (bool) {
        address owner = ownerOf(stateId);
        return (spender == owner || getApproved(stateId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Helper to check if a recipient supports ERC721Receiver interface.
     * Borrowed from OpenZeppelin ERC721._checkOnERC721Received.
     */
    function _checkOnERC721Received(address from, address to, uint256 stateId, bytes memory data) private returns (bool) {
        if (to.code.length == 0) {
            return true; // EOAs accept NFTs
        }
        try IERC721Receiver(to).onERC721Received(msg.sender, from, stateId, data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert("ERC721: transfer to non ERC721Receiver implementer");
            } else {
                assembly {
                    revert(add(32, reason), mload(reason))
                }
            }
        }
    }


    // --- Core State Management ---

    /**
     * @dev Generates a new Quantum Fluctuation State.
     * Requires paying the `baseGenerateCostEnergy` in internal Energy balance.
     * Initializes state with random-ish amplitude, phase, and a random dimension.
     */
    function generateFluctuationState() public payable whenNotPaused {
        uint256 cost = simParams.baseGenerateCostEnergy;
        if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
        }
        _burnEnergy(msg.sender, cost);

        _stateIds.increment();
        uint256 newStateId = _stateIds.current();

        uint256 entropy = _generateEntropy(newStateId);

        // Simple pseudo-random initial properties
        uint256 initialAmplitude = (entropy % (simParams.maxInitialAmplitude - simParams.minInitialAmplitude + 1)) + simParams.minInitialAmplitude;
        uint256 initialPhase = (entropy % (simParams.maxInitialPhase - simParams.minInitialPhase + 1)) + simParams.minInitialPhase;
        uint8 initialDimension = uint8((entropy >> 8) % simParams.totalDimensions); // Use different bits for dimension

        _states[newStateId] = QuantumStateUnit({
            id: newStateId,
            owner: msg.sender,
            status: StateStatus.Superposition,
            dimension: initialDimension,
            amplitude: initialAmplitude,
            phase: initialPhase,
            creationBlock: block.number,
            lastInteractionBlock: block.number,
            entangledWith: 0,
            pendingYield: 0
        });

        _addStateToOwner(msg.sender, newStateId);

        emit StateGenerated(newStateId, msg.sender, initialDimension, initialAmplitude, initialPhase);
        emit Transfer(address(0), msg.sender, newStateId); // ERC721 Mint Event
    }

    /**
     * @dev Attempts to "observe" a QFS, triggering a probabilistic collapse.
     * Can be called by anyone, but requires the observer to pay Energy.
     * The state must be in Superposition or Entangled.
     */
    function observeFluctuationState(uint256 stateId) public payable whenNotPaused {
        if (!_stateExists(stateId)) {
             revert InvalidStateId();
        }
        QuantumStateUnit storage state = _states[stateId];

        if (!_isStateActive(stateId)) {
             revert StateNotActive();
        }

        uint256 cost = simParams.observeEnergyCost;
         if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
         }
        _burnEnergy(msg.sender, cost);

        state.lastInteractionBlock = block.number;

        // --- Probabilistic Collapse Logic ---
        uint256 entropy = _generateEntropy(stateId);

        // Calculate weighted probabilities based on state properties, dimension, and external influence
        uint256 yieldWeight = simParams.collapseProb_YieldEnergy;
        uint256 inertWeight = simParams.collapseProb_BecomeInert;
        // uint256 breakEntangleWeight = simParams.collapseProb_BreakEntanglement;
        // uint256 dimShiftWeight = simParams.collapseProb_DimensionalShift;

        // Apply dimension modifiers (ensure resulting weight is not negative)
        yieldWeight = uint256(int256(yieldWeight) + dimParams[state.dimension].collapseProbModifier_YieldEnergy);
        yieldWeight = yieldWeight > 0 ? yieldWeight : 0;

        // Apply external influence (example: higher influence increases yield chance)
        uint256 influenceScaled = _currentExternalInfluence * simParams.externalInfluenceScalingFactor;
        yieldWeight += influenceScaled;


        // Define the possible outcomes and their calculated weights
        uint256[] memory weights = new uint256[](2); // Yield, Inert
        weights[0] = yieldWeight;
        weights[1] = inertWeight;
        // weights[2] = breakEntangleWeight;
        // weights[3] = dimShiftWeight; // Add more outcomes here with corresponding weights

        uint256 chosenOutcomeIndex = _selectOutcome(weights, entropy);

        string memory outcomeType;
        uint256 outcomeValue = 0; // Represents yielded Energy

        // Execute the chosen outcome
        if (chosenOutcomeIndex == 0) { // Outcome: Yield Energy
            outcomeType = "YieldEnergy";
            uint256 yieldAmount = simParams.energyYieldBase + (state.amplitude * simParams.energyYieldPerAmplitudeUnit);
            // Apply dimension modifier to yield amount
            yieldAmount = uint256(int256(yieldAmount) + dimParams[state.dimension].energyYieldModifier);
            yieldAmount = yieldAmount > 0 ? yieldAmount : 0;

            state.pendingYield = yieldAmount;
            outcomeValue = yieldAmount;
             // State moves to Collapsed, owner claims yield later
            state.status = StateStatus.Collapsed;


        } else if (chosenOutcomeIndex == 1) { // Outcome: Become Inert (no yield)
            outcomeType = "BecomeInert";
            outcomeValue = 0;
            state.status = StateStatus.Inert; // State is now permanently Inert
             // Clear any pending yield if no yield outcome was chosen
            state.pendingYield = 0;

        }
        // Add more outcome branches here based on chosenOutcomeIndex

        // Handle entanglement break on collapse (example)
        if (state.status == StateStatus.Entangled && chosenOutcomeIndex != 0) { // If not yielding, perhaps entanglement breaks
             uint256 entangledId = state.entangledWith;
            if (entangledId > 0 && _stateExists(entangledId)) {
                 _states[entangledId].entangledWith = 0;
                 if (_states[entangledId].status == StateStatus.Entangled) {
                     _states[entangledId].status = StateStatus.Superposition; // Return other state to superposition
                 }
                 state.entangledWith = 0;
                 emit EntanglementDissolved(state.id, entangledId);
            }
        }

        // The state is now either Collapsed (with pending yield) or Inert (no yield).
        // Ownership remains with the original owner.

        emit StateCollapsed(stateId, msg.sender, outcomeType, outcomeValue);
    }

    /**
     * @dev Allows the owner of a Collapsed state to redeem its pending yield (Energy).
     * The state becomes Inert after redemption.
     */
    function redeemCollapsedState(uint256 stateId) public onlyStateOwner(stateId) whenNotPaused {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        QuantumStateUnit storage state = _states[stateId];

        if (state.status != StateStatus.Collapsed) {
            revert StateNotCollapsed();
        }

        uint256 yieldAmount = state.pendingYield;
        if (yieldAmount == 0) {
            revert NoYieldToClaim();
        }

        _mintEnergy(state.owner, yieldAmount);
        state.pendingYield = 0; // Clear pending yield
        state.status = StateStatus.Inert; // State becomes inert permanently

        emit EnergyYieldClaimed(state.owner, yieldAmount);
         // No ERC721 Transfer event needed as ownership doesn't change, only status.
    }


    /**
     * @dev Burns a QFS state, removing it permanently.
     * Can be called by the state's owner.
     */
    function burnFluctuationState(uint256 stateId) public onlyStateOwner(stateId) whenNotPaused {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        QuantumStateUnit storage state = _states[stateId];

        // If entangled, dissolve entanglement first
        if (state.entangledWith > 0 && _stateExists(state.entangledWith)) {
             _states[state.entangledWith].entangledWith = 0;
              if (_states[state.entangledWith].status == StateStatus.Entangled) {
                 _states[state.entangledWith].status = StateStatus.Superposition; // Return other state to superposition
             }
             emit EntanglementDissolved(state.id, state.entangledWith);
        }

        address owner = state.owner;

        // Clear data and remove from owner tracking
        delete _states[stateId];
        _removeStateFromOwner(owner, stateId); // Also clears approvals

        emit StateBurned(stateId, owner);
        emit Transfer(owner, address(0), stateId); // ERC721 Burn Event
    }


    // --- Advanced State Interaction ---

    /**
     * @dev Allows the owner to cultivate a state in Superposition or Entangled.
     * Costs Energy and increases amplitude and slightly shifts phase, improving collapse chances.
     */
    function cultivateFluctuation(uint256 stateId) public onlyStateOwner(stateId) whenNotPaused {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        QuantumStateUnit storage state = _states[stateId];

        if (!_isStateActive(stateId)) {
            revert StateNotActive();
        }

        uint256 cost = simParams.cultivateEnergyCost;
         if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
         }
        _burnEnergy(msg.sender, cost);

        // Apply cultivation effects
        state.amplitude += simParams.cultivateAmplitudeIncrease;

        // Simple phase shift: add/subtract a random amount within range
        uint256 entropy = _generateEntropy(stateId + block.timestamp); // Mix time for variety
        int256 phaseChange = int256(entropy % (simParams.cultivatePhaseChangeRange * 2 + 1)) - int256(simParams.cultivatePhaseChangeRange);
        int256 newPhase = int256(state.phase) + phaseChange;

        // Keep phase within 0-360 range (modulo arithmetic for potentially negative results)
        state.phase = uint256(newPhase % 360);
        if (state.phase < 0) {
            state.phase += 360;
        }


        state.lastInteractionBlock = block.number;

        emit StateCultivated(stateId, msg.sender, state.amplitude, state.phase);
    }

    /**
     * @dev Attempts to entangle two states owned by the caller.
     * Both states must be in Superposition. Probabilistic success.
     * Costs Energy.
     */
    function attemptEntangleStates(uint256 stateId1, uint256 stateId2) public onlyStateOwner(stateId1) onlyStateOwner(stateId2) whenNotPaused {
        if (stateId1 == stateId2) {
            revert SelfEntanglement();
        }
         if (!_stateExists(stateId1) || !_stateExists(stateId2)) {
             revert InvalidStateId();
         }

        QuantumStateUnit storage state1 = _states[stateId1];
        QuantumStateUnit storage state2 = _states[stateId2];

        if (state1.status != StateStatus.Superposition) {
             revert StateNotSuperposition();
        }
         if (state2.status != StateStatus.Superposition) {
             revert StateNotSuperposition();
        }
        if (state1.entangledWith > 0 || state2.entangledWith > 0) {
             revert AlreadyEntangled(state1.entangledWith > 0 ? state1.id : state2.id);
        }

        uint256 cost = simParams.entanglementAttemptCostEnergy;
         if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
         }
        _burnEnergy(msg.sender, cost);

        // Calculate success probability influenced by phase difference
        // Absolute phase difference, scaled
        uint256 phaseDiff = state1.phase > state2.phase ? state1.phase - state2.phase : state2.phase - state1.phase;
        uint256 phaseEffect = (phaseDiff * simParams.phaseDifferenceInfluenceOnEntangle) / 360; // Simple scaling

        uint256 successWeight = simParams.baseEntangleSuccessRate + phaseEffect;
        uint256 failWeight = 1000 - successWeight; // Assume weights are out of 1000

        uint256 entropy = _generateEntropy(stateId1 + stateId2);
        uint256[] memory weights = new uint256[](2);
        weights[0] = successWeight; // Success
        weights[1] = failWeight;   // Fail

        if (_selectOutcome(weights, entropy) == 0) {
            // Success
            state1.status = StateStatus.Entangled;
            state2.status = StateStatus.Entangled;
            state1.entangledWith = stateId2;
            state2.entangledWith = stateId1;
            state1.lastInteractionBlock = block.number;
            state2.lastInteractionBlock = block.number;
            emit StatesEntangled(stateId1, stateId2);
        } else {
            // Fail - States remain in Superposition, cost is paid.
             state1.lastInteractionBlock = block.number; // Still an interaction
            state2.lastInteractionBlock = block.number;
            // No event for failed attempt
        }
    }

    /**
     * @dev Attempts to dissolve the entanglement involving a state owned by the caller.
     * The state must be Entangled. Probabilistic success.
     * Costs Energy.
     */
    function dissolveEntanglement(uint256 stateId) public onlyStateOwner(stateId) whenNotPaused {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        QuantumStateUnit storage state = _states[stateId];

        if (state.status != StateStatus.Entangled) {
            revert StateNotEntangled();
        }

        uint256 entangledId = state.entangledWith;
        if (entangledId == 0 || !_stateExists(entangledId)) {
             // Should not happen if status is Entangled, but good defensive check
             revert InvalidStateId();
        }
         QuantumStateUnit storage entangledState = _states[entangledId];

        uint256 cost = simParams.dissolveEntanglementCostEnergy;
         if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
         }
        _burnEnergy(msg.sender, cost);

        uint256 entropy = _generateEntropy(stateId + entangledId + block.timestamp);
        uint256 successWeight = simParams.baseDissolveSuccessRate;
        uint256 failWeight = 1000 - successWeight; // Assume weights are out of 1000

        uint256[] memory weights = new uint256[](2);
        weights[0] = successWeight; // Success
        weights[1] = failWeight;   // Fail

        if (_selectOutcome(weights, entropy) == 0) {
            // Success
            state.status = StateStatus.Superposition; // Return to Superposition
            state.entangledWith = 0;
             if(entangledState.status == StateStatus.Entangled) { // Ensure other state is also Entangled
                 entangledState.status = StateStatus.Superposition;
             }
             entangledState.entangledWith = 0;

            state.lastInteractionBlock = block.number;
            entangledState.lastInteractionBlock = block.number;
            emit EntanglementDissolved(state.id, entangledId);
        } else {
            // Fail - States remain Entangled, cost is paid.
            state.lastInteractionBlock = block.number; // Still an interaction
            entangledState.lastInteractionBlock = block.number;
             // No event for failed attempt
        }
    }

    /**
     * @dev Attempts to shift a state's dimension.
     * Can be called by the owner. State must be active. Probabilistic success.
     * Costs Energy.
     */
    function shiftDimension(uint256 stateId, uint8 targetDimension) public onlyStateOwner(stateId) whenNotPaused {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        QuantumStateUnit storage state = _states[stateId];

         if (!_isStateActive(stateId)) {
             revert StateNotActive();
         }

        if (targetDimension >= simParams.totalDimensions) {
             revert InvalidDimension(targetDimension);
        }
        if (state.dimension == targetDimension) {
             // No change needed, maybe still pay cost? Or just revert? Let's revert.
             return; // Or revert("Already in target dimension");
        }


        uint256 cost = simParams.shiftDimensionCostEnergy;
         if (_energyBalances[msg.sender] < cost) {
             revert InsufficientEnergy(cost, _energyBalances[msg.sender]);
         }
        _burnEnergy(msg.sender, cost);

        uint256 entropy = _generateEntropy(stateId + targetDimension);
        uint256 successWeight = simParams.baseShiftSuccessRate;
        uint256 failWeight = 1000 - successWeight; // Assume weights are out of 1000

        uint256[] memory weights = new uint256[](2);
        weights[0] = successWeight; // Success
        weights[1] = failWeight;   // Fail

        if (_selectOutcome(weights, entropy) == 0) {
            // Success
            uint8 oldDimension = state.dimension;
            state.dimension = targetDimension;
            state.lastInteractionBlock = block.number;
            emit DimensionShifted(stateId, oldDimension, targetDimension);
        } else {
            // Fail - State remains in current dimension, cost is paid.
            state.lastInteractionBlock = block.number; // Still an interaction
             // No event for failed attempt
        }
    }


    // --- Querying State & Parameters (View Functions) ---

    /**
     * @dev Gets detailed information about a specific QFS state.
     */
    function getFluctuationState(uint256 stateId) public view returns (QuantumStateUnit memory) {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        return _states[stateId];
    }

     /**
      * @dev Gets all state IDs owned by an address. (Simplified, less efficient for many states).
      */
    function getFluctuationStatesByOwner(address owner) public view returns (uint256[] memory) {
        return _ownerStates[owner];
    }

     /**
      * @dev Gets the total number of QFS states ever generated.
      */
    function getTotalFluctuationStates() public view returns (uint256) {
        return _stateIds.current();
    }

     /**
      * @dev Queries if a state is entangled and with which state ID.
      * Returns 0 if not entangled.
      */
    function queryEntanglementStatus(uint256 stateId) public view returns (uint256 entangledWithId) {
        if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
        return _states[stateId].entangledWith;
    }

     /**
      * @dev Provides a prediction of potential collapse outcomes and their *current* weighted probabilities.
      * This is based on the state's current properties and contract parameters, NOT the actual deterministic outcome.
      */
     function predictCollapseOutcome(uint256 stateId) public view returns (string[] memory outcomeTypes, uint256[] memory weightedProbabilities) {
         if (!_stateExists(stateId)) {
             revert InvalidStateId();
         }
         QuantumStateUnit memory state = _states[stateId];

         // Calculate the same weights as in observeFluctuationState (without rolling the dice)
        uint256 yieldWeight = simParams.collapseProb_YieldEnergy;
        uint256 inertWeight = simParams.collapseProb_BecomeInert;
        // Add other potential outcome weights here

        // Apply dimension modifiers
        yieldWeight = uint256(int256(yieldWeight) + dimParams[state.dimension].collapseProbModifier_YieldEnergy);
        yieldWeight = yieldWeight > 0 ? yieldWeight : 0;

        // Apply external influence
        uint256 influenceScaled = _currentExternalInfluence * simParams.externalInfluenceScalingFactor;
        yieldWeight += influenceScaled;

        // Return outcome types and their corresponding weights
        outcomeTypes = new string[](2); // Adjust size based on outcomes
        weightedProbabilities = new uint256[](2);

        outcomeTypes[0] = "YieldEnergy";
        weightedProbabilities[0] = yieldWeight;

        outcomeTypes[1] = "BecomeInert";
        weightedProbabilities[1] = inertWeight;

        // Add other outcomes...

        return (outcomeTypes, weightedProbabilities);
     }

     /**
      * @dev Gets the parameters specific to a given dimension.
      */
     function getDimensionalParameters(uint8 dimensionId) public view returns (DimensionParameters memory) {
        if (dimensionId >= simParams.totalDimensions) {
             revert InvalidDimension(dimensionId);
        }
        return dimParams[dimensionId];
     }

     /**
      * @dev Gets the current external influence data.
      */
     function getCurrentInfluence() public view returns (uint256) {
         return _currentExternalInfluence;
     }

    // --- Energy Token Management ---

     /**
      * @dev Allows a user to claim their accumulated Energy balance.
      * Note: In this model, yield is claimed via `redeemCollapsedState`.
      * This function is more if there were passive accruals or rewards separate from collapse yields.
      * Let's repurpose this to simply be the getter for balance. Claiming is handled by redeemCollapsedState.
      */
     // function claimEnergy() public {
     //     // This function is redundant if yield is claimed directly via redeemCollapsedState
     //     // Keeping the signature but noting its limited use based on the current model
     //     // Maybe future versions allow claiming protocol fees or other sources?
     //     // For now, claim is handled by redeemCollapsedState.
     // }

     /**
      * @dev Gets the Energy balance for an address.
      */
     function getEnergyBalance(address owner) public view returns (uint256) {
         return _energyBalances[owner];
     }

     /**
      * @dev Gets the total minted Energy supply.
      */
     function getTotalEnergySupply() public view returns (uint256) {
         return _totalEnergySupply;
     }

     /**
      * @dev Allows a user to transfer their internal Energy balance to another user.
      */
     function transferEnergy(address to, uint256 amount) public whenNotPaused {
        require(to != address(0), "Cannot transfer to zero address");
        _transferEnergy(msg.sender, to, amount);
     }


    // --- Parameter & Control (Owner / Authorized) ---

    /**
     * @dev Owner function to update parameters for state generation.
     */
    function updateGenerationParameters(uint256 _baseGenerateCostEnergy, uint256 _minInitialAmplitude, uint256 _maxInitialAmplitude, uint256 _minInitialPhase, uint256 _maxInitialPhase, uint8 _totalDimensions) public onlyOwner {
        simParams.baseGenerateCostEnergy = _baseGenerateCostEnergy;
        simParams.minInitialAmplitude = _minInitialAmplitude;
        simParams.maxInitialAmplitude = _maxInitialAmplitude;
        simParams.minInitialPhase = _minInitialPhase;
        simParams.maxInitialPhase = _maxInitialPhase;
        simParams.totalDimensions = _totalDimensions; // Be careful changing this if dimensions already exist!
        // Maybe add checks or migration logic for changing totalDimensions
    }

    /**
     * @dev Owner function to update parameters for state collapse outcomes.
     */
    function updateCollapseParameters(uint256 _observeEnergyCost, uint256 _collapseProb_YieldEnergy, uint256 _collapseProb_BecomeInert, uint256 _energyYieldPerAmplitudeUnit, uint256 _energyYieldBase, uint256 _externalInfluenceScalingFactor) public onlyOwner {
        // Ensure probabilities sum up to a reasonable total (e.g., 1000) - add more checks if more outcomes exist
        require(_collapseProb_YieldEnergy + _collapseProb_BecomeInert <= 1000, "Probabilities exceed total");
        simParams.observeEnergyCost = _observeEnergyCost;
        simParams.collapseProb_YieldEnergy = _collapseProb_YieldEnergy;
        simParams.collapseProb_BecomeInert = _collapseProb_BecomeInert;
        simParams.energyYieldPerAmplitudeUnit = _energyYieldPerAmplitudeUnit;
        simParams.energyYieldBase = _energyYieldBase;
        simParams.externalInfluenceScalingFactor = _externalInfluenceScalingFactor;
    }

    /**
     * @dev Owner function to update parameters for entanglement.
     */
    function updateEntanglementParameters(uint256 _entanglementAttemptCostEnergy, uint256 _baseEntangleSuccessRate, uint256 _phaseDifferenceInfluenceOnEntangle, uint256 _dissolveEntanglementCostEnergy, uint256 _baseDissolveSuccessRate) public onlyOwner {
        require(_baseEntangleSuccessRate <= 1000, "Entangle success rate exceeds 1000");
        require(_baseDissolveSuccessRate <= 1000, "Dissolve success rate exceeds 1000");
        simParams.entanglementAttemptCostEnergy = _entanglementAttemptCostEnergy;
        simParams.baseEntangleSuccessRate = _baseEntangleSuccessRate;
        simParams.phaseDifferenceInfluenceOnEntangle = _phaseDifferenceInfluenceOnEntangle;
        simParams.dissolveEntanglementCostEnergy = _dissolveEntanglementCostEnergy;
        simParams.baseDissolveSuccessRate = _baseDissolveSuccessRate;
    }

    /**
     * @dev Owner function to update parameters for cultivation.
     */
    function updateCultivationParameters(uint256 _cultivateEnergyCost, uint256 _cultivateAmplitudeIncrease, uint256 _cultivatePhaseChangeRange) public onlyOwner {
        simParams.cultivateEnergyCost = _cultivateEnergyCost;
        simParams.cultivateAmplitudeIncrease = _cultivateAmplitudeIncrease;
        simParams.cultivatePhaseChangeRange = _cultivatePhaseChangeRange;
    }

     /**
      * @dev Owner function to update parameters for a specific dimension.
      */
     function updateDimensionalParameters(uint8 dimensionId, int256 _collapseProbModifier_YieldEnergy, int256 _energyYieldModifier) public onlyOwner {
         if (dimensionId >= simParams.totalDimensions) {
             revert InvalidDimension(dimensionId);
         }
         dimParams[dimensionId] = DimensionParameters({
             collapseProbModifier_YieldEnergy: _collapseProbModifier_YieldEnergy,
             energyYieldModifier: _energyYieldModifier
         });
     }

    /**
     * @dev Owner function to set the authorized oracle address.
     */
    function setOracleAddress(address _oracle) public onlyOwner {
        require(_oracle != address(0), "Oracle address cannot be zero");
        oracleAddress = _oracle;
    }

    /**
     * @dev Callable ONLY by the authorized oracle address. Pushes external influence data.
     * This data will affect subsequent probabilistic outcomes.
     */
    function pushExternalInfluence(uint256 influenceData) public onlyOracle whenNotPaused {
        _currentExternalInfluence = influenceData;
        emit ExternalInfluencePushed(influenceData, msg.sender);
    }

     /**
      * @dev Owner function to withdraw any other tokens that might be accidentally sent or collected
      * by the contract (e.g., if generation required ETH instead of Energy).
      */
     function withdrawProtocolYield(address tokenAddress, uint256 amount) public onlyOwner {
        if (tokenAddress == address(0)) { // ETH withdrawal
             require(amount <= address(this).balance, "Insufficient ETH balance");
             payable(owner()).transfer(amount);
        } else { // ERC20 token withdrawal
            IERC20 token = IERC20(tokenAddress);
            require(amount <= token.balanceOf(address(this)), "Insufficient token balance");
            token.transfer(owner(), amount);
        }
     }

    // Pausable functions (inherited from OpenZeppelin)
    function pauseContract() public onlyOwner {
        _pause();
    }

    function unpauseContract() public onlyOwner {
        _unpause();
    }

    function isPaused() public view returns (bool) {
        return paused();
    }

    // Ownable functions (inherited from OpenZeppelin)
    // transferOwnership, renounceOwnership are available
}

// Simple ERC20 interface for withdrawProtocolYield
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

// Interface for ERC721Receiver
interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}
```