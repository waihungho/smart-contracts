Okay, let's design a smart contract around a concept that involves dynamic digital assets with evolving traits, resource management, and some interesting mechanics beyond simple ownership and transfer.

**Concept:** "Aetherial Forges" - A protocol where users can mint, cultivate, refine, and even fuse unique digital 'Artifacts'. These Artifacts have on-chain stats that change based on time, user interaction, and specific crafting/reforging operations. There's an internal resource ('Resonance') generated by the protocol and consumed by operations, and a sink for value.

**Core Ideas:**
1.  **Dynamic Traits:** Artifact stats (e.g., Power, Stability, Harmony, Entropy) are stored on-chain and change over time or via functions.
2.  **Time-Based Evolution:** Artifacts naturally age, increasing Entropy and potentially decreasing Stability.
3.  **User Interaction:** Users must perform actions ('Nourish', 'Refine') to maintain or boost stats and counteract decay.
4.  **Crafting/Reforging:** Complex operations ('Empower', 'Reconstruct', 'Fuse') that consume resources (ETH/Tokens, Resonance), potentially introduce randomness, and significantly alter traits, maybe even creating new artifacts.
5.  **Internal Resource (Resonance):** A conceptual resource within the protocol, perhaps generated passively over time or linked to staked artifacts. Used as a 'cost' for certain operations.
6.  **Value Sink:** A portion of ETH/token costs for operations is locked in the contract, potentially distributable via governance or specific rules later.
7.  **Limited Supply/Scarcity:** Control over total artifacts or resources.

**Outline:**

1.  **License and Pragma**
2.  **Imports:** ERC721, Ownable, maybe a simple SafeMath if not using Solidity >= 0.8.
3.  **Error Definitions:** Custom errors for clarity.
4.  **Events:** For key actions (Mint, Reforge, Fuse, ParamChange, etc.)
5.  **Structs:** Define the `Artifact` structure with its on-chain traits and state variables.
6.  **State Variables:** Mappings for artifacts, counters, protocol parameters, Resonance tracking.
7.  **Modifiers:** Custom access control and state checks.
8.  **Enum:** For configurable parameters.
9.  **Constructor:** Initialize contract, ERC721 details, and initial parameters.
10. **ERC721 Core Functions:** Implement/Override standard ERC721 functions.
11. **Artifact Management & Interaction Functions:**
    *   Minting new artifacts.
    *   Viewing artifact details & calculating current stats.
    *   Nourishing/maintaining artifacts (counteracting decay).
    *   Empowering/boosting specific traits.
    *   Reforging/Reconstructing (random element).
    *   Fusing artifacts (combining into a new one).
    *   Burning/Sacrificing artifacts.
12. **Resonance Resource Functions:**
    *   Generating Resonance (conceptually, tied to time/staking).
    *   Consuming Resonance for operations.
    *   Viewing user's accumulated Resonance.
13. **Protocol Sink & Parameter Functions:**
    *   Viewing protocol balance.
    *   Withdrawing from the sink (owner/governance).
    *   Setting configurable parameters.
14. **Utility Functions:**
    *   Total supply.
    *   Checking artifact existence.
    *   Basic random number simulation (with security warning).
    *   TokenURI implementation.

**Function Summary:**

1.  `constructor()`: Initializes the contract, sets ERC721 name/symbol, initial parameters, and owner.
2.  `supportsInterface(bytes4 interfaceId)`: ERC165 compliance.
3.  `balanceOf(address owner)`: ERC721 standard. Returns the number of artifacts owned by an address.
4.  `ownerOf(uint256 tokenId)`: ERC721 standard. Returns the owner of an artifact.
5.  `safeTransferFrom(address from, address to, uint256 tokenId)`: ERC721 standard. Safely transfers an artifact.
6.  `safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)`: ERC721 standard. Safely transfers an artifact with data.
7.  `transferFrom(address from, address to, uint256 tokenId)`: ERC721 standard. Transfers an artifact (less safe than `safeTransferFrom`).
8.  `approve(address to, uint256 tokenId)`: ERC721 standard. Approves an address to manage an artifact.
9.  `getApproved(uint256 tokenId)`: ERC721 standard. Returns the approved address for an artifact.
10. `setApprovalForAll(address operator, bool approved)`: ERC721 standard. Approves or revokes operator status for an address.
11. `isApprovedForAll(address owner, address operator)`: ERC721 standard. Checks if an address is an approved operator.
12. `tokenURI(uint256 tokenId)`: ERC721 standard. Returns the metadata URI for an artifact.
13. `totalSupply()`: Returns the total number of artifacts minted.
14. `artifactExists(uint256 tokenId)`: Internal helper to check if an artifact ID is valid and minted.
15. `_calculateDecay(uint256 _lastInteractionTime)`: Internal helper to calculate decay based on time passed.
16. `_generateResonance(address owner)`: Internal helper (or public function) to conceptually generate Resonance for an owner (simplified as a placeholder here).
17. `mintArtifact(string memory initialMetadataURI)`: Mints a new artifact. Costs ETH, assigns initial traits, and generates a unique ID. Records creation and interaction time.
18. `getArtifactDetails(uint256 tokenId)`: View function to get the static stored details of an artifact *before* applying current decay.
19. `calculateCurrentStats(uint256 tokenId)`: View function to calculate and return the artifact's current effective stats by applying decay based on `block.timestamp`.
20. `nourishArtifact(uint256 tokenId)`: Allows the owner to nourish their artifact. Resets the decay timer (`lastInteractionTime`), potentially costs Resonance or ETH, and might give a small boost to Stability/Harmony.
21. `empowerArtifact(uint256 tokenId, uint256 resonanceCost)`: Allows the owner to boost the Power trait of their artifact. Consumes Resonance.
22. `reconstructArtifact(uint256 tokenId, uint256 ethCost)`: A more complex operation. Costs ETH. Applies a significant stat modification based on a pseudo-random factor, potentially altering multiple traits including Entropy. Resets decay timer.
23. `fuseArtifacts(uint256 tokenId1, uint256 tokenId2)`: Burns two artifacts owned by the caller and mints a *new* one. The new artifact's stats are derived from the fused ones based on specific rules (e.g., average, sum with bonus, or a completely new calculation). Costs ETH and Resonance.
24. `sacrificeArtifact(uint256 tokenId)`: Permanently burns an artifact. Might provide a small amount of Resonance back, or increase stats of *other* artifacts owned by the caller (optional complex mechanic, let's keep it simple burn for now).
25. `getUserResonance(address user)`: View function to see how much Resonance a user has accumulated (conceptually).
26. `withdrawProtocolSink(uint256 amount)`: Allows the owner to withdraw accumulated ETH from the protocol sink.
27. `setParameter(ParameterType param, uint256 value)`: Allows the owner to adjust key protocol parameters (e.g., decay rate, mint cost, resonance costs, fusion rules) via an enum.
28. `getContractBalance()`: View function to check the total ETH held in the contract sink.
29. `transferOwnership(address newOwner)`: Ownable standard.
30. `renounceOwnership()`: Ownable standard.

*Self-Correction:* We need at least 20 *functions*. The ERC721 standard requires several. The outline above lists many custom ones. Let's make sure the count is solid. ERC721 base functions usually cover ~10-12. We have added ~18 custom ones. That gets us well over 20. `_generateResonance` and `_calculateDecay` are internal helpers, let's count only public/external/view/pure functions.

Let's adjust the list slightly to ensure distinct functions:

1.  `constructor`
2.  `supportsInterface`
3.  `balanceOf`
4.  `ownerOf`
5.  `safeTransferFrom` (two versions, counted as one external entry point)
6.  `transferFrom`
7.  `approve`
8.  `getApproved`
9.  `setApprovalForAll`
10. `isApprovedForAll`
11. `tokenURI`
12. `totalSupply` (often added for convenience)
13. `mintArtifact`
14. `getArtifactDetails` (view)
15. `calculateCurrentStats` (view)
16. `nourishArtifact`
17. `empowerArtifact`
18. `reconstructArtifact`
19. `fuseArtifacts`
20. `sacrificeArtifact`
21. `getUserResonance` (view - need a way to *conceptually* track or calculate this)
22. `harvestResonance` (external function to trigger Resonance calculation/claiming - better than internal auto-gen for simplicity)
23. `withdrawProtocolSink`
24. `setParameter`
25. `getParameter` (view - useful)
26. `getContractBalance` (view)
27. `transferOwnership`
28. `renounceOwnership`
29. `canDecayArtifact(uint256 tokenId)`: View function to check if an artifact is eligible for decay calculation now.
30. `triggerDecayCalculation(uint256 tokenId)`: Public function allowing anyone to trigger the decay state update if eligible (similar to `decayArtifact` concept).

Okay, 30+ functions, covering ERC721 basics, dynamic state, resource management concepts, crafting, and parameter control. This looks like a solid foundation for an advanced/creative concept.

Let's implement the Resonance concept simply: users accumulate Resonance based on how long they own artifacts, and `harvestResonance` calculates and updates their balance. Resonance is then consumed by other functions. Decay is applied when viewing current stats or explicitly triggered.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Still useful for clarity in some places

// --- OUTLINE ---
// 1. License and Pragma
// 2. Imports: ERC721, Ownable, Counters, SafeMath
// 3. Error Definitions
// 4. Events: Track key lifecycle and state changes.
// 5. Structs: Artifact definition.
// 6. Enum: Parameter types for configuration.
// 7. State Variables: Mappings for artifacts, counters, parameters, resonance, etc.
// 8. Modifiers: Access control, state checks.
// 9. Constructor: Initialize contract, ERC721, owner, base parameters.
// 10. ERC721 Core Functions: Implementation of standard ERC721 methods.
// 11. Artifact Management & Interaction Functions:
//     - Minting new artifacts (cost, initial traits).
//     - Viewing artifact details (static and calculated).
//     - Nourishing/Maintaining (counteract decay, reset timers).
//     - Empowering (boost specific traits).
//     - Reconstructing (random stat modification, cost).
//     - Fusing (combine two into one, burn originals, complex stat calculation).
//     - Sacrificing (burn artifact, maybe small gain).
//     - Triggering decay calculation.
// 12. Resonance Resource Functions:
//     - Tracking user Resonance balance.
//     - Harvesting Resonance (claim accumulated amount).
//     - Internal functions to check/consume Resonance.
// 13. Protocol Sink & Parameter Functions:
//     - Viewing contract ETH balance (sink).
//     - Withdrawing from sink (owner).
//     - Setting/Getting configurable parameters.
// 14. Utility & Helper Functions:
//     - Existence checks.
//     - Time/decay calculations.
//     - Pseudo-randomness simulation (with warning).
//     - TokenURI logic.

// --- FUNCTION SUMMARY ---
// constructor() - Initialize contract.
// supportsInterface(bytes4 interfaceId) - ERC165 support.
// balanceOf(address owner) - ERC721: Get artifact count for owner.
// ownerOf(uint256 tokenId) - ERC721: Get owner of token.
// safeTransferFrom(address from, address to, uint256 tokenId) - ERC721: Safe transfer.
// safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) - ERC721: Safe transfer with data.
// transferFrom(address from, address to, uint256 tokenId) - ERC721: Basic transfer.
// approve(address to, uint256 tokenId) - ERC721: Approve address for token.
// getApproved(uint256 tokenId) - ERC721: Get approved address.
// setApprovalForAll(address operator, bool approved) - ERC721: Set operator status.
// isApprovedForAll(address owner, address operator) - ERC721: Check operator status.
// tokenURI(uint256 tokenId) - ERC721: Get metadata URI.
// totalSupply() - Get total minted artifacts.
// artifactExists(uint256 tokenId) - Check if artifact exists.
// _calculateDecayAmount(uint256 _lastInteractionTime, uint256 _decayRate) - Calculate decay based on time.
// _pseudoRandom(uint256 seed) - Simple (insecure) randomness helper.
// _calculateResonanceGeneration(address user) - Calculate pending Resonance for user.
// mintArtifact(string memory initialMetadataURI) payable - Mint a new artifact.
// getArtifactDetails(uint256 tokenId) view - Get static stored artifact data.
// calculateCurrentStats(uint256 tokenId) view - Get stats with current decay applied.
// canTriggerDecay(uint256 tokenId) view - Check if decay calculation is due.
// triggerDecayCalculation(uint256 tokenId) - Apply decay to artifact state (anyone can call if due).
// nourishArtifact(uint256 tokenId) - Reset decay timer, minor stats boost. Requires Resonance.
// empowerArtifact(uint256 tokenId, uint256 powerBoost) - Boost Power trait. Requires Resonance.
// reconstructArtifact(uint256 tokenId) payable - Randomly alter stats significantly. Requires ETH.
// fuseArtifacts(uint256 tokenId1, uint256 tokenId2, string memory newTokenMetadataURI) payable - Burn two, mint one new artifact. Complex stat derivation. Requires ETH & Resonance.
// sacrificeArtifact(uint256 tokenId) - Burn an artifact.
// harvestResonance() - Claim accumulated Resonance.
// getUserResonance(address user) view - Get user's current Resonance balance.
// withdrawProtocolSink(uint256 amount) onlyOwner - Withdraw ETH from contract.
// setParameter(ParameterType param, uint256 value) onlyOwner - Set configurable parameters.
// getParameter(ParameterType param) view - Get configurable parameter value.
// getContractBalance() view - Get contract's ETH balance.
// transferOwnership(address newOwner) onlyOwner - Transfer contract ownership.
// renounceOwnership() onlyOwner - Renounce contract ownership.


contract AetherialForges is ERC721, Ownable {
    using Counters for Counters.Counter;
    using SafeMath for uint256; // Using SafeMath explicitly for complex arithmetic clarity, though overflow checks are built into 0.8+

    // --- Errors ---
    error ArtifactDoesNotExist(uint256 tokenId);
    error NotArtifactOwnerOrApproved(uint256 tokenId);
    error ArtifactAlreadyExists(uint256 tokenId); // Should not happen with counter
    error InvalidParameter(uint256 paramIndex);
    error InsufficientResonance(uint256 required, uint256 available);
    error InsufficientEth(uint256 required, uint256 available);
    error DecayNotDue(uint256 tokenId);
    error CannotFuseSameArtifact();
    error CannotFuseUnownedArtifacts();
    error InvalidFusionCombination(); // Or some specific fusion rule violated
    error CannotWithdrawMoreThanBalance(uint256 requested, uint256 available);

    // --- Events ---
    event ArtifactMinted(uint256 indexed tokenId, address indexed owner, uint256 initialPower, uint256 initialStability, uint256 initialHarmony, uint256 initialEntropy);
    event ArtifactStatsUpdated(uint256 indexed tokenId, uint256 newPower, uint256 newStability, uint256 newHarmony, uint256 newEntropy, string reason);
    event ArtifactDecayed(uint256 indexed tokenId, uint256 decayAmount, uint256 newEntropy);
    event ArtifactNourished(uint256 indexed tokenId, uint256 resonanceUsed);
    event ArtifactEmpowered(uint256 indexed tokenId, uint256 powerBoost, uint256 resonanceUsed);
    event ArtifactReconstructed(uint256 indexed tokenId, uint256 ethCost);
    event ArtifactFused(uint256 indexed newTokenId, uint256 indexed oldTokenId1, uint256 indexed oldTokenId2, uint256 ethCost, uint256 resonanceUsed);
    event ArtifactSacrificed(uint256 indexed tokenId, address indexed owner);
    event ParameterChanged(uint256 indexed paramType, uint256 newValue);
    event ProtocolSinkWithdrawn(address indexed receiver, uint256 amount);
    event ResonanceHarvested(address indexed user, uint256 amount);
    event ResonanceSpent(address indexed user, uint256 amount);


    // --- Structs ---
    struct Artifact {
        uint256 power;      // Affects effectiveness in certain operations (conceptually)
        uint256 stability;  // Resistance to decay, affects stat floor
        uint256 harmony;    // Affects Resonance generation or specific interactions
        uint256 entropy;    // Increases over time, negatively impacts stats or requires maintenance

        uint256 creationTime;       // Timestamp of creation
        uint256 lastInteractionTime; // Timestamp of last Nourish/Reconstruct/Fuse
        uint256 lastDecayCalculationTime; // Timestamp when decay was last applied to state

        uint256 resonanceHarvestedAmount; // Total resonance harvested by this artifact owner from this artifact (complex, let's track resonance per user instead)
        // bool isStaked; // Could add for staking mechanics, deferred for simplicity

        string metadataURI; // Base metadata URI
    }

    // --- State Variables ---
    Counters.Counter private _tokenIdCounter; // Tracks total number of artifacts minted
    mapping(uint256 => Artifact) private _artifacts; // Stores artifact data by token ID
    mapping(address => uint256) private _userResonanceBalance; // Tracks user's accumulated Resonance

    // Timestamp when a user last harvested Resonance (used for calculation)
    mapping(address => uint256) private _userLastResonanceHarvestTime;

    // Configurable Parameters
    enum ParameterType {
        MintCostEth,
        BaseDecayRatePerDay, // Decay added to Entropy per day
        MaxEntropy,
        NourishResonanceCost,
        EmpowerResonanceCostPerPoint,
        ReconstructEthCost,
        FuseEthCost,
        FuseResonanceCost,
        ResonanceGenerationRatePerHour // Resonance generated per artifact owner per hour (simplified)
    }

    mapping(ParameterType => uint256) private _parameters;

    // --- Modifiers ---
    modifier whenArtifactExists(uint256 tokenId) {
        if (!_exists(tokenId)) { // Uses ERC721 _exists
            revert ArtifactDoesNotExist(tokenId);
        }
        _;
    }

    modifier onlyOwnerOfArtifact(uint256 tokenId) {
        if (ownerOf(tokenId) != _msgSender()) {
             revert NotArtifactOwnerOrApproved(tokenId);
        }
        _;
    }

    modifier canInteractWithArtifact(uint256 tokenId) {
        address artifactOwner = ownerOf(tokenId);
        if (artifactOwner != _msgSender() && !isApprovedForAll(artifactOwner, _msgSender())) {
             revert NotArtifactOwnerOrApproved(tokenId);
        }
        _;
    }

    modifier sufficientResonance(uint256 requiredAmount) {
        if (_userResonanceBalance[_msgSender()] < requiredAmount) {
            revert InsufficientResonance(requiredAmount, _userResonanceBalance[_msgSender()]);
        }
        _;
    }

    // --- Constructor ---
    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(_msgSender()) {
        // Set initial parameters
        _parameters[ParameterType.MintCostEth] = 0.1 ether; // Example cost to mint
        _parameters[ParameterType.BaseDecayRatePerDay] = 10; // Base Entropy increase per day
        _parameters[ParameterType.MaxEntropy] = 1000; // Max possible Entropy before potential issues
        _parameters[ParameterType.NourishResonanceCost] = 50; // Resonance cost to Nourish
        _parameters[ParameterType.EmpowerResonanceCostPerPoint] = 5; // Resonance cost per Power point
        _parameters[ParameterType.ReconstructEthCost] = 0.05 ether; // ETH cost to Reconstruct
        _parameters[ParameterType.FuseEthCost] = 0.2 ether; // ETH cost to Fuse
        _parameters[ParameterType.FuseResonanceCost] = 200; // Resonance cost to Fuse
        _parameters[ParameterType.ResonanceGenerationRatePerHour] = 10; // Resonance generated per hour per artifact owner

        // Set initial last harvest time for owner to now (or block.timestamp)
        _userLastResonanceHarvestTime[owner()] = block.timestamp;
    }

    // --- ERC721 Core Functions ---
    // (Implemented by inheriting ERC721, no need to redefine unless overriding)
    // The standard ERC721 functions like balanceOf, ownerOf, safeTransferFrom, approve, getApproved,
    // setApprovalForAll, isApprovedForAll are automatically available.

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721)
        whenArtifactExists(tokenId)
        returns (string memory)
    {
        // We store a base URI per artifact, dynamic data would be fetched off-chain
        // using calculateCurrentStats and combined with this base URI's metadata.
        return _artifacts[tokenId].metadataURI;
    }

    function totalSupply() public view returns (uint256) {
        return _tokenIdCounter.current();
    }

    // --- Utility & Helper Functions ---

    function artifactExists(uint256 tokenId) public view returns (bool) {
        return _exists(tokenId); // Uses ERC721 _exists
    }

    /**
     * @dev Calculates the amount of entropy increase based on time elapsed.
     * This is a pure calculation based on time and rate.
     * @param _lastInteractionTime The timestamp of the last user interaction.
     * @param _decayRate The base decay rate per day.
     * @return The calculated entropy increase.
     */
    function _calculateDecayAmount(uint256 _lastInteractionTime, uint256 _decayRate) internal view returns (uint256) {
        uint256 timeElapsed = block.timestamp.sub(_lastInteractionTime);
        // Calculate decay based on days passed. Using 1 day = 86400 seconds.
        // Example: decay = days_elapsed * decay_rate
        // Time is uint, division truncates. This means decay only applies in full 'day' increments.
        uint256 daysElapsed = timeElapsed.div(86400);
        return daysElapsed.mul(_decayRate);
    }

     /**
      * @dev Provides a simple, insecure pseudo-random number based on block data.
      * WARNING: Do NOT use for security-sensitive operations in production.
      * Attackers can manipulate block data to influence outcomes. Use Chainlink VRF or similar for secure randomness.
      * @param seed A seed value, typically block.timestamp or block.number.
      * @return A pseudo-random uint256.
      */
    function _pseudoRandom(uint256 seed) internal view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, block.number, msg.sender, seed)));
    }

    /**
     * @dev Calculates the Resonance accumulated by a user since their last harvest.
     * This is a conceptual calculation based on time and fixed rate per owner (can be extended per artifact).
     * @param user The address of the user.
     * @return The pending Resonance amount.
     */
    function _calculateResonanceGeneration(address user) internal view returns (uint256) {
        uint256 lastHarvest = _userLastResonanceHarvestTime[user];
        if (lastHarvest == 0) {
             // First time interacting or harvesting, start timer now.
             // No Resonance generated yet.
             return 0;
        }
        uint256 timeElapsed = block.timestamp.sub(lastHarvest);
        uint256 generationRate = _parameters[ParameterType.ResonanceGenerationRatePerHour]; // Rate per hour

        // Calculate resonance based on hours passed
        uint256 hoursElapsed = timeElapsed.div(3600); // 1 hour = 3600 seconds
        return hoursElapsed.mul(generationRate);
    }

     /**
      * @dev Internal function to spend a user's Resonance.
      * @param user The user spending Resonance.
      * @param amount The amount to spend.
      */
    function _spendResonance(address user, uint256 amount) internal {
        _userResonanceBalance[user] = _userResonanceBalance[user].sub(amount);
        emit ResonanceSpent(user, amount);
    }

    // --- Artifact Management & Interaction Functions ---

    /**
     * @dev Mints a new artifact for the caller.
     * Requires sending `MintCostEth` amount of ETH.
     * Assigns initial random-ish stats and records timestamps.
     * @param initialMetadataURI The base metadata URI for the new artifact.
     */
    function mintArtifact(string memory initialMetadataURI) public payable {
        uint256 mintCost = _parameters[ParameterType.MintCostEth];
        if (msg.value < mintCost) {
            revert InsufficientEth(mintCost, msg.value);
        }

        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();
        address minter = _msgSender();
        uint256 currentTime = block.timestamp;

        // Simple pseudo-random initial stats (INSECURE for production)
        uint256 seed = newTokenId.add(currentTime).add(uint256(uint160(minter)));
        uint256 random1 = _pseudoRandom(seed);
        uint256 random2 = _pseudoRandom(random1);
        uint256 random3 = _pseudoRandom(random2);
        uint256 random4 = _pseudoRandom(random3);

        // Initial stats are based on randomness, scaled, and capped
        uint256 initialPower = 50 + (random1 % 50); // 50-99
        uint256 initialStability = 60 + (random2 % 40); // 60-99
        uint256 initialHarmony = 70 + (random3 % 30); // 70-99
        uint256 initialEntropy = random4 % 20; // 0-19 (low initial entropy)

        _artifacts[newTokenId] = Artifact({
            power: initialPower,
            stability: initialStability,
            harmony: initialHarmony,
            entropy: initialEntropy,
            creationTime: currentTime,
            lastInteractionTime: currentTime,
            lastDecayCalculationTime: currentTime,
            resonanceHarvestedAmount: 0, // Placeholder
            metadataURI: initialMetadataURI
        });

        _safeMint(minter, newTokenId);

        // Send any excess ETH back
        if (msg.value > mintCost) {
            payable(minter).transfer(msg.value.sub(mintCost));
        }

        emit ArtifactMinted(newTokenId, minter, initialPower, initialStability, initialHarmony, initialEntropy);
    }

    /**
     * @dev Gets the static, stored details of an artifact. Does NOT apply current decay.
     * @param tokenId The ID of the artifact.
     * @return Artifact struct data.
     */
    function getArtifactDetails(uint256 tokenId)
        public
        view
        whenArtifactExists(tokenId)
        returns (Artifact memory)
    {
        return _artifacts[tokenId];
    }

    /**
     * @dev Calculates the current effective stats of an artifact by applying decay.
     * This is a view function and does NOT modify the artifact's state.
     * To update the state with decay, use `triggerDecayCalculation`.
     * @param tokenId The ID of the artifact.
     * @return power, stability, harmony, entropy after applying decay.
     */
    function calculateCurrentStats(uint256 tokenId)
        public
        view
        whenArtifactExists(tokenId)
        returns (uint256 power, uint256 stability, uint256 harmony, uint256 entropy)
    {
        Artifact memory artifact = _artifacts[tokenId];
        uint256 baseDecayRate = _parameters[ParameterType.BaseDecayRatePerDay];

        // Calculate potential entropy increase since last interaction (or creation if no interaction)
        uint256 potentialEntropyIncrease = _calculateDecayAmount(artifact.lastInteractionTime, baseDecayRate);

        // The current entropy is the stored entropy plus the potential increase, capped by MaxEntropy
        uint256 currentEntropy = artifact.entropy.add(potentialEntropyIncrease);
        if (currentEntropy > _parameters[ParameterType.MaxEntropy]) {
            currentEntropy = _parameters[ParameterType.MaxEntropy];
        }

        // Stats are affected by entropy (example formulas)
        // Higher entropy reduces Power and Stability
        uint256 powerPenalty = currentEntropy.div(10); // Example: 1 Power lost per 10 Entropy
        uint256 stabilityPenalty = currentEntropy.div(8); // Example: 1 Stability lost per 8 Entropy

        power = artifact.power > powerPenalty ? artifact.power.sub(powerPenalty) : 0;
        stability = artifact.stability > stabilityPenalty ? artifact.stability.sub(stabilityPenalty) : 0;
        harmony = artifact.harmony; // Harmony might not be directly affected by Entropy decay
        entropy = currentEntropy;

        return (power, stability, harmony, entropy);
    }

    /**
     * @dev Checks if an artifact is eligible for a state decay calculation update.
     * This prevents constant calls to update state if decay isn't due.
     * @param tokenId The ID of the artifact.
     * @return True if decay state can be updated, false otherwise.
     */
    function canTriggerDecay(uint256 tokenId)
        public
        view
        whenArtifactExists(tokenId)
        returns (bool)
    {
         Artifact storage artifact = _artifacts[tokenId];
         uint256 baseDecayRate = _parameters[ParameterType.BaseDecayRatePerDay];
         // Decay is due if enough time has passed since the last interaction/calculation
         // to cause at least one unit of decay according to the base rate.
         // We calculate the potential decay based on last interaction time for consistency
         // with calculateCurrentStats view, ensuring state update reflects that.
         uint224 timeElapsed = uint224(block.timestamp.sub(artifact.lastInteractionTime));
         uint256 decayDue = timeElapsed.div(86400).mul(baseDecayRate);

         // Also consider time since last *state* update. If decay has accrued since then, update is possible.
         // This handles cases where calculateCurrentStats shows decay, but lastInteractionTime is old
         // but lastDecayCalculationTime was more recent.
         uint224 timeSinceLastCalc = uint224(block.timestamp.sub(artifact.lastDecayCalculationTime));
         uint256 decaySinceLastCalc = timeSinceLastCalc.div(86400).mul(baseDecayRate);


         // Decay can be triggered if either potential decay from last interaction
         // *or* decay since last *state* calculation has accumulated.
         // A simpler rule: just check time since last *state* calculation.
         // If enough time for at least 1 unit of decay has passed since last calc, trigger is allowed.
         uint256 timeSinceLastStateCalc = block.timestamp.sub(artifact.lastDecayCalculationTime);
         return timeSinceLastStateCalc.div(86400).mul(baseDecayRate) > 0;
    }

    /**
     * @dev Triggers the decay calculation and updates the artifact's state.
     * Can be called by anyone, but only updates state if enough time has passed
     * since the last state update (as checked by `canTriggerDecay`).
     * This effectively "bakes in" the accrued entropy.
     * @param tokenId The ID of the artifact.
     */
    function triggerDecayCalculation(uint256 tokenId)
        public
        whenArtifactExists(tokenId)
    {
        Artifact storage artifact = _artifacts[tokenId];

        // Check if decay update is actually due to prevent unnecessary calls
        if (!canTriggerDecay(tokenId)) {
             revert DecayNotDue(tokenId);
        }

        uint256 baseDecayRate = _parameters[ParameterType.BaseDecayRatePerDay];

        // Calculate entropy increase since the last STATE update
        uint256 timeElapsedSinceLastCalc = block.timestamp.sub(artifact.lastDecayCalculationTime);
        uint256 entropyIncrease = timeElapsedSinceLastCalc.div(86400).mul(baseDecayRate);

        artifact.entropy = artifact.entropy.add(entropyIncrease);
        uint256 maxEntropy = _parameters[ParameterType.MaxEntropy];
         if (artifact.entropy > maxEntropy) {
            artifact.entropy = maxEntropy;
        }

        artifact.lastDecayCalculationTime = block.timestamp; // Update the state calculation time

        // Note: The *effective* stats seen via `calculateCurrentStats` still use `lastInteractionTime`
        // for decay calculation, which might be older. This function specifically updates the *base* entropy state.
        // This design allows decay to accrue visibly in the view function, and then be periodically
        // "committed" to the artifact's permanent state by calling this function.

        emit ArtifactDecayed(tokenId, entropyIncrease, artifact.entropy);
        // No need to emit StatsUpdated here unless other stats are directly affected by this state update
        // independent of the `calculateCurrentStats` view logic.
    }


    /**
     * @dev Allows the owner or approved operator to nourish an artifact.
     * Resets the internal decay timer (lastInteractionTime), adds a small boost to Stability/Harmony,
     * and costs Resonance.
     * @param tokenId The ID of the artifact.
     */
    function nourishArtifact(uint256 tokenId)
        public
        whenArtifactExists(tokenId)
        canInteractWithArtifact(tokenId)
        sufficientResonance(_parameters[ParameterType.NourishResonanceCost])
    {
        Artifact storage artifact = _artifacts[tokenId];
        uint256 resonanceCost = _parameters[ParameterType.NourishResonanceCost];

        _spendResonance(_msgSender(), resonanceCost);

        artifact.lastInteractionTime = block.timestamp; // Reset decay timer

        // Small boost to Stability and Harmony
        artifact.stability = artifact.stability.add(5); // Example boost
        artifact.harmony = artifact.harmony.add(3); // Example boost
        // Prevent stats from exceeding a reasonable cap (e.g., 200) - add cap logic if needed

        emit ArtifactNourished(tokenId, resonanceCost);
        emit ArtifactStatsUpdated(tokenId, artifact.power, artifact.stability, artifact.harmony, artifact.entropy, "Nourished");
    }

    /**
     * @dev Allows the owner or approved operator to empower an artifact, increasing its Power.
     * Costs Resonance based on the desired boost amount.
     * @param tokenId The ID of the artifact.
     * @param powerBoost The amount to increase Power by.
     */
    function empowerArtifact(uint256 tokenId, uint256 powerBoost)
        public
        whenArtifactExists(tokenId)
        canInteractWithArtifact(tokenId)
        sufficientResonance(powerBoost.mul(_parameters[ParameterType.EmpowerResonanceCostPerPoint]))
    {
        require(powerBoost > 0, "Power boost must be positive");
        Artifact storage artifact = _artifacts[tokenId];
        uint256 resonanceCost = powerBoost.mul(_parameters[ParameterType.EmpowerResonanceCostPerPoint]);

        _spendResonance(_msgSender(), resonanceCost);

        artifact.power = artifact.power.add(powerBoost);
         // Prevent stats from exceeding a reasonable cap (e.g., 200) - add cap logic if needed

        emit ArtifactEmpowered(tokenId, powerBoost, resonanceCost);
         emit ArtifactStatsUpdated(tokenId, artifact.power, artifact.stability, artifact.harmony, artifact.entropy, "Empowered");
    }


    /**
     * @dev Allows the owner or approved operator to reconstruct an artifact.
     * A more drastic operation that randomly alters all stats. Costs ETH.
     * Resets interaction timer. Uses pseudo-randomness (WARNING: INSECURE).
     * @param tokenId The ID of the artifact.
     */
    function reconstructArtifact(uint256 tokenId)
        public
        payable
        whenArtifactExists(tokenId)
        canInteractWithArtifact(tokenId)
    {
        uint256 ethCost = _parameters[ParameterType.ReconstructEthCost];
        if (msg.value < ethCost) {
            revert InsufficientEth(ethCost, msg.value);
        }

        Artifact storage artifact = _artifacts[tokenId];
        uint256 currentTime = block.timestamp;

        // Apply state decay *before* reconstructing based on time since last state update
        // This ensures decay isn't bypassed by reconstructing.
        triggerDecayCalculation(tokenId); // This will revert if not due, which is fine.

        // Use pseudo-randomness for new stats (INSECURE)
        uint256 seed = tokenId.add(currentTime).add(uint256(uint160(_msgSender()))).add(block.number);
        uint256 random1 = _pseudoRandom(seed);
        uint256 random2 = _pseudoRandom(random1);
        uint256 random3 = _pseudoRandom(random2);
        uint256 random4 = _pseudoRandom(random3);

        // New stats based on randomness, potentially influenced by old stats or capped
        // Example: new stat = (old stat * factor + random_component) / divisor
        artifact.power = (artifact.power.mul(7).add(random1 % 100)).div(10).add(10); // Example formula
        artifact.stability = (artifact.stability.mul(6).add(random2 % 100)).div(10).add(10); // Example formula
        artifact.harmony = (artifact.harmony.mul(8).add(random3 % 100)).div(10).add(10); // Example formula
        artifact.entropy = (artifact.entropy.div(2)).add(random4 % 50); // Entropy might be partially reduced + new random entropy

        // Add capping logic if needed (e.g., max 200 for Power/Stability/Harmony, maxEntropy for Entropy)
        uint256 maxEntropy = _parameters[ParameterType.MaxEntropy];
        if (artifact.entropy > maxEntropy) artifact.entropy = maxEntropy;


        artifact.lastInteractionTime = currentTime; // Reset decay timer
        // lastDecayCalculationTime is already updated by triggerDecayCalculation

        // Send any excess ETH back
        if (msg.value > ethCost) {
            payable(_msgSender()).transfer(msg.value.sub(ethCost));
        }

        emit ArtifactReconstructed(tokenId, ethCost);
        emit ArtifactStatsUpdated(tokenId, artifact.power, artifact.stability, artifact.harmony, artifact.entropy, "Reconstructed");
    }


    /**
     * @dev Allows the owner to fuse two artifacts into a new, potentially more powerful one.
     * Burns the two original artifacts and mints a new one with stats derived from the originals.
     * Complex operation requiring ETH and Resonance. Uses pseudo-randomness (WARNING: INSECURE).
     * @param tokenId1 The ID of the first artifact to fuse.
     * @param tokenId2 The ID of the second artifact to fuse.
     * @param newTokenMetadataURI The base metadata URI for the resulting fused artifact.
     */
    function fuseArtifacts(uint256 tokenId1, uint256 tokenId2, string memory newTokenMetadataURI)
        public
        payable
        whenArtifactExists(tokenId1)
        whenArtifactExists(tokenId2)
        sufficientResonance(_parameters[ParameterType.FuseResonanceCost])
    {
        require(tokenId1 != tokenId2, "Cannot fuse an artifact with itself");

        address owner = _msgSender();
        require(ownerOf(tokenId1) == owner && ownerOf(tokenId2) == owner, "Caller must own both artifacts");

        uint256 ethCost = _parameters[ParameterType.FuseEthCost];
         if (msg.value < ethCost) {
            revert InsufficientEth(ethCost, msg.value);
        }
        uint256 resonanceCost = _parameters[ParameterType.FuseResonanceCost];

        _spendResonance(owner, resonanceCost);

        // Apply state decay to both artifacts *before* fusing
        // This ensures decay isn't bypassed by fusing.
        // We wrap calls in try/catch in case decay isn't due, but still want fusion to proceed.
        try this.triggerDecayCalculation(tokenId1) {} catch {}
        try this.triggerDecayCalculation(tokenId2) {} catch {}


        Artifact memory art1 = _artifacts[tokenId1];
        Artifact memory art2 = _artifacts[tokenId2];

        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();
        uint256 currentTime = block.timestamp;

        // --- Complex Fusion Stat Derivation Logic (Example) ---
        // New stats are a combination, maybe average or sum, with potential bonuses/penalties
        // based on original stats and a random factor. Entropy could be reduced.
        uint256 seed = tokenId1.add(tokenId2).add(currentTime).add(uint256(uint160(owner))).add(block.number);
        uint256 randomFactor = _pseudoRandom(seed);

        uint256 newPower = (art1.power.add(art2.power)).div(2).add(randomFactor % 30); // Average + bonus
        uint256 newStability = (art1.stability.add(art2.stability)).div(2).add(randomFactor % 20); // Average + bonus
        uint256 newHarmony = art1.harmony.add(art2.harmony); // Sum Harmony
        uint256 newEntropy = (art1.entropy.add(art2.entropy)).div(3); // Average, but reduced

        // Add capping logic if needed
        uint256 maxEntropy = _parameters[ParameterType.MaxEntropy];
         if (newEntropy > maxEntropy) newEntropy = maxEntropy;

        _artifacts[newTokenId] = Artifact({
            power: newPower,
            stability: newStability,
            harmony: newHarmony,
            entropy: newEntropy,
            creationTime: currentTime,
            lastInteractionTime: currentTime, // New artifact starts fresh
            lastDecayCalculationTime: currentTime,
            resonanceHarvestedAmount: 0, // Placeholder
            metadataURI: newTokenMetadataURI
        });
        // --- End Fusion Stat Derivation ---


        // Burn the original artifacts
        _burn(tokenId1);
        delete _artifacts[tokenId1]; // Clean up storage for burned tokens
        _burn(tokenId2);
        delete _artifacts[tokenId2]; // Clean up storage for burned tokens

        // Mint the new artifact
        _safeMint(owner, newTokenId);

        // Send any excess ETH back
        if (msg.value > ethCost) {
            payable(owner).transfer(msg.value.sub(ethCost));
        }

        emit ArtifactFused(newTokenId, tokenId1, tokenId2, ethCost, resonanceCost);
        emit ArtifactMinted(newTokenId, owner, newPower, newStability, newHarmony, newEntropy); // Also emit minted for the new token
    }

    /**
     * @dev Allows the owner or approved operator to sacrifice an artifact.
     * Permanently burns the artifact.
     * @param tokenId The ID of the artifact to sacrifice.
     */
    function sacrificeArtifact(uint256 tokenId)
        public
        whenArtifactExists(tokenId)
        canInteractWithArtifact(tokenId)
    {
        address owner = ownerOf(tokenId);
        _burn(tokenId);
        delete _artifacts[tokenId]; // Clean up storage for burned token

        // Could add a small Resonance gain here for sacrificing, or a small stat boost to *other* artifacts owned by the user
        // Example: _userResonanceBalance[owner] = _userResonanceBalance[owner].add(artifact.entropy / 10);

        emit ArtifactSacrificed(tokenId, owner);
    }


    // --- Resonance Resource Functions ---

    /**
     * @dev Harvests accumulated Resonance for the caller.
     * Calculates Resonance based on time since last harvest and updates balance.
     */
    function harvestResonance() public {
        address user = _msgSender();
        uint256 pendingResonance = _calculateResonanceGeneration(user);

        if (pendingResonance > 0) {
            _userResonanceBalance[user] = _userResonanceBalance[user].add(pendingResonance);
            _userLastResonanceHarvestTime[user] = block.timestamp; // Update last harvest time
            emit ResonanceHarvested(user, pendingResonance);
        } else {
            // If no pending resonance, just update the harvest time to now to start accrual
            // or if it's the first time, initialize it.
             if(_userLastResonanceHarvestTime[user] == 0) {
                 _userLastResonanceHarvestTime[user] = block.timestamp;
             }
        }
    }

    /**
     * @dev Gets the current Resonance balance of a user (including pending, not yet harvested).
     * @param user The address of the user.
     * @return The total Resonance balance (current + pending).
     */
    function getUserResonance(address user) public view returns (uint256) {
        uint256 currentBalance = _userResonanceBalance[user];
        uint256 pending = _calculateResonanceGeneration(user);
        return currentBalance.add(pending);
    }


    // --- Protocol Sink & Parameter Functions ---

    /**
     * @dev Allows the owner to withdraw ETH from the contract's balance (the protocol sink).
     * @param amount The amount of ETH to withdraw.
     */
    function withdrawProtocolSink(uint256 amount) public onlyOwner {
        if (amount > address(this).balance) {
            revert CannotWithdrawMoreThanBalance(amount, address(this).balance);
        }
        payable(owner()).transfer(amount);
        emit ProtocolSinkWithdrawn(owner(), amount);
    }

    /**
     * @dev Allows the owner to set configurable protocol parameters.
     * @param param The parameter type (enum).
     * @param value The new value for the parameter.
     */
    function setParameter(ParameterType param, uint256 value) public onlyOwner {
        // Basic validation for reasonable values could be added here
        // e.g., require(value > 0, "Parameter value must be positive");

        _parameters[param] = value;
        emit ParameterChanged(uint256(param), value);
    }

    /**
     * @dev Gets the current value of a configurable parameter.
     * @param param The parameter type (enum).
     * @return The parameter value.
     */
    function getParameter(ParameterType param) public view returns (uint256) {
        return _parameters[param];
    }

     /**
      * @dev Gets the current ETH balance of the contract (the protocol sink).
      */
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }

    // --- Ownable Functions ---
    // transferOwnership and renounceOwnership are provided by inheriting Ownable
}
```

**Explanation of Advanced/Interesting Concepts & Functions:**

1.  **Dynamic On-Chain Traits (`Artifact` struct, `power`, `stability`, `harmony`, `entropy`):** Unlike typical NFTs where metadata is static or off-chain, key attributes are stored and modified within the smart contract itself.
2.  **Time-Based Decay (`entropy`, `lastInteractionTime`, `_calculateDecayAmount`, `calculateCurrentStats`, `triggerDecayCalculation`):** Introduces a maintenance mechanic. Artifacts degrade (increase entropy) over time unless users interact with them. `calculateCurrentStats` provides a *view* of decay, while `triggerDecayCalculation` *commits* this decay to the artifact's state, making it visible in `getArtifactDetails` over time. Anyone can trigger decay calculation if due, encouraging network participation.
3.  **Resource Management (`Resonance` concept, `_userResonanceBalance`, `harvestResonance`, `_calculateResonanceGeneration`, `_spendResonance`):** Introduces an internal, non-transferable (in this simplified version) resource generated by engaging with the protocol (owning artifacts over time). This resource is required as a cost for specific advanced operations.
4.  **Multiple Interaction Types (`nourishArtifact`, `empowerArtifact`, `reconstructArtifact`, `fuseArtifacts`):** Provides distinct ways for users to interact with and influence their assets, each with different costs (ETH/Resonance) and outcomes (counteracting decay, boosting specific stats, random transformation, creation of new assets).
5.  **Complex State Transitions (`reconstructArtifact`, `fuseArtifacts`):** These functions involve significant state changes, burning/minting tokens, and potentially complex calculations for deriving new stats, introducing elements of crafting or evolution. Fusion, in particular, is a creative mechanic for combining assets.
6.  **Protocol Sink (`payable` functions, `withdrawProtocolSink`, `getContractBalance`):** A portion of the value (ETH) used in operations like minting, reconstructing, and fusing is collected within the contract, creating a pool that could eventually be controlled by governance or used for other protocol purposes.
7.  **Configurable Parameters (`ParameterType` enum, `_parameters` mapping, `setParameter`, `getParameter`):** Allows the contract owner (or a future governance module) to adjust core mechanics like costs, decay rates, and generation rates without deploying a new contract. This adds flexibility and potential for protocol evolution.
8.  **Pseudorandomness (`_pseudoRandom`):** Used in `reconstructArtifact` and `fuseArtifacts` to introduce unpredictable outcomes, making crafting more of a gamble or unique process. **Crucially, the insecure nature of block-based randomness is noted.** In a production system, Chainlink VRF or similar would be essential.
9.  **Gas Efficiency Consideration (`triggerDecayCalculation`):** Separating the *calculation* of current stats (view function `calculateCurrentStats`) from the *state update* (transaction function `triggerDecayCalculation`) allows users to see the decay effect without paying gas, and allows the state update to be batched or triggered by the protocol or other users when gas is cheaper or when an action is dependent on the current baked-in state.
10. **Detailed Events and Errors:** Helps off-chain applications track state changes and provides clear feedback to users in case of failure.

This contract provides a framework for a dynamic, interactive NFT-like system with multiple avenues for user engagement and asset evolution, going beyond simple buy/sell/transfer mechanics.