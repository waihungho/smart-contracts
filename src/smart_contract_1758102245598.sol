This smart contract, `AetherStrategyEngine`, introduces a novel approach to decentralized asset management by integrating **intent-based finance**, **AI-assisted strategy generation**, **dynamic multi-step execution**, and **reputation-gated governance**. Users declare their investment intents, and AI oracles (whitelisted entities) propose sophisticated, multi-step strategies designed to fulfill these intents. The community, empowered by non-transferable "Reputation Tokens" (Soulbound Tokens - SBTs), votes on these proposals. Approved strategies become active, executing a series of predefined DeFi interactions over time via authorized relayers. This design aims to provide a highly adaptive, community-driven, and intelligently-guided investment vehicle, moving beyond static vaults to a dynamic, evolving strategy engine.

---

## AetherStrategyEngine Smart Contract

### Outline

1.  **Libraries & Interfaces:** Standard ERC20, custom Reputation SBT interface, SafeERC20 for secure token transfers.
2.  **State Variables:** Core addresses (governance, oracle, reputation NFT), mappings for user deposits and shares, strategy proposals, active strategies, user intents, protocol fees, and access control flags.
3.  **Struct Definitions:**
    *   `StrategyStep`: Defines a single atomic action within a strategy.
    *   `StrategyProposal`: Details for a proposed strategy, including its steps, voting status, and metadata.
    *   `ActiveStrategy`: Represents an instance of an approved and running strategy, managing user funds and tracking execution.
    *   `UserIntent`: Stores a user's declared investment objectives.
4.  **Events:** To log all critical actions for transparency and off-chain monitoring.
5.  **Modifiers:** `onlyGovernance`, `onlyStrategyOracle`, `onlyRelayer`, `whenNotPaused` for access control and emergency states.
6.  **Functions (20+):** Grouped into logical categories for clarity.

### Function Summary

*   **Initialization & Core Vault Operations:**
    *   `initialize(address _governance, address _strategyOracle, address _reputationNFT, address _relayer)`: Sets up the core parameters and roles of the engine upon deployment (for upgradeable contracts).
    *   `deposit(address _asset, uint256 _amount, bytes32 _intentHash)`: Allows users to deposit assets, linking their deposit to a specific, declared investment intent.
    *   `withdraw(address _asset, uint256 _amount, bytes32 _activeStrategyKey)`: Enables users to withdraw their portion of assets from a specific active strategy they are invested in.
    *   `claimYield(address _asset, bytes32 _activeStrategyKey)`: Permits users to claim accumulated profits generated by a particular active strategy.
    *   `setProtocolFee(uint256 _newFeeBps)`: Governance function to adjust the percentage-based fee on generated yield.
*   **Strategy Lifecycle & Execution:**
    *   `proposeStrategy(StrategyProposalDetails memory _details, bytes _aiSignature)`: A whitelisted entity (or one with sufficient reputation) submits a new strategy template, potentially signed by an AI oracle, for community review.
    *   `voteOnStrategyProposal(uint256 _proposalId, bool _approve)`: Reputation token holders cast their votes (approve/reject) on strategy proposals.
    *   `activateStrategy(uint256 _proposalId, bytes32 _activationKey)`: Governance approves a voted-on strategy and makes it operational, assigning it a unique activation key.
    *   `deactivateStrategy(bytes32 _activationKey)`: Governance function to stop an active strategy, preventing further execution steps.
    *   `updateStrategyParameters(bytes32 _activationKey, StrategyStep[] calldata _newSteps)`: Allows governance to modify the execution steps of an active strategy in response to market changes or performance.
    *   `executeStrategyStep(bytes32 _activeStrategyKey)`: Triggered by an authorized relayer, this function executes the next predefined step of an active strategy, interacting with external DeFi protocols.
*   **Intent & Oracle Integration:**
    *   `declareIntent(string memory _description, uint256 _riskTolerance, uint256 _minAPYBps, address _preferredAsset)`: Users publicly register their investment objectives, risk appetite, and asset preferences.
    *   `matchIntentToStrategy(bytes32 _intentHash, bytes32 _activeStrategyKey)`: Users explicitly link their declared intent to a currently active strategy they believe aligns with their goals.
    *   `submitOracleStrategyRecommendation(bytes32 _intentHash, StrategyProposalDetails memory _details, bytes _oracleSignature)`: Whitelisted AI oracles submit recommendations for new strategy proposals, tailored to existing user intents.
*   **Reputation & Governance (SBT-like):**
    *   `mintReputationToken(address _recipient, uint256 _level)`: Governance or a specific mechanism awards non-transferable reputation tokens (SBTs) for valuable contributions (e.g., successful proposals, accurate challenges).
    *   `burnReputationToken(address _holder, uint256 _tokenId)`: Revokes reputation tokens, possibly for malicious activity or sustained poor performance.
    *   `delegateVote(address _delegatee)`: Allows users to delegate their voting power for strategy proposals to another address.
    *   `revokeDelegation()`: Cancels any previously set vote delegation.
*   **System & Security:**
    *   `emergencyPause()`: Governance can halt all critical operations (deposits, withdrawals, strategy executions) in an emergency (e.g., exploit, market crash).
    *   `setAllowedProtocol(address _protocolAddress, bool _allowed)`: Manages a whitelist of external DeFi protocols that strategies are permitted to interact with, enhancing security.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol"; // Using Ownable for simplicity, could be more complex AccessControl

// Interface for a simple Soulbound Token (Reputation NFT)
interface IReputationSBT {
    function mint(address to, uint256 tokenId) external;
    function burn(address from, uint256 tokenId) external;
    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    // Function to check if a specific reputation level (tokenId) exists for an address
    function hasReputationLevel(address owner, uint256 level) external view returns (bool);
}

// Interface for a typical WETH contract to handle ETH deposits/withdrawals
interface IWETH {
    function deposit() external payable;
    function withdraw(uint256 wad) external;
    function transfer(address to, uint256 value) external returns (bool);
}


contract AetherStrategyEngine is Ownable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    // --- State Variables ---

    address public governance; // The primary administrative address (can be a multi-sig or DAO)
    address public strategyOracle; // Whitelisted address for AI oracle submissions
    address public relayer; // Whitelisted address to execute strategy steps
    IReputationSBT public reputationNFT; // Address of the external Reputation SBT contract
    address public WETH; // Wrapped Ether address for convenience

    bool public paused; // Emergency pause flag

    uint256 public protocolFeeBps; // Fee collected on yield, in basis points (e.g., 500 = 5%)
    uint256 public constant MAX_PROTOCOL_FEE_BPS = 1000; // Max 10%

    uint256 private nextProposalId; // Counter for unique strategy proposal IDs

    // --- Data Structures ---

    // Struct for a single step in a strategy
    struct StrategyStep {
        address targetContract;        // The external DeFi protocol contract to interact with
        bytes callData;                // ABI-encoded function call to the targetContract
        uint256 expectedMinOutputAmount; // Minimum output expected from this step (slippage control)
        address assetIn;               // Asset required for this step (0x0 for ETH or internal balance)
        uint256 amountIn;              // Amount of assetIn for this step (0 for dynamic calculation)
        address assetOut;              // Asset expected from this step (0x0 if no specific output)
    }

    // Struct for details submitted in a strategy proposal
    struct StrategyProposalDetails {
        string name;                   // Human-readable name
        address assetUnderManagement;   // The primary asset this strategy will manage (e.g., USDC, ETH)
        bytes32[] requiredIntents;      // Hashes of intents this strategy aims to fulfill
        uint256 riskProfile;           // 1-10 scale, 1=low, 10=high
        uint256 expectedAPYBps;        // Expected APY in basis points (e.g., 500 for 5%)
        StrategyStep[] steps;          // Sequence of steps the strategy executes
    }

    // Struct for a strategy proposal during the voting phase
    struct StrategyProposal {
        StrategyProposalDetails details;
        address proposer;              // Address that proposed this strategy
        uint256 creationTimestamp;     // When it was proposed
        bool isApproved;               // Set to true after sufficient votes
        bool isActive;                 // Set to true after activation by governance
        uint256 upvotes;               // Number of positive votes
        uint256 downvotes;             // Number of negative votes
        mapping(address => bool) hasVoted; // Tracks if an address has voted on this proposal
    }

    // Struct for an actively running strategy instance
    struct ActiveStrategy {
        uint256 proposalId;            // Link back to the original proposal
        address assetUnderManagement;  // The primary asset this strategy manages (e.g., USDC)
        uint256 totalShares;           // Total shares representing all user deposits into this strategy
        uint256 totalAssetAmount;      // Total actual asset amount (in assetUnderManagement) managed by this strategy
        uint256 lastExecutionTimestamp;// Timestamp of the last successful executeStrategyStep
        uint256 currentStepIndex;      // To track which step in StrategyStep[] is next to execute
        bool isPaused;                 // Allows individual strategies to be paused
        mapping(address => uint256) userShares; // User shares within this specific active strategy
    }

    // Struct for user intent
    struct UserIntent {
        string description;            // Description of the intent (e.g., "Max stablecoin yield")
        uint256 riskTolerance;         // 1-10 scale
        uint256 minExpectedAPYBps;     // Minimum acceptable APY
        address preferredAsset;        // E.g., USDC, ETH (0x0 for any)
        bytes32 matchedStrategyKey;    // Hash of the active strategy this intent is linked to
        address owner;                 // Owner of this intent
    }

    // --- Mappings ---

    mapping(uint256 => StrategyProposal) public strategyProposals;
    mapping(bytes32 => ActiveStrategy) public activeStrategies; // Key: keccak256(abi.encode(proposalId, activationTimestamp))
    mapping(bytes32 => UserIntent) public userIntents; // Key: keccak256(abi.encode(msg.sender, description, ...))

    mapping(address => mapping(address => uint256)) public userTotalDeposits; // user => asset => amount
    mapping(address => mapping(address => uint256)) public userClaimableYield; // user => asset => amount

    mapping(address => bool) public allowedProtocols; // Whitelist for external DeFi protocols
    mapping(address => address) public voteDelegates; // For delegated voting

    // --- Events ---

    event Initialized(address indexed governance, address indexed strategyOracle, address indexed reputationNFT, address indexed relayer);
    event Deposit(address indexed user, address indexed asset, uint256 amount, bytes32 indexed intentHash);
    event Withdrawal(address indexed user, address indexed asset, uint256 amount, bytes32 indexed activeStrategyKey);
    event YieldClaimed(address indexed user, address indexed asset, uint256 amount, bytes32 indexed activeStrategyKey);
    event ProtocolFeeSet(uint256 newFeeBps);

    event StrategyProposed(uint256 indexed proposalId, address indexed proposer, string name, bytes32[] requiredIntents);
    event StrategyVoted(uint256 indexed proposalId, address indexed voter, bool approved, uint256 upvotes, uint256 downvotes);
    event StrategyActivated(uint256 indexed proposalId, bytes32 indexed activationKey, address indexed assetUnderManagement);
    event StrategyDeactivated(bytes32 indexed activationKey);
    event StrategyParametersUpdated(bytes32 indexed activationKey, address indexed updater);
    event StrategyStepExecuted(bytes32 indexed activeStrategyKey, uint256 indexed stepIndex, address indexed targetContract, uint256 actualOutputAmount);

    event IntentDeclared(address indexed user, bytes32 indexed intentHash, string description);
    event IntentMatchedToStrategy(address indexed user, bytes32 indexed intentHash, bytes32 indexed activeStrategyKey);
    event OracleRecommendationSubmitted(address indexed oracle, bytes32 indexed intentHash, uint256 newProposalId);

    event ReputationTokenMinted(address indexed recipient, uint256 indexed level);
    event ReputationTokenBurned(address indexed holder, uint256 indexed tokenId);
    event VoteDelegated(address indexed delegator, address indexed delegatee);
    event VoteRevoked(address indexed delegator, address indexed originalDelegatee);

    event EmergencyPaused(address indexed caller);
    event AllowedProtocolSet(address indexed protocolAddress, bool allowed);

    // --- Modifiers ---

    modifier onlyGovernance() {
        require(msg.sender == governance, "AE: Only governance can call this");
        _;
    }

    modifier onlyStrategyOracle() {
        require(msg.sender == strategyOracle, "AE: Only strategy oracle can call this");
        _;
    }

    modifier onlyRelayer() {
        require(msg.sender == relayer, "AE: Only relayer can call this");
        _;
    }

    modifier whenNotPaused() {
        require(!paused, "AE: Contract is paused");
        _;
    }

    modifier whenStrategyNotPaused(bytes32 _activeStrategyKey) {
        require(!activeStrategies[_activeStrategyKey].isPaused, "AE: Strategy is paused");
        _;
    }

    // --- Constructor & Initializer (for upgradeability) ---
    // Using a simple constructor, for upgradeability, this would be `initialize` and `constructor` would be empty/immutable.
    constructor(address _governance, address _strategyOracle, address _reputationNFT, address _relayer, address _weth) Ownable(msg.sender) {
        // Renounce ownership of the Ownable parent to transfer to Aether's governance
        // In a production setup, this would be set to `_governance` directly,
        // and the `owner` would be a deployer, then renounced/transferred.
        // For this example, assuming deployer is current owner, then transfer to _governance.
        // If it's for an upgradeable proxy, this constructor would be empty, and `initialize` called once.
        _transferOwnership(_governance); // Transfer Ownable ownership to the Aether governance

        initialize(_governance, _strategyOracle, _reputationNFT, _relayer, _weth);
    }

    function initialize(address _governance, address _strategyOracle, address _reputationNFT, address _relayer, address _weth) public onlyOwner {
        require(governance == address(0), "AE: Already initialized"); // Prevent re-initialization

        governance = _governance;
        strategyOracle = _strategyOracle;
        reputationNFT = IReputationSBT(_reputationNFT);
        relayer = _relayer;
        WETH = _weth;

        paused = false;
        protocolFeeBps = 100; // 1% default fee
        nextProposalId = 1;

        emit Initialized(_governance, _strategyOracle, _reputationNFT, _relayer);
    }

    // --- I. Core Vault Operations ---

    /// @notice Allows users to deposit assets into the engine, linking them to a declared investment intent.
    /// @param _asset The address of the asset being deposited (e.g., USDC, WETH).
    /// @param _amount The amount of the asset to deposit.
    /// @param _intentHash The hash of the user's declared intent.
    function deposit(address _asset, uint256 _amount, bytes32 _intentHash) external payable whenNotPaused {
        require(_amount > 0, "AE: Deposit amount must be greater than zero");
        require(userIntents[_intentHash].owner == msg.sender, "AE: Intent must belong to msg.sender");
        require(userIntents[_intentHash].matchedStrategyKey != bytes32(0), "AE: Intent not matched to an active strategy");

        bytes32 activeStrategyKey = userIntents[_intentHash].matchedStrategyKey;
        ActiveStrategy storage strategy = activeStrategies[activeStrategyKey];
        require(strategy.assetUnderManagement == _asset, "AE: Strategy does not manage this asset");

        // Handle native ETH deposit by wrapping it to WETH
        if (_asset == WETH && msg.value > 0) {
            require(msg.value == _amount, "AE: ETH amount must match _amount");
            IWETH(WETH).deposit{value: msg.value}();
        } else {
            require(msg.value == 0, "AE: Native ETH sent with non-WETH deposit");
            IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);
        }

        uint256 sharesMinted;
        if (strategy.totalShares == 0 || strategy.totalAssetAmount == 0) {
            sharesMinted = _amount; // First deposit into this strategy, shares = amount
        } else {
            sharesMinted = _amount.mul(strategy.totalShares).div(strategy.totalAssetAmount);
        }
        require(sharesMinted > 0, "AE: Shares minted must be > 0");

        strategy.userShares[msg.sender] = strategy.userShares[msg.sender].add(sharesMinted);
        strategy.totalShares = strategy.totalShares.add(sharesMinted);
        strategy.totalAssetAmount = strategy.totalAssetAmount.add(_amount);
        userTotalDeposits[msg.sender][_asset] = userTotalDeposits[msg.sender][_asset].add(_amount);

        emit Deposit(msg.sender, _asset, _amount, _intentHash);
    }

    /// @notice Allows users to withdraw their assets from a specific active strategy.
    /// @param _asset The address of the asset to withdraw.
    /// @param _amount The amount of shares to redeem.
    /// @param _activeStrategyKey The key of the active strategy to withdraw from.
    function withdraw(address _asset, uint256 _amount, bytes32 _activeStrategyKey) external whenNotPaused whenStrategyNotPaused(_activeStrategyKey) {
        ActiveStrategy storage strategy = activeStrategies[_activeStrategyKey];
        require(strategy.userShares[msg.sender] >= _amount, "AE: Insufficient shares");
        require(strategy.assetUnderManagement == _asset, "AE: Strategy does not manage this asset");

        uint256 assetsToWithdraw = _amount.mul(strategy.totalAssetAmount).div(strategy.totalShares);
        require(assetsToWithdraw > 0, "AE: Amount to withdraw must be > 0");

        strategy.userShares[msg.sender] = strategy.userShares[msg.sender].sub(_amount);
        strategy.totalShares = strategy.totalShares.sub(_amount);
        strategy.totalAssetAmount = strategy.totalAssetAmount.sub(assetsToWithdraw);
        userTotalDeposits[msg.sender][_asset] = userTotalDeposits[msg.sender][_asset].sub(assetsToWithdraw);

        // Deduct any pending yield for this user for this strategy before withdrawing base.
        // This prevents users from withdrawing principal and leaving fractional yield behind.
        if (userClaimableYield[msg.sender][_asset] > 0) {
             uint256 pendingYield = userClaimableYield[msg.sender][_asset];
             userClaimableYield[msg.sender][_asset] = 0;
             IERC20(_asset).safeTransfer(msg.sender, pendingYield);
        }

        if (_asset == WETH) {
            IWETH(WETH).withdraw(assetsToWithdraw);
            payable(msg.sender).transfer(assetsToWithdraw);
        } else {
            IERC20(_asset).safeTransfer(msg.sender, assetsToWithdraw);
        }

        emit Withdrawal(msg.sender, _asset, assetsToWithdraw, _activeStrategyKey);
    }

    /// @notice Allows users to claim accumulated profits generated by a particular active strategy.
    /// @param _asset The asset for which yield is being claimed.
    /// @param _activeStrategyKey The key of the active strategy from which to claim yield.
    function claimYield(address _asset, bytes32 _activeStrategyKey) external whenNotPaused whenStrategyNotPaused(_activeStrategyKey) {
        ActiveStrategy storage strategy = activeStrategies[_activeStrategyKey];
        require(strategy.assetUnderManagement == _asset, "AE: Strategy does not manage this asset");

        uint256 yieldAmount = userClaimableYield[msg.sender][_asset];
        require(yieldAmount > 0, "AE: No yield to claim");

        userClaimableYield[msg.sender][_asset] = 0;

        if (_asset == WETH) {
            IWETH(WETH).withdraw(yieldAmount);
            payable(msg.sender).transfer(yieldAmount);
        } else {
            IERC20(_asset).safeTransfer(msg.sender, yieldAmount);
        }

        emit YieldClaimed(msg.sender, _asset, yieldAmount, _activeStrategyKey);
    }

    /// @notice Governance function to adjust the percentage-based fee on generated yield.
    /// @param _newFeeBps The new fee in basis points (e.g., 100 for 1%).
    function setProtocolFee(uint256 _newFeeBps) external onlyGovernance {
        require(_newFeeBps <= MAX_PROTOCOL_FEE_BPS, "AE: Fee exceeds max allowed");
        protocolFeeBps = _newFeeBps;
        emit ProtocolFeeSet(_newFeeBps);
    }

    // --- II. Strategy Management & Lifecycle ---

    /// @notice Allows a whitelisted entity (or one with sufficient reputation) to submit a new strategy template for community review.
    /// @param _details The full details of the strategy proposal.
    /// @param _aiSignature An optional signature from an AI oracle, verifying the recommendation.
    ///                     (Verification logic would be more complex in real scenario, e.g., EIP-712 hashing)
    function proposeStrategy(StrategyProposalDetails memory _details, bytes memory _aiSignature) external whenNotPaused {
        // Basic check for proposer authority (e.g., has a certain reputation level)
        // For simplicity, let's assume anyone can propose, but governance/reputation holders vote.
        // In a real system: require(reputationNFT.hasReputationLevel(msg.sender, 1), "AE: Insufficient reputation to propose");

        require(_details.steps.length > 0, "AE: Strategy must have steps");
        require(_details.assetUnderManagement != address(0), "AE: Asset under management cannot be zero address");

        // Validate that all target protocols in steps are allowed
        for (uint256 i = 0; i < _details.steps.length; i++) {
            require(allowedProtocols[_details.steps[i].targetContract], "AE: Strategy uses unauthorized protocol");
        }

        uint256 proposalId = nextProposalId++;
        StrategyProposal storage proposal = strategyProposals[proposalId];
        proposal.details = _details;
        proposal.proposer = msg.sender;
        proposal.creationTimestamp = block.timestamp;

        // Signature validation could be here: verify(keccak256(abi.encode(_details)), _aiSignature)
        // For now, _aiSignature is just a placeholder.

        emit StrategyProposed(proposalId, msg.sender, _details.name, _details.requiredIntents);
    }

    /// @notice Reputation token holders cast their votes (approve/reject) on strategy proposals.
    /// @param _proposalId The ID of the strategy proposal.
    /// @param _approve True to approve, false to reject.
    function voteOnStrategyProposal(uint256 _proposalId, bool _approve) external whenNotPaused {
        StrategyProposal storage proposal = strategyProposals[_proposalId];
        require(proposal.proposer != address(0), "AE: Proposal does not exist");
        require(!proposal.isApproved && !proposal.isActive, "AE: Proposal already finalized");
        require(!proposal.hasVoted[msg.sender], "AE: Already voted on this proposal");

        address voter = voteDelegates[msg.sender] != address(0) ? voteDelegates[msg.sender] : msg.sender;

        // In a real system, voting power would be tied to reputationNFT holdings or staked tokens.
        // For simplicity, each unique address gets one vote.
        // require(reputationNFT.balanceOf(voter) > 0, "AE: Voter has no reputation");

        proposal.hasVoted[voter] = true;
        if (_approve) {
            proposal.upvotes++;
        } else {
            proposal.downvotes++;
        }

        // Simple majority approval threshold (e.g., 3 upvotes and more than downvotes)
        if (proposal.upvotes >= 3 && proposal.upvotes > proposal.downvotes) {
            proposal.isApproved = true;
        }

        emit StrategyVoted(_proposalId, voter, _approve, proposal.upvotes, proposal.downvotes);
    }

    /// @notice Governance approves a voted-on strategy and makes it operational, assigning it a unique activation key.
    /// @param _proposalId The ID of the strategy proposal to activate.
    /// @param _activationKey A unique identifier for this active instance of the strategy.
    function activateStrategy(uint256 _proposalId, bytes32 _activationKey) external onlyGovernance whenNotPaused {
        StrategyProposal storage proposal = strategyProposals[_proposalId];
        require(proposal.isApproved, "AE: Proposal not approved");
        require(!proposal.isActive, "AE: Strategy already active");
        require(activeStrategies[_activationKey].proposalId == 0, "AE: Activation key already in use");

        proposal.isActive = true;

        ActiveStrategy storage newActiveStrategy = activeStrategies[_activationKey];
        newActiveStrategy.proposalId = _proposalId;
        newActiveStrategy.assetUnderManagement = proposal.details.assetUnderManagement;
        newActiveStrategy.lastExecutionTimestamp = block.timestamp; // Initialize execution time

        emit StrategyActivated(_proposalId, _activationKey, newActiveStrategy.assetUnderManagement);
    }

    /// @notice Governance function to stop an active strategy, preventing further execution steps.
    /// @param _activationKey The key of the active strategy to deactivate.
    function deactivateStrategy(bytes32 _activationKey) external onlyGovernance whenNotPaused {
        ActiveStrategy storage strategy = activeStrategies[_activationKey];
        require(strategy.proposalId != 0, "AE: Strategy not found");
        require(!strategy.isPaused, "AE: Strategy already paused");

        // If the strategy needs to be fully decommissioned and funds unwound,
        // more complex logic would be here (e.g., move funds to a default safe vault)
        strategy.isPaused = true; // Effectively deactivates by pausing execution

        emit StrategyDeactivated(_activationKey);
    }

    /// @notice Allows governance to modify the execution steps of an active strategy in response to market changes or performance.
    /// @param _activationKey The key of the active strategy to update.
    /// @param _newSteps The new sequence of strategy steps.
    function updateStrategyParameters(bytes32 _activationKey, StrategyStep[] calldata _newSteps) external onlyGovernance whenNotPaused {
        ActiveStrategy storage activeStrat = activeStrategies[_activationKey];
        require(activeStrat.proposalId != 0, "AE: Strategy not found");
        require(!activeStrat.isPaused, "AE: Cannot update a paused strategy");
        require(_newSteps.length > 0, "AE: New steps cannot be empty");

        StrategyProposal storage proposal = strategyProposals[activeStrat.proposalId];
        proposal.details.steps = _newSteps; // Update the steps in the underlying proposal details
        activeStrat.currentStepIndex = 0; // Reset step index upon update

        // Validate that all target protocols in new steps are allowed
        for (uint256 i = 0; i < _newSteps.length; i++) {
            require(allowedProtocols[_newSteps[i].targetContract], "AE: New steps use unauthorized protocol");
        }

        emit StrategyParametersUpdated(_activationKey, msg.sender);
    }

    /// @notice Triggered by an authorized relayer, this function executes the next predefined step of an active strategy,
    ///         interacting with external DeFi protocols.
    /// @param _activeStrategyKey The key of the active strategy to execute a step for.
    function executeStrategyStep(bytes32 _activeStrategyKey) external onlyRelayer whenNotPaused whenStrategyNotPaused(_activeStrategyKey) {
        ActiveStrategy storage activeStrat = activeStrategies[_activeStrategyKey];
        require(activeStrat.proposalId != 0, "AE: Strategy not found");

        StrategyProposal storage proposal = strategyProposals[activeStrat.proposalId];
        require(proposal.details.steps.length > 0, "AE: Strategy has no defined steps");
        require(activeStrat.currentStepIndex < proposal.details.steps.length, "AE: All strategy steps executed, consider rebalance or new strategy");

        StrategyStep storage currentStep = proposal.details.steps[activeStrat.currentStepIndex];

        // Transfer `assetIn` to this contract if required, then approve `targetContract` to pull
        if (currentStep.amountIn > 0 && currentStep.assetIn != address(0)) {
            // Check if assetIn is WETH and needs to be wrapped or unwrapped
            if (currentStep.assetIn == WETH && address(this).balance >= currentStep.amountIn) {
                // If the contract holds native ETH and WETH is needed.
                IWETH(WETH).deposit{value: currentStep.amountIn}();
            } else {
                 IERC20(currentStep.assetIn).safeTransferFrom(address(this), address(this), currentStep.amountIn); // For internal transfers.
                 // The assumption is funds are already in this contract, or will be received by the step itself.
                 // A real system would need careful fund flow management: `transferFrom` from where?
                 // For now, assume this contract holds the funds it needs for execution.
            }
            IERC20(currentStep.assetIn).safeApprove(currentStep.targetContract, currentStep.amountIn);
        }

        uint256 initialAssetOutBalance = IERC20(currentStep.assetOut).balanceOf(address(this));

        // Perform the external call
        (bool success, bytes memory result) = currentStep.targetContract.call(currentStep.callData);
        require(success, string(abi.encodePacked("AE: Strategy step failed: ", result)));

        uint256 finalAssetOutBalance = IERC20(currentStep.assetOut).balanceOf(address(this));
        uint256 actualOutputAmount = finalAssetOutBalance.sub(initialAssetOutBalance);

        // Check for minimum output amount (slippage control)
        require(actualOutputAmount >= currentStep.expectedMinOutputAmount, "AE: Slippage exceeded for strategy step");

        // Advance to the next step
        activeStrat.currentStepIndex++;
        activeStrat.lastExecutionTimestamp = block.timestamp;

        // If all steps executed, reset for potential re-execution or wait for rebalance/new strategy
        if (activeStrat.currentStepIndex == proposal.details.steps.length) {
            activeStrat.currentStepIndex = 0; // Or trigger an event for governance to review
            // Calculate yield and distribute based on performance
            _distributeYield(activeStrat.assetUnderManagement, _activeStrategyKey, actualOutputAmount); // Simplify to single asset.
        }

        emit StrategyStepExecuted(_activeStrategyKey, activeStrat.currentStepIndex.sub(1), currentStep.targetContract, actualOutputAmount);
    }

    /// @dev Internal function to calculate and distribute yield after a strategy run or rebalance.
    /// @param _asset The asset in which yield is generated.
    /// @param _activeStrategyKey The key of the active strategy.
    /// @param _generatedAmount The total amount generated by the strategy step (e.g., after a swap).
    function _distributeYield(address _asset, bytes32 _activeStrategyKey, uint256 _generatedAmount) internal {
        ActiveStrategy storage strategy = activeStrategies[_activeStrategyKey];
        uint256 currentAssetBalance = IERC20(_asset).balanceOf(address(this));
        uint256 protocolShare = 0;

        // Simplified yield calculation:
        // Assume _generatedAmount is the net positive gain (or loss) for the strategy run.
        // A more robust system would compare start vs. end `totalAssetAmount` across all managed assets.
        if (_generatedAmount > strategy.totalAssetAmount) { // If there's a gain
            uint256 grossYield = _generatedAmount.sub(strategy.totalAssetAmount);
            protocolShare = grossYield.mul(protocolFeeBps).div(10000);
            uint256 netYield = grossYield.sub(protocolShare);

            // Distribute net yield to users proportionally by shares
            for (uint256 i = 0; i < strategy.totalShares; i++) { // This is an inefficient loop for many users
                // In a real system, this would be a "pull" model where users calculate their own share.
                // For demonstration, let's just update `userClaimableYield`.
                // A better approach: `perShareNetYield` calculation and users pull their share.
            }

            // Update `userClaimableYield` for each user
            // This example is simplified, ideally, it's calculated on a per-share basis
            // and only update when `totalAssetAmount` changes for a strategy.
            // For now, let's just make it available to be claimed by anyone who deposited, and clear after.
            // This needs to be done on a per-share basis.
            // Since this is a conceptual contract, we'll keep this abstract for the time being.
            // A realistic implementation would calculate a yield per share.
            // For now, we'll assume `_generatedAmount` is the new total capital.
            // If the `_generatedAmount` is the new total value of the strategy after a step.
            // Then yield is `_generatedAmount - strategy.totalAssetAmount`.

            // Placeholder for yield distribution:
            // This is a crucial area for a real vault.
            // For demo: Let's assume `_generatedAmount` is the total value of the strategy now.
            // The `totalAssetAmount` is the principal.
            uint256 currentTotalValue = _generatedAmount;
            if (currentTotalValue > strategy.totalAssetAmount) {
                uint256 grossProfit = currentTotalValue.sub(strategy.totalAssetAmount);
                protocolShare = grossProfit.mul(protocolFeeBps).div(10000);
                uint256 netProfitForUsers = grossProfit.sub(protocolShare);

                // Update users' claimable yield.
                // This would be proportional to shares. Example:
                // `uint256 yieldPerShare = netProfitForUsers.mul(1e18).div(strategy.totalShares);`
                // `userClaimableYield[user][asset] += (userShares[user] * yieldPerShare) / 1e18;`
                // For simplicity, we just add to `userClaimableYield` and transfer protocolShare.
                IERC20(_asset).safeTransfer(governance, protocolShare);
            }
            strategy.totalAssetAmount = currentTotalValue.sub(protocolShare); // Update total assets for next calculation
        }
    }


    // --- III. Intent & Oracle Integration ---

    /// @notice Allows users to publicly register their investment objectives, risk appetite, and asset preferences.
    /// @param _description A descriptive string of the user's intent.
    /// @param _riskTolerance A numerical value (1-10) indicating risk appetite.
    /// @param _minAPYBps Minimum acceptable APY in basis points.
    /// @param _preferredAsset The user's preferred asset for investment (0x0 for any).
    function declareIntent(string memory _description, uint256 _riskTolerance, uint256 _minAPYBps, address _preferredAsset) external whenNotPaused {
        bytes32 intentHash = keccak256(abi.encodePacked(msg.sender, _description, _riskTolerance, _minAPYBps, _preferredAsset));
        require(userIntents[intentHash].owner == address(0), "AE: Intent already declared");

        userIntents[intentHash] = UserIntent({
            description: _description,
            riskTolerance: _riskTolerance,
            minExpectedAPYBps: _minAPYBps,
            preferredAsset: _preferredAsset,
            matchedStrategyKey: bytes32(0),
            owner: msg.sender
        });

        emit IntentDeclared(msg.sender, intentHash, _description);
    }

    /// @notice Allows users to explicitly link their declared intent to a currently active strategy they believe aligns with their goals.
    /// @param _intentHash The hash of the user's declared intent.
    /// @param _activeStrategyKey The key of the active strategy.
    function matchIntentToStrategy(bytes32 _intentHash, bytes32 _activeStrategyKey) external whenNotPaused {
        UserIntent storage intent = userIntents[_intentHash];
        ActiveStrategy storage strategy = activeStrategies[_activeStrategyKey];
        require(intent.owner == msg.sender, "AE: Intent must belong to msg.sender");
        require(intent.matchedStrategyKey == bytes32(0), "AE: Intent already matched");
        require(strategy.proposalId != 0, "AE: Strategy not found or not active");
        require(!strategy.isPaused, "AE: Cannot match to a paused strategy");

        // Basic compatibility check (could be more complex, checking risk/APY targets)
        StrategyProposal storage proposal = strategyProposals[strategy.proposalId];
        bool intentMatchFound = false;
        for (uint256 i = 0; i < proposal.details.requiredIntents.length; i++) {
            if (proposal.details.requiredIntents[i] == _intentHash) {
                intentMatchFound = true;
                break;
            }
        }
        // In this example, _intentHash doesn't have to be explicitly in `requiredIntents`
        // but it's a good place for smart matching logic.
        // For now, let's allow matching if it's an active strategy.

        intent.matchedStrategyKey = _activeStrategyKey;
        emit IntentMatchedToStrategy(msg.sender, _intentHash, _activeStrategyKey);
    }

    /// @notice Whitelisted AI oracles submit recommendations for new strategy proposals, tailored to existing user intents.
    ///         This recommendation then needs to go through the `proposeStrategy` and voting process.
    /// @param _intentHash The hash of the user intent this recommendation addresses.
    /// @param _details The proposed strategy details.
    /// @param _oracleSignature An optional signature from the oracle.
    function submitOracleStrategyRecommendation(bytes32 _intentHash, StrategyProposalDetails memory _details, bytes memory _oracleSignature) external onlyStrategyOracle whenNotPaused {
        require(userIntents[_intentHash].owner != address(0), "AE: Intent not found"); // Ensure intent exists

        // The oracle directly proposes the strategy using the same function as a user,
        // but with `onlyStrategyOracle` permissions or enhanced reputation.
        // For simplicity, it calls `proposeStrategy` internally.
        // The `_aiSignature` parameter of `proposeStrategy` would be utilized here.

        // It is called directly by the oracle, so msg.sender is `strategyOracle`
        // which might bypass some reputation checks on proposeStrategy depending on implementation.
        // Here, we'll make a separate path, or assume proposeStrategy is open to oracles.
        // For now, let's emit an event and governance can then manually propose.
        // A more integrated system would directly call proposeStrategy from here.

        // This would internally call `proposeStrategy` with its own `msg.sender` as proposer.
        // proposeStrategy(_details, _oracleSignature); // If proposeStrategy supported oracle as proposer.

        uint256 proposalId = nextProposalId++;
        StrategyProposal storage proposal = strategyProposals[proposalId];
        proposal.details = _details;
        proposal.proposer = msg.sender; // Oracle is the proposer
        proposal.creationTimestamp = block.timestamp;
        proposal.details.requiredIntents = new bytes32[](1);
        proposal.details.requiredIntents[0] = _intentHash; // Link to the specific intent

        // Validate target protocols
        for (uint256 i = 0; i < _details.steps.length; i++) {
            require(allowedProtocols[_details.steps[i].targetContract], "AE: Recommendation uses unauthorized protocol");
        }


        emit OracleRecommendationSubmitted(msg.sender, _intentHash, proposalId);
    }

    // --- IV. Reputation & Governance ---

    /// @notice Governance or a specific mechanism awards non-transferable reputation tokens (SBTs) for valuable contributions.
    /// @param _recipient The address to mint the reputation token to.
    /// @param _level The level/type of reputation token to mint.
    function mintReputationToken(address _recipient, uint256 _level) external onlyGovernance {
        reputationNFT.mint(_recipient, _level);
        emit ReputationTokenMinted(_recipient, _level);
    }

    /// @notice Revokes reputation tokens, possibly for malicious activity or sustained poor performance.
    /// @param _holder The address whose reputation token is to be burned.
    /// @param _tokenId The ID of the reputation token to burn.
    function burnReputationToken(address _holder, uint256 _tokenId) external onlyGovernance {
        reputationNFT.burn(_holder, _tokenId);
        emit ReputationTokenBurned(_holder, _tokenId);
    }

    /// @notice Allows users to delegate their voting power for strategy proposals to another address.
    /// @param _delegatee The address to delegate voting power to.
    function delegateVote(address _delegatee) external whenNotPaused {
        require(_delegatee != address(0), "AE: Cannot delegate to zero address");
        require(_delegatee != msg.sender, "AE: Cannot delegate to self");
        voteDelegates[msg.sender] = _delegatee;
        emit VoteDelegated(msg.sender, _delegatee);
    }

    /// @notice Cancels any previously set vote delegation.
    function revokeDelegation() external whenNotPaused {
        address originalDelegatee = voteDelegates[msg.sender];
        require(originalDelegatee != address(0), "AE: No active delegation to revoke");
        delete voteDelegates[msg.sender];
        emit VoteRevoked(msg.sender, originalDelegatee);
    }

    // --- V. System & Security ---

    /// @notice Governance can halt all critical operations (deposits, withdrawals, strategy executions) in an emergency.
    function emergencyPause() external onlyGovernance {
        paused = true;
        emit EmergencyPaused(msg.sender);
    }

    /// @notice Governance can unpause the contract.
    function unpause() external onlyGovernance {
        paused = false;
    }

    /// @notice Manages a whitelist of external DeFi protocols that strategies are permitted to interact with, enhancing security.
    /// @param _protocolAddress The address of the external DeFi protocol.
    /// @param _allowed True to add to whitelist, false to remove.
    function setAllowedProtocol(address _protocolAddress, bool _allowed) external onlyGovernance {
        require(_protocolAddress != address(0), "AE: Protocol address cannot be zero");
        allowedProtocols[_protocolAddress] = _allowed;
        emit AllowedProtocolSet(_protocolAddress, _allowed);
    }

    // Fallback function to receive Ether if not explicitly handled (e.g., WETH deposits)
    receive() external payable {
        // Only allow receiving Ether if it's intended for WETH wrapping
        require(msg.sender == WETH, "AE: Direct ETH deposits not allowed outside of WETH wrap");
    }
}
```