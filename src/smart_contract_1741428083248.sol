```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title CryptoEcosystem: Dynamic On-Chain Ecosystem Simulator
 * @author Gemini AI Assistant
 * @dev A smart contract simulating a dynamic on-chain ecosystem with evolving digital creatures,
 *      resource management, genetic traits, and decentralized governance. This contract
 *      aims to explore advanced concepts like on-chain evolution, algorithmic randomness,
 *      dynamic NFTs, and decentralized decision-making within a game-like environment.
 *
 * **Outline and Function Summary:**
 *
 * **1. Ecosystem Initialization & Parameters:**
 *    - `initializeEcosystem(string _ecosystemName, uint256 _initialCreatureSupply, uint256 _resourceSupply)`: Initializes the ecosystem with name, initial creatures, and resources.
 *    - `setEcosystemParameter(string _parameterName, uint256 _parameterValue)`: Allows admin to adjust ecosystem parameters (e.g., mutation rate, resource regeneration rate).
 *    - `getEcosystemParameter(string _parameterName) public view returns (uint256)`: Retrieves the value of a specific ecosystem parameter.
 *
 * **2. Creature Lifecycle & Genetics:**
 *    - `createCreature(string _creatureName, uint256[] memory _initialGenes)`: Allows users to create new creatures with custom names and initial genetic traits.
 *    - `breedCreatures(uint256 _creatureId1, uint256 _creatureId2)`: Enables breeding of two creatures, resulting in a new creature with combined and mutated genes.
 *    - `mutateCreature(uint256 _creatureId)`: Induces random mutations in a creature's genes based on the ecosystem's mutation rate.
 *    - `evolveCreature(uint256 _creatureId)`: Allows creatures to evolve by spending resources and fulfilling specific conditions (e.g., age, resource accumulation).
 *    - `getCreatureGenes(uint256 _creatureId) public view returns (uint256[] memory)`: Retrieves the genetic makeup of a creature.
 *    - `getCreatureAttributes(uint256 _creatureId) public view returns (string[] memory, uint256[] memory)`: Derives and returns attributes of a creature based on its genes.
 *    - `creatureAging(uint256 _creatureId)`: Simulates the aging process of a creature, potentially affecting its attributes and lifespan.
 *    - `creatureDeath(uint256 _creatureId)`: Simulates natural death of creatures based on lifespan or other conditions.
 *
 * **3. Resource Management & Economy:**
 *    - `claimResources()`: Allows users to claim resources generated by the ecosystem based on creature ownership or staking.
 *    - `stakeCreatureForResources(uint256 _creatureId)`: Allows users to stake creatures to passively generate resources.
 *    - `unstakeCreature(uint256 _creatureId)`: Allows users to unstake their creature from resource generation.
 *    - `getResourceBalance(address _user) public view returns (uint256)`: Retrieves the resource balance of a user.
 *    - `transferResources(address _recipient, uint256 _amount)`: Allows users to transfer resources to other users within the ecosystem.
 *
 * **4. Ecosystem Interactions & Events:**
 *    - `creatureInteraction(uint256 _creatureId1, uint256 _creatureId2, string memory _interactionType)`: Simulates interactions between creatures (e.g., competition, cooperation) and triggers events based on genes and environment.
 *    - `environmentalEvent()`: Simulates random environmental events that can affect creatures and resource distribution in the ecosystem.
 *
 * **5. Decentralized Governance & Community Control:**
 *    - `proposeEcosystemChange(string memory _proposalDescription, string memory _parameterToChange, uint256 _newParameterValue)`: Allows users to propose changes to ecosystem parameters.
 *    - `voteOnProposal(uint256 _proposalId, bool _vote)`: Allows users to vote on active ecosystem change proposals.
 *    - `executeProposal(uint256 _proposalId)`: Executes approved ecosystem change proposals if they reach quorum and pass threshold.
 *
 * **6. Utility & Information Functions:**
 *    - `getEcosystemName() public view returns (string memory)`: Returns the name of the ecosystem.
 *    - `getTotalCreatures() public view returns (uint256)`: Returns the total number of creatures in the ecosystem.
 *    - `getTotalResources() public view returns (uint256)`: Returns the total resources currently in the ecosystem.
 *    - `getCreatureOwner(uint256 _creatureId) public view returns (address)`: Retrieves the owner of a specific creature.
 *    - `isCreatureAlive(uint256 _creatureId) public view returns (bool)`: Checks if a creature is currently alive in the ecosystem.
 */

contract CryptoEcosystem {
    string public ecosystemName;
    address public ecosystemAdmin;

    // --- Data Structures ---
    struct Creature {
        string name;
        address owner;
        uint256[] genes;
        uint256 birthTimestamp;
        uint256 lastInteractionTimestamp;
        bool isAlive;
    }

    struct EcosystemProposal {
        string description;
        string parameterToChange;
        uint256 newParameterValue;
        uint256 startTime;
        uint256 endTime;
        uint256 yesVotes;
        uint256 noVotes;
        bool isActive;
        bool isExecuted;
    }

    mapping(uint256 => Creature) public creatures;
    uint256 public creatureCount;

    mapping(address => uint256) public resourceBalances;
    uint256 public totalResources;

    mapping(string => uint256) public ecosystemParameters; // Key-value parameters for ecosystem dynamics

    mapping(uint256 => EcosystemProposal) public proposals;
    uint256 public proposalCount;

    mapping(uint256 => bool) public stakedCreatures; // Track staked creatures for resource generation

    // --- Events ---
    event EcosystemInitialized(string ecosystemName, address admin, uint256 initialCreatureSupply, uint256 initialResourceSupply);
    event EcosystemParameterSet(string parameterName, uint256 parameterValue, address admin);
    event CreatureCreated(uint256 creatureId, string creatureName, address owner);
    event CreaturesBred(uint256 newCreatureId, uint256 parent1Id, uint256 parent2Id, address owner);
    event CreatureMutated(uint256 creatureId);
    event CreatureEvolved(uint256 creatureId);
    event ResourcesClaimed(address user, uint256 amount);
    event ResourcesTransferred(address sender, address recipient, uint256 amount);
    event CreatureStaked(uint256 creatureId, address owner);
    event CreatureUnstaked(uint256 creatureId, address owner);
    event EcosystemProposalCreated(uint256 proposalId, address proposer, string description, string parameterToChange, uint256 newValue);
    event EcosystemProposalVoted(uint256 proposalId, address voter, bool vote);
    event EcosystemProposalExecuted(uint256 proposalId, string parameterChanged, uint256 newValue);
    event CreatureDied(uint256 creatureId);
    event EnvironmentalEventOccurred(string eventDescription);
    event CreatureInteractionOccurred(uint256 creatureId1, uint256 creatureId2, string interactionType);

    // --- Modifiers ---
    modifier onlyOwner() {
        require(msg.sender == ecosystemAdmin, "Only ecosystem admin can call this function.");
        _;
    }

    modifier creatureExists(uint256 _creatureId) {
        require(creatures[_creatureId].owner != address(0), "Creature does not exist.");
        _;
    }

    modifier creatureOwner(uint256 _creatureId) {
        require(creatures[_creatureId].owner == msg.sender, "You are not the owner of this creature.");
        _;
    }

    modifier creatureAlive(uint256 _creatureId) {
        require(creatures[_creatureId].isAlive, "Creature is not alive.");
        _;
    }

    modifier proposalExists(uint256 _proposalId) {
        require(proposals[_proposalId].isActive, "Proposal does not exist or is not active.");
        _;
    }

    // --- Constructor ---
    constructor() {
        ecosystemAdmin = msg.sender;
    }

    // --- 1. Ecosystem Initialization & Parameters ---
    function initializeEcosystem(string memory _ecosystemName, uint256 _initialCreatureSupply, uint256 _resourceSupply) public onlyOwner {
        require(bytes(ecosystemName).length > 0 && _initialCreatureSupply > 0 && _resourceSupply > 0, "Invalid initialization parameters.");
        require(bytes(ecosystemName).length <= 50, "Ecosystem name too long (max 50 characters).");

        ecosystemName = _ecosystemName;
        totalResources = _resourceSupply;

        // Initialize initial creatures (basic creatures with default genes - can be expanded)
        for (uint256 i = 0; i < _initialCreatureSupply; i++) {
            _createInitialCreature("Initial Creature", i); // Internal function for initial creature creation
        }

        ecosystemParameters["mutationRate"] = 5; // Example: 5% mutation rate (can be adjusted)
        ecosystemParameters["resourceRegenRate"] = 10; // Example: 10 resource units per block (can be adjusted)
        ecosystemParameters["baseLifespan"] = 1000; // Base lifespan in blocks for creatures
        ecosystemParameters["evolutionCost"] = 100; // Resource cost for evolution

        emit EcosystemInitialized(_ecosystemName, ecosystemAdmin, _initialCreatureSupply, _resourceSupply);
    }

    function setEcosystemParameter(string memory _parameterName, uint256 _parameterValue) public onlyOwner {
        require(bytes(_parameterName).length > 0 && _parameterValue >= 0, "Invalid parameter name or value.");
        ecosystemParameters[_parameterName] = _parameterValue;
        emit EcosystemParameterSet(_parameterName, _parameterValue, msg.sender);
    }

    function getEcosystemParameter(string memory _parameterName) public view returns (uint256) {
        return ecosystemParameters[_parameterName];
    }

    function getEcosystemName() public view returns (string memory) {
        return ecosystemName;
    }

    function getTotalCreatures() public view returns (uint256) {
        return creatureCount;
    }

    function getTotalResources() public view returns (uint256) {
        return totalResources;
    }


    // --- 2. Creature Lifecycle & Genetics ---
    function createCreature(string memory _creatureName, uint256[] memory _initialGenes) public {
        require(bytes(_creatureName).length > 0 && bytes(_creatureName).length <= 50, "Creature name invalid or too long.");
        require(_initialGenes.length > 0, "Initial genes must be provided.");

        creatureCount++;
        creatures[creatureCount] = Creature({
            name: _creatureName,
            owner: msg.sender,
            genes: _initialGenes,
            birthTimestamp: block.timestamp,
            lastInteractionTimestamp: block.timestamp,
            isAlive: true
        });

        emit CreatureCreated(creatureCount, _creatureName, msg.sender);
    }

    // Internal function to create initial creatures during ecosystem setup
    function _createInitialCreature(string memory _creatureName, uint256 _seed) internal {
        creatureCount++;
        uint256[] memory initialGenes = new uint256[](5); // Example: 5 genes
        // Generate some basic genes based on seed for initial creatures (can be more sophisticated)
        for (uint256 i = 0; i < 5; i++) {
            initialGenes[i] = uint256(keccak256(abi.encode(creatureCount, i, _seed))) % 100; // Simple gene generation
        }

        creatures[creatureCount] = Creature({
            name: _creatureName,
            owner: address(this), // Initially owned by contract (can be distributed later)
            genes: initialGenes,
            birthTimestamp: block.timestamp,
            lastInteractionTimestamp: block.timestamp,
            isAlive: true
        });
    }

    function breedCreatures(uint256 _creatureId1, uint256 _creatureId2) public
    creatureExists(_creatureId1) creatureExists(_creatureId2)
    creatureOwner(_creatureId1) creatureOwner(_creatureId2)
    creatureAlive(_creatureId1) creatureAlive(_creatureId2)
    {
        Creature storage parent1 = creatures[_creatureId1];
        Creature storage parent2 = creatures[_creatureId2];

        require(parent1.owner == parent2.owner, "Both creatures must be owned by the same user to breed."); // Example: Breeding only within same owner
        require(block.timestamp > parent1.lastInteractionTimestamp + 1 days && block.timestamp > parent2.lastInteractionTimestamp + 1 days, "Creatures need cooldown before breeding."); // Cooldown period

        uint256[] memory childGenes = _combineGenes(parent1.genes, parent2.genes);
        childGenes = _mutateGenes(childGenes);

        creatureCount++;
        creatures[creatureCount] = Creature({
            name: string(abi.encodePacked(parent1.name, " & ", parent2.name, " Child")),
            owner: msg.sender,
            genes: childGenes,
            birthTimestamp: block.timestamp,
            lastInteractionTimestamp: block.timestamp,
            isAlive: true
        });

        parent1.lastInteractionTimestamp = block.timestamp;
        parent2.lastInteractionTimestamp = block.timestamp;

        emit CreaturesBred(creatureCount, _creatureId1, _creatureId2, msg.sender);
    }

    function mutateCreature(uint256 _creatureId) public creatureExists(_creatureId) creatureOwner(_creatureId) creatureAlive(_creatureId) {
        creatures[_creatureId].genes = _mutateGenes(creatures[_creatureId].genes);
        emit CreatureMutated(_creatureId);
    }

    function evolveCreature(uint256 _creatureId) public creatureExists(_creatureId) creatureOwner(_creatureId) creatureAlive(_creatureId) {
        uint256 evolutionCost = getEcosystemParameter("evolutionCost");
        require(resourceBalances[msg.sender] >= evolutionCost, "Not enough resources to evolve.");

        creatures[_creatureId].genes = _evolveGenes(creatures[_creatureId].genes); // Apply evolution logic to genes
        resourceBalances[msg.sender] -= evolutionCost;

        emit CreatureEvolved(_creatureId);
    }

    function getCreatureGenes(uint256 _creatureId) public view creatureExists(_creatureId) returns (uint256[] memory) {
        return creatures[_creatureId].genes;
    }

    function getCreatureAttributes(uint256 _creatureId) public view creatureExists(_creatureId) returns (string[] memory, uint256[] memory) {
        // Example: Decode genes into attributes (can be more complex mapping)
        uint256[] memory genes = creatures[_creatureId].genes;
        string[] memory attributeNames = new string[](genes.length);
        uint256[] memory attributeValues = new uint256[](genes.length);

        for (uint256 i = 0; i < genes.length; i++) {
            attributeNames[i] = string(abi.encodePacked("Attribute ", Strings.toString(i)));
            attributeValues[i] = genes[i];
        }
        return (attributeNames, attributeValues);
    }

    function creatureAging(uint256 _creatureId) public creatureExists(_creatureId) creatureAlive(_creatureId) {
        uint256 baseLifespan = getEcosystemParameter("baseLifespan");
        uint256 age = (block.timestamp - creatures[_creatureId].birthTimestamp) / 1 days; // Example: Age in days (adjust as needed)

        if (age >= baseLifespan) {
            creatureDeath(_creatureId);
        }
        // Can add more aging effects on attributes based on age here.
    }

    function creatureDeath(uint256 _creatureId) public creatureExists(_creatureId) creatureAlive(_creatureId) {
        creatures[_creatureId].isAlive = false;
        emit CreatureDied(_creatureId);
    }

    function isCreatureAlive(uint256 _creatureId) public view creatureExists(_creatureId) returns (bool) {
        return creatures[_creatureId].isAlive;
    }

    function getCreatureOwner(uint256 _creatureId) public view creatureExists(_creatureId) returns (address) {
        return creatures[_creatureId].owner;
    }


    // --- 3. Resource Management & Economy ---
    function claimResources() public {
        uint256 regenRate = getEcosystemParameter("resourceRegenRate");
        uint256 amount = regenRate; // Example: Fixed amount per claim (can be based on creature ownership, staking etc.)

        resourceBalances[msg.sender] += amount;
        totalResources += amount; // Ecosystem resources also increase (can be different logic)

        emit ResourcesClaimed(msg.sender, amount);
    }

    function stakeCreatureForResources(uint256 _creatureId) public creatureExists(_creatureId) creatureOwner(_creatureId) creatureAlive(_creatureId) {
        require(!stakedCreatures[_creatureId], "Creature already staked.");
        stakedCreatures[_creatureId] = true;
        emit CreatureStaked(_creatureId, msg.sender);
    }

    function unstakeCreature(uint256 _creatureId) public creatureExists(_creatureId) creatureOwner(_creatureId) creatureAlive(_creatureId) {
        require(stakedCreatures[_creatureId], "Creature is not staked.");
        stakedCreatures[_creatureId] = false;
        emit CreatureUnstaked(_creatureId, msg.sender);
    }

    function getResourceBalance(address _user) public view returns (uint256) {
        return resourceBalances[_user];
    }

    function transferResources(address _recipient, uint256 _amount) public {
        require(_recipient != address(0) && _amount > 0, "Invalid recipient or amount.");
        require(resourceBalances[msg.sender] >= _amount, "Insufficient resource balance.");

        resourceBalances[msg.sender] -= _amount;
        resourceBalances[_recipient] += _amount;

        emit ResourcesTransferred(msg.sender, _recipient, _amount);
    }


    // --- 4. Ecosystem Interactions & Events ---
    function creatureInteraction(uint256 _creatureId1, uint256 _creatureId2, string memory _interactionType) public
    creatureExists(_creatureId1) creatureExists(_creatureId2)
    creatureAlive(_creatureId1) creatureAlive(_creatureId2)
    {
        // Example: Simple interaction logic based on creature genes and interaction type
        uint256 interactionResult = _simulateInteraction(creatures[_creatureId1].genes, creatures[_creatureId2].genes, _interactionType);

        // Apply effects based on interactionResult (e.g., resource gain/loss, gene mutation for one or both creatures)
        if (_interactionType == "compete") {
            if (interactionResult > 50) { // Example: Creature 1 wins
                resourceBalances[creatures[_creatureId1].owner] += 10; // Winner gains resources
                emit CreatureInteractionOccurred(_creatureId1, _creatureId2, "competition_win");
            } else {
                resourceBalances[creatures[_creatureId2].owner] += 10; // Creature 2 wins
                emit CreatureInteractionOccurred(_creatureId1, _creatureId2, "competition_lose");
            }
        } else if (_interactionType == "cooperate") {
            resourceBalances[creatures[_creatureId1].owner] += 5; // Both gain resources for cooperation
            resourceBalances[creatures[_creatureId2].owner] += 5;
             emit CreatureInteractionOccurred(_creatureId1, _creatureId2, "cooperation");
        } else {
            revert("Invalid interaction type.");
        }

        creatures[_creatureId1].lastInteractionTimestamp = block.timestamp;
        creatures[_creatureId2].lastInteractionTimestamp = block.timestamp;
    }

    function environmentalEvent() public {
        // Example: Random environmental event affecting ecosystem
        uint256 eventRoll = uint256(keccak256(abi.encode(block.timestamp, block.difficulty, creatureCount))) % 100;

        if (eventRoll < 30) { // 30% chance of a "positive" event
            uint256 resourceBoost = 500;
            totalResources += resourceBoost;
            emit EnvironmentalEventOccurred("Resource Bloom: Ecosystem resources increased by 500!");
        } else if (eventRoll < 60) { // 30% chance of a "negative" event
            uint256 resourceLoss = 200;
            if (totalResources > resourceLoss) {
                totalResources -= resourceLoss;
                emit EnvironmentalEventOccurred("Resource Scarcity: Ecosystem resources decreased by 200!");
            } else {
                totalResources = 0;
                emit EnvironmentalEventOccurred("Resource Scarcity: Ecosystem resources depleted!");
            }
        } else { // 40% chance of no significant event
            emit EnvironmentalEventOccurred("Stable Environment: No significant environmental event.");
        }
    }


    // --- 5. Decentralized Governance & Community Control ---
    function proposeEcosystemChange(string memory _proposalDescription, string memory _parameterToChange, uint256 _newParameterValue) public {
        require(bytes(_proposalDescription).length > 0 && bytes(_parameterToChange).length > 0, "Invalid proposal description or parameter.");
        require(bytes(_proposalDescription).length <= 200, "Proposal description too long (max 200 characters).");

        proposalCount++;
        proposals[proposalCount] = EcosystemProposal({
            description: _proposalDescription,
            parameterToChange: _parameterToChange,
            newParameterValue: _newParameterValue,
            startTime: block.timestamp,
            endTime: block.timestamp + 7 days, // Example: 7 days voting period
            yesVotes: 0,
            noVotes: 0,
            isActive: true,
            isExecuted: false
        });

        emit EcosystemProposalCreated(proposalCount, msg.sender, _proposalDescription, _parameterToChange, _newParameterValue);
    }

    function voteOnProposal(uint256 _proposalId, bool _vote) public proposalExists(_proposalId) {
        require(block.timestamp < proposals[_proposalId].endTime, "Voting period has ended.");
        require(!proposals[_proposalId].isExecuted, "Proposal already executed.");

        if (_vote) {
            proposals[_proposalId].yesVotes++;
        } else {
            proposals[_proposalId].noVotes++;
        }

        emit EcosystemProposalVoted(_proposalId, msg.sender, _vote);
    }

    function executeProposal(uint256 _proposalId) public proposalExists(_proposalId) {
        require(block.timestamp >= proposals[_proposalId].endTime, "Voting period not yet ended.");
        require(!proposals[_proposalId].isExecuted, "Proposal already executed.");

        uint256 quorum = getTotalCreatures() / 2; // Example: 50% quorum (can be adjusted)
        uint256 passThreshold = 60; // Example: 60% yes votes to pass (can be adjusted)

        uint256 totalVotes = proposals[_proposalId].yesVotes + proposals[_proposalId].noVotes;
        uint256 yesPercentage = (proposals[_proposalId].yesVotes * 100) / totalVotes; // Avoid division by zero if no votes

        if (totalVotes >= quorum && yesPercentage >= passThreshold) {
            setEcosystemParameter(proposals[_proposalId].parameterToChange, proposals[_proposalId].newParameterValue);
            proposals[_proposalId].isActive = false;
            proposals[_proposalId].isExecuted = true;
            emit EcosystemProposalExecuted(_proposalId, proposals[_proposalId].parameterToChange, proposals[_proposalId].newParameterValue);
        } else {
            proposals[_proposalId].isActive = false; // Proposal fails if not passed
        }
    }


    // --- 6. Utility & Information Functions ---
    function getCreatureDetails(uint256 _creatureId) public view creatureExists(_creatureId) returns (string memory name, address owner, uint256[] memory genes, uint256 birthTime, bool alive) {
        Creature storage creature = creatures[_creatureId];
        return (creature.name, creature.owner, creature.genes, creature.birthTimestamp, creature.isAlive);
    }

    // --- Internal Helper Functions ---
    function _combineGenes(uint256[] memory _genes1, uint256[] memory _genes2) internal pure returns (uint256[] memory) {
        require(_genes1.length == _genes2.length, "Genes arrays must be of the same length.");
        uint256[] memory combinedGenes = new uint256[](_genes1.length);
        for (uint256 i = 0; i < _genes1.length; i++) {
            combinedGenes[i] = (_genes1[i] + _genes2[i]) / 2; // Simple average gene combination
        }
        return combinedGenes;
    }

    function _mutateGenes(uint256[] memory _genes) internal view returns (uint256[] memory) {
        uint256 mutationRate = getEcosystemParameter("mutationRate");
        uint256[] memory mutatedGenes = new uint256[](_genes.length);
        for (uint256 i = 0; i < _genes.length; i++) {
            if (uint256(keccak256(abi.encode(block.timestamp, i, _genes[i]))) % 100 < mutationRate) { // Roll for mutation
                // Simple mutation: slightly change gene value (+/- a small random value)
                int256 mutationAmount = int256(uint256(keccak256(abi.encode(block.timestamp, i, _genes[i], msg.sender))) % 10) - 5; // Range -5 to +5
                int256 mutatedValue = int256(_genes[i]) + mutationAmount;
                if (mutatedValue < 0) mutatedValue = 0; // Ensure gene value stays non-negative
                if (mutatedValue > 100) mutatedValue = 100; // Example gene range 0-100
                mutatedGenes[i] = uint256(mutatedValue);
            } else {
                mutatedGenes[i] = _genes[i]; // No mutation
            }
        }
        return mutatedGenes;
    }

    function _evolveGenes(uint256[] memory _genes) internal pure returns (uint256[] memory) {
        uint256[] memory evolvedGenes = new uint256[](_genes.length);
        for (uint256 i = 0; i < _genes.length; i++) {
            // Example: Simple evolution - increase gene value by a fixed amount (can be more sophisticated)
            evolvedGenes[i] = _genes[i] + 10;
            if (evolvedGenes[i] > 100) evolvedGenes[i] = 100; // Cap gene value
        }
        return evolvedGenes;
    }

    function _simulateInteraction(uint256[] memory _genes1, uint256[] memory _genes2, string memory _interactionType) internal pure returns (uint256) {
        uint256 score1 = 0;
        uint256 score2 = 0;
        for (uint256 i = 0; i < _genes1.length; i++) {
            score1 += _genes1[i];
            score2 += _genes2[i];
        }

        // Example: Simple score-based interaction outcome
        if (_interactionType == "compete") {
            return score1 - score2 + 50; // Return a value centered around 50, higher means creature 1 is more "successful"
        } else if (_interactionType == "cooperate") {
            return score1 + score2; // Example cooperation score
        } else {
            return 50; // Default neutral outcome
        }
    }
}

// --- Utility Library ---
library Strings {
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
```