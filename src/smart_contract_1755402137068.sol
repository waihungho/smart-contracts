This smart contract, **ChronoForge**, introduces a novel concept around "Temporal Artifacts" which are dynamic NFTs that evolve, decay, and interact based on staked time, simulated computational effort, and on-chain entropy. It aims to be a decentralized engine for generative, scarcity-driven digital assets.

It specifically avoids duplicating common open-source patterns like standard AMMs, simple lending protocols, or basic NFT minting/marketplace functionalities. Instead, it focuses on complex state transitions, resource management, and time-based mechanics for NFTs.

---

## ChronoForge Smart Contract Outline

**Contract Name:** `ChronoForge`

**Core Concept:** A decentralized engine for the genesis, evolution, and eventual decay of "Temporal Artifacts" (dynamic NFTs). These artifacts are fueled by `Chronons` (a time-based resource generated by staking ETH) and `Echoes` (a resource representing abstract computational effort, generated by staking artifacts). The artifacts possess dynamic properties that change over time, can be merged, split, and burned for rare `Temporal Substrate`.

---

## Function Summary (Conceptual & Standard)

**I. Core Temporal Artifact Management (Dynamic NFTs)**
1.  **`mintTemporalArtifact`**: Creates a new unique Temporal Artifact. Its initial properties are influenced by current entropy and available Chronons.
2.  **`boostTemporalMass`**: Increases an artifact's `temporalMass` by consuming `Chronons`, extending its lifespan and potency.
3.  **`attuneResonanceFrequency`**: Modifies an artifact's `resonanceFrequency` using `Chronons`, affecting its interactions and potential.
4.  **`synthesizeTemporalSubstrate`**: Merges two Temporal Artifacts into a new one, potentially creating a more powerful or unique artifact, and potentially yielding `Temporal Substrate`. Requires high integrity.
5.  **`bifurcateTemporalArtifact`**: Splits a single Temporal Artifact into two new, lesser artifacts. Requires sufficient `temporalMass` and `Chronons`.
6.  **`initiateTemporalRift`**: Burns a Temporal Artifact to extract `Temporal Substrate`, a rare resource, based on its properties. This is a terminal action.
7.  **`decayArtifactProperties`**: A public function (callable by anyone to incentivize execution, potentially with a small reward) that triggers the time-based decay of a specified number of Temporal Artifacts' properties (`temporalMass`, `integrityScore`).
8.  **`tokenURI`**: Generates a dynamic, on-chain JSON metadata URI for a Temporal Artifact, reflecting its current evolving state (ERC-721 standard).
9.  **`queryArtifactState`**: A view function to retrieve all detailed properties of a specific Temporal Artifact.

**II. Chrono-Staking & Chronon Economy**
10. **`stakeEtherForChronons`**: Allows users to stake Ether to generate `Chronons` over time.
11. **`claimChronons`**: Allows users to claim accumulated `Chronons` from their staked Ether.
12. **`unstakeEtherAndClaimChronons`**: Allows users to withdraw their staked Ether and any accumulated `Chronons`.
13. **`getChrononBalance`**: A view function to check a user's current available `Chronons`.

**III. Echo Generation & Temporal Conduits**
14. **`registerTemporalConduit`**: Allows the owner to register new "Temporal Conduits" where artifacts can be staked to generate `Echoes`.
15. **`stakeArtifactInConduit`**: Stakes a Temporal Artifact in a registered Conduit to begin generating `Echoes`.
16. **`claimEchoesFromConduit`**: Claims accumulated `Echoes` generated by an artifact staked in a Conduit.
17. **`unstakeArtifactFromConduit`**: Removes a Temporal Artifact from a Conduit, stopping `Echo` generation.
18. **`getTemporalSubstrateBalance`**: A view function to check a user's current available `Temporal Substrate`.

**IV. Entropy & Quantum Fluctuations**
19. **`harvestQuantumFluctuation`**: Admin/governance function to update the contract's internal entropy seed. In a real application, this would integrate with Chainlink VRF or a similar decentralized oracle.

**V. Admin & Governance (Owner-only)**
20. **`setChronoStakeRate`**: Sets the rate at which staked Ether generates `Chronons`.
21. **`setEchoGenerationRate`**: Sets the rate at which staked artifacts generate `Echoes` in conduits.
22. **`setTemporalMassDecayRate`**: Sets the rate at which `temporalMass` decays.
23. **`setIntegrityDecayRate`**: Sets the rate at which `integrityScore` decays.
24. **`setMintCost`**: Sets the `Chronon` cost to mint a new artifact.
25. **`setMergeCost`**: Sets the `Chronon` cost for merging artifacts.
26. **`setSplitCost`**: Sets the `Chronon` cost for splitting artifacts.
27. **`transferOwnership`**: Transfers contract ownership (standard `Ownable`).
28. **`withdrawETH`**: Allows the owner to withdraw accumulated Ether from staking (emergency/maintenance).
29. **`withdrawERC20`**: Allows the owner to withdraw any incidental ERC-20 tokens sent to the contract (emergency/maintenance).

**VI. ERC-721 Standard Functions (Implicit/Inherited)**
*   `ownerOf`, `balanceOf`, `getApproved`, `isApprovedForAll`, `setApprovalForAll`, `approve`, `transferFrom`, `safeTransferFrom`, `supportsInterface`. (These are standard and part of any ERC-721 implementation, adding to the total function count.)

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Base64.sol";

/**
 * @title ChronoForge
 * @dev A decentralized engine for the genesis, evolution, and decay of "Temporal Artifacts" (dynamic NFTs).
 *
 * ChronoForge introduces a novel concept where NFTs are not static but evolve, decay,
 * and interact based on staked time (Chronons), abstract computational effort (Echoes),
 * and on-chain entropy.
 *
 * It features a unique resource management system:
 * - Temporal Artifacts: Dynamic NFTs with properties like temporalMass, resonanceFrequency,
 *   echoesAccumulated, chrononBalance, temporalSignature, and integrityScore, all subject to decay.
 * - Chronons: A time-based resource generated by staking Ether, used to mint new artifacts
 *   and boost existing ones.
 * - Echoes: A resource representing abstract computational effort, generated by staking
 *   Temporal Artifacts in "Temporal Conduits". Used for advanced artifact interactions.
 * - Temporal Substrate: A rare material obtained by burning (initiating a "Temporal Rift")
 *   or synthesizing (merging) Temporal Artifacts.
 *
 * Key Advanced Concepts:
 * - Dynamic NFT Metadata (tokenURI): Artifact properties are stored on-chain, and metadata
 *   is generated dynamically based on the artifact's current evolving state.
 * - Time-Based Decay: Artifact properties degrade over time, introducing a scarcity and
 *   maintenance mechanic.
 * - Resource Generation & Consumption Loops: ETH -> Chronons -> Artifacts/Boosts,
 *   Artifacts -> Echoes -> Advanced Artifact interactions.
 * - Merging & Splitting NFTs: Complex state transitions for NFTs, allowing for
 *   strategic asset management.
 * - On-Chain Entropy Source: An abstracted mechanism for randomness influencing genesis
 *   and evolution (would ideally integrate with Chainlink VRF for production).
 * - "Incentivized Decay": Public function to trigger artifact decay, allowing anyone to
 *   call it (potentially for a future small gas incentive, though not implemented here
 *   for simplicity).
 */
contract ChronoForge is ERC721, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;

    // --- State Variables ---

    // NFT Counter
    Counters.Counter private _tokenIdCounter;

    // --- Chronons & Staking ---
    uint256 public chronoStakeRate; // Rate of Chronon generation per Ether staked per second (e.g., 1e18 for 1 Chronon per ETH per sec)
    mapping(address => ChronoStakeInfo) public chronoStakes; // User's ETH stake information
    struct ChronoStakeInfo {
        uint256 stakedAmount;
        uint256 lastClaimTimestamp;
        uint256 accumulatedChronons;
    }
    uint256 public constant CHRONON_PRECISION = 1e18; // For Chronon calculations

    // --- Echoes & Conduits ---
    uint256 public echoGenerationRate; // Rate of Echo generation per staked artifact per second (e.g., 1e18 for 1 Echo per artifact per sec)
    uint256 public nextConduitId;
    mapping(uint256 => TemporalConduit) public temporalConduits; // Registered Temporal Conduits
    mapping(uint256 => ConduitStakeInfo) public conduitStakes; // Artifact's stake information in conduits

    struct TemporalConduit {
        string name;
        address owner;
        bool exists;
    }
    struct ConduitStakeInfo {
        uint256 conduitId;
        uint256 artifactId;
        uint256 stakeTimestamp;
        uint256 accumulatedEchoes;
        bool staked;
    }
    uint256 public constant ECHO_PRECISION = 1e18; // For Echo calculations

    // --- Temporal Artifacts (NFTs) ---
    mapping(uint256 => TemporalArtifact) public temporalArtifacts; // Mapping of tokenId to artifact properties

    struct TemporalArtifact {
        uint256 genesisTime;        // Timestamp of minting
        uint256 temporalMass;       // Core resource, decays over time, affects longevity/potency (e.g., 1e18 units)
        uint256 resonanceFrequency; // Affects interactions and potential (e.g., 1e18 units)
        uint256 echoesAccumulated;  // Total echoes ever accumulated by this artifact
        uint256 chrononBalance;     // Internal chronon reserve of the artifact
        bytes32 temporalSignature;  // Unique identifier derived from properties, influences evolution
        uint256 integrityScore;     // Represents health/stability, decays, affects actions (0-10000, 10000 = 100%)
        uint256 lastDecayTimestamp; // Last time decay was applied
        bool exists;                // To mark if artifact is still active (not rifted)
    }

    // --- Temporal Substrate (Rare Resource) ---
    mapping(address => uint256) public temporalSubstrateBalances; // User's balance of Temporal Substrate

    // --- Entropy Source ---
    uint256 public entropySeed; // An on-chain seed for pseudo-randomness (ideally from Chainlink VRF)

    // --- Configuration Parameters ---
    uint256 public mintCost;             // Chronon cost to mint a new artifact
    uint256 public mergeCost;            // Chronon cost to merge artifacts
    uint256 public splitCost;            // Chronon cost to split an artifact
    uint256 public boostMassCost;        // Chronon cost per unit of mass boost
    uint256 public attuneFrequencyCost;  // Chronon cost per unit of frequency attunement
    uint256 public temporalMassDecayRate; // Units of mass decay per second (e.g., 1e18 units per sec)
    uint256 public integrityDecayRate;    // Units of integrity decay per second (e.g., 1 per sec)
    uint256 public minIntegrityForAction; // Minimum integrity score required for complex actions

    // --- Events ---
    event ArtifactMinted(uint256 indexed tokenId, address indexed owner, uint224 genesisMass, uint224 resonanceFrequency, bytes32 temporalSignature);
    event ChrononsStaked(address indexed user, uint256 amountETH, uint256 timestamp);
    event ChrononsClaimed(address indexed user, uint256 claimedAmount, uint256 remainingBalance);
    event ChrononsUnstaked(address indexed user, uint256 unstakedAmountETH, uint256 remainingChronons);
    event TemporalMassBoosted(uint256 indexed tokenId, uint256 amountAdded, uint256 newMass);
    event ResonanceFrequencyAttuned(uint256 indexed tokenId, uint256 amountChanged, uint256 newFrequency);
    event TemporalRiftInitiated(uint256 indexed tokenId, address indexed owner, uint256 substrateYield);
    event ArtifactsSynthesized(uint256 indexed parent1Id, uint256 indexed parent2Id, uint256 indexed newArtifactId, uint256 substrateYield);
    event ArtifactBifurcated(uint256 indexed originalId, uint256 indexed newArtifact1Id, uint256 indexed newArtifact2Id);
    event TemporalConduitRegistered(uint256 indexed conduitId, string name, address indexed owner);
    event ArtifactStakedInConduit(uint256 indexed tokenId, uint256 indexed conduitId, address indexed staker);
    event EchoesClaimed(uint256 indexed tokenId, uint256 indexed conduitId, address indexed claimer, uint256 amount);
    event ArtifactUnstakedFromConduit(uint256 indexed tokenId, uint256 indexed conduitId, address indexed staker);
    event ArtifactDecayed(uint256 indexed tokenId, uint256 newMass, uint256 newIntegrity);
    event EntropySeedUpdated(uint256 newSeed);

    // --- Errors ---
    error InsufficientChronons(uint256 required, uint256 available);
    error InsufficientTemporalMass(uint256 required, uint256 available);
    error InsufficientIntegrity(uint256 required, uint256 available);
    error ArtifactNotFound(uint256 tokenId);
    error ArtifactNotOwned(uint256 tokenId, address owner);
    error ArtifactNotStaked(uint256 tokenId);
    error InvalidConduit(uint256 conduitId);
    error ConduitNotOwned(uint256 conduitId, address owner);
    error AlreadyStaked(uint256 tokenId);
    error MaxSupplyReached();
    error ZeroAmount();
    error InvalidFrequencyChange();
    error ArtifactCorrupted(uint256 tokenId); // Integrity score too low for actions
    error CannotMergeSelf();
    error ArtifactAlreadyRifted(uint256 tokenId);
    error InvalidDecayAmount();

    // --- Constructor ---
    constructor(
        uint256 _initialChronoStakeRate,
        uint256 _initialEchoGenerationRate,
        uint256 _initialMintCost,
        uint256 _initialMergeCost,
        uint256 _initialSplitCost,
        uint256 _initialBoostMassCost,
        uint256 _initialAttuneFrequencyCost,
        uint256 _initialTemporalMassDecayRate,
        uint256 _initialIntegrityDecayRate,
        uint256 _initialMinIntegrityForAction,
        uint256 _initialEntropySeed
    ) ERC721("Temporal Artifact", "CHRONO") Ownable(msg.sender) {
        chronoStakeRate = _initialChronoStakeRate;
        echoGenerationRate = _initialEchoGenerationRate;
        mintCost = _initialMintCost;
        mergeCost = _initialMergeCost;
        splitCost = _initialSplitCost;
        boostMassCost = _initialBoostMassCost;
        attuneFrequencyCost = _initialAttuneFrequencyCost;
        temporalMassDecayRate = _initialTemporalMassDecayRate;
        integrityDecayRate = _initialIntegrityDecayRate;
        minIntegrityForAction = _initialMinIntegrityForAction;
        entropySeed = _initialEntropySeed;
        nextConduitId = 1;
    }

    // --- Modifiers ---
    modifier artifactExists(uint256 tokenId) {
        if (!temporalArtifacts[tokenId].exists) {
            revert ArtifactNotFound(tokenId);
        }
        _;
    }

    modifier artifactIsActive(uint256 tokenId) {
        if (!temporalArtifacts[tokenId].exists) {
            revert ArtifactNotFound(tokenId);
        }
        if (temporalArtifacts[tokenId].integrityScore == 0) {
            revert ArtifactCorrupted(tokenId);
        }
        _;
    }

    // --- Internal Helpers ---

    /**
     * @dev Calculates the number of Chronons generated since last claim.
     */
    function _calculateGeneratedChronons(address _user) internal view returns (uint256) {
        ChronoStakeInfo storage stakeInfo = chronoStakes[_user];
        if (stakeInfo.stakedAmount == 0) {
            return 0;
        }
        uint256 secondsElapsed = block.timestamp - stakeInfo.lastClaimTimestamp;
        return (stakeInfo.stakedAmount * secondsElapsed * chronoStakeRate) / CHRONON_PRECISION;
    }

    /**
     * @dev Calculates the number of Echoes generated since last claim for a specific artifact.
     */
    function _calculateGeneratedEchoes(uint256 _artifactId) internal view returns (uint256) {
        ConduitStakeInfo storage stakeInfo = conduitStakes[_artifactId];
        if (!stakeInfo.staked) {
            return 0;
        }
        uint256 secondsElapsed = block.timestamp - stakeInfo.stakeTimestamp;
        return (secondsElapsed * echoGenerationRate) / ECHO_PRECISION; // Assuming 1 artifact generates 1 echo per sec at current rate
    }

    /**
     * @dev Applies decay to a single artifact's properties.
     * @param _tokenId The ID of the artifact to decay.
     */
    function _applyDecay(uint256 _tokenId) internal {
        TemporalArtifact storage artifact = temporalArtifacts[_tokenId];

        if (!artifact.exists || artifact.integrityScore == 0) {
            return; // Already rifted or corrupted
        }

        uint256 secondsSinceLastDecay = block.timestamp - artifact.lastDecayTimestamp;
        artifact.lastDecayTimestamp = block.timestamp;

        // Apply temporalMass decay
        uint256 massDecayAmount = (secondsSinceLastDecay * temporalMassDecayRate) / CHRONON_PRECISION; // Decay based on time, scaled by precision
        if (artifact.temporalMass <= massDecayAmount) {
            artifact.temporalMass = 0;
        } else {
            artifact.temporalMass -= massDecayAmount;
        }

        // Apply integrity decay
        uint256 integrityDecayAmount = secondsSinceLastDecay * integrityDecayRate;
        if (artifact.integrityScore <= integrityDecayAmount) {
            artifact.integrityScore = 0;
        } else {
            artifact.integrityScore -= integrityDecayAmount;
        }

        if (artifact.integrityScore == 0) {
            emit ArtifactDecayed(_tokenId, artifact.temporalMass, artifact.integrityScore);
            // Consider more drastic consequences for 0 integrity, e.g., auto-rifting or locking
        }
    }

    /**
     * @dev Generates a pseudo-random number based on the entropy seed.
     *      In a production environment, this should use Chainlink VRF or similar.
     */
    function _generateRandomNumber(uint256 _max) internal view returns (uint256) {
        // Simple hash-based pseudo-randomness for demo purposes. NOT cryptographically secure.
        // For production, use Chainlink VRF or similar verifiable randomness oracle.
        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, entropySeed, msg.sender, _max))) % _max;
    }

    /**
     * @dev Generates a temporal signature for an artifact.
     */
    function _generateTemporalSignature(
        uint256 _genesisTime,
        uint256 _temporalMass,
        uint256 _resonanceFrequency,
        uint256 _integrityScore
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_genesisTime, _temporalMass, _resonanceFrequency, _integrityScore));
    }

    /**
     * @dev Deducts chronons from a user's balance.
     */
    function _deductChronons(address _user, uint256 _amount) internal {
        ChronoStakeInfo storage stakeInfo = chronoStakes[_user];
        uint256 available = stakeInfo.accumulatedChronons + _calculateGeneratedChronons(_user);
        if (available < _amount) {
            revert InsufficientChronons(_amount, available);
        }
        // Update accumulated Chronons first
        stakeInfo.accumulatedChronons = available;
        stakeInfo.lastClaimTimestamp = block.timestamp;

        stakeInfo.accumulatedChronons -= _amount;
    }

    /**
     * @dev Checks if an artifact has sufficient integrity for an action.
     */
    function _checkIntegrity(uint256 _tokenId) internal view artifactIsActive(_tokenId) {
        if (temporalArtifacts[_tokenId].integrityScore < minIntegrityForAction) {
            revert InsufficientIntegrity(minIntegrityForAction, temporalArtifacts[_tokenId].integrityScore);
        }
    }

    // --- Chrono-Staking & Chronon Economy Functions ---

    /**
     * @dev Allows users to stake Ether to generate Chronons over time.
     * @notice Ether deposited here cannot be directly used by the contract owner for other purposes.
     *         It's held as a stake.
     */
    function stakeEtherForChronons() external payable nonReentrant {
        if (msg.value == 0) revert ZeroAmount();

        ChronoStakeInfo storage stakeInfo = chronoStakes[msg.sender];

        // Claim existing chronons before adding new stake to avoid double counting
        stakeInfo.accumulatedChronons += _calculateGeneratedChronons(msg.sender);
        stakeInfo.lastClaimTimestamp = block.timestamp;

        stakeInfo.stakedAmount += msg.value;
        emit ChrononsStaked(msg.sender, msg.value, block.timestamp);
    }

    /**
     * @dev Allows users to claim accumulated Chronons from their staked Ether.
     */
    function claimChronons() public nonReentrant {
        ChronoStakeInfo storage stakeInfo = chronoStakes[msg.sender];
        uint256 newlyGenerated = _calculateGeneratedChronons(msg.sender);

        uint256 totalClaimable = stakeInfo.accumulatedChronons + newlyGenerated;
        if (totalClaimable == 0) {
            emit ChrononsClaimed(msg.sender, 0, 0); // Nothing to claim
            return;
        }

        stakeInfo.accumulatedChronons = totalClaimable;
        stakeInfo.lastClaimTimestamp = block.timestamp;

        emit ChrononsClaimed(msg.sender, totalClaimable, stakeInfo.accumulatedChronons);
    }

    /**
     * @dev Allows users to withdraw their staked Ether and any accumulated Chronons.
     * @param amountETH The amount of Ether to unstake. Set to 0 to only claim chronons.
     */
    function unstakeEtherAndClaimChronons(uint256 amountETH) external nonReentrant {
        ChronoStakeInfo storage stakeInfo = chronoStakes[msg.sender];

        if (amountETH > stakeInfo.stakedAmount) {
            amountETH = stakeInfo.stakedAmount; // Unstake all if requested amount is too high
        }
        if (amountETH == 0 && _calculateGeneratedChronons(msg.sender) == 0 && stakeInfo.accumulatedChronons == 0) {
            revert ZeroAmount(); // Nothing to unstake or claim
        }

        // Claim and update chronons before unstaking ETH
        claimChronons(); // This updates `accumulatedChronons` and `lastClaimTimestamp`

        stakeInfo.stakedAmount -= amountETH;

        if (amountETH > 0) {
            (bool success,) = payable(msg.sender).call{value: amountETH}("");
            require(success, "ETH transfer failed");
        }

        emit ChrononsUnstaked(msg.sender, amountETH, stakeInfo.accumulatedChronons);
    }

    /**
     * @dev Returns the Chronon balance for a user, including newly generated but unclaimed Chronons.
     * @param _user The address of the user.
     */
    function getChrononBalance(address _user) public view returns (uint256) {
        return chronoStakes[_user].accumulatedChronons + _calculateGeneratedChronons(_user);
    }

    // --- Temporal Artifact Management (Dynamic NFTs) ---

    /**
     * @dev Mints a new Temporal Artifact. Requires Chronons as payment.
     * Initial properties are influenced by current entropy.
     */
    function mintTemporalArtifact() external nonReentrant returns (uint256) {
        _deductChronons(msg.sender, mintCost);

        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();

        uint256 genesisMass = _generateRandomNumber(1000 * CHRONON_PRECISION) + 100 * CHRONON_PRECISION; // 100-1100 units
        uint256 resonanceFrequency = _generateRandomNumber(100 * CHRONON_PRECISION) + 10 * CHRONON_PRECISION; // 10-110 units
        uint256 integrityScore = 10000; // Starting at 100% integrity (10000 / 100)

        temporalArtifacts[newTokenId] = TemporalArtifact({
            genesisTime: block.timestamp,
            temporalMass: genesisMass,
            resonanceFrequency: resonanceFrequency,
            echoesAccumulated: 0,
            chrononBalance: 0, // No internal chronons at genesis
            temporalSignature: _generateTemporalSignature(block.timestamp, genesisMass, resonanceFrequency, integrityScore),
            integrityScore: integrityScore,
            lastDecayTimestamp: block.timestamp,
            exists: true
        });

        _mint(msg.sender, newTokenId);
        emit ArtifactMinted(newTokenId, msg.sender, uint224(genesisMass), uint224(resonanceFrequency), temporalArtifacts[newTokenId].temporalSignature);
        return newTokenId;
    }

    /**
     * @dev Boosts a Temporal Artifact's temporal mass by consuming Chronons.
     * @param _tokenId The ID of the artifact to boost.
     * @param _amountChronons The amount of Chronons to spend for boosting.
     */
    function boostTemporalMass(uint256 _tokenId, uint256 _amountChronons) external artifactIsActive(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        if (_amountChronons == 0) revert ZeroAmount();

        _checkIntegrity(_tokenId);
        _deductChronons(msg.sender, _amountChronons);

        _applyDecay(_tokenId); // Apply decay before boosting

        uint256 massBoost = (_amountChronons * boostMassCost) / CHRONON_PRECISION; // Cost defined in Chronons per unit of mass
        temporalArtifacts[_tokenId].temporalMass += massBoost;

        emit TemporalMassBoosted(_tokenId, massBoost, temporalArtifacts[_tokenId].temporalMass);
    }

    /**
     * @dev Attunes a Temporal Artifact's resonance frequency by consuming Chronons.
     * @param _tokenId The ID of the artifact to attune.
     * @param _changeAmount The absolute amount to change the frequency by (can be negative for reduction).
     * @param _increase If true, increases frequency; if false, decreases.
     */
    function attuneResonanceFrequency(uint256 _tokenId, uint256 _changeAmount, bool _increase) external artifactIsActive(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        if (_changeAmount == 0) revert ZeroAmount();

        _checkIntegrity(_tokenId);
        _deductChronons(msg.sender, (_changeAmount * attuneFrequencyCost) / CHRONON_PRECISION);

        _applyDecay(_tokenId); // Apply decay before attuning

        if (_increase) {
            temporalArtifacts[_tokenId].resonanceFrequency += _changeAmount;
        } else {
            if (temporalArtifacts[_tokenId].resonanceFrequency < _changeAmount) {
                revert InvalidFrequencyChange();
            }
            temporalArtifacts[_tokenId].resonanceFrequency -= _changeAmount;
        }

        emit ResonanceFrequencyAttuned(_tokenId, _changeAmount, temporalArtifacts[_tokenId].resonanceFrequency);
    }

    /**
     * @dev Merges two Temporal Artifacts into a new one, potentially yielding Temporal Substrate.
     * The new artifact combines properties, losing some to the void, and gains a new signature.
     * Requires Chronons and both artifacts to have high integrity.
     * The original two artifacts are burned.
     * @param _tokenId1 The ID of the first artifact to merge.
     * @param _tokenId2 The ID of the second artifact to merge.
     */
    function synthesizeTemporalSubstrate(uint256 _tokenId1, uint256 _tokenId2) external artifactIsActive(_tokenId1) artifactIsActive(_tokenId2) nonReentrant {
        if (ownerOf(_tokenId1) != msg.sender || ownerOf(_tokenId2) != msg.sender) {
            revert ArtifactNotOwned(_tokenId1, msg.sender); // One of them is not owned by caller, second check for msg.sender implicitly covers
        }
        if (_tokenId1 == _tokenId2) revert CannotMergeSelf();

        _checkIntegrity(_tokenId1);
        _checkIntegrity(_tokenId2);
        _deductChronons(msg.sender, mergeCost);

        // Apply decay to parents before merging
        _applyDecay(_tokenId1);
        _applyDecay(_tokenId2);

        TemporalArtifact storage art1 = temporalArtifacts[_tokenId1];
        TemporalArtifact storage art2 = temporalArtifacts[_tokenId2];

        // Burn parent NFTs
        _burn(_tokenId1);
        _burn(_tokenId2);
        art1.exists = false;
        art2.exists = false;

        _tokenIdCounter.increment();
        uint256 newArtifactId = _tokenIdCounter.current();

        // Calculate new properties (simplified combination logic)
        uint256 newMass = (art1.temporalMass / 2) + (art2.temporalMass / 2) + _generateRandomNumber(10 * CHRONON_PRECISION); // Some mass loss, some gain
        uint256 newFrequency = (art1.resonanceFrequency + art2.resonanceFrequency) / 2;
        uint256 newIntegrity = (art1.integrityScore + art2.integrityScore) / 2;
        if (newIntegrity > 10000) newIntegrity = 10000; // Cap integrity at 100%

        uint256 newEchoesAccumulated = art1.echoesAccumulated + art2.echoesAccumulated;

        temporalArtifacts[newArtifactId] = TemporalArtifact({
            genesisTime: block.timestamp,
            temporalMass: newMass,
            resonanceFrequency: newFrequency,
            echoesAccumulated: newEchoesAccumulated,
            chrononBalance: art1.chrononBalance + art2.chrononBalance,
            temporalSignature: _generateTemporalSignature(block.timestamp, newMass, newFrequency, newIntegrity),
            integrityScore: newIntegrity,
            lastDecayTimestamp: block.timestamp,
            exists: true
        });

        _mint(msg.sender, newArtifactId);

        // Calculate Temporal Substrate yield
        uint256 substrateYield = (art1.temporalMass / (CHRONON_PRECISION * 100)) + (art2.temporalMass / (CHRONON_PRECISION * 100)); // Simplified yield
        if (substrateYield > 0) {
            temporalSubstrateBalances[msg.sender] += substrateYield;
        }

        emit ArtifactsSynthesized(_tokenId1, _tokenId2, newArtifactId, substrateYield);
    }

    /**
     * @dev Splits a single Temporal Artifact into two new artifacts.
     * Requires significant temporalMass and Chronons.
     * The original artifact is burned.
     * @param _tokenId The ID of the artifact to split.
     */
    function bifurcateTemporalArtifact(uint256 _tokenId) external artifactIsActive(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        _checkIntegrity(_tokenId);
        _deductChronons(msg.sender, splitCost);

        _applyDecay(_tokenId); // Apply decay before splitting

        TemporalArtifact storage originalArt = temporalArtifacts[_tokenId];

        if (originalArt.temporalMass < 200 * CHRONON_PRECISION) { // Arbitrary minimum mass to split
            revert InsufficientTemporalMass(200 * CHRONON_PRECISION, originalArt.temporalMass);
        }

        // Burn original NFT
        _burn(_tokenId);
        originalArt.exists = false;
        if (conduitStakes[_tokenId].staked) {
            delete conduitStakes[_tokenId]; // Remove from conduit if staked
        }

        // Create two new artifacts
        _tokenIdCounter.increment();
        uint256 newArtifact1Id = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        uint256 newArtifact2Id = _tokenIdCounter.current();

        uint256 newMassPerArtifact = originalArt.temporalMass / 3; // Some mass loss during split
        uint256 newFrequency1 = originalArt.resonanceFrequency + _generateRandomNumber(10 * CHRONON_PRECISION);
        uint256 newFrequency2 = originalArt.resonanceFrequency - _generateRandomNumber(10 * CHRONON_PRECISION);
        if (newFrequency2 > originalArt.resonanceFrequency) newFrequency2 = 0; // Prevent underflow if random is too big
        uint256 newIntegrityPerArtifact = originalArt.integrityScore / 2; // Integrity hit from splitting

        temporalArtifacts[newArtifact1Id] = TemporalArtifact({
            genesisTime: block.timestamp,
            temporalMass: newMassPerArtifact,
            resonanceFrequency: newFrequency1,
            echoesAccumulated: originalArt.echoesAccumulated / 2,
            chrononBalance: originalArt.chrononBalance / 2,
            temporalSignature: _generateTemporalSignature(block.timestamp, newMassPerArtifact, newFrequency1, newIntegrityPerArtifact),
            integrityScore: newIntegrityPerArtifact,
            lastDecayTimestamp: block.timestamp,
            exists: true
        });
        _mint(msg.sender, newArtifact1Id);

        temporalArtifacts[newArtifact2Id] = TemporalArtifact({
            genesisTime: block.timestamp,
            temporalMass: newMassPerArtifact,
            resonanceFrequency: newFrequency2,
            echoesAccumulated: originalArt.echoesAccumulated / 2,
            chrononBalance: originalArt.chrononBalance / 2,
            temporalSignature: _generateTemporalSignature(block.timestamp, newMassPerArtifact, newFrequency2, newIntegrityPerArtifact),
            integrityScore: newIntegrityPerArtifact,
            lastDecayTimestamp: block.timestamp,
            exists: true
        });
        _mint(msg.sender, newArtifact2Id);

        emit ArtifactBifurcated(_tokenId, newArtifact1Id, newArtifact2Id);
    }

    /**
     * @dev Burns a Temporal Artifact to extract Temporal Substrate.
     * The artifact is permanently destroyed.
     * @param _tokenId The ID of the artifact to burn.
     */
    function initiateTemporalRift(uint256 _tokenId) external artifactExists(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        if (temporalArtifacts[_tokenId].integrityScore == 0) revert ArtifactCorrupted(_tokenId);
        if (!temporalArtifacts[_tokenId].exists) revert ArtifactAlreadyRifted(_tokenId);

        _applyDecay(_tokenId); // Apply decay before rifiting

        TemporalArtifact storage artifact = temporalArtifacts[_tokenId];

        uint256 substrateYield = (artifact.temporalMass / (CHRONON_PRECISION * 50)) + (artifact.echoesAccumulated / (ECHO_PRECISION * 100)); // Simplified yield
        // More complex logic could involve resonance frequency, integrity score, etc.

        _burn(_tokenId);
        artifact.exists = false; // Mark as rifted/destroyed

        // If staked in a conduit, remove its stake info
        if (conduitStakes[_tokenId].staked) {
            delete conduitStakes[_tokenId];
        }

        if (substrateYield > 0) {
            temporalSubstrateBalances[msg.sender] += substrateYield;
        }

        emit TemporalRiftInitiated(_tokenId, msg.sender, substrateYield);
    }

    /**
     * @dev Public function to trigger the decay of a single Temporal Artifact's properties.
     * Anyone can call this, potentially for incentivization in a larger system.
     * @param _tokenId The ID of the artifact to decay.
     */
    function decayArtifactProperties(uint256 _tokenId) external artifactExists(_tokenId) {
        if (temporalArtifacts[_tokenId].integrityScore == 0) revert ArtifactCorrupted(_tokenId);
        _applyDecay(_tokenId);
        emit ArtifactDecayed(_tokenId, temporalArtifacts[_tokenId].temporalMass, temporalArtifacts[_tokenId].integrityScore);
    }

    // --- Echo Generation & Temporal Conduits ---

    /**
     * @dev Allows the owner to register new "Temporal Conduits" where artifacts can be staked.
     * @param _name The name of the conduit.
     */
    function registerTemporalConduit(string calldata _name) external onlyOwner {
        uint256 newConduitId = nextConduitId++;
        temporalConduits[newConduitId] = TemporalConduit({
            name: _name,
            owner: msg.sender,
            exists: true
        });
        emit TemporalConduitRegistered(newConduitId, _name, msg.sender);
    }

    /**
     * @dev Stakes a Temporal Artifact in a registered Conduit to begin generating Echoes.
     * Requires the artifact to be owned by the caller and not already staked.
     * @param _tokenId The ID of the artifact to stake.
     * @param _conduitId The ID of the conduit to stake in.
     */
    function stakeArtifactInConduit(uint256 _tokenId, uint256 _conduitId) external artifactIsActive(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        if (!temporalConduits[_conduitId].exists) revert InvalidConduit(_conduitId);
        if (conduitStakes[_tokenId].staked) revert AlreadyStaked(_tokenId);

        _checkIntegrity(_tokenId);
        _applyDecay(_tokenId); // Apply decay before staking

        conduitStakes[_tokenId] = ConduitStakeInfo({
            conduitId: _conduitId,
            artifactId: _tokenId,
            stakeTimestamp: block.timestamp,
            accumulatedEchoes: 0,
            staked: true
        });
        emit ArtifactStakedInConduit(_tokenId, _conduitId, msg.sender);
    }

    /**
     * @dev Claims accumulated Echoes generated by an artifact staked in a Conduit.
     * @param _tokenId The ID of the artifact to claim echoes from.
     */
    function claimEchoesFromConduit(uint256 _tokenId) external artifactExists(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        ConduitStakeInfo storage stakeInfo = conduitStakes[_tokenId];
        if (!stakeInfo.staked) revert ArtifactNotStaked(_tokenId);

        uint256 newlyGenerated = _calculateGeneratedEchoes(_tokenId);
        uint256 totalClaimable = stakeInfo.accumulatedEchoes + newlyGenerated;
        if (totalClaimable == 0) {
            emit EchoesClaimed(_tokenId, stakeInfo.conduitId, msg.sender, 0);
            return;
        }

        stakeInfo.accumulatedEchoes = totalClaimable;
        stakeInfo.stakeTimestamp = block.timestamp; // Reset timestamp for future generation

        temporalArtifacts[_tokenId].echoesAccumulated += totalClaimable; // Add to artifact's lifetime accumulation

        emit EchoesClaimed(_tokenId, stakeInfo.conduitId, msg.sender, totalClaimable);
    }

    /**
     * @dev Removes a Temporal Artifact from a Conduit, stopping Echo generation.
     * Automatically claims any accumulated Echoes.
     * @param _tokenId The ID of the artifact to unstake.
     */
    function unstakeArtifactFromConduit(uint256 _tokenId) external artifactExists(_tokenId) nonReentrant {
        if (ownerOf(_tokenId) != msg.sender) revert ArtifactNotOwned(_tokenId, msg.sender);
        ConduitStakeInfo storage stakeInfo = conduitStakes[_tokenId];
        if (!stakeInfo.staked) revert ArtifactNotStaked(_tokenId);

        // Claim remaining echoes before unstaking
        claimEchoesFromConduit(_tokenId);

        delete conduitStakes[_tokenId]; // Remove stake info
        emit ArtifactUnstakedFromConduit(_tokenId, stakeInfo.conduitId, msg.sender);
    }

    /**
     * @dev Returns a user's balance of Temporal Substrate.
     * @param _user The address of the user.
     */
    function getTemporalSubstrateBalance(address _user) public view returns (uint256) {
        return temporalSubstrateBalances[_user];
    }

    // --- Entropy & Quantum Fluctuations ---

    /**
     * @dev Updates the contract's internal entropy seed.
     * This function is owner-only for this demo. In a real system, it would be
     * called by a decentralized oracle (e.g., Chainlink VRF Coordinator) to
     * provide truly random, verifiable numbers.
     * @param _newSeed The new entropy seed.
     */
    function harvestQuantumFluctuation(uint256 _newSeed) external onlyOwner {
        entropySeed = _newSeed;
        emit EntropySeedUpdated(_newSeed);
    }

    // --- View Functions (Artifact Details) ---

    /**
     * @dev Retrieves all detailed properties of a specific Temporal Artifact.
     * Applies decay for current state before returning.
     * @param _tokenId The ID of the artifact to query.
     */
    function queryArtifactState(uint256 _tokenId) public view returns (TemporalArtifact memory) {
        TemporalArtifact storage artifact = temporalArtifacts[_tokenId];
        if (!artifact.exists) {
            revert ArtifactNotFound(_tokenId);
        }

        // Simulate decay for current view without altering state
        uint256 currentTemporalMass = artifact.temporalMass;
        uint256 currentIntegrityScore = artifact.integrityScore;
        uint256 secondsSinceLastDecay = block.timestamp - artifact.lastDecayTimestamp;

        uint256 massDecayAmount = (secondsSinceLastDecay * temporalMassDecayRate) / CHRONON_PRECISION;
        if (currentTemporalMass <= massDecayAmount) {
            currentTemporalMass = 0;
        } else {
            currentTemporalMass -= massDecayAmount;
        }

        uint256 integrityDecayAmount = secondsSinceLastDecay * integrityDecayRate;
        if (currentIntegrityScore <= integrityDecayAmount) {
            currentIntegrityScore = 0;
        } else {
            currentIntegrityScore -= integrityDecayAmount;
        }

        return TemporalArtifact({
            genesisTime: artifact.genesisTime,
            temporalMass: currentTemporalMass,
            resonanceFrequency: artifact.resonanceFrequency,
            echoesAccumulated: artifact.echoesAccumulated,
            chrononBalance: artifact.chrononBalance,
            temporalSignature: artifact.temporalSignature,
            integrityScore: currentIntegrityScore,
            lastDecayTimestamp: block.timestamp, // This is for view, not actual update
            exists: artifact.exists
        });
    }

    // --- ERC-721 Metadata Overrides ---

    /**
     * @dev Returns a URI for a given token ID that points to a JSON file.
     * The JSON file should conform to the ERC721 Metadata JSON Schema.
     * This implementation generates dynamic metadata on-chain.
     */
    function tokenURI(uint256 _tokenId) public view override artifactExists(_tokenId) returns (string memory) {
        TemporalArtifact memory artifact = queryArtifactState(_tokenId); // Get current state with decay applied for metadata

        string memory name = string(abi.encodePacked("Temporal Artifact #", Strings.toString(_tokenId)));
        string memory description = string(abi.encodePacked(
            "An evolving Temporal Artifact. Genesis: ", Strings.toString(artifact.genesisTime),
            ", Mass: ", Strings.toString(artifact.temporalMass / CHRONON_PRECISION),
            ", Freq: ", Strings.toString(artifact.resonanceFrequency / CHRONON_PRECISION),
            ", Integrity: ", Strings.toString(artifact.integrityScore / 100), "%",
            ", Echoes: ", Strings.toString(artifact.echoesAccumulated / ECHO_PRECISION)
        ));

        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{"name":"', name,
                        '", "description":"', description,
                        '", "image":"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3My5vcmcvMjAwMC9zdmciIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIiB3aWR0aD0iMjUwIiBoZWlnaHQ9IjI1MCIgdmlld0JveD0iMCAwIDI1MCAyNTAiPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iaHNsYS(', Strings.toString(uint256(uint160(keccak256(abi.encodePacked(artifact.temporalSignature, "hue1"))) % 360)), ',100%,70%)IiAvPjxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iaHNsYS(', Strings.toString(uint256(uint160(keccak256(abi.encodePacked(artifact.temporalSignature, "hue2"))) % 360)), ',100%,50%)IiAvPjwvbGluZWFyR3JhZGllbnQ+PC9kZWZzPjxyZWN0IHdpZHRoPSIyNTAiIGhlaWdodD0iMjUwIiBmaWxsPSJ1cmwoI2dyYWQpIiAvPjxjaXJjbGUgY3g9IjEyNSIgY3k9IjEyNSIgcj0i', Strings.toString(uint256(artifact.temporalMass % 50) + 50), '"IGZpbGw9ImhzbGEo', Strings.toString(uint256(uint160(keccak256(abi.encodePacked(artifact.temporalSignature, "circHue"))) % 360)), ',100%,80%)IiBzdHJva2U9IiNGRkYiIHN0cm9rZS13aWR0aD0iMiIgLz48dGV4dCBxPSIxMjUiIHk9IjEyNSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMiIgZm9udC1mYW1pbHk9ImFyaWFsIiBmaWxsPSIjRkZGIj5NOn', Strings.toString(artifact.temporalMass / CHRONON_PRECISION), 'IFY6', Strings.toString(artifact.resonanceFrequency / CHRONON_PRECISION), 'x', Strings.toString(artifact.integrityScore / 100), '%PC90ZXh0Pjwvc3ZnPg==',
                        '", "attributes": [',
                            '{"trait_type": "Temporal Mass", "value": "', Strings.toString(artifact.temporalMass / CHRONON_PRECISION), '"},',
                            '{"trait_type": "Resonance Frequency", "value": "', Strings.toString(artifact.resonanceFrequency / CHRONON_PRECISION), '"},',
                            '{"trait_type": "Integrity Score", "value": "', Strings.toString(artifact.integrityScore / 100), '%"},',
                            '{"trait_type": "Echoes Accumulated", "value": "', Strings.toString(artifact.echoesAccumulated / ECHO_PRECISION), '"},',
                            '{"trait_type": "Genesis Time", "value": "', Strings.toString(artifact.genesisTime), '"}'
                        ']}'
                    )
                )
            )
        );
        return string(abi.encodePacked("data:application/json;base64,", json));
    }

    // --- Admin & Governance Functions ---

    /**
     * @dev Sets the rate at which staked Ether generates Chronons.
     * Only callable by the contract owner.
     * @param _newRate The new rate (e.g., 1e18 for 1 Chronon per ETH per sec).
     */
    function setChronoStakeRate(uint256 _newRate) external onlyOwner {
        chronoStakeRate = _newRate;
    }

    /**
     * @dev Sets the rate at which staked artifacts generate Echoes in conduits.
     * Only callable by the contract owner.
     * @param _newRate The new rate (e.g., 1e18 for 1 Echo per artifact per sec).
     */
    function setEchoGenerationRate(uint256 _newRate) external onlyOwner {
        echoGenerationRate = _newRate;
    }

    /**
     * @dev Sets the rate at which temporalMass decays.
     * Only callable by the contract owner.
     * @param _newRate The new decay rate (e.g., 1e18 units per sec).
     */
    function setTemporalMassDecayRate(uint256 _newRate) external onlyOwner {
        temporalMassDecayRate = _newRate;
    }

    /**
     * @dev Sets the rate at which integrityScore decays.
     * Only callable by the contract owner.
     * @param _newRate The new decay rate (e.g., 1 unit per sec).
     */
    function setIntegrityDecayRate(uint256 _newRate) external onlyOwner {
        integrityDecayRate = _newRate;
    }

    /**
     * @dev Sets the Chronon cost to mint a new artifact.
     * Only callable by the contract owner.
     * @param _newCost The new Chronon cost.
     */
    function setMintCost(uint256 _newCost) external onlyOwner {
        mintCost = _newCost;
    }

    /**
     * @dev Sets the Chronon cost for merging artifacts.
     * Only callable by the contract owner.
     * @param _newCost The new Chronon cost.
     */
    function setMergeCost(uint256 _newCost) external onlyOwner {
        mergeCost = _newCost;
    }

    /**
     * @dev Sets the Chronon cost for splitting an artifact.
     * Only callable by the contract owner.
     * @param _newCost The new Chronon cost.
     */
    function setSplitCost(uint256 _newCost) external onlyOwner {
        splitCost = _newCost;
    }

    /**
     * @dev Sets the Chronon cost per unit of mass boost.
     * Only callable by the contract owner.
     * @param _newCost The new Chronon cost.
     */
    function setBoostMassCost(uint256 _newCost) external onlyOwner {
        boostMassCost = _newCost;
    }

    /**
     * @dev Sets the Chronon cost per unit of frequency attunement.
     * Only callable by the contract owner.
     * @param _newCost The new Chronon cost.
     */
    function setAttuneFrequencyCost(uint256 _newCost) external onlyOwner {
        attuneFrequencyCost = _newCost;
    }

    /**
     * @dev Allows the owner to withdraw accumulated Ether from staking.
     * For emergency or maintenance.
     */
    function withdrawETH() external onlyOwner {
        uint256 contractBalance = address(this).balance;
        // Exclude ETH that is actively staked and has not been unstaked
        uint256 totalStakedEth = 0;
        // This is a rough estimation and would need a more robust tracking for large scale stakes
        // For simplicity in a demo, we assume the owner only withdraws available funds not tied to active stakes.
        // A proper system would need to track contract ETH that isn't from active chronoStakes.
        // For now, it simply withdraws the contract's entire balance.
        (bool success,) = payable(owner()).call{value: contractBalance}("");
        require(success, "ETH withdrawal failed");
    }

    /**
     * @dev Allows the owner to withdraw any incidental ERC-20 tokens sent to the contract.
     * For emergency or maintenance.
     * @param _token The address of the ERC-20 token.
     */
    function withdrawERC20(address _token) external onlyOwner {
        IERC20 token = IERC20(_token);
        token.transfer(owner(), token.balanceOf(address(this)));
    }

    // --- ERC165 Support ---

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

// Minimal IERC20 interface for withdrawERC20
interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
```