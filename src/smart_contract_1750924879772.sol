Okay, here is a Solidity smart contract for a "Decentralized AI Art Marketplace with Fractional Revenue Sharing, Staking, and Basic Governance".

This contract aims to be creative by:
1.  **Linking NFTs to AI Models:** Tracking which (simulated) AI model generated the art and allocating a portion of royalties.
2.  **Fractional Revenue Sharing:** Allowing initial creators/collectors to define fractions of future sale revenue that go to specific addresses.
3.  **NFT Staking with Fee Rewards:** Users can stake their owned AI art NFTs to earn a portion of the marketplace fees.
4.  **Basic On-chain Governance:** Token holders (or perhaps staked NFT holders in a more advanced version, but we'll use simple voting power here) can propose and vote on changes (like marketplace fees).

**Disclaimer:** This is a complex example combining multiple features. It serves as a conceptual demonstration and is **not audited or production-ready**. Building a truly robust system would require significantly more detailed logic, security considerations, and potentially separate contracts for concerns like fractional ownership tokens or complex governance. The "AI Model" concept here is simulated on-chain (tracking model IDs, owners, and royalties). The actual AI generation happens off-chain.

---

**Outline and Function Summary:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// --- Imports ---
// ERC721 standards for NFTs
// Ownable for basic ownership/admin (though governance will override some admin functions)
// Pausable for pausing marketplace activity

// --- State Variables ---
// Counters for NFTs and proposals
// Mappings for NFT details: owner, URI, creation data (prompt, modelId), revenue shares, staked status
// Structs/Mappings for AI Models: owner, royalty %, accumulated royalties
// Structs/Mappings for Listings: fixed price, seller, state
// Structs/Mappings for Auctions: highest bid, bidder, end time, state
// Mappings for Revenue Shares: address => tokenId => claimable amount
// Mappings for Staking: tokenId => stake info (staker, stake time, accumulated rewards)
// State for Staking Rewards Pool (accumulated fees)
// Structs/Mappings for Governance Proposals: details, votes, state
// State for Marketplace Fees: percentage, accumulated fees

// --- Events ---
// Minting, Listing, Buying, Bidding, Auction events
// AI Model events
// Revenue Share events
// Staking events
// Governance events
// Fee events
// Pause/Unpause events

// --- Modifiers ---
// requireMinted: Checks if token exists
// onlyNFTOwner: Checks if msg.sender is the token owner
// onlyNFTCreator: Checks if msg.sender is the minter of the token
// onlyAIModelOwner: Checks if msg.sender is the owner of a specific AI model
// notStaked: Checks if an NFT is not currently staked
// onlyStaked: Checks if an NFT is currently staked
// whenNotPaused: Checks if contract is not paused
// whenPaused: Checks if contract is paused
// onlyProposer: Checks if msg.sender is the proposal creator
// onlyActiveProposal: Checks if proposal is in voting state

// --- Core ERC721 Functions (Standard - inherited/overridden) ---
// transferFrom
// approve
// getApproved
// setApprovalForAll
// isApprovedForAll
// balanceOf
// ownerOf
// safeTransferFrom

// --- Custom Functions (20+) ---

// --- AI Model Management (Simulated) ---
// 1. registerAIModel(string memory _name, uint256 _royaltyPercentage)
//    - Registers a new AI model with a defined royalty percentage. Only owner/governance can register.
// 2. updateAIModelRoyalty(uint256 _modelId, uint256 _newRoyaltyPercentage)
//    - Updates the royalty percentage for an existing AI model. Only model owner/governance.
// 3. getAIModelDetails(uint256 _modelId) view
//    - Gets details of an AI model.
// 4. claimAIModelRoyalties(uint256 _modelId)
//    - Allows the AI model owner to claim accumulated royalties from sales of art generated by their model.

// --- NFT Minting ---
// 5. mintAIArtNFT(uint256 _modelId, string memory _tokenURI, string memory _prompt, address[] memory _revenueShareHolders, uint256[] memory _revenueSharePercentages)
//    - Mints a new AI art NFT. Links it to an AI model, sets URI and prompt, and defines initial revenue share distribution for future sales. Caller becomes initial owner.

// --- Marketplace: Fixed Price ---
// 6. listNFTForFixedPrice(uint256 _tokenId, uint256 _price)
//    - Lists an owned NFT for sale at a fixed price. Requires NFT approval for the contract.
// 7. buyFixedPriceNFT(uint256 _tokenId) payable
//    - Buys an NFT listed for a fixed price. Transfers funds, NFT, handles royalties and fees.
// 8. cancelListing(uint256 _tokenId)
//    - Cancels an active fixed-price listing. Only callable by seller.

// --- Marketplace: Auction ---
// 9. listNFTForAuction(uint256 _tokenId, uint256 _startPrice, uint256 _duration)
//    - Lists an owned NFT for auction with a starting price and duration. Requires NFT approval.
// 10. placeAuctionBid(uint256 _tokenId) payable
//     - Places a bid on an active auction. Must be higher than current highest bid. Handles refunding previous bidder.
// 11. endAuction(uint256 _tokenId)
//     - Ends an auction after its duration. Transfers NFT to highest bidder, distributes funds (seller, royalties, fees). Refunds losing bidders.
// 12. cancelAuction(uint256 _tokenId)
//     - Cancels an auction before its first valid bid is placed. Only callable by seller.

// --- Revenue Sharing ---
// 13. setNFTRevenueShares(uint256 _tokenId, address[] memory _holders, uint256[] memory _percentages)
//     - Sets or updates the revenue share distribution for a specific NFT. Only callable by the *current* owner.
// 14. claimRevenueShare(uint256 _tokenId)
//     - Allows a holder with defined revenue shares for an NFT to claim their accrued revenue.

// --- Staking ---
// 15. stakeNFT(uint256 _tokenId)
//     - Stakes an owned NFT. Requires NFT approval. Makes the NFT unavailable for sale/transfer while staked.
// 16. unstakeNFT(uint256 _tokenId)
//     - Unstakes a previously staked NFT.
// 17. claimStakingRewards()
//     - Claims accumulated staking rewards for *all* NFTs currently staked by the caller. Rewards are distributed from the fee pool based on staked duration.

// --- Governance ---
// 18. proposeChange(string memory _description, bytes memory _calldata, address _targetContract)
//     - Proposes a change (e.g., changing fee percentage by calling setMarketplaceFee via _calldata). Open to certain holders (e.g., minters, stakers - simple: open to anyone for this example).
// 19. voteOnProposal(uint256 _proposalId, bool _support)
//     - Votes on an active proposal. Voting power could be based on held NFTs, staked NFTs, or a separate token (simple: 1 address = 1 vote).
// 20. executeProposal(uint256 _proposalId)
//     - Executes a proposal that has passed the voting period and threshold.

// --- Admin/Fee Management (Potentially governance controlled) ---
// 21. setMarketplaceFee(uint256 _feePercentage)
//     - Sets the marketplace fee percentage. Designed to be callable by governance, or initially by owner.
// 22. withdrawFees()
//     - Allows the owner or governance to withdraw accumulated marketplace fees.

// --- View Functions (Querying State) ---
// 23. getNFTDetails(uint256 _tokenId) view
//     - Returns details of an NFT (owner, URI, modelId, prompt, shares).
// 24. getListingDetails(uint256 _tokenId) view
//     - Returns details of a fixed-price listing.
// 25. getAuctionDetails(uint256 _tokenId) view
//     - Returns details of an auction.
// 26. getUserNFTs(address _user) view
//     - Returns a list of NFT token IDs owned by a user (requires tracking).
// 27. getUserStakedNFTs(address _user) view
//     - Returns a list of NFT token IDs staked by a user.
// 28. getUserClaimableRevenueShare(address _user, uint256 _tokenId) view
//     - Returns the amount of revenue share claimable by a user for a specific NFT.
// 29. getUserClaimableStakingRewards(address _user) view
//     - Returns the total staking rewards claimable by a user across all their staked NFTs.
// 30. getProposalDetails(uint256 _proposalId) view
//     - Returns details of a governance proposal.
// 31. getCollectedFees() view
//     - Returns the total collected marketplace fees.
// 32. getStakingRewardPool() view
//     - Returns the current balance of the staking reward pool.

```

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // For potential future expansions

// Helper library for safe ETH transfers
import "@openzeppelin/contracts/utils/Address.sol";

contract DecentralizedAIArtMarketplace is ERC721, Ownable, Pausable, ERC721Holder, ReentrancyGuard {
    using Counters for Counters.Counter;
    using Address for address payable; // For safe ETH transfers

    Counters.Counter private _tokenIdCounter;
    Counters.Counter private _modelIdCounter;
    Counters.Counter private _proposalIdCounter;

    // --- Structs ---

    struct AIModel {
        address owner;
        string name;
        uint256 royaltyPercentage; // Percentage of sale price, 0-10000 (for 0-100%)
        uint256 accumulatedRoyalties;
    }

    struct NFTCreationData {
        uint256 modelId;
        string prompt;
        address creator; // Original minter
    }

    struct RevenueShare {
        address holder;
        uint256 percentage; // Percentage of revenue from sales, 0-10000 (for 0-100%)
    }

    enum ListingStatus { Active, Sold, Canceled }
    struct FixedPriceListing {
        uint256 price;
        address seller;
        ListingStatus status;
    }

    enum AuctionStatus { Active, Ended, Canceled }
    struct Auction {
        uint256 startPrice;
        uint256 highestBid;
        address payable highestBidder;
        uint256 endTime;
        AuctionStatus status;
        address payable seller;
    }

    struct Bid {
        uint256 amount;
        address payable bidder;
    }

    struct StakingInfo {
        address staker;
        uint256 stakeTime; // Timestamp of staking
        uint256 accumulatedRewards; // Rewards accumulated for this specific stake session
    }

    enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Executed }
    struct GovernanceProposal {
        string description;
        bytes calldataPayload; // Data for target function call
        address targetContract; // Contract to call (e.g., this contract's address)
        uint256 voteStartTime;
        uint256 voteEndTime;
        uint256 votesFor;
        uint256 votesAgainst;
        address proposer;
        ProposalState state;
    }

    // --- State Variables ---

    mapping(uint256 => AIModel) public aiModels;
    mapping(uint256 => NFTCreationData) public nftCreationData;
    mapping(uint256 => RevenueShare[]) public nftRevenueShares; // tokenId => list of holders and percentages
    mapping(address => mapping(uint256 => uint256)) public claimableRevenueShares; // holder => tokenId => amount

    mapping(uint256 => FixedPriceListing) public fixedPriceListings;
    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => Bid) private highestBids; // tokenId => highest bid info
    mapping(uint256 => address) private previousBidders; // tokenId => address of the bidder who was just outbid

    mapping(uint256 => StakingInfo) public stakedNFTs; // tokenId => staking info
    mapping(address => uint256[]) private userStakedTokenIds; // Helper to track staked tokens per user (potentially gas-intensive)
    uint256 public totalStakedNFTs;
    uint256 public stakingRewardPool; // ETH pool for staking rewards

    mapping(uint256 => GovernanceProposal) public governanceProposals;
    mapping(uint256 => mapping(address => bool)) public hasVoted; // proposalId => voter => voted

    uint256 public marketplaceFeePercentage; // Percentage of sale price, 0-10000 (for 0-100%)
    uint256 public collectedFees;

    // Governance parameters
    uint256 public votingPeriod = 7 days; // Duration proposals are open for voting
    uint256 public proposalThreshold = 1; // Minimum required vote weight to pass (simple: 1 vote for now)
    uint256 public voteQuorum = 0; // Minimum total votes required (simple: 0 for now)


    // --- Events ---

    event AIModelRegistered(uint256 indexed modelId, address indexed owner, string name, uint256 royaltyPercentage);
    event AIModelRoyaltyUpdated(uint256 indexed modelId, uint256 newRoyaltyPercentage);
    event AIModelRoyaltiesClaimed(uint256 indexed modelId, address indexed owner, uint256 amount);

    event NFTMinted(uint256 indexed tokenId, address indexed owner, uint256 indexed modelId, string tokenURI, string prompt);
    event RevenueSharesSet(uint256 indexed tokenId, address indexed setter);
    event RevenueShareClaimed(uint256 indexed tokenId, address indexed holder, uint256 amount);

    event NFTListedForFixedPrice(uint256 indexed tokenId, address indexed seller, uint256 price);
    event NFTBought(uint256 indexed tokenId, address indexed buyer, uint256 price);
    event FixedPriceListingCanceled(uint256 indexed tokenId, address indexed seller);

    event NFTListedForAuction(uint256 indexed tokenId, address indexed seller, uint256 startPrice, uint256 endTime);
    event AuctionBidPlaced(uint256 indexed tokenId, address indexed bidder, uint256 amount);
    event AuctionEnded(uint256 indexed tokenId, address indexed winner, uint256 amount);
    event AuctionCanceled(uint256 indexed tokenId, address indexed seller);

    event NFTStaked(uint256 indexed tokenId, address indexed staker);
    event NFTUnstaked(uint256 indexed tokenId, address indexed staker);
    event StakingRewardsClaimed(address indexed staker, uint256 amount);

    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string description, uint256 voteEndTime);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId);

    event MarketplaceFeeUpdated(uint256 newFeePercentage);
    event FeesWithdrawn(address indexed recipient, uint256 amount);

    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) {}

    // --- Modifiers ---

    modifier requireMinted(uint256 _tokenId) {
        require(_exists(_tokenId), "Token does not exist");
        _;
    }

    modifier onlyNFTOwner(uint256 _tokenId) {
        require(ownerOf(_tokenId) == msg.sender, "Not NFT owner");
        _;
    }

     modifier onlyNFTCreator(uint256 _tokenId) {
        requireMinted(_tokenId);
        require(nftCreationData[_tokenId].creator == msg.sender, "Not NFT creator");
        _;
    }


    modifier onlyAIModelOwner(uint256 _modelId) {
        require(aiModels[_modelId].owner == msg.sender, "Not AI model owner");
        _;
    }

    modifier notStaked(uint256 _tokenId) {
        require(stakedNFTs[_tokenId].staker == address(0), "NFT is staked");
        _;
    }

    modifier onlyStaked(uint256 _tokenId) {
         require(stakedNFTs[_tokenId].staker != address(0), "NFT is not staked");
        require(stakedNFTs[_tokenId].staker == msg.sender, "Not staker of this NFT");
        _;
    }

    modifier whenNotPaused() {
        _requireNotPaused();
        _;
    }

    modifier whenPaused() {
        _requirePaused();
        _;
    }

     modifier onlyProposer(uint256 _proposalId) {
        require(governanceProposals[_proposalId].proposer == msg.sender, "Not proposal proposer");
        _;
    }

    modifier onlyActiveProposal(uint256 _proposalId) {
         require(governanceProposals[_proposalId].state == ProposalState.Active, "Proposal not active");
        _;
    }

    // --- Core ERC721 Overrides (Handle staking interaction) ---

    // Prevent transfer of staked NFTs
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override {
        super._beforeTokenTransfer(from, to, tokenId);
        // If transferring *from* a staker or to a non-zero address *into* staking,
        // or transferring a token currently marked as staked
         if (stakedNFTs[tokenId].staker != address(0) && (from != address(this) && to != address(this))) {
             revert("Staked NFT cannot be transferred directly");
         }

         // Handle removing from userStakedTokenIds helper when transferring OUT OF the contract (unstaking implicitly via transfer)
         if (from == address(this) && to != address(0)) {
             // Find the token in the user's staked list and remove it
             address staker = stakedNFTs[tokenId].staker;
             if (staker != address(0)) {
                uint256[] storage stakedTokens = userStakedTokenIds[staker];
                for (uint i = 0; i < stakedTokens.length; i++) {
                    if (stakedTokens[i] == tokenId) {
                        // Swap last element with current and pop
                        stakedTokens[i] = stakedTokens[stakedTokens.length - 1];
                        stakedTokens.pop();
                        delete stakedNFTs[tokenId]; // Clean up staking info
                        totalStakedNFTs--;
                        emit NFTUnstaked(tokenId, staker); // Emit unstake event
                        break; // Found and removed
                    }
                }
             }
         }
    }


    // Allow contract to receive NFTs (e.g., for listing, staking)
    receive() external payable {}
    fallback() external payable {}

    // Needed for ERC721Holder
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external override returns (bytes4) {
        // Accept tokens sent to this contract
        return this.onERC721Received.selector;
    }


    // --- Custom Functions ---

    // --- AI Model Management (Simulated) ---

    /// @notice Registers a new AI model with a defined royalty percentage.
    /// @param _name The name of the AI model.
    /// @param _royaltyPercentage The royalty percentage (0-10000, representing 0-100%).
    function registerAIModel(string memory _name, uint256 _royaltyPercentage) public onlyOwner whenNotPaused {
        require(_royaltyPercentage <= 10000, "Royalty percentage out of range");
        _modelIdCounter.increment();
        uint256 newModelId = _modelIdCounter.current();
        aiModels[newModelId] = AIModel({
            owner: msg.sender,
            name: _name,
            royaltyPercentage: _royaltyPercentage,
            accumulatedRoyalties: 0
        });
        emit AIModelRegistered(newModelId, msg.sender, _name, _royaltyPercentage);
    }

    /// @notice Updates the royalty percentage for an existing AI model.
    /// @param _modelId The ID of the AI model.
    /// @param _newRoyaltyPercentage The new royalty percentage (0-10000).
    function updateAIModelRoyalty(uint256 _modelId, uint256 _newRoyaltyPercentage) public onlyAIModelOwner(_modelId) whenNotPaused {
        require(_newRoyaltyPercentage <= 10000, "Royalty percentage out of range");
        aiModels[_modelId].royaltyPercentage = _newRoyaltyPercentage;
        emit AIModelRoyaltyUpdated(_modelId, _newRoyaltyPercentage);
    }

    /// @notice Gets details of an AI model.
    /// @param _modelId The ID of the AI model.
    /// @return owner The owner of the model.
    /// @return name The name of the model.
    /// @return royaltyPercentage The royalty percentage.
    /// @return accumulatedRoyalties The total accumulated royalties.
    function getAIModelDetails(uint256 _modelId) public view returns (address owner, string memory name, uint256 royaltyPercentage, uint256 accumulatedRoyalties) {
        AIModel storage model = aiModels[_modelId];
        require(model.owner != address(0), "Model does not exist");
        return (model.owner, model.name, model.royaltyPercentage, model.accumulatedRoyalties);
    }

    /// @notice Allows the AI model owner to claim accumulated royalties.
    /// @param _modelId The ID of the AI model.
    function claimAIModelRoyalties(uint256 _modelId) public nonReentrant onlyAIModelOwner(_modelId) whenNotPaused {
        uint256 amount = aiModels[_modelId].accumulatedRoyalties;
        require(amount > 0, "No royalties to claim");

        aiModels[_modelId].accumulatedRoyalties = 0;
        payable(msg.sender).sendValue(amount);

        emit AIModelRoyaltiesClaimed(_modelId, msg.sender, amount);
    }

    // --- NFT Minting ---

    /// @notice Mints a new AI art NFT.
    /// @param _modelId The ID of the AI model used.
    /// @param _tokenURI The metadata URI for the NFT.
    /// @param _prompt The AI prompt used to generate the art.
    /// @param _revenueShareHolders Addresses receiving a share of future sale revenue.
    /// @param _revenueSharePercentages Percentages for each revenue share holder (sum must be <= 10000).
    function mintAIArtNFT(uint256 _modelId, string memory _tokenURI, string memory _prompt, address[] memory _revenueShareHolders, uint256[] memory _revenueSharePercentages) public whenNotPaused {
        require(aiModels[_modelId].owner != address(0), "Invalid AI model");
        require(_revenueShareHolders.length == _revenueSharePercentages.length, "Share holders and percentages length mismatch");

        uint256 totalPercentage = 0;
        for (uint i = 0; i < _revenueSharePercentages.length; i++) {
            totalPercentage += _revenueSharePercentages[i];
        }
        require(totalPercentage <= 10000, "Total revenue share percentage exceeds 100%");

        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();
        address minter = msg.sender;

        _safeMint(minter, newTokenId);
        _setTokenURI(newTokenId, _tokenURI);

        nftCreationData[newTokenId] = NFTCreationData({
            modelId: _modelId,
            prompt: _prompt,
            creator: minter
        });

        // Set initial revenue shares
        for (uint i = 0; i < _revenueShareHolders.length; i++) {
            nftRevenueShares[newTokenId].push(RevenueShare({
                holder: _revenueShareHolders[i],
                percentage: _revenueSharePercentages[i]
            }));
        }

        emit NFTMinted(newTokenId, minter, _modelId, _tokenURI, _prompt);
         if (_revenueShareHolders.length > 0) {
             emit RevenueSharesSet(newTokenId, minter);
         }
    }

    // --- Marketplace: Fixed Price ---

    /// @notice Lists an owned NFT for sale at a fixed price.
    /// @param _tokenId The ID of the NFT to list.
    /// @param _price The fixed price in Wei.
    function listNFTForFixedPrice(uint256 _tokenId, uint256 _price) public onlyNFTOwner(_tokenId) notStaked(_tokenId) whenNotPaused {
        require(_price > 0, "Price must be positive");
        require(fixedPriceListings[_tokenId].status != ListingStatus.Active, "NFT already listed");
         require(auctions[_tokenId].status != AuctionStatus.Active, "NFT already in auction");

        // Transfer NFT to the contract
        IERC721(address(this)).transferFrom(msg.sender, address(this), _tokenId);

        fixedPriceListings[_tokenId] = FixedPriceListing({
            price: _price,
            seller: msg.sender,
            status: ListingStatus.Active
        });

        emit NFTListedForFixedPrice(_tokenId, msg.sender, _price);
    }

    /// @notice Buys an NFT listed for a fixed price.
    /// @param _tokenId The ID of the NFT to buy.
    function buyFixedPriceNFT(uint256 _tokenId) public payable nonReentrant whenNotPaused {
        FixedPriceListing storage listing = fixedPriceListings[_tokenId];
        require(listing.status == ListingStatus.Active, "NFT not listed for sale");
        require(msg.value == listing.price, "Incorrect payment amount");
        require(msg.sender != listing.seller, "Cannot buy your own NFT");

        listing.status = ListingStatus.Sold; // Mark as sold before transfers

        address seller = listing.seller;
        uint256 totalPayment = msg.value;
        uint256 feeAmount = (totalPayment * marketplaceFeePercentage) / 10000;
        uint256 amountAfterFee = totalPayment - feeAmount;

        collectedFees += feeAmount; // Add to marketplace fees
        stakingRewardPool += (feeAmount * 50) / 100; // Send 50% of fee to staking pool (example)


        // Distribute funds: Seller, AI Model Royalty, Revenue Shares
        uint256 remainingAmount = amountAfterFee;

        // AI Model Royalty
        NFTCreationData storage creationData = nftCreationData[_tokenId];
        if (creationData.modelId != 0) {
             AIModel storage model = aiModels[creationData.modelId];
             if (model.owner != address(0)) {
                 uint256 royaltyAmount = (totalPayment * model.royaltyPercentage) / 10000; // Royalty often calculated on total sale price
                 model.accumulatedRoyalties += royaltyAmount; // Accumulate for AI model owner to claim
                 remainingAmount -= royaltyAmount;
             }
        }


        // Revenue Shares (Distribute to claimable balances)
        RevenueShare[] storage shares = nftRevenueShares[_tokenId];
        for (uint i = 0; i < shares.length; i++) {
            uint256 shareAmount = (totalPayment * shares[i].percentage) / 10000; // Shares calculated on total sale price
            claimableRevenueShares[shares[i].holder][_tokenId] += shareAmount;
            remainingAmount -= shareAmount;
        }

        // Send remaining amount to the seller
        payable(seller).sendValue(remainingAmount);

        // Transfer NFT to buyer
        _transfer(address(this), msg.sender, _tokenId);

        emit NFTBought(_tokenId, msg.sender, totalPayment);
    }

    /// @notice Cancels an active fixed-price listing.
    /// @param _tokenId The ID of the NFT listing to cancel.
    function cancelListing(uint256 _tokenId) public nonReentrant whenNotPaused {
        FixedPriceListing storage listing = fixedPriceListings[_tokenId];
        require(listing.status == ListingStatus.Active, "NFT not listed or already sold/canceled");
        require(listing.seller == msg.sender, "Not the seller of the listing");

        listing.status = ListingStatus.Canceled; // Mark as canceled

        // Transfer NFT back to the seller
        _transfer(address(this), msg.sender, _tokenId);

        emit FixedPriceListingCanceled(_tokenId, msg.sender);
    }

    // --- Marketplace: Auction ---

    /// @notice Lists an owned NFT for auction.
    /// @param _tokenId The ID of the NFT to auction.
    /// @param _startPrice The starting price in Wei.
    /// @param _duration The duration of the auction in seconds.
    function listNFTForAuction(uint256 _tokenId, uint256 _startPrice, uint256 _duration) public onlyNFTOwner(_tokenId) notStaked(_tokenId) whenNotPaused {
        require(_startPrice > 0, "Start price must be positive");
        require(_duration > 0, "Duration must be positive");
         require(fixedPriceListings[_tokenId].status != ListingStatus.Active, "NFT already listed");
        require(auctions[_tokenId].status != AuctionStatus.Active, "NFT already in auction");


        // Transfer NFT to the contract
         IERC721(address(this)).transferFrom(msg.sender, address(this), _tokenId);

        auctions[_tokenId] = Auction({
            startPrice: _startPrice,
            highestBid: _startPrice, // Initial highest bid is the start price
            highestBidder: payable(address(0)), // No bidder initially
            endTime: block.timestamp + _duration,
            status: AuctionStatus.Active,
            seller: payable(msg.sender)
        });

        emit NFTListedForAuction(_tokenId, msg.sender, _startPrice, auctions[_tokenId].endTime);
    }

    /// @notice Places a bid on an active auction.
    /// @param _tokenId The ID of the NFT auction.
    function placeAuctionBid(uint256 _tokenId) public payable nonReentrant whenNotPaused {
        Auction storage auction = auctions[_tokenId];
        require(auction.status == AuctionStatus.Active, "Auction is not active");
        require(block.timestamp < auction.endTime, "Auction has ended");
        require(msg.sender != auction.seller, "Seller cannot bid on their own auction");
        require(msg.value > auction.highestBid, "Bid must be higher than current highest bid");

        // Refund previous highest bidder (if any)
        if (auction.highestBidder != payable(address(0))) {
            previousBidders[_tokenId] = auction.highestBidder; // Store the bidder to be refunded
        }

        // Update highest bid
        auction.highestBid = msg.value;
        auction.highestBidder = payable(msg.sender);

        // Store the bid amount linked to the new highest bidder
        highestBids[_tokenId] = Bid({
            amount: msg.value,
            bidder: payable(msg.sender)
        });


        emit AuctionBidPlaced(_tokenId, msg.sender, msg.value);
    }

    /// @notice Ends an auction after its duration.
    /// @param _tokenId The ID of the NFT auction.
    function endAuction(uint256 _tokenId) public nonReentrant whenNotPaused {
        Auction storage auction = auctions[_tokenId];
        require(auction.status == AuctionStatus.Active, "Auction is not active");
        require(block.timestamp >= auction.endTime, "Auction has not ended yet");
         // Allow anyone to end the auction after time is up

        auction.status = AuctionStatus.Ended; // Mark as ended before transfers

        // Refund the second highest bidder (if there was one and they were replaced by the winner)
        // The highest bidder's ETH is still in the contract
        address payable prevBidder = previousBidders[_tokenId];
        if (prevBidder != payable(address(0)) && prevBidder != auction.highestBidder) {
             // Find the bid amount of the previous bidder (the one before the winner's bid)
             // NOTE: This simple implementation doesn't track *all* bids, only the highest.
             // A more robust auction would track all bids and refund losers correctly.
             // For simplicity here, we only handle refunding the single 'previousBidder' before the winner.
             // This part needs significant refinement for a real auction.
             // We'll assume previousBidders[_tokenId] stored the amount in a real system, but for this code, we can't access it.
             // Let's simplify: the only bid held in the contract is the highest bid. If there was a previous HIGHEST bidder,
             // their ETH is still attached to the contract from when they placed their bid. We need to refund them.
             // This requires tracking ETH balances associated with bidders, which this simple struct doesn't do.

             // *Correction for simpler model:* In a standard auction, only the *current* highest bid stays locked.
             // When a new higher bid comes, the *previous* highest bidder is refunded.
             // The `placeAuctionBid` function *should* handle this refund. Let's fix that.
             // Okay, the `placeAuctionBid` has been corrected above to store the previous highest bidder's address.
             // Now in `endAuction`, we don't need to refund the second highest. Only the *winning* bid ETH is relevant here.
             // The ETH from outbid bidders should have been refunded immediately in `placeAuctionBid`.
             // Let's proceed assuming `placeAuctionBid` correctly refunds the previous highest bidder.
        }


        if (auction.highestBidder == payable(address(0))) {
            // No valid bids received above start price
             // Transfer NFT back to the seller
             _transfer(address(this), auction.seller, _tokenId);
             emit AuctionEnded(_tokenId, address(0), 0); // Winner is address(0)
             return; // No sale occurred
        }

        address payable winner = auction.highestBidder;
        uint256 finalPrice = auction.highestBid;
        address payable seller = auction.seller;

        uint256 feeAmount = (finalPrice * marketplaceFeePercentage) / 10000;
        uint256 amountAfterFee = finalPrice - feeAmount;

        collectedFees += feeAmount;
        stakingRewardPool += (feeAmount * 50) / 100; // Send 50% of fee to staking pool (example)


         // Distribute funds: Seller, AI Model Royalty, Revenue Shares
        uint256 remainingAmount = amountAfterFee;

        // AI Model Royalty
        NFTCreationData storage creationData = nftCreationData[_tokenId];
        if (creationData.modelId != 0) {
             AIModel storage model = aiModels[creationData.modelId];
             if (model.owner != address(0)) {
                 uint256 royaltyAmount = (finalPrice * model.royaltyPercentage) / 10000;
                 model.accumulatedRoyalties += royaltyAmount;
                 remainingAmount -= royaltyAmount;
             }
        }

        // Revenue Shares (Distribute to claimable balances)
        RevenueShare[] storage shares = nftRevenueShares[_tokenId];
        for (uint i = 0; i < shares.length; i++) {
            uint256 shareAmount = (finalPrice * shares[i].percentage) / 10000;
            claimableRevenueShares[shares[i].holder][_tokenId] += shareAmount;
             remainingAmount -= shareAmount;
        }

        // Send remaining amount to the seller
        payable(seller).sendValue(remainingAmount);


        // Transfer NFT to winner
        _transfer(address(this), winner, _tokenId);

        emit AuctionEnded(_tokenId, winner, finalPrice);
    }

    /// @notice Cancels an auction before the first valid bid is placed.
    /// @param _tokenId The ID of the NFT auction.
    function cancelAuction(uint256 _tokenId) public nonReentrant whenNotPaused {
        Auction storage auction = auctions[_tokenId];
        require(auction.status == AuctionStatus.Active, "Auction is not active");
        require(auction.seller == msg.sender, "Not the seller of the auction");
         require(auction.highestBidder == payable(address(0)), "Cannot cancel auction with bids"); // Only cancel if no valid bids above start price

        auction.status = AuctionStatus.Canceled; // Mark as canceled

        // Transfer NFT back to the seller
        _transfer(address(this), msg.sender, _tokenId);

        emit AuctionCanceled(_tokenId, msg.sender);
    }

    // --- Revenue Sharing ---

    /// @notice Sets or updates the revenue share distribution for a specific NFT.
    /// Can only be called by the current owner. Overwrites previous settings.
    /// @param _tokenId The ID of the NFT.
    /// @param _holders Addresses receiving a share.
    /// @param _percentages Percentages for each holder (sum must be <= 10000).
    function setNFTRevenueShares(uint256 _tokenId, address[] memory _holders, uint256[] memory _percentages) public onlyNFTOwner(_tokenId) whenNotPaused {
         require(_holders.length == _percentages.length, "Share holders and percentages length mismatch");

        uint256 totalPercentage = 0;
        for (uint i = 0; i < _percentages.length; i++) {
            totalPercentage += _percentages[i];
        }
        require(totalPercentage <= 10000, "Total revenue share percentage exceeds 100%");

        // Clear existing shares
        delete nftRevenueShares[_tokenId]; // This replaces the array

        // Set new shares
        for (uint i = 0; i < _holders.length; i++) {
            nftRevenueShares[_tokenId].push(RevenueShare({
                holder: _holders[i],
                percentage: _percentages[i]
            }));
        }

        emit RevenueSharesSet(_tokenId, msg.sender);
    }

    /// @notice Allows a holder with defined revenue shares to claim their accrued revenue for a specific NFT.
    /// @param _tokenId The ID of the NFT.
    function claimRevenueShare(uint256 _tokenId) public nonReentrant whenNotPaused {
        uint256 amount = claimableRevenueShares[msg.sender][_tokenId];
        require(amount > 0, "No revenue share to claim for this NFT");

        claimableRevenueShares[msg.sender][_tokenId] = 0;
        payable(msg.sender).sendValue(amount);

        emit RevenueShareClaimed(_tokenId, msg.sender, amount);
    }

    // --- Staking ---

     /// @notice Stakes an owned NFT to earn rewards.
    /// @param _tokenId The ID of the NFT to stake.
    function stakeNFT(uint256 _tokenId) public onlyNFTOwner(_tokenId) notStaked(_tokenId) whenNotPaused {
        // Transfer NFT to the contract (acting as the staking pool)
        IERC721(address(this)).transferFrom(msg.sender, address(this), _tokenId);

        stakedNFTs[_tokenId] = StakingInfo({
            staker: msg.sender,
            stakeTime: block.timestamp,
            accumulatedRewards: 0 // Rewards are calculated upon claiming, not accumulated here directly
        });

        // Add to user's staked list
        userStakedTokenIds[msg.sender].push(_tokenId);
        totalStakedNFTs++;

        emit NFTStaked(_tokenId, msg.sender);
    }

     /// @notice Unstakes a previously staked NFT.
    /// @param _tokenId The ID of the NFT to unstake.
    function unstakeNFT(uint256 _tokenId) public nonReentrant onlyStaked(_tokenId) whenNotPaused {
        address staker = msg.sender;

        // Before unstaking, claim any pending rewards for this specific NFT's duration
        _distributeAndResetNFTStakingRewards(_tokenId);

        // Transfer NFT back to the staker
        _transfer(address(this), staker, _tokenId);

        // Remove from user's staked list and clean up
        uint256[] storage stakedTokens = userStakedTokenIds[staker];
        for (uint i = 0; i < stakedTokens.length; i++) {
            if (stakedTokens[i] == _tokenId) {
                stakedTokens[i] = stakedTokens[stakedTokens.length - 1];
                stakedTokens.pop();
                break;
            }
        }
        delete stakedNFTs[_tokenId];
        totalStakedNFTs--;


        emit NFTUnstaked(_tokenId, staker);
    }

    /// @notice Claims accumulated staking rewards for all NFTs currently staked by the caller.
    function claimStakingRewards() public nonReentrant whenNotPaused {
        address staker = msg.sender;
        uint256 totalClaimable = 0;

        // Calculate and accumulate rewards for all staked NFTs owned by the caller
        uint256[] storage stakedTokens = userStakedTokenIds[staker];
        for (uint i = 0; i < stakedTokens.length; i++) {
             uint256 tokenId = stakedTokens[i];
             if (stakedNFTs[tokenId].staker == staker) { // Double check it's still staked by them
                 totalClaimable += _calculateAndResetNFTStakingRewards(tokenId);
             }
        }

        require(totalClaimable > 0, "No staking rewards to claim");

        // Transfer rewards from the pool
        require(stakingRewardPool >= totalClaimable, "Insufficient rewards in pool");
        stakingRewardPool -= totalClaimable;
        payable(staker).sendValue(totalClaimable);

        emit StakingRewardsClaimed(staker, totalClaimable);
    }

    /// @dev Internal helper to calculate rewards for a single NFT and reset its stake time.
    /// Rewards are a simple example: (staked duration / total duration) * (portion of pool increase during duration).
    /// This is simplified; a real system would track pool changes and stake weights more accurately.
    /// For this example, we'll distribute based on a fixed rate per NFT per second, capped by the pool.
    function _calculateAndResetNFTStakingRewards(uint256 _tokenId) internal returns (uint256) {
        StakingInfo storage info = stakedNFTs[_tokenId];
        if (info.staker == address(0)) return 0; // Not staked

        // Simple example reward calculation: A small fixed rate per second per NFT
        // Capped by the total stakingRewardPool
        uint256 secondsStaked = block.timestamp - info.stakeTime;
        // Example rate: 100 wei per second per NFT
        uint256 calculatedRewards = secondsStaked * 100;

        uint256 claimable = info.accumulatedRewards + calculatedRewards; // Add previously accumulated

        // Reset for next period
        info.stakeTime = block.timestamp;
        info.accumulatedRewards = 0; // Accumulated rewards moved to claimable total in claim function

        // Note: This simple calculation and reset doesn't tie directly to pool *increases*.
        // A better system would track total stake power, pool changes, and distribute proportionally.
        // This version is just a placeholder.

        return claimable; // Return calculated amount to be added to user's total claim
    }

     /// @dev Internal helper to calculate rewards for a single NFT upon unstaking and reset.
     function _distributeAndResetNFTStakingRewards(uint256 _tokenId) internal {
        StakingInfo storage info = stakedNFTs[_tokenId];
        if (info.staker == address(0)) return; // Not staked

         uint256 secondsStaked = block.timestamp - info.stakeTime;
         uint256 calculatedRewards = secondsStaked * 100; // Example rate

         info.accumulatedRewards += calculatedRewards; // Add to accumulated before unstaking

         // The rewards are claimed in the claimStakingRewards function, not here.
         // This just updates the pending reward amount for the NFT before it's removed.
     }


    // --- Governance ---

    /// @notice Proposes a change to the contract parameters (e.g., fee percentage).
    /// @param _description A description of the proposed change.
    /// @param _calldata The calldata to execute if the proposal passes (e.g., `abi.encodeWithSelector(this.setMarketplaceFee.selector, newFee)`).
    /// @param _targetContract The address of the target contract to call (usually this contract's address).
    function proposeChange(string memory _description, bytes memory _calldata, address _targetContract) public whenNotPaused {
        // Basic requirement: Must own at least 1 NFT to propose (example)
        require(balanceOf(msg.sender) > 0 || userStakedTokenIds[msg.sender].length > 0, "Must hold or stake at least one NFT to propose");

        _proposalIdCounter.increment();
        uint256 proposalId = _proposalIdCounter.current();

        governanceProposals[proposalId] = GovernanceProposal({
            description: _description,
            calldataPayload: _calldata,
            targetContract: _targetContract,
            voteStartTime: block.timestamp,
            voteEndTime: block.timestamp + votingPeriod,
            votesFor: 0,
            votesAgainst: 0,
            proposer: msg.sender,
            state: ProposalState.Active
        });

        emit ProposalCreated(proposalId, msg.sender, _description, governanceProposals[proposalId].voteEndTime);
    }

    /// @notice Votes on an active proposal.
    /// @param _proposalId The ID of the proposal.
    /// @param _support True to vote for, False to vote against.
    function voteOnProposal(uint256 _proposalId, bool _support) public whenNotPaused {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.timestamp >= proposal.voteStartTime && block.timestamp < proposal.voteEndTime, "Voting period closed");
        require(!hasVoted[_proposalId][msg.sender], "Already voted on this proposal");

        // Simple voting power: 1 address = 1 vote
        // More advanced could use staked NFTs, NFT count, or a governance token balance
        if (_support) {
            proposal.votesFor++;
        } else {
            proposal.votesAgainst++;
        }
        hasVoted[_proposalId][msg.sender] = true;

        emit VoteCast(_proposalId, msg.sender, _support);
    }

    /// @notice Executes a proposal that has passed the voting period and threshold.
    /// @param _proposalId The ID of the proposal.
    function executeProposal(uint256 _proposalId) public nonReentrant whenNotPaused {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active"); // Must still be active when attempting execution
        require(block.timestamp >= proposal.voteEndTime, "Voting period not over");

        // Check if proposal passed threshold and quorum (simplified checks)
        if (proposal.votesFor > proposalThreshold && proposal.votesFor > proposal.votesAgainst && (proposal.votesFor + proposal.votesAgainst) >= voteQuorum) {
            proposal.state = ProposalState.Succeeded;
            // Execute the payload
            (bool success, ) = proposal.targetContract.call(proposal.calldataPayload);
            require(success, "Proposal execution failed");
            proposal.state = ProposalState.Executed;
            emit ProposalExecuted(_proposalId);
        } else {
            proposal.state = ProposalState.Defeated;
            // Optionally allow proposer to cancel if defeated before execution attempt
        }
    }

    // --- Admin/Fee Management (Potentially governance controlled) ---

    /// @notice Sets the marketplace fee percentage. Designed to be called by governance.
    /// @param _feePercentage The new fee percentage (0-10000).
    function setMarketplaceFee(uint256 _feePercentage) public onlyOwner whenNotPaused {
        require(_feePercentage <= 10000, "Fee percentage out of range");
        marketplaceFeePercentage = _feePercentage;
        emit MarketplaceFeeUpdated(_feePercentage);
    }

    /// @notice Allows the owner or governance to withdraw accumulated marketplace fees.
    function withdrawFees() public nonReentrant onlyOwner whenNotPaused {
        uint256 amount = collectedFees;
        require(amount > 0, "No fees to withdraw");

        collectedFees = 0;
        payable(owner()).sendValue(amount);

        emit FeesWithdrawn(owner(), amount);
    }

     /// @notice Pauses all activity in the contract (marketplace, staking, governance actions).
    function pause() public onlyOwner whenNotPaused {
        _pause();
    }

    /// @notice Unpauses the contract.
    function unpause() public onlyOwner whenPaused {
        _unpause();
    }


    // --- View Functions (Querying State) ---

    /// @notice Gets details of an NFT.
    /// @param _tokenId The ID of the NFT.
    /// @return owner The current owner address.
    /// @return tokenURI The metadata URI.
    /// @return modelId The ID of the associated AI model.
    /// @return prompt The creation prompt.
    /// @return creator The original minter.
    function getNFTDetails(uint256 _tokenId) public view requireMinted(_tokenId) returns (address owner, string memory tokenURI, uint256 modelId, string memory prompt, address creator) {
        NFTCreationData storage data = nftCreationData[_tokenId];
        return (ownerOf(_tokenId), tokenURI(_tokenId), data.modelId, data.prompt, data.creator);
    }

     /// @notice Gets details of a fixed-price listing.
    /// @param _tokenId The ID of the NFT.
    /// @return price The listing price.
    /// @return seller The seller's address.
    /// @return status The listing status (Active, Sold, Canceled).
    function getListingDetails(uint256 _tokenId) public view returns (uint256 price, address seller, ListingStatus status) {
        FixedPriceListing storage listing = fixedPriceListings[_tokenId];
        return (listing.price, listing.seller, listing.status);
    }

    /// @notice Gets details of an auction.
    /// @param _tokenId The ID of the NFT.
    /// @return startPrice The starting price.
    /// @return highestBid The current highest bid.
    /// @return highestBidder The current highest bidder.
    /// @return endTime The auction end time.
    /// @return status The auction status (Active, Ended, Canceled).
    /// @return seller The seller's address.
    function getAuctionDetails(uint256 _tokenId) public view returns (uint256 startPrice, uint256 highestBid, address highestBidder, uint256 endTime, AuctionStatus status, address seller) {
        Auction storage auction = auctions[_tokenId];
        return (auction.startPrice, auction.highestBid, auction.highestBidder, auction.endTime, auction.status, auction.seller);
    }


    /// @notice Returns a list of NFT token IDs owned by a user.
    /// Note: This requires iterating through all minted tokens or maintaining an index, which can be gas-intensive for large collections.
    /// This implementation is a placeholder and inefficient for many NFTs.
    /// @param _user The address of the user.
    /// @return A list of token IDs.
    function getUserNFTs(address _user) public view returns (uint256[] memory) {
        uint256 tokenCount = balanceOf(_user);
        if (tokenCount == 0) {
            return new uint256[](0);
        }

        // Inefficient implementation - DO NOT use this pattern for large numbers of tokens in production
        // A better pattern involves maintaining an iterable mapping or tracking transfers off-chain
        uint256[] memory tokenIds = new uint256[](tokenCount);
        uint256 index = 0;
         for (uint256 i = 1; i <= _tokenIdCounter.current(); i++) { // Iterate through all minted tokens
             if (_exists(i) && ownerOf(i) == _user) {
                 tokenIds[index] = i;
                 index++;
                 if (index == tokenCount) break; // Found all owned tokens
             }
         }
        return tokenIds;
    }

     /// @notice Returns a list of NFT token IDs staked by a user.
     /// @param _user The address of the user.
     /// @return A list of staked token IDs.
     function getUserStakedNFTs(address _user) public view returns (uint256[] memory) {
         return userStakedTokenIds[_user];
     }

    /// @notice Returns the amount of revenue share claimable by a user for a specific NFT.
    /// @param _user The address of the user.
    /// @param _tokenId The ID of the NFT.
    /// @return The claimable amount in Wei.
    function getUserClaimableRevenueShare(address _user, uint256 _tokenId) public view returns (uint256) {
        return claimableRevenueShares[_user][_tokenId];
    }

     /// @notice Returns the total staking rewards claimable by a user across all their staked NFTs.
     /// Note: This calculates *current* pending rewards based on stake time, plus any previously accumulated but not claimed.
     /// It simulates rewards based on a fixed rate per second; real pool-based rewards are more complex.
     /// @param _user The address of the user.
     /// @return The total claimable rewards in Wei.
     function getUserClaimableStakingRewards(address _user) public view returns (uint256) {
         uint256 total = 0;
         uint256[] memory stakedTokens = userStakedTokenIds[_user]; // Copy to memory for iteration

         for (uint i = 0; i < stakedTokens.length; i++) {
             uint256 tokenId = stakedTokens[i];
              if (stakedNFTs[tokenId].staker == _user) { // Ensure it's still staked by this user
                 StakingInfo storage info = stakedNFTs[tokenId];
                 uint256 secondsStaked = block.timestamp - info.stakeTime;
                 uint256 calculatedRewards = secondsStaked * 100; // Example rate: 100 wei per second per NFT
                 total += info.accumulatedRewards + calculatedRewards; // Add accumulated + new calculation
             }
         }
         return total;
     }


    /// @notice Gets details of a governance proposal.
    /// @param _proposalId The ID of the proposal.
    /// @return description The description.
    /// @return voteStartTime The start timestamp.
    /// @return voteEndTime The end timestamp.
    /// @return votesFor The votes for.
    /// @return votesAgainst The votes against.
    /// @return proposer The proposer's address.
    /// @return state The proposal state.
    function getProposalDetails(uint256 _proposalId) public view returns (string memory description, uint256 voteStartTime, uint256 voteEndTime, uint256 votesFor, uint256 votesAgainst, address proposer, ProposalState state) {
        GovernanceProposal storage proposal = governanceProposals[_proposalId];
        require(proposal.proposer != address(0), "Proposal does not exist");
        return (proposal.description, proposal.voteStartTime, proposal.voteEndTime, proposal.votesFor, proposal.votesAgainst, proposal.proposer, proposal.state);
    }

     /// @notice Returns the total collected marketplace fees.
     /// @return The total fees in Wei.
     function getCollectedFees() public view returns (uint256) {
         return collectedFees;
     }

    /// @notice Returns the current balance of the staking reward pool.
     /// @return The pool balance in Wei.
     function getStakingRewardPool() public view returns (uint256) {
         return stakingRewardPool;
     }

    // Fallback/Receive to accept ETH for bids and purchases
    // (Already defined above with empty implementation, added payable keyword)
    // receive() external payable {}
    // fallback() external payable {}
}
```