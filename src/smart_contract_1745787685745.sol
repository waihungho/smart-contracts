Okay, let's design a complex, creative, and relatively advanced smart contract that combines several concepts: **Dynamic NFTs**, **Staking/Bonding** of a fungible token *to* an NFT, **Time-Based Evolution**, and **On-Chain Attribute Calculation / Metadata Generation**.

We'll call this concept "Temporal Essence Forging". Users forge unique "Essence" NFTs (ERC721). These Essences have dynamic attributes and "evolve" over time. Evolution can be influenced by "bonding" a specific ERC20 token (let's call it "ChronoFuel") to the Essence. Bonded ChronoFuel can also generate yield over time, claimable by the Essence owner. The NFT's metadata (via `tokenURI`) must dynamically reflect its current state and attributes.

This avoids duplicating simple ERC721/ERC20, basic staking, or standard fixed-metadata NFTs. It involves inter-token interaction, dynamic state, and on-chain data generation.

---

**Contract Name:** TemporalEssenceForge

**Concept:** Forging and managing dynamic NFTs (Essences) that evolve based on time and bonded ChronoFuel (an ERC20 token). Bonded fuel generates yield. NFT metadata is calculated on-chain based on current state.

**Core Components:**
1.  **ERC721 (Essence):** The main NFT representing a Temporal Essence.
2.  **ERC20 (ChronoFuel):** A separate token (address is configured) used for forging, bonding, and generated as yield.
3.  **Dynamic State:** Each Essence tracks its creation time, last evolution time, last bond change time, amount of bonded ChronoFuel, and a numerical `temporalState` representing its evolution level.
4.  **Evolution:** `temporalState` increases over time. Bonding ChronoFuel can accelerate this or unlock higher states. There might be costs or conditions for evolution.
5.  **Bonding/Staking:** Users lock ChronoFuel within the Essence contract, associated with a specific Essence NFT ID.
6.  **Yield:** Bonded ChronoFuel generates more ChronoFuel over time, claimable by the Essence owner.
7.  **Dynamic Attributes:** Based on `temporalState` and bonded fuel, the Essence has calculated attributes (e.g., Resilience, Flux, Aura).
8.  **On-Chain Metadata (`tokenURI`):** The `tokenURI` function calculates the Essence's state, attributes, and generates a data URI containing JSON metadata reflecting its *current* state.

---

**Function Summary:**

**I. ERC721 Standard Functions (Implicit via Inheritance/Overrides):**
1.  `balanceOf(address owner)`: Get number of Essences owned by an address.
2.  `ownerOf(uint256 tokenId)`: Get the owner of a specific Essence ID.
3.  `transferFrom(address from, address to, uint256 tokenId)`: Transfer Essence.
4.  `safeTransferFrom(address from, address to, uint256 tokenId)`: Safer transfer.
5.  `approve(address to, uint256 tokenId)`: Approve address to transfer Essence.
6.  `getApproved(uint256 tokenId)`: Get approved address for Essence.
7.  `setApprovalForAll(address operator, bool approved)`: Set approval for all Essences.
8.  `isApprovedForAll(address owner, address operator)`: Check if operator is approved for all.
9.  `name()`: Get the contract name ("TemporalEssence").
10. `symbol()`: Get the contract symbol ("TE").
11. `supportsInterface(bytes4 interfaceId)`: Standard interface check.

**II. Core Temporal Essence Functionality:**
12. `forgeEssence(uint256 initialFuelBond)`: Mints a new Essence NFT for the caller. Requires transferring `initialFuelBond` amount of ChronoFuel to the contract and bonds it to the new Essence. Sets initial state.
13. `bondChronoFuel(uint256 essenceId, uint256 amount)`: Allows the owner of `essenceId` to bond more ChronoFuel to it. Transfers fuel to the contract and updates the Essence's bonded amount and last bond update time.
14. `unbondChronoFuel(uint256 essenceId, uint256 amount)`: Allows the owner to unbond fuel. Transfers fuel from the contract back to the owner. May incur a penalty based on time bonded or other parameters.
15. `claimTemporalYield(uint256 essenceId)`: Allows the owner to claim accumulated ChronoFuel yield generated by the bonded fuel on this Essence. Transfers yield from the contract.
16. `evolveEssence(uint256 essenceId)`: Triggers an evolution check and potential update for the Essence's `temporalState`. Calculates state change based on time since last evolution and bonded fuel. May consume fuel or have other conditions.
17. `tokenURI(uint256 essenceId)`: (Override) Calculates the Essence's current state, attributes, and generates a data URI (base64 encoded JSON) containing metadata like name, description, attributes, etc. *This is a key dynamic function*.

**III. State & Calculation View Functions:**
18. `getEssenceState(uint256 essenceId)`: Returns core state data for an Essence (creation time, last evolution, bonded fuel, temporal state).
19. `getEssenceAttributes(uint256 essenceId)`: Calculates and returns the derived attributes (Resilience, Flux, Aura) based on the current state.
20. `calculateCurrentYieldAmount(uint256 essenceId)`: Calculates and returns the amount of yield currently available to be claimed for an Essence.
21. `calculateUnbondPenalty(uint256 essenceId, uint256 amount)`: Calculates the penalty amount for unbonding a specific amount of fuel based on current state and time.
22. `calculateNextEvolutionCost(uint256 essenceId)`: Calculates the ChronoFuel cost (if any) required for the next evolution step.
23. `checkEvolutionReadiness(uint256 essenceId)`: Returns boolean indicating if the Essence meets the conditions (time, fuel) for the next evolution step.
24. `simulateFutureState(uint256 essenceId, uint256 timeDelta)`: (View) Projects and returns the expected state and attributes of an Essence after a given time duration, without changing state.
25. `getTotalEssences()`: Returns the total number of Essences ever forged.
26. `getEssenceCreationTime(uint256 essenceId)`: Returns the timestamp when an Essence was forged.
27. `getLastEvolutionTime(uint256 essenceId)`: Returns the timestamp of the last successful evolution for an Essence.
28. `getEssenceBondDetails(uint256 essenceId)`: Returns bonded fuel amount and last bond update time.

**IV. Owner/Admin Functions:**
29. `setChronoFuelToken(address _chronoFuelAddress)`: Owner sets the address of the ChronoFuel ERC20 contract.
30. `setEvolutionParameters(uint256 baseEvolutionTime, uint256 fuelEvolutionBoost)`: Owner sets parameters influencing evolution speed based on time and fuel.
31. `setYieldParameters(uint256 yieldRatePerFuelPerSecond)`: Owner sets the rate at which bonded fuel generates yield.
32. `setUnbondPenaltyParameters(uint256 basePenaltyBps, uint256 penaltyDecayTime)`: Owner sets parameters for the unbonding penalty.
33. `withdrawStuckTokens(address tokenAddress, uint256 amount)`: Emergency function for owner to withdraw tokens accidentally sent directly to the contract address (excluding bonded/yield fuel).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"; // For getTotalEssences (indexed tokens)
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/math/Math.sol"; // For min/max/sqrt etc if needed in calculations

// Outline & Function Summary:
// This smart contract implements the "Temporal Essence Forging" concept.
// It manages dynamic NFTs (Essences) that evolve over time and based on
// bonded ChronoFuel (an ERC20 token). Bonded fuel generates yield.
// The NFT metadata is generated dynamically on-chain reflecting its current state.

// Core Components: ERC721 (Essence), ERC20 (ChronoFuel interaction),
// Dynamic State (temporalState, bondedFuel), Time-Based Evolution,
// Bonding/Staking, Yield Generation, On-Chain Attribute Calculation,
// Dynamic On-Chain Metadata (tokenURI).

// Function Summary:
// I. ERC721 Standard Functions (Inherited/Overridden): balanceOf, ownerOf,
//    transferFrom, safeTransferFrom, approve, getApproved, setApprovalForAll,
//    isApprovedForAll, name, symbol, supportsInterface.
// II. Core Temporal Essence Functionality:
//    forgeEssence - Mints new NFT, bonds initial fuel.
//    bondChronoFuel - Bond more fuel to an existing Essence.
//    unbondChronoFuel - Unbond fuel from an Essence (may incur penalty).
//    claimTemporalYield - Claim generated fuel yield.
//    evolveEssence - Trigger state evolution based on time/fuel.
//    tokenURI - Generate dynamic on-chain metadata (Base64 Data URI).
// III. State & Calculation View Functions:
//    getEssenceState - Get raw state data.
//    getEssenceAttributes - Calculate/get dynamic attributes.
//    calculateCurrentYieldAmount - Calculate pending yield.
//    calculateUnbondPenalty - Calculate penalty for unbonding.
//    calculateNextEvolutionCost - Calculate fuel cost for next evolution.
//    checkEvolutionReadiness - Check if ready for evolution.
//    simulateFutureState - Project state into the future.
//    getTotalEssences - Total NFTs minted.
//    getEssenceCreationTime - Get mint time.
//    getLastEvolutionTime - Get last evolution time.
//    getEssenceBondDetails - Get bonded fuel & last update time.
// IV. Owner/Admin Functions:
//    setChronoFuelToken - Set ERC20 token address.
//    setEvolutionParameters - Configure evolution rules.
//    setYieldParameters - Configure yield rate.
//    setUnbondPenaltyParameters - Configure unbonding penalty rules.
//    withdrawStuckTokens - Emergency withdrawal of other tokens.

contract TemporalEssenceForge is ERC721Enumerable, ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;
    using Strings for uint256;

    // --- Errors ---
    error InvalidEssenceId();
    error NotEssenceOwner(uint256 essenceId);
    error InsufficientChronoFuel(uint256 required, uint256 available);
    error InsufficientBondedFuel(uint256 essenceId, uint256 requested, uint256 bonded);
    error NoYieldAvailable(uint256 essenceId);
    error EvolutionNotReady(uint256 essenceId);
    error ZeroAddressNotAllowed();
    error TransferFailed();

    // --- State Variables ---
    IERC20 public chronoFuelToken;
    uint256 private _nextTokenId; // Counter for minting new Essences

    // Structure to hold dynamic data for each Essence NFT
    struct EssenceData {
        uint64 creationTime;      // Timestamp of minting
        uint64 lastEvolutionTime; // Timestamp of last successful evolution
        uint64 lastBondUpdateTime; // Timestamp of last bond/unbond action
        uint256 bondedFuel;       // Amount of ChronoFuel bonded to this Essence
        uint256 temporalState;    // Represents the evolution stage (0 to N)
    }

    mapping(uint256 => EssenceData) public essenceData;

    // Parameters for dynamic calculations (set by owner)
    uint256 public baseEvolutionTime = 1 days;         // Base time needed per evolution step
    uint256 public fuelEvolutionBoostPer1kBond = 100; // How much faster (in seconds) evolution is per 1000 fuel bonded
    uint256 public yieldRatePerFuelPerSecond = 10 ** 12; // Yield rate (e.g., 1e12 = 0.000001 tokens/fuel/sec if token has 18 decimals)
    uint256 public unbondPenaltyBps = 500;           // Base penalty in basis points (500 = 5%)
    uint256 public unbondPenaltyDecayTime = 7 days;    // Time over which penalty decays to zero

    // --- Events ---
    event EssenceForged(uint256 indexed essenceId, address indexed owner, uint256 initialBond);
    event ChronoFuelBonded(uint256 indexed essenceId, address indexed owner, uint256 amount);
    event ChronoFuelUnbonded(uint256 indexed essenceId, address indexed owner, uint256 amount, uint256 penalty);
    event TemporalYieldClaimed(uint256 indexed essenceId, address indexed owner, uint256 amount);
    event EssenceEvolved(uint256 indexed essenceId, uint256 newTemporalState);
    event ParametersUpdated();
    event ChronoFuelTokenSet(address indexed chronoFuelAddress);

    // --- Constructor ---
    constructor(address initialOwner, address _chronoFuelAddress) ERC721("TemporalEssence", "TE") Ownable(initialOwner) {
        if (_chronoFuelAddress == address(0)) revert ZeroAddressNotAllowed();
        chronoFuelToken = IERC20(_chronoFuelAddress);
        _nextTokenId = 1; // Start token IDs from 1
    }

    // --- Modifiers ---
    modifier onlyEssenceOwner(uint256 essenceId) {
        if (!_exists(essenceId)) revert InvalidEssenceId();
        if (ownerOf(essenceId) != _msgSender()) revert NotEssenceOwner(essenceId);
        _;
    }

    // --- Core Functionality ---

    /// @notice Forges a new Temporal Essence NFT, bonding initial ChronoFuel.
    /// @param initialFuelBond The amount of ChronoFuel to bond initially.
    /// @dev Mints a new ERC721, transfers initial fuel from caller to contract, updates state.
    function forgeEssence(uint256 initialFuelBond) external nonReentrant returns (uint256 essenceId) {
        essenceId = _nextTokenId++;
        address owner = _msgSender();

        // Transfer initial fuel from the sender
        if (initialFuelBond > 0) {
            uint256 callerFuel = chronoFuelToken.balanceOf(owner);
            if (callerFuel < initialFuelBond) revert InsufficientChronoFuel(initialFuelBond, callerFuel);
            chronoFuelToken.safeTransferFrom(owner, address(this), initialFuelBond);
        }

        // Mint the NFT
        _safeMint(owner, essenceId);

        // Initialize Essence state
        uint64 currentTime = uint64(block.timestamp);
        essenceData[essenceId] = EssenceData({
            creationTime: currentTime,
            lastEvolutionTime: currentTime,
            lastBondUpdateTime: currentTime,
            bondedFuel: initialFuelBond,
            temporalState: 0 // Starts at state 0
        });

        emit EssenceForged(essenceId, owner, initialFuelBond);
    }

    /// @notice Bonds additional ChronoFuel to an existing Temporal Essence.
    /// @param essenceId The ID of the Essence to bond fuel to.
    /// @param amount The amount of ChronoFuel to bond.
    /// @dev Transfers fuel from caller to contract, updates bonded fuel and last bond update time.
    function bondChronoFuel(uint256 essenceId, uint256 amount) external nonReentrant onlyEssenceOwner(essenceId) {
        if (amount == 0) return; // Nothing to bond

        address owner = _msgSender();
        uint256 callerFuel = chronoFuelToken.balanceOf(owner);
        if (callerFuel < amount) revert InsufficientChronoFuel(amount, callerFuel);

        // Claim any pending yield *before* updating bond state
        uint256 yield = calculateCurrentYieldAmount(essenceId);
        if (yield > 0) {
            _claimYield(essenceId, owner, yield);
        }

        // Transfer fuel and update state
        chronoFuelToken.safeTransferFrom(owner, address(this), amount);
        essenceData[essenceId].bondedFuel = essenceData[essenceId].bondedFuel + amount;
        essenceData[essenceId].lastBondUpdateTime = uint64(block.timestamp);

        emit ChronoFuelBonded(essenceId, owner, amount);
    }

    /// @notice Unbonds ChronoFuel from a Temporal Essence.
    /// @param essenceId The ID of the Essence to unbond fuel from.
    /// @param amount The amount of ChronoFuel to unbond.
    /// @dev Transfers fuel from contract back to caller. May apply penalty.
    function unbondChronoFuel(uint256 essenceId, uint256 amount) external nonReentrant onlyEssenceOwner(essenceId) {
        if (amount == 0) return; // Nothing to unbond

        EssenceData storage data = essenceData[essenceId];
        if (data.bondedFuel < amount) revert InsufficientBondedFuel(essenceId, amount, data.bondedFuel);

        // Claim any pending yield *before* updating bond state
        uint256 yield = calculateCurrentYieldAmount(essenceId);
        if (yield > 0) {
            _claimYield(essenceId, _msgSender(), yield);
        }

        // Calculate penalty
        uint256 penalty = calculateUnbondPenalty(essenceId, amount);
        uint256 amountAfterPenalty = amount - penalty;

        // Update state
        data.bondedFuel = data.bondedFuel - amount;
        data.lastBondUpdateTime = uint64(block.timestamp);

        // Transfer fuel back
        chronoFuelToken.safeTransfer(_msgSender(), amountAfterPenalty);
        // Penalty amount stays in the contract's ChronoFuel balance

        emit ChronoFuelUnbonded(essenceId, _msgSender(), amount, penalty);
    }

    /// @notice Claims accumulated ChronoFuel yield for a Temporal Essence.
    /// @param essenceId The ID of the Essence to claim yield from.
    /// @dev Calculates and transfers yield from contract to owner.
    function claimTemporalYield(uint256 essenceId) external nonReentrant onlyEssenceOwner(essenceId) {
        uint256 yield = calculateCurrentYieldAmount(essenceId);
        if (yield == 0) revert NoYieldAvailable(essenceId);

        _claimYield(essenceId, _msgSender(), yield);
    }

    /// @dev Internal helper to claim yield. Assumes yield > 0.
    function _claimYield(uint256 essenceId, address owner, uint256 amount) internal {
        // Update state to reset yield calculation starting point
        essenceData[essenceId].lastBondUpdateTime = uint64(block.timestamp);

        // Transfer yield
        chronoFuelToken.safeTransfer(owner, amount);

        emit TemporalYieldClaimed(essenceId, owner, amount);
    }

    /// @notice Attempts to evolve the Temporal Essence to the next state.
    /// @param essenceId The ID of the Essence to evolve.
    /// @dev Checks conditions (time, fuel), updates temporalState, and resets last evolution time.
    function evolveEssence(uint256 essenceId) external nonReentrant onlyEssenceOwner(essenceId) {
        if (!checkEvolutionReadiness(essenceId)) revert EvolutionNotReady(essenceId);

        EssenceData storage data = essenceData[essenceId];
        uint256 evolutionCost = calculateNextEvolutionCost(essenceId);

        // Consume fuel cost from bonded fuel if required
        if (evolutionCost > 0) {
             if (data.bondedFuel < evolutionCost) revert InsufficientBondedFuel(essenceId, evolutionCost, data.bondedFuel);
             data.bondedFuel -= evolutionCost;
             // Note: Cost comes from bonded fuel, not contract balance. This changes the state.
             // lastBondUpdateTime could be updated here if spending bonded fuel should reset yield calculation.
             // Let's *not* reset yield claim eligibility by spending bonded fuel for evolution.
        }

        // Perform evolution
        data.temporalState += 1;
        data.lastEvolutionTime = uint64(block.timestamp);

        // Re-calculate yield and penalty points since state changed
        data.lastBondUpdateTime = uint64(block.timestamp); // Reset bond time to avoid claiming yield on the fuel just spent on evolution

        emit EssenceEvolved(essenceId, data.temporalState);
    }

    /// @notice Returns the Base64 encoded JSON metadata for a Temporal Essence.
    /// @param essenceId The ID of the Essence.
    /// @dev Calculates attributes and state data on-chain and formats as a data URI.
    function tokenURI(uint256 essenceId) public view override returns (string memory) {
        if (!_exists(essenceId)) revert ERC721Metadata("tokenURI: nonexistant token", essenceId);

        EssenceData memory data = essenceData[essenceId];
        (uint256 resilience, uint256 flux, uint256 aura) = getEssenceAttributes(essenceId);
        uint256 yieldAvailable = calculateCurrentYieldAmount(essenceId);

        // Build JSON string
        string memory json = string(abi.encodePacked(
            '{"name": "Temporal Essence #', essenceId.toString(), '",',
            '"description": "A digital entity evolving through time and bonded ChronoFuel.",',
            '"image": "data:image/svg+xml;base64,...",', // Placeholder for a base64 SVG or image URI
            '"attributes": [',
                '{"trait_type": "Temporal State", "value": ', data.temporalState.toString(), '},',
                '{"trait_type": "Bonded ChronoFuel", "value": ', data.bondedFuel.toString(), '},', // Consider token decimals for display
                '{"trait_type": "Resilience", "value": ', resilience.toString(), '},',
                '{"trait_type": "Flux", "value": ', flux.toString(), '},',
                '{"trait_type": "Aura", "value": ', aura.toString(), '},',
                '{"trait_type": "Yield Available", "value": ', yieldAvailable.toString(), '}', // Display formatted value?
            ']}'
        ));

        // Encode JSON to Base64
        string memory base64Json = Base64.encode(bytes(json));

        // Return as data URI
        return string(abi.encodePacked('data:application/json;base64,', base64Json));
    }

    // --- State & Calculation View Functions ---

    /// @notice Gets the core state data for a Temporal Essence.
    /// @param essenceId The ID of the Essence.
    /// @return A tuple containing creationTime, lastEvolutionTime, lastBondUpdateTime, bondedFuel, temporalState.
    function getEssenceState(uint256 essenceId) public view returns (uint64, uint64, uint64, uint256, uint256) {
         if (!_exists(essenceId)) revert InvalidEssenceId();
         EssenceData memory data = essenceData[essenceId];
         return (data.creationTime, data.lastEvolutionTime, data.lastBondUpdateTime, data.bondedFuel, data.temporalState);
    }

    /// @notice Calculates and returns the dynamic attributes for a Temporal Essence.
    /// @param essenceId The ID of the Essence.
    /// @return A tuple containing Resilience, Flux, and Aura attributes.
    /// @dev Attributes are calculated based on temporal state and bonded fuel. (Simplified formula)
    function getEssenceAttributes(uint256 essenceId) public view returns (uint256 resilience, uint256 flux, uint256 aura) {
        if (!_exists(essenceId)) revert InvalidEssenceId();
        EssenceData memory data = essenceData[essenceId];

        // Simplified calculation logic: Attributes shift based on temporalState
        // and get a boost from bonded fuel. (Example formulas)
        uint256 state = data.temporalState;
        uint256 bonded = data.bondedFuel; // Needs adjustment for token decimals in real app

        // Base attributes based on state range
        if (state < 10) { // Young state
            resilience = 10 + state;
            flux = 50 + (10 - state) * 2;
            aura = 5 + state / 2;
        } else if (state < 30) { // Mature state
            resilience = 20 + (state - 10) * 2;
            flux = 30 + (state - 10);
            aura = 10 + (state - 10) / 2;
        } else { // Ancient state
            resilience = 60 + (state - 30);
            flux = 40 + (state - 30) / 2;
            aura = 30 + (state - 30) * 3;
        }

        // Boost from bonded fuel (simple example: sqrt of fuel gives a boost)
        uint256 fuelBoost = bonded > 0 ? Math.sqrt(bonded) / (10 ** (chronoFuelToken.decimals() / 2)) : 0; // Adjust based on decimals!
        resilience += fuelBoost;
        flux += fuelBoost;
        aura += fuelBoost;

        // Cap attributes if necessary (optional)
        resilience = Math.min(resilience, 1000);
        flux = Math.min(flux, 1000);
        aura = Math.min(aura, 1000);
    }

    /// @notice Calculates the amount of yield currently available for an Essence.
    /// @param essenceId The ID of the Essence.
    /// @return The amount of ChronoFuel yield ready to be claimed.
    function calculateCurrentYieldAmount(uint256 essenceId) public view returns (uint256) {
        if (!_exists(essenceId)) return 0; // Or revert InvalidEssenceId();
        EssenceData memory data = essenceData[essenceId];

        if (data.bondedFuel == 0 || yieldRatePerFuelPerSecond == 0) {
            return 0;
        }

        uint256 timeElapsed = block.timestamp - data.lastBondUpdateTime;
        // Yield = bondedFuel * timeElapsed * yieldRatePerFuelPerSecond
        // Using fixed-point arithmetic for potential sub-second rates or small rates
        // Assuming yieldRatePerFuelPerSecond is scaled appropriately (e.g., 1e18 for 1 token/fuel/sec)
        uint256 yield = (data.bondedFuel * timeElapsed * yieldRatePerFuelPerSecond) / (10 ** 18); // Adjust scaling if yieldRate is not 1e18 based

        return yield;
    }

    /// @notice Calculates the penalty for unbonding a specific amount of fuel from an Essence.
    /// @param essenceId The ID of the Essence.
    /// @param amount The amount of fuel proposed to unbond.
    /// @return The penalty amount.
    /// @dev Penalty decays over time since last bond update.
    function calculateUnbondPenalty(uint256 essenceId, uint256 amount) public view returns (uint256) {
        if (!_exists(essenceId) || amount == 0) return 0;
        EssenceData memory data = essenceData[essenceId];
        if (data.bondedFuel < amount) return 0; // Cannot unbond more than bonded

        uint256 timeSinceLastBondUpdate = block.timestamp - data.lastBondUpdateTime;

        // Penalty decreases linearly over unbondPenaltyDecayTime
        // If timeSinceLastBondUpdate >= unbondPenaltyDecayTime, penalty is 0.
        // Otherwise, penalty = (amount * unbondPenaltyBps / 10000) * (unbondPenaltyDecayTime - timeSinceLastBondUpdate) / unbondPenaltyDecayTime
        if (timeSinceLastBondUpdate >= unbondPenaltyDecayTime) {
            return 0;
        } else {
            uint256 initialPenaltyAmount = (amount * unbondPenaltyBps) / 10000;
            uint256 remainingPenaltyRatio = (unbondPenaltyDecayTime - timeSinceLastBondUpdate) * 1e18 / unbondPenaltyDecayTime; // Scaled
            return (initialPenaltyAmount * remainingPenaltyRatio) / 1e18; // Apply ratio
        }
    }

    /// @notice Calculates the ChronoFuel cost required for the next evolution step.
    /// @param essenceId The ID of the Essence.
    /// @return The ChronoFuel cost. (Simplified: Maybe costs fuel at higher states?)
    function calculateNextEvolutionCost(uint256 essenceId) public view returns (uint256) {
        if (!_exists(essenceId)) return 0;
        EssenceData memory data = essenceData[essenceId];

        // Simplified example: Evolution costs fuel only after state X
        uint256 state = data.temporalState;
        if (state < 5) return 0; // Free evolution for first 5 states
        return (state - 4) * 10 ** chronoFuelToken.decimals(); // Cost increases with state, adjusted for decimals
    }

    /// @notice Checks if an Essence is ready to evolve to the next state.
    /// @param essenceId The ID of the Essence.
    /// @return True if ready, false otherwise.
    /// @dev Ready if enough time passed (adjusted by fuel boost) and sufficient bonded fuel for cost.
    function checkEvolutionReadiness(uint256 essenceId) public view returns (bool) {
        if (!_exists(essenceId)) return false;
        EssenceData memory data = essenceData[essenceId];

        uint256 requiredCost = calculateNextEvolutionCost(essenceId);
        if (data.bondedFuel < requiredCost) {
             return false; // Not enough fuel bonded for the cost
        }

        uint256 timeSinceLastEvolution = block.timestamp - data.lastEvolutionTime;
        uint256 fuelBoostSeconds = (data.bondedFuel * fuelEvolutionBoostPer1kBond) / 1000; // Calculate time reduction from fuel boost
        uint256 effectiveBaseTime = baseEvolutionTime > fuelBoostSeconds ? baseEvolutionTime - fuelBoostSeconds : 0;

        return timeSinceLastEvolution >= effectiveBaseTime;
    }

    /// @notice Simulates the projected state and attributes of an Essence after a time delta.
    /// @param essenceId The ID of the Essence.
    /// @param timeDelta Seconds into the future to simulate.
    /// @return A tuple containing simulated temporalState, bondedFuel (including potential yield), and attributes.
    /// @dev This is a view function and does not change contract state. Simplifies complex projections.
    function simulateFutureState(uint256 essenceId, uint256 timeDelta) public view returns (uint256 simulatedTemporalState, uint256 simulatedBondedFuel, uint256 resilience, uint256 flux, uint256 aura) {
         if (!_exists(essenceId)) revert InvalidEssenceId();
         EssenceData memory data = essenceData[essenceId];

         uint256 currentTime = block.timestamp;
         uint256 futureTime = currentTime + timeDelta;

         // Simulate Yield Accumulation
         uint256 timeSinceLastBondUpdate = currentTime - data.lastBondUpdateTime;
         uint256 futureTimeSinceLastBondUpdate = futureTime - data.lastBondUpdateTime;

         uint256 yieldAccumulatedDuringDelta = 0;
         if (data.bondedFuel > 0 && yieldRatePerFuelPerSecond > 0) {
             // Calculate yield accumulated *up to* the future time point
              yieldAccumulatedDuringDelta = (data.bondedFuel * futureTimeSinceLastBondUpdate * yieldRatePerFuelPerSecond) / (10 ** 18); // Scaled
              // Subtract yield already claimable at current time to get only delta yield
              yieldAccumulatedDuringDelta = yieldAccumulatedDuringDelta > calculateCurrentYieldAmount(essenceId) ? yieldAccumulatedDuringDelta - calculateCurrentYieldAmount(essenceId) : 0;
         }
         simulatedBondedFuel = data.bondedFuel + yieldAccumulatedDuringDelta;

         // Simulate Evolution
         uint256 timeSinceLastEvolution = currentTime - data.lastEvolutionTime;
         uint256 futureTimeSinceLastEvolution = futureTime - data.lastEvolutionTime;
         uint256 state = data.temporalState;

         // Simple simulation: check evolution readiness repeatedly
         // A more complex simulation would calculate exactly how many evolution steps occur
         // based on time and available fuel. For simplicity, let's just project based on time passed
         // vs the effective base time per evolution step, assuming fuel cost is always met.
         uint256 fuelBoostSeconds = (data.bondedFuel * fuelEvolutionBoostPer1kBond) / 1000;
         uint256 effectiveBaseTime = baseEvolutionTime > fuelBoostSeconds ? baseEvolutionTime - fuelBoostSeconds : 0;
         effectiveBaseTime = effectiveBaseTime > 0 ? effectiveBaseTime : 1; // Prevent division by zero

         uint256 potentialEvolutions = futureTimeSinceLastEvolution / effectiveBaseTime;

         simulatedTemporalState = state + potentialEvolutions; // Oversimplified: assumes fuel cost is always covered

         // Simulate Attributes based on projected state and fuel
         // Create a temporary EssenceData struct for attribute calculation
         EssenceData memory simulatedData = EssenceData({
             creationTime: data.creationTime,
             lastEvolutionTime: data.lastEvolutionTime, // Not relevant for future calculation within this view
             lastBondUpdateTime: data.lastBondUpdateTime, // Not relevant for future calculation within this view
             bondedFuel: simulatedBondedFuel,
             temporalState: simulatedTemporalState
         });

         // Calculate attributes using the simulated data
         (resilience, flux, aura) = _calculateAttributes(simulatedData);

         return (simulatedTemporalState, simulatedBondedFuel, resilience, flux, aura);
    }

    // Internal helper for attribute calculation (used by getEssenceAttributes and simulateFutureState)
    function _calculateAttributes(EssenceData memory data) internal view returns (uint256 resilience, uint256 flux, uint256 aura) {
         uint256 state = data.temporalState;
         uint256 bonded = data.bondedFuel; // Needs adjustment for token decimals

         // Base attributes based on state range (Same logic as getEssenceAttributes)
        if (state < 10) { // Young state
            resilience = 10 + state;
            flux = 50 + (10 > state ? (10 - state) * 2 : 0); // Ensure no negative values
            aura = 5 + state / 2;
        } else if (state < 30) { // Mature state
            resilience = 20 + (state > 10 ? (state - 10) * 2 : 0);
            flux = 30 + (state > 10 ? (state - 10) : 0);
            aura = 10 + (state > 10 ? (state - 10) / 2 : 0);
        } else { // Ancient state
            resilience = 60 + (state > 30 ? (state - 30) : 0);
            flux = 40 + (state > 30 ? (state - 30) / 2 : 0);
            aura = 30 + (state > 30 ? (state - 30) * 3 : 0);
        }

        // Boost from bonded fuel (simple example: sqrt of fuel gives a boost)
        // Need to be careful with sqrt on large numbers and token decimals.
        // Let's assume ChronoFuel has 18 decimals for this calculation example.
        // This might require a custom sqrt for larger numbers or using a different boost formula.
        // Example with scaling: treat fuel as units * 1e18, take sqrt, then rescale.
        // A simpler approach for demonstration: divide fuel by a large number before sqrt.
        uint256 fuelUnits = bonded / (10 ** chronoFuelToken.decimals()); // Get integer units
        uint256 fuelBoost = fuelUnits > 0 ? Math.sqrt(fuelUnits) * 5 : 0; // Apply some factor to sqrt

        resilience += fuelBoost;
        flux += fuelBoost;
        aura += fuelBoost;

        // Cap attributes if necessary
        resilience = Math.min(resilience, 1000);
        flux = Math.min(flux, 1000);
        aura = Math.min(aura, 1000);
    }

    /// @notice Gets the total number of Essences forged.
    function getTotalEssences() public view returns (uint256) {
        return _nextTokenId - 1; // tokenIds start from 1
    }

    /// @notice Gets the creation timestamp of an Essence.
    function getEssenceCreationTime(uint256 essenceId) public view returns (uint64) {
        if (!_exists(essenceId)) revert InvalidEssenceId();
        return essenceData[essenceId].creationTime;
    }

    /// @notice Gets the timestamp of the last evolution for an Essence.
    function getLastEvolutionTime(uint256 essenceId) public view returns (uint64) {
        if (!_exists(essenceId)) revert InvalidEssenceId();
        return essenceData[essenceId].lastEvolutionTime;
    }

     /// @notice Gets the bonded fuel amount and last bond update time for an Essence.
    function getEssenceBondDetails(uint256 essenceId) public view returns (uint256 bondedFuel, uint64 lastBondUpdateTime) {
        if (!_exists(essenceId)) revert InvalidEssenceId();
        EssenceData memory data = essenceData[essenceId];
        return (data.bondedFuel, data.lastBondUpdateTime);
    }


    // --- Owner/Admin Functions ---

    /// @notice Sets the address of the ChronoFuel ERC20 token contract.
    /// @param _chronoFuelAddress The address of the ERC20 contract.
    /// @dev Only owner can call. Must be a valid address.
    function setChronoFuelToken(address _chronoFuelAddress) external onlyOwner {
        if (_chronoFuelAddress == address(0)) revert ZeroAddressNotAllowed();
        chronoFuelToken = IERC20(_chronoFuelAddress);
        emit ChronoFuelTokenSet(_chronoFuelAddress);
    }

    /// @notice Sets parameters controlling Essence evolution.
    /// @param _baseEvolutionTime Base time required between evolution steps.
    /// @param _fuelEvolutionBoostPer1kBond Seconds reduced per 1000 bonded fuel.
    /// @dev Only owner can call.
    function setEvolutionParameters(uint256 _baseEvolutionTime, uint256 _fuelEvolutionBoostPer1kBond) external onlyOwner {
        baseEvolutionTime = _baseEvolutionTime;
        fuelEvolutionBoostPer1kBond = _fuelEvolutionBoostPer1kBond;
        emit ParametersUpdated();
    }

    /// @notice Sets the yield rate for bonded ChronoFuel.
    /// @param _yieldRatePerFuelPerSecond Rate scaled by 1e18 for precision (e.g., 1e18 = 1 token/fuel/sec).
    /// @dev Only owner can call. Rate is per fuel unit per second.
    function setYieldParameters(uint256 _yieldRatePerFuelPerSecond) external onlyOwner {
        yieldRatePerFuelPerSecond = _yieldRatePerFuelPerSecond;
        emit ParametersUpdated();
    }

    /// @notice Sets parameters for the unbonding penalty.
    /// @param _unbondPenaltyBps Base penalty percentage in basis points (e.g., 500 = 5%).
    /// @param _penaltyDecayTime Time in seconds over which the penalty decays to zero.
    /// @dev Only owner can call.
    function setUnbondPenaltyParameters(uint256 _unbondPenaltyBps, uint256 _penaltyDecayTime) external onlyOwner {
        unbondPenaltyBps = _unbondPenaltyBps;
        unbondPenaltyDecayTime = _penaltyDecayTime;
        emit ParametersUpdated();
    }

    /// @notice Allows the owner to withdraw other ERC20 tokens accidentally sent to the contract.
    /// @param tokenAddress The address of the token to withdraw.
    /// @param amount The amount to withdraw.
    /// @dev Protects bonded fuel and yield, only withdraws excess. Use with caution.
    function withdrawStuckTokens(address tokenAddress, uint256 amount) external onlyOwner nonReentrant {
        if (tokenAddress == address(chronoFuelToken)) {
            // Cannot withdraw ChronoFuel directly with this function,
            // as it might include bonded fuel or accumulated yield.
            // A more sophisticated withdrawal function would be needed if necessary.
            revert("Cannot withdraw ChronoFuel using this function.");
        }
        IERC20 stuckToken = IERC20(tokenAddress);
        uint256 balance = stuckToken.balanceOf(address(this));
        uint256 amountToTransfer = Math.min(amount, balance);

        if (amountToTransfer > 0) {
            stuckToken.safeTransfer(_msgSender(), amountToTransfer);
        }
    }

    // --- ERC721 Overrides ---

    // Required for ERC721Enumerable
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override(ERC721Enumerable, ERC721) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);

        // Optional: Handle state change on transfer.
        // For this concept, bonded fuel stays with the NFT.
        // Maybe reset yield or penalty decay timer on transfer?
        // Let's reset lastBondUpdateTime on transfer to effectively reset yield calculation for the new owner.
        // This is a design choice. Could also let yield continue untouched.
        if (from != address(0) && to != address(0)) {
             if (_exists(tokenId)) { // Ensure Essence exists before accessing data
                 essenceData[tokenId].lastBondUpdateTime = uint64(block.timestamp);
                 // Could also reset lastEvolutionTime if transfers should pause/reset evolution progress.
                 // Let's keep evolution clock ticking unless manually evolved.
             }
        }
    }

    // Override supportsInterface for ERC721Enumerable
    function supportsInterface(bytes4 interfaceId) public view override(ERC721Enumerable, ERC721) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    // The rest of ERC721Enumerable functions (totalSupply, tokenByIndex, tokenOfOwnerByIndex)
    // are inherited and work with _beforeTokenTransfer and _safeMint/_burn hooks.
}
```

---

**Explanation of Advanced/Creative Concepts Used:**

1.  **Dynamic State & Evolution:** The `EssenceData` struct and the `temporalState` variable give each NFT a unique, on-chain state that changes *over time* (`block.timestamp`) and *based on user interaction* (`bondedFuel`, `evolveEssence`). This goes beyond static attributes defined at minting.
2.  **ERC20 Bonding to ERC721:** Users "stake" ChronoFuel specifically to an *individual* NFT ID, not just a general staking pool. This ties the utility of the fungible token directly to the non-fungible asset, creating a resource management layer around each NFT.
3.  **Yield Generation:** Bonded fuel actively generates more of the fungible token over time, providing an economic incentive for holding and maintaining the NFT by bonding fuel. This is a form of on-chain passive income tied to an NFT.
4.  **On-Chain Attribute Calculation:** Attributes like Resilience, Flux, and Aura are *not* stored directly but are calculated every time `getEssenceAttributes` is called, based on the NFT's *current* `temporalState` and `bondedFuel`. This makes the attributes truly dynamic and responsive.
5.  **Dynamic On-Chain Metadata (`tokenURI`):** The `tokenURI` function doesn't just return a static URL. It calculates the NFT's current state and attributes, formats this data into a JSON string, Base64 encodes it, and returns it as a Data URI. This means the metadata shown on marketplaces can dynamically update as the NFT evolves, *without* relying on off-chain servers (though a complex image would still likely require an API). This is a significant step towards fully on-chain dynamic NFTs.
6.  **Parameterization by Owner:** Key economic and evolutionary parameters (`baseEvolutionTime`, `fuelEvolutionBoostPer1kBond`, `yieldRatePerFuelPerSecond`, `unbondPenaltyBps`, `unbondPenaltyDecayTime`) are configurable by the owner. This allows tuning the game mechanics post-deployment (though requires careful governance or multi-sig in a real application).
7.  **State Simulation:** The `simulateFutureState` function is a view function that allows users (or frontends) to project how an Essence *might* look or perform in the future based on current state and a time delta, without executing a transaction. This is useful for user experience and strategic planning within the system.
8.  **Unbonding Penalty:** Introduces a simple economic disincentive for immediately withdrawing bonded fuel, adding a layer of strategy.
9.  **Inter-Contract Communication:** The contract directly interacts with an external ERC20 contract (`IERC20`, `SafeERC20`) for `transferFrom` and `transfer` operations related to bonding, unbonding, and yield claiming.
10. **Use of OpenZeppelin Standards:** Leverages battle-tested libraries (`ERC721Enumerable`, `ReentrancyGuard`, `Ownable`, `SafeERC20`, `Math`, `Strings`, `Base64`) while adding custom logic, demonstrating best practices in building upon existing infrastructure.
11. **Custom Errors:** Using `error` declarations for clearer and gas-efficient error handling.
12. **Time-Based Logic:** Extensive use of `block.timestamp` to drive mechanics like evolution, yield accumulation, and penalty decay.

This contract provides a foundation for a decentralized application involving collectible, evolving digital assets with resource management and yield farming components, showcasing several non-trivial Solidity patterns. Remember this is a complex example and would require significant testing and auditing for production use.