```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title QuantumLeapProtocol
 * @dev A smart contract managing dynamic Chronopods (ERC-1155 assets)
 *      with state transitions, energy mechanics, resource generation,
 *      and a research system, incorporating time-based and conditional logic.
 *      This contract combines elements of gamification, programmable assets,
 *      and resource management into a self-contained protocol simulation.
 *
 * Outline:
 * 1. Contract Information (Pragma, Imports, License)
 * 2. Contract Definition (Inheritance)
 * 3. Libraries
 * 4. State Variables
 *    - ERC-1155 related state
 *    - Protocol specific state (Pod configs, Resource configs, Research configs, User states, Energy system)
 * 5. Enums and Structs
 *    - Pod States
 *    - Configuration Structs (Pod, Resource, Research)
 *    - User State Struct (Energy, Research)
 * 6. Events
 * 7. Modifiers
 * 8. Constructor
 * 9. ERC-1155 Standard Functions (Implemented via OZ)
 * 10. Core Protocol Logic Functions (>20 functions total)
 *     - Pod Management (Minting, Activation, Deactivation, Time Locking, Upgrading, Combining)
 *     - Energy & Resource Management (Accrual, Claiming, Burning)
 *     - Research System (Initiation, Completion, Unlocking)
 *     - Configuration & Admin Functions
 *     - View & Utility Functions
 * 11. Internal Helper Functions
 *
 * Function Summary:
 * - Standard ERC-1155 Functions: balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, safeBatchTransferFrom.
 * - mintPod: Creates a new Chronopod token instance for a user.
 * - activatePod: Transitions a Chronopod to 'Active' state, enabling energy/resource generation (consumes energy).
 * - deactivatePod: Transitions an 'Active' Chronopod back to 'Dormant' state (may have cooldown).
 * - timeLockPod: Locks an 'Active' Chronopod for a specific duration in 'TimeLocked' state.
 * - claimTimeLockedPod: Allows claiming a 'TimeLocked' Chronopod after its unlock time.
 * - upgradePod: Improves a Chronopod's properties by consuming resources and energy.
 * - combinePods: Burns two Chronopods to potentially create a new, improved one (consumes energy/resources).
 * - accrueEnergy: Calculates and adds generated energy to the user's balance based on active pods and time elapsed.
 * - getUserEnergyBalance: Returns the user's current accrued energy.
 * - claimGeneratedResources: Claims pending resources generated by a specific Active or TimeLocked pod.
 * - getPendingResourcesForPod: Returns the amount of resources a specific pod has generated but not yet claimed.
 * - burnResources: Burns a specified amount of resources owned by the user (can potentially generate energy).
 * - initiateResearch: Starts a research project by consuming energy/resources (time-based).
 * - completeResearch: Finalizes a research project after the required time has passed, potentially unlocking new resources/capabilities.
 * - getResearchStatus: Returns the current progress and status of a user's research project.
 * - unlockNewResourceType: An internal function called upon successful research completion to make a new resource type available.
 * - setPodConfiguration: Owner function to define properties for different Chronopod types.
 * - setResourceConfiguration: Owner function to define properties for different Resource types.
 * - setResearchConfiguration: Owner function to define requirements and unlocks for research topics.
 * - getPodConfiguration: Returns the configuration struct for a specific pod type.
 * - getResourceConfiguration: Returns the configuration struct for a specific resource type.
 * - getResearchConfiguration: Returns the configuration struct for a specific research topic.
 * - getPodState: Returns the current state of a specific Chronopod instance.
 * - getUserResearchProgress: Returns detailed research progress for a user on a specific topic.
 * - setBaseGenerationRates: Owner function to set global energy and resource generation rates.
 * - pause: Pauses contract operations (Owner).
 * - unpause: Unpauses contract operations (Owner).
 * - withdrawProtocolFees: Allows owner to withdraw collected fees (if any implemented, placeholder).
 * - getNextPodId: Returns the ID for the next minted pod instance.
 * - getAvailableResearchTopics: Lists the IDs of all configured research topics.
 * - internal: _updateUserEnergyAndResources (Helper for calculating and updating accruals)
 */
contract QuantumLeapProtocol is ERC1155, Ownable, Pausable, ReentrancyGuard {
    using SafeMath for uint256;
    using Counters for Counters.Counter;

    // --- State Variables ---

    // Global counters for unique instance IDs
    Counters.Counter private _podInstanceIds;
    Counters.Counter private _resourceInstanceIds; // Although resources might be fungible within types, this could track unique *spawns* if needed, though simpler to track type balance. Let's stick to ERC1155 fungibility for resources for now.

    // ERC-1155 State (handled by OZ)
    // Mapping from token ID to URI (not strictly needed if base URI is used, but allows unique metadata per ID)
    mapping(uint256 => string) private _tokenURIs;

    // Protocol Configuration
    struct PodConfig {
        uint256 podTypeId; // Identifier for the type of pod
        string name;
        string uri; // Base URI for this pod type metadata
        uint256 initialEnergyCost; // Energy to mint/activate
        uint256 energyGenerationRate; // Energy generated per unit of time (e.g., per hour)
        uint256 resourceGenerationRate; // Resources generated per unit of time
        uint256 generatedResourceType; // The type of resource this pod generates
        mapping(uint256 => uint256) upgradeCostsResources; // Resources needed for upgrades
        uint256 upgradeEnergyCost; // Energy needed for upgrades
        // Potentially more properties: durability, efficiency modifier, etc.
    }
    mapping(uint256 => PodConfig) public podConfigurations;
    uint256[] public availablePodTypes; // List of configured pod type IDs

    struct ResourceConfig {
        uint256 resourceTypeId; // Identifier for the type of resource (matches generatedResourceType in PodConfig)
        string name;
        string uri; // Base URI for this resource type metadata
        bool burnableForEnergy; // Can this resource be burned for energy?
        uint256 energyPerBurnedUnit; // How much energy per unit burned
        bool isInitiallyAvailable; // Is this resource type available from the start or requires research?
        // Potentially more properties: tradable, consumable effects, etc.
    }
    mapping(uint256 => ResourceConfig) public resourceConfigurations;
    uint256[] public availableResourceTypes; // List of configured resource type IDs

    struct ResearchTopic {
        uint256 topicId; // Identifier for the research topic
        string name;
        mapping(uint256 => uint256) requiredResources; // Resources needed to start
        uint256 requiredEnergy; // Energy needed to start
        uint256 requiredDuration; // Time needed to complete (in seconds)
        uint256 unlocksResourceType; // The resource type ID unlocked upon completion (0 if none)
        // Potentially more: unlocks upgrade types, new abilities, etc.
    }
    mapping(uint256 => ResearchTopic) public researchConfigurations;
    uint256[] public availableResearchTopics; // List of configured research topic IDs

    // User Specific State
    enum PodState { Dormant, Active, TimeLocked, Generating } // Generating implies Active/TimeLocked state where accrual happens
    mapping(uint256 => PodState) public podStates; // State of each unique pod *instance* ID

    mapping(uint256 => uint256) public podStateTimestamps; // Timestamp when pod state last changed (for accrual calculations)
    mapping(uint256 => uint256) public podUnlockTimestamps; // Specific unlock time for TimeLocked pods

    mapping(address => uint256) public userEnergyBalance; // Energy balance per user (internal)

    // Mapping from pod instance ID to pending resources (accumulated but not claimed)
    mapping(uint256 => uint256) public podPendingResources;

    struct UserResearch {
        uint256 topicId;
        uint256 startTime;
        bool completed;
    }
    mapping(address => UserResearch) public userResearchStatus; // Only one research project at a time per user

    // Global Configuration (Rates applied universally or as base)
    uint256 public baseEnergyGenerationRatePerSec = 0; // Base rate independent of pods
    uint256 public baseResourceGenerationRatePerSec = 0; // Base rate independent of pods

    // Protocol Fees (optional, placeholder)
    address public protocolFeeRecipient;
    uint256 public protocolFeePercentage; // Basis points (e.g., 100 = 1%)

    // --- Events ---
    event PodMinted(address indexed user, uint256 indexed podId, uint256 indexed podTypeId);
    event PodStateChanged(uint256 indexed podId, PodState newState, uint256 timestamp);
    event EnergyAccrued(address indexed user, uint256 amount);
    event ResourcesClaimed(address indexed user, uint256 indexed podId, uint256 indexed resourceTypeId, uint256 amount);
    event ResourcesBurned(address indexed user, uint256 indexed resourceTypeId, uint256 amount, uint256 energyGained);
    event PodUpgraded(address indexed user, uint256 indexed podId, uint256 indexed upgradeType); // upgradeType could be config ID or specific value
    event PodCombined(address indexed user, uint256 indexed podId1, uint256 indexed podId2, uint256 indexed newPodId);
    event ResearchInitiated(address indexed user, uint256 indexed topicId, uint256 startTime);
    event ResearchCompleted(address indexed user, uint256 indexed topicId, uint256 completionTime, uint256 unlockedResourceType);
    event ConfigurationUpdated(string configType, uint256 indexed configId);
    event FeeWithdrawn(address indexed recipient, uint256 amount);

    // --- Modifiers ---
    modifier onlyPodOwner(uint256 podId) {
        require(_balances[address(this)][podId] == 0, "Pod must be owned by contract for state change"); // State changes happen on contract-owned instance
        require(balanceOf(msg.sender, podId) > 0, "Caller must own the pod instance");
        _;
    }

    modifier onlyPodState(uint256 podId, PodState requiredState) {
        require(podStates[podId] == requiredState, "Pod is not in the required state");
        _;
    }

    modifier onlyResourceAvailable(uint256 resourceTypeId) {
        ResourceConfig storage resConfig = resourceConfigurations[resourceTypeId];
        require(resConfig.resourceTypeId != 0, "Resource type not configured");
        if (!resConfig.isInitiallyAvailable) {
            // Check if the resource has been unlocked via research
            bool unlocked = false;
            for(uint i = 0; i < availableResearchTopics.length; i++) {
                 uint256 topicId = availableResearchTopics[i];
                 ResearchTopic storage researchConfig = researchConfigurations[topicId];
                 if (researchConfig.unlocksResourceType == resourceTypeId) {
                     UserResearch storage userResearch = userResearchStatus[msg.sender];
                     if (userResearch.topicId == topicId && userResearch.completed) {
                         unlocked = true;
                         break;
                     }
                 }
            }
            require(unlocked, "Resource type not yet unlocked via research");
        }
        _;
    }


    // --- Constructor ---
    constructor(
        string memory uri,
        address initialOwner,
        address _protocolFeeRecipient
    ) ERC1155(uri) Ownable(initialOwner) Pausable(false) {
        protocolFeeRecipient = _protocolFeeRecipient;
        // Initial configurations should be set by owner after deployment
        // setPodConfiguration, setResourceConfiguration, setResearchConfiguration, setBaseGenerationRates
    }

    // --- ERC-1155 Standard Functions ---
    // balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, safeBatchTransferFrom
    // Implemented by OpenZeppelin ERC1155 base contract.
    // Note: safeTransferFrom/safeBatchTransferFrom will check isApprovedForAll

    // We may need to override _beforeTokenTransfer or _afterTokenTransfer
    // to handle state changes or accruals upon transfer if needed.
    // For this design, state changes (Active, TimeLocked) put the token
    // in the contract's address, preventing transfer while in that state.
    // Dormant tokens can be transferred.

    function uri(uint256 tokenId) public view override returns (string memory) {
        // Check if it's a Pod instance
        PodState state = podStates[tokenId];
        if (uint(state) > 0 || _podInstanceIds.current() >= tokenId) { // Check if it's likely a minted pod instance
             uint256 podTypeId = _getPodTypeId(tokenId); // Assumes podTypeId is encoded or stored
             if (podConfigurations[podTypeId].podTypeId != 0) {
                 return string.concat(podConfigurations[podTypeId].uri, string(abi.encodePacked(tokenId))); // Append instance ID or other unique data
             }
        }

        // Check if it's a configured Resource type
        ResourceConfig storage resConfig = resourceConfigurations[tokenId];
        if (resConfig.resourceTypeId != 0) {
             return string.concat(resConfig.uri, string(abi.encodePacked(tokenId))); // Resource type ID is the token ID
        }

        // Default URI from constructor
        return super.uri(tokenId);
    }


    // --- Core Protocol Logic Functions ---

    /**
     * @dev Mints a new Chronopod instance of a specific type for the caller.
     * @param podTypeId The type of pod to mint.
     * @param to The recipient address.
     */
    function mintPod(uint256 podTypeId, address to) external nonReentrant whenNotPaused {
        PodConfig storage config = podConfigurations[podTypeId];
        require(config.podTypeId != 0, "Invalid pod type");
        require(userEnergyBalance[msg.sender] >= config.initialEnergyCost, "Insufficient energy to mint");

        uint256 newTokenId = _podInstanceIds.current(); // Use current before incrementing for the new ID
        _podInstanceIds.increment();

        userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].sub(config.initialEnergyCost);
        _mint(to, newTokenId, 1, "", ""); // Mint the unique instance

        podStates[newTokenId] = PodState.Dormant; // Starts in Dormant state
        podStateTimestamps[newTokenId] = block.timestamp; // Record initial state change time

        emit PodMinted(to, newTokenId, podTypeId);
    }

     /**
     * @dev Transitions a Dormant pod to Active state, consuming energy.
     * @param podId The unique instance ID of the pod.
     */
    function activatePod(uint256 podId) external nonReentrant onlyPodOwner(podId) onlyPodState(podId, PodState.Dormant) whenNotPaused {
        // First, accrue any pending energy/resources before state change
        _updateUserEnergyAndResources(msg.sender);

        // Check energy cost (can be defined per pod type or a standard cost)
        uint256 podTypeId = _getPodTypeId(podId); // Need to get the type of this instance
        PodConfig storage config = podConfigurations[podTypeId];
        require(config.podTypeId != 0, "Invalid pod type config for instance"); // Should not happen if minted correctly

        // Let's say activation cost is same as initial mint cost for simplicity
        require(userEnergyBalance[msg.sender] >= config.initialEnergyCost, "Insufficient energy to activate");

        userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].sub(config.initialEnergyCost);

        // Transfer token to contract to signify state control
        _safeTransferFrom(msg.sender, address(this), podId, 1, "");

        podStates[podId] = PodState.Active;
        podStateTimestamps[podId] = block.timestamp;

        emit PodStateChanged(podId, PodState.Active, block.timestamp);
    }

     /**
     * @dev Transitions an Active pod back to Dormant state.
     * @param podId The unique instance ID of the pod.
     */
    function deactivatePod(uint256 podId) external nonReentrant onlyPodOwner(podId) onlyPodState(podId, PodState.Active) whenNotPaused {
        // Accrue before changing state
        _updateUserEnergyAndResources(msg.sender);

        // Transfer token back to owner
        _safeTransferFrom(address(this), msg.sender, podId, 1, "");

        podStates[podId] = PodState.Dormant;
        podStateTimestamps[podId] = block.timestamp;

        emit PodStateChanged(podId, PodState.Dormant, block.timestamp);
    }

     /**
     * @dev Locks an Active pod for a future unlock time, transitioning to TimeLocked state.
     * @param podId The unique instance ID of the pod.
     * @param unlockTime The future timestamp when the pod can be claimed.
     */
    function timeLockPod(uint256 podId, uint256 unlockTime) external nonReentrant onlyPodOwner(podId) onlyPodState(podId, PodState.Active) whenNotPaused {
        require(unlockTime > block.timestamp, "Unlock time must be in the future");

        // Accrue before changing state
        _updateUserEnergyAndResources(msg.sender);

        // Token should already be with the contract if it's Active
        require(balanceOf(address(this), podId) > 0, "Pod not held by contract");

        podStates[podId] = PodState.TimeLocked;
        podStateTimestamps[podId] = block.timestamp; // Record time locked
        podUnlockTimestamps[podId] = unlockTime; // Record unlock time

        emit PodStateChanged(podId, PodState.TimeLocked, block.timestamp);
    }

     /**
     * @dev Claims a TimeLocked pod after its unlock time has passed.
     * @param podId The unique instance ID of the pod.
     */
    function claimTimeLockedPod(uint256 podId) external nonReentrant onlyPodOwner(podId) onlyPodState(podId, PodState.TimeLocked) whenNotPaused {
        require(block.timestamp >= podUnlockTimestamps[podId], "Time lock has not expired yet");

        // Accrue before changing state
        _updateUserEnergyAndResources(msg.sender);

        // Transfer token back to owner
        _safeTransferFrom(address(this), msg.sender, podId, 1, "");

        podStates[podId] = PodState.Dormant; // Return to Dormant after claiming
        podStateTimestamps[podId] = block.timestamp;

        // Clear unlock timestamp
        delete podUnlockTimestamps[podId];

        emit PodStateChanged(podId, PodState.Dormant, block.timestamp);
    }


    /**
     * @dev Upgrades a Chronopod, consuming resources and energy.
     * @param podId The unique instance ID of the pod to upgrade.
     * @param upgradeTypeIdentifier An identifier for the specific upgrade path/level.
     *   (Example: could be 0 for basic upgrade, 1 for efficiency upgrade, etc.)
     *   (Advanced: upgradeTypeIdentifier could map to config struct defining costs/effects)
     */
    function upgradePod(uint256 podId, uint256 upgradeTypeIdentifier) external nonReentrant onlyPodOwner(podId) onlyPodState(podId, PodState.Dormant) whenNotPaused {
        // For simplicity, let's assume upgrading requires the pod to be Dormant.
        // More complex logic could allow upgrading in place while Active, with penalties/pauses.

        // Accrue before action
        _updateUserEnergyAndResources(msg.sender);

        uint256 podTypeId = _getPodTypeId(podId);
        PodConfig storage config = podConfigurations[podTypeId];
        require(config.podTypeId != 0, "Invalid pod type config for instance");

        // --- Define Upgrade Costs and Effects (Simplified Example) ---
        // In a real system, this would be more complex, potentially defined
        // in a separate upgrade config mapping based on podTypeId and upgradeTypeIdentifier
        uint256 requiredEnergy = config.upgradeEnergyCost; // Example: use base upgrade cost from config
        uint256 requiredResourceAmount = config.upgradeCostsResources[upgradeTypeIdentifier]; // Example: get resource cost for this upgrade identifier
        uint256 requiredResourceType = config.generatedResourceType; // Example: upgrade requires its own generated resource

        require(userEnergyBalance[msg.sender] >= requiredEnergy, "Insufficient energy for upgrade");
        require(balanceOf(msg.sender, requiredResourceType) >= requiredResourceAmount, "Insufficient resources for upgrade");
        // --- End Simplified Example ---


        // Consume resources and energy
        userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].sub(requiredEnergy);
        _burn(msg.sender, requiredResourceType, requiredResourceAmount);

        // --- Apply Upgrade Effects ---
        // This is the creative part. How does upgrading affect the pod?
        // It could modify stored properties for this specific instance ID.
        // Example: Increase energy/resource generation rate for this pod instance.
        // Needs a mapping: podInstanceId -> {modified stats}
        // Let's add a simple placeholder: assume upgrading *increases* the base generation rate for this instance.
        // This requires storing per-instance modifiers or new stats.
        // uint256 newEnergyRate = config.energyGenerationRate.add(upgradeTypeIdentifier * 10); // Example calculation
        // uint256 newResourceRate = config.resourceGenerationRate.add(upgradeTypeIdentifier * 5); // Example calculation
        // _setPodInstanceRates(podId, newEnergyRate, newResourceRate); // Need a function/mapping for instance stats

        // As storing instance-specific config complicates state significantly,
        // a simpler approach for *this example* is to use upgradeTypeIdentifier
        // purely for cost and event logging, implying internal protocol
        // updates or off-chain logic handles the statistical change.
        // Or, let the upgrade burn the old pod and mint a *new* type representing the upgraded version.
        // Let's choose the burn+mint approach for simplicity in this example,
        // effectively "combining" old pod + resources into new pod. Renaming function to reflect this better.
        // Let's revert this - upgrade implies modifying *this* pod instance, not creating a new one.
        // We *must* store per-instance properties to make upgrades meaningful on a specific NFT.
        // Let's add state for instance-specific modifiers.

        // Adding state:
        // mapping(uint256 => uint256) public podInstanceEnergyRateModifier;
        // mapping(uint256 => uint256) public podInstanceResourceRateModifier;

        // Apply modifiers (example: linear increase based on upgradeTypeIdentifier)
        // podInstanceEnergyRateModifier[podId] = podInstanceEnergyRateModifier[podId].add(upgradeTypeIdentifier * 10);
        // podInstanceResourceRateModifier[podId] = podInstanceResourceRateModifier[podId].add(upgradeTypeIdentifier * 5);

        // For this example, let's keep it simpler and just log the upgrade.
        // The actual stat changes could be derived from `getPodProperties` view function
        // which could look up an 'upgrade level' stored per instance ID and apply modifiers.
        // Let's add a mapping `mapping(uint256 => uint256) public podInstanceUpgradeLevel;`
        mapping(uint256 => uint256) public podInstanceUpgradeLevel;
        podInstanceUpgradeLevel[podId] = podInstanceUpgradeLevel[podId].add(1); // Increment upgrade level

        emit PodUpgraded(msg.sender, podId, podInstanceUpgradeLevel[podId]); // Use the new level as the identifier in event
    }

     /**
     * @dev Burns two Chronopods to potentially create a new, different type.
     * @param podId1 The first pod instance ID.
     * @param podId2 The second pod instance ID.
     */
    function combinePods(uint256 podId1, uint256 podId2) external nonReentrant whenNotPaused {
        require(podId1 != podId2, "Cannot combine a pod with itself");
        require(balanceOf(msg.sender, podId1) > 0, "Caller must own first pod");
        require(balanceOf(msg.sender, podId2) > 0, "Caller must own second pod");
        require(podStates[podId1] == PodState.Dormant, "First pod must be Dormant");
        require(podStates[podId2] == PodState.Dormant, "Second pod must be Dormant");

        // Accrue before action
        _updateUserEnergyAndResources(msg.sender);

        // --- Define Combination Logic & Costs (Example) ---
        // This could be complex based on the types of podId1 and podId2.
        // Maybe combining two of type A gives a chance of type B, C, or D.
        // Maybe requires energy or specific resources.
        uint256 requiredEnergy = 500; // Example cost
        require(userEnergyBalance[msg.sender] >= requiredEnergy, "Insufficient energy for combination");
        userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].sub(requiredEnergy);

        // Burn the two input pods
        _burn(msg.sender, podId1, 1);
        _burn(msg.sender, podId2, 1);

        // --- Determine Resulting Pod Type (Example Logic) ---
        // Simple Example: Combine two of type 1 gives one of type 2.
        uint256 podTypeId1 = _getPodTypeId(podId1); // Assuming we can get type from ID
        uint256 podTypeId2 = _getPodTypeId(podId2);

        uint256 newPodTypeId = 0;
        // This logic would be based on a config mapping: (type1, type2) => resultType
        // Example: If type1==1 and type2==1, newPodTypeId = 2
        if (podTypeId1 == 1 && podTypeId2 == 1) {
            newPodTypeId = 2;
        } else if (podTypeId1 == 2 && podTypeId2 == 2) {
            newPodTypeId = 3;
        }
        // Add more combination rules here

        require(newPodTypeId != 0, "Invalid combination of pod types");
        PodConfig storage newConfig = podConfigurations[newPodTypeId];
        require(newConfig.podTypeId != 0, "Resulting pod type not configured");


        // Mint the new resulting pod
        uint256 newPodId = _podInstanceIds.current();
        _podInstanceIds.increment();
        _mint(msg.sender, newPodId, 1, "", "");
        podStates[newPodId] = PodState.Dormant; // New pod starts Dormant
        podStateTimestamps[newPodId] = block.timestamp;


        emit PodCombined(msg.sender, podId1, podId2, newPodId);
    }

     /**
     * @dev Calculates and accrues energy for the caller based on active pods.
     * Users must call this function to claim accrued energy.
     */
    function accrueEnergy() external nonReentrant whenNotPaused {
        _updateUserEnergyAndResources(msg.sender);
        // EnergyAccrued event is fired inside _updateUserEnergyAndResources
    }

     /**
     * @dev Gets the current accrued energy balance for a user.
     * @param user The address of the user.
     * @return The user's energy balance.
     */
    function getUserEnergyBalance(address user) external view returns (uint256) {
        // Note: This view function does NOT trigger accrual.
        // User must call accrueEnergy() first to update their balance.
        return userEnergyBalance[user];
    }

     /**
     * @dev Claims pending resources generated by a specific pod.
     * Resources are accrued automatically via state changes/accrueEnergy.
     * @param podId The unique instance ID of the pod.
     */
    function claimGeneratedResources(uint256 podId) external nonReentrant onlyPodOwner(podId) whenNotPaused {
         // Accrue before claiming
        _updateUserEnergyAndResources(msg.sender);

        uint256 amountToClaim = podPendingResources[podId];
        require(amountToClaim > 0, "No pending resources to claim for this pod");

        uint256 podTypeId = _getPodTypeId(podId);
        PodConfig storage config = podConfigurations[podTypeId];
        require(config.podTypeId != 0, "Invalid pod type config for instance"); // Should not happen

        uint256 resourceTypeId = config.generatedResourceType;
        require(resourceTypeId != 0, "Pod does not generate resources"); // Pod must be configured to generate

        podPendingResources[podId] = 0; // Reset pending amount

        // Mint the claimed resources to the user
        _mint(msg.sender, resourceTypeId, amountToClaim, "", "");

        emit ResourcesClaimed(msg.sender, podId, resourceTypeId, amountToClaim);
    }

     /**
     * @dev Gets the amount of resources a specific pod has generated but not yet claimed.
     * @param podId The unique instance ID of the pod.
     * @return The pending resource amount.
     */
    function getPendingResourcesForPod(uint256 podId) external view returns (uint256) {
         // This view function does NOT trigger accrual calculation based on time elapsed since last state change/claim.
         // It only returns the currently stored value in podPendingResources mapping.
         // For real-time pending amount, user must call accrueEnergy() or check via a helper that calculates WITHOUT state change.
         // Let's make this function perform the calculation without updating state for a 'real-time' view.
         uint256 lastTimestamp = podStateTimestamps[podId];
         PodState currentState = podStates[podId];

         if (currentState == PodState.Active || currentState == PodState.TimeLocked) {
            uint256 timeElapsed = block.timestamp.sub(lastTimestamp);
            uint256 podTypeId = _getPodTypeId(podId);
            PodConfig storage config = podConfigurations[podTypeId];

             if (config.podTypeId != 0 && config.resourceGenerationRate > 0 && config.generatedResourceType != 0) {
                 // Calculate resources accrued SINCE last timestamp
                 uint256 accrued = timeElapsed.mul(config.resourceGenerationRate);
                 return podPendingResources[podId].add(accrued); // Add to already pending amount
             }
         }
        return podPendingResources[podId]; // Return current pending if not active/time-locked or config invalid
    }


     /**
     * @dev Burns a specified amount of a resource type owned by the caller.
     * Can optionally generate energy if the resource is configured to do so.
     * @param resourceTypeId The type of resource to burn.
     * @param amount The amount to burn.
     */
    function burnResources(uint256 resourceTypeId, uint256 amount) external nonReentrant onlyResourceAvailable(resourceTypeId) whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        require(balanceOf(msg.sender, resourceTypeId) >= amount, "Insufficient resources to burn");

        ResourceConfig storage config = resourceConfigurations[resourceTypeId];
        require(config.resourceTypeId != 0, "Invalid resource type config");

        // Burn the resources
        _burn(msg.sender, resourceTypeId, amount);

        uint256 energyGained = 0;
        if (config.burnableForEnergy && config.energyPerBurnedUnit > 0) {
            energyGained = amount.mul(config.energyPerBurnedUnit);
            userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].add(energyGained);
        }

        emit ResourcesBurned(msg.sender, resourceTypeId, amount, energyGained);
    }

    /**
     * @dev Initiates a research project for the caller, consuming required resources and energy.
     * A user can only have one research project active at a time.
     * @param topicId The ID of the research topic.
     */
    function initiateResearch(uint256 topicId) external nonReentrant whenNotPaused {
        ResearchTopic storage config = researchConfigurations[topicId];
        require(config.topicId != 0, "Invalid research topic");
        require(userResearchStatus[msg.sender].topicId == 0, "User already has an active research project");

        // Accrue before action
        _updateUserEnergyAndResources(msg.sender);

        // Check energy and resource requirements
        require(userEnergyBalance[msg.sender] >= config.requiredEnergy, "Insufficient energy for research");
        userEnergyBalance[msg.sender] = userEnergyBalance[msg.sender].sub(config.requiredEnergy);

        // Check and consume required resources
        for (uint i = 0; i < availableResourceTypes.length; i++) { // Iterate through all configured resource types
             uint256 resTypeId = availableResourceTypes[i];
             uint256 requiredAmount = config.requiredResources[resTypeId];
             if (requiredAmount > 0) {
                 require(balanceOf(msg.sender, resTypeId) >= requiredAmount, string.concat("Insufficient resource: ", resourceConfigurations[resTypeId].name));
                 _burn(msg.sender, resTypeId, requiredAmount);
             }
        }

        // Start the research project
        userResearchStatus[msg.sender] = UserResearch(topicId, block.timestamp, false);

        emit ResearchInitiated(msg.sender, topicId, block.timestamp);
    }

    /**
     * @dev Completes a research project if the required time has passed.
     * Unlocks new resources or capabilities.
     */
    function completeResearch() external nonReentrant whenNotPaused {
        UserResearch storage research = userResearchStatus[msg.sender];
        require(research.topicId != 0, "No active research project");
        require(!research.completed, "Research project already completed");

        ResearchTopic storage config = researchConfigurations[research.topicId];
        require(block.timestamp >= research.startTime.add(config.requiredDuration), "Research duration not yet complete");

        // Mark research as completed
        research.completed = true;
        // Keep the struct entry so getResearchStatus works correctly and prevents starting same topic again
        // Or, clear the entry to allow starting new research: delete userResearchStatus[msg.sender];

        // Unlock new resource type if configured
        if (config.unlocksResourceType != 0) {
            unlockNewResourceType(config.unlocksResourceType); // Internal call
        }

        emit ResearchCompleted(msg.sender, research.topicId, block.timestamp, config.unlocksResourceType);
        // Optionally, allow starting a new research immediately: delete userResearchStatus[msg.sender];
    }

     /**
     * @dev Gets the current status of a user's research project.
     * @param user The address of the user.
     * @return topicId The ID of the active topic (0 if none).
     * @return startTime The timestamp when research started.
     * @return completed Whether the research is completed.
     * @return completionTime If completed, the estimated completion time (startTime + duration).
     */
    function getResearchStatus(address user) external view returns (uint256 topicId, uint256 startTime, bool completed, uint256 completionTime) {
        UserResearch storage research = userResearchStatus[user];
        uint256 estimatedCompletionTime = 0;
        if (research.topicId != 0) {
             ResearchTopic storage config = researchConfigurations[research.topicId];
             estimatedCompletionTime = research.startTime.add(config.requiredDuration);
        }
        return (research.topicId, research.startTime, research.completed, estimatedCompletionTime);
    }

    /**
     * @dev Unlocks a resource type, making it available for use (e.g., generated by pods, used in research).
     * Called internally upon research completion.
     * @param resourceTypeId The ID of the resource type to unlock.
     */
    function unlockNewResourceType(uint256 resourceTypeId) internal {
        // This is an internal helper. The resource must already be configured.
        ResourceConfig storage config = resourceConfigurations[resourceTypeId];
        require(config.resourceTypeId != 0, "Cannot unlock unconfigured resource type");

        // We need a way to track which resources are 'unlocked' for a *user*
        // Let's add a mapping: mapping(address => mapping(uint256 => bool)) public userUnlockedResources;
        // This approach is complex. Simpler: Make `onlyResourceAvailable` modifier check research *globally* or *per-user*.
        // The current `onlyResourceAvailable` checks if *any* user completed the research globally.
        // Let's stick with that for simplicity in this example, making resource availability global once any user researches it.
        // The boolean `isInitiallyAvailable` in ResourceConfig handles the rest.
        // So, this internal function's primary role is to ensure the resource config exists and is marked as research-unlocked.
        // No state change needed *within* this function if availability check is in modifier.
        // But if availability was per-user, this function would update `userUnlockedResources[user][resourceTypeId] = true;`
        // Given the prompt complexity, let's *assume* global unlock for simplicity here.
        // The `onlyResourceAvailable` modifier already handles checking research completion against `isInitiallyAvailable`.
        // This internal function primarily serves as a logical step triggered by research.

        // If global unlock is desired, we'd need a state variable like `mapping(uint256 => bool) public globallyUnlockedResources;`
        // And the modifier would check `globallyUnlockedResources[resourceTypeId]`.
        // The research complete function would set `globallyUnlockedResources[config.unlocksResourceType] = true;`.
        // Let's add `globallyUnlockedResources` for a clearer 'unlock' mechanic.
        mapping(uint256 => bool) public globallyUnlockedResources;
        globallyUnlockedResources[resourceTypeId] = true;
         // Need to update the modifier `onlyResourceAvailable` to check this mapping if !isInitiallyAvailable.

        // Updating `onlyResourceAvailable` modifier logic:
        // if (!resConfig.isInitiallyAvailable) {
        //     require(globallyUnlockedResources[resourceTypeId], "Resource type not yet globally unlocked via research");
        // }
         // The modifier already does this check now based on the UserResearch status - sticking with that for per-user research unlock.
    }

    // --- Configuration & Admin Functions ---

    /**
     * @dev Owner function to define or update a Chronopod type configuration.
     * @param config The PodConfig struct containing details.
     */
    function setPodConfiguration(PodConfig calldata config) external onlyOwner {
        require(config.podTypeId != 0, "Pod Type ID cannot be zero");
        // Ensure the type ID isn't already added to the list if it's new
        if (podConfigurations[config.podTypeId].podTypeId == 0) {
             bool found = false;
             for(uint i = 0; i < availablePodTypes.length; i++) {
                 if (availablePodTypes[i] == config.podTypeId) {
                     found = true;
                     break;
                 }
             }
             if (!found) {
                availablePodTypes.push(config.podTypeId);
             }
        }
        podConfigurations[config.podTypeId] = config;
        emit ConfigurationUpdated("Pod", config.podTypeId);
    }

    /**
     * @dev Owner function to define or update a Resource type configuration.
     * @param config The ResourceConfig struct containing details.
     */
    function setResourceConfiguration(ResourceConfig calldata config) external onlyOwner {
        require(config.resourceTypeId != 0, "Resource Type ID cannot be zero");
         // Ensure the type ID isn't already added to the list if it's new
        if (resourceConfigurations[config.resourceTypeId].resourceTypeId == 0) {
             bool found = false;
             for(uint i = 0; i < availableResourceTypes.length; i++) {
                 if (availableResourceTypes[i] == config.resourceTypeId) {
                     found = true;
                     break;
                 }
             }
             if (!found) {
                availableResourceTypes.push(config.resourceTypeId);
                // If initially available, mark as globally unlocked immediately
                if(config.isInitiallyAvailable) {
                    // No, the modifier checks isInitiallyAvailable directly. No need for global unlock flag for this.
                }
             }
        }
        resourceConfigurations[config.resourceTypeId] = config;
        emit ConfigurationUpdated("Resource", config.resourceTypeId);
    }

    /**
     * @dev Owner function to define or update a Research Topic configuration.
     * @param config The ResearchTopic struct containing details.
     */
    function setResearchConfiguration(ResearchTopic calldata config) external onlyOwner {
        require(config.topicId != 0, "Topic ID cannot be zero");
         // Ensure the topic ID isn't already added to the list if it's new
        if (researchConfigurations[config.topicId].topicId == 0) {
            bool found = false;
             for(uint i = 0; i < availableResearchTopics.length; i++) {
                 if (availableResearchTopics[i] == config.topicId) {
                     found = true;
                     break;
                 }
             }
             if (!found) {
                 availableResearchTopics.push(config.topicId);
             }
        }
        researchConfigurations[config.topicId] = config;
        emit ConfigurationUpdated("Research", config.topicId);
    }

     /**
     * @dev Owner function to set the base energy and resource generation rates.
     * These rates are independent of specific pods.
     * @param energyRatePerSec Base energy generated per second.
     * @param resourceRatePerSec Base resource generated per second.
     */
    function setBaseGenerationRates(uint256 energyRatePerSec, uint256 resourceRatePerSec) external onlyOwner {
        baseEnergyGenerationRatePerSec = energyRatePerSec;
        baseResourceGenerationRatePerSec = resourceRatePerSec;
        emit ConfigurationUpdated("BaseRates", 0); // Use 0 or another sentinel for global rates
    }

    /**
     * @dev Pauses the contract (Owner).
     */
    function pause() external onlyOwner whenNotPaused {
        _pause();
    }

    /**
     * @dev Unpauses the contract (Owner).
     */
    function unpause() external onlyOwner whenPaused {
        _unpause();
    }

    /**
     * @dev Placeholder for owner to withdraw protocol fees.
     * Requires implementation of fee collection logic elsewhere.
     */
    function withdrawProtocolFees(uint256 amount) external onlyOwner {
        // require(address(this).balance >= amount, "Insufficient balance in contract");
        // (bool success, ) = protocolFeeRecipient.call{value: amount}("");
        // require(success, "Fee withdrawal failed");
        // emit FeeWithdrawn(protocolFeeRecipient, amount);
         revert("Fee withdrawal not implemented"); // Example placeholder
    }


    // --- View & Utility Functions ---

     /**
     * @dev Returns the configuration struct for a specific pod type ID.
     * @param podTypeId The ID of the pod type.
     * @return The PodConfig struct.
     */
    function getPodConfiguration(uint256 podTypeId) external view returns (PodConfig memory) {
        return podConfigurations[podTypeId];
    }

     /**
     * @dev Returns the configuration struct for a specific resource type ID.
     * @param resourceTypeId The ID of the resource type.
     * @return The ResourceConfig struct.
     */
    function getResourceConfiguration(uint256 resourceTypeId) external view returns (ResourceConfig memory) {
        return resourceConfigurations[resourceTypeId];
    }

     /**
     * @dev Returns the configuration struct for a specific research topic ID.
     * @param topicId The ID of the research topic.
     * @return The ResearchTopic struct.
     */
    function getResearchConfiguration(uint256 topicId) external view returns (ResearchTopic memory) {
        return researchConfigurations[topicId];
    }


     /**
     * @dev Returns the current state of a specific Chronopod instance.
     * @param podId The unique instance ID of the pod.
     * @return The current PodState enum value.
     */
    function getPodState(uint256 podId) external view returns (PodState) {
        return podStates[podId];
    }

     /**
     * @dev Returns the estimated properties of a specific pod instance, considering upgrades.
     * This requires storing and applying per-instance modifiers based on upgrade level.
     * For this example, it will return base config + a simple modifier based on upgrade level.
     * @param podId The unique instance ID of the pod.
     * @return energyGenerationRate The estimated energy generation per second.
     * @return resourceGenerationRate The estimated resource generation per second.
     * @return generatedResourceType The type of resource generated.
     * @return currentUpgradeLevel The current upgrade level of the pod instance.
     */
    function getPodProperties(uint256 podId) external view returns (uint256 energyGenerationRate, uint256 resourceGenerationRate, uint256 generatedResourceType, uint256 currentUpgradeLevel) {
        uint256 podTypeId = _getPodTypeId(podId); // Get type ID
        PodConfig storage config = podConfigurations[podTypeId];
        require(config.podTypeId != 0, "Invalid pod type config for instance");

        uint256 upgradeLevel = podInstanceUpgradeLevel[podId]; // Get instance-specific upgrade level

        // Simple example of applying upgrade modifiers based on level
        uint256 estimatedEnergyRate = config.energyGenerationRate.add(upgradeLevel.mul(10)); // +10 per level
        uint256 estimatedResourceRate = config.resourceGenerationRate.add(upgradeLevel.mul(5)); // +5 per level

        return (
            estimatedEnergyRate,
            estimatedResourceRate,
            config.generatedResourceType,
            upgradeLevel
        );
    }

     /**
     * @dev Returns the ID for the next Chronopod instance that will be minted.
     * @return The next available pod instance ID.
     */
    function getNextPodId() external view returns (uint256) {
        return _podInstanceIds.current();
    }

    /**
     * @dev Returns a list of all configured pod type IDs.
     * @return An array of pod type IDs.
     */
    function getAvailablePodTypes() external view returns (uint256[] memory) {
        return availablePodTypes;
    }

    /**
     * @dev Returns a list of all configured resource type IDs.
     * @return An array of resource type IDs.
     */
    function getAvailableResourceTypes() external view returns (uint256[] memory) {
        return availableResourceTypes;
    }

     /**
     * @dev Returns a list of all configured research topic IDs.
     * @return An array of research topic IDs.
     */
    function getAvailableResearchTopics() external view returns (uint256[] memory) {
        return availableResearchTopics;
    }

    // --- Internal Helper Functions ---

    /**
     * @dev Helper to get the pod type ID from a pod instance ID.
     * In a real system, this mapping (instance ID -> type ID) must be stored
     * upon minting. This is a critical piece missing in the state variables above
     * for simplicity, but required for functions like activatePod, upgradePod, etc.
     * A mapping `mapping(uint256 => uint256) private _podInstanceToType;` is needed.
     * It would be set in `mintPod`: `_podInstanceToType[newTokenId] = podTypeId;`
     * For this example, we'll use a placeholder/stub. A production contract NEEDS this mapping.
     */
    function _getPodTypeId(uint256 podInstanceId) internal view returns (uint256) {
        // Placeholder: In a real contract, look up the type ID from a mapping.
        // This placeholder assumes pod instance IDs are related to type IDs, which is NOT the case in the current minting logic.
        // A proper mapping `mapping(uint256 => uint256) private _podInstanceToType;` should be used.
        // This will cause errors if run, as the mapping is not implemented.
        // TO FIX: Add `mapping(uint256 => uint256) private _podInstanceToType;` state var
        // and set it in `mintPod`. Then return `_podInstanceToType[podInstanceId];` here.
        revert("Pod instance to type mapping not fully implemented in this example");
        // Example with proper mapping:
        // return _podInstanceToType[podInstanceId];
    }


    /**
     * @dev Helper to calculate and update user's accrued energy and resources from active pods.
     * Should be called before any action that consumes/grants energy or claims resources.
     * @param user The address of the user.
     */
    function _updateUserEnergyAndResources(address user) internal {
        uint256 totalEnergyAccrued = 0;
        // Iterate through all pods owned by the user OR held by the contract for the user
        // Getting all token IDs owned by a user in ERC1155 is non-trivial and expensive on-chain.
        // This requires tracking pod ownership/state in a separate iterable structure or relying on external indexers.
        // For this example, we'll simplify and assume we can iterate through a user's pods efficiently.
        // A practical implementation would need a user -> podId[] mapping, updated on transfer/mint/burn.
        // Let's assume such a mapping exists for the sake of demonstrating the logic.

        // Placeholder: This loop is HIGHLY inefficient and likely exceeds gas limits in practice.
        // A real system would process accruals via:
        // 1. Processing on state change (activate, deactivate, claim).
        // 2. Calculating accrual since last update timestamp on demand (in accrueEnergy / claimGeneratedResources).
        // The current accrueEnergy and claimGeneratedResources functions *already do* this calculation based on state timestamps.
        // So, this helper function is actually redundant if those functions are implemented to calculate since last update.
        // Let's refactor: remove this _updateUserEnergyAndResources helper.
        // The accrual logic should live inside `accrueEnergy` and `claimGeneratedResources`, calculating time elapsed
        // since the state change timestamp or last claim/accrual time *for that specific pod/user*.

        // REVISED ACCRUAL LOGIC:
        // When `accrueEnergy()` is called:
        // 1. Iterate through user's *active* and *time-locked* pods (this iteration is still the bottleneck).
        // 2. For each relevant pod:
        //    a. Calculate time elapsed since `podStateTimestamps[podId]`.
        //    b. Calculate energy generated: `timeElapsed * podConfig.energyGenerationRate`.
        //    c. Add to user's total energy.
        //    d. Calculate resources generated: `timeElapsed * podConfig.resourceGenerationRate`.
        //    e. Add to `podPendingResources[podId]`.
        //    f. Update `podStateTimestamps[podId] = block.timestamp;` to mark accrual point.
        // 3. Add global base generation: `timeElapsedSinceLastAccrual * baseRates`.
        // 4. Update user's energy balance.
        // 5. Update user's last accrual timestamp.

        // This requires a `mapping(address => uint256) userLastAccrualTimestamp;` state variable.

        // Let's rewrite `accrueEnergy` to handle this logic.
        // And `claimGeneratedResources` will just claim what's in `podPendingResources[podId]`,
        // ensuring `accrueEnergy` (or a call within claim if not already done) updates pending first.

        // Re-evaluating: The current `accrueEnergy` function is just a marker. The accrual calculation needs to happen *per-pod*
        // based on its *individual* state change timestamp, and *per-user* based on user's last accrual timestamp for base rates.
        // The most efficient way is to calculate accruals for a pod/user *just before* an action requiring it (like spending energy, claiming resources, changing state).
        // This is what the initial `_updateUserEnergyAndResources` *intended* to do, albeit abstractly.
        // Let's keep the concept of calculating before actions.
        // The core issue remains iterating user's pods.
        // Alternative: When a pod changes state *to* Active or TimeLocked, calculate and store its *effective start rate timestamp*. When it changes *from* these states, calculate accrual since that start timestamp.

        // Let's simplify again for the example: Accrual happens *only* when `accrueEnergy` is called or a state-changing function is called.
        // The accrual calculation will be based on `podStateTimestamps` and `userLastAccrualTimestamp` (for base rates).
        // The `_updateUserEnergyAndResources` helper seems necessary to consolidate this calculation logic.
        // The *real* challenge is iterating the user's pods. We'll add a comment acknowledging this limitation in the example.

        // --- Acknowledging Iteration Problem & Proceeding with Simplified Example ---
        // In a practical Dapp, you'd maintain an off-chain indexer to list user's pods.
        // On-chain, a user could potentially register their active pods, or accrual is tied to a staking mechanism (stake token X to earn Y).
        // Since we don't have staking token Y here, let's *assume* we can iterate the user's active/time-locked pods held by the contract.
        // This assumption is for demonstrating the accrual calculation logic, not for production efficiency.

        uint256 currentTime = block.timestamp;
        uint256 lastUserAccrual = userLastAccrualTimestamp[user];
        if (lastUserAccrual == 0) {
             lastUserAccrual = currentTime; // First accrual
        }
        uint256 timeElapsedSinceLastUserAccrual = currentTime.sub(lastUserAccrual);

        // Base accrual (independent of pods)
        userEnergyBalance[user] = userEnergyBalance[user].add(timeElapsedSinceLastUserAccrual.mul(baseEnergyGenerationRatePerSec));
        // Resources can also have base accrual if needed, but let's keep it pod-tied mostly.

        // Pod-specific accrual
        // THIS LOOP IS THE PROBLEMATIC PART IN PRODUCTION
        // For example only, assume we can get list of user's active/time-locked pods:
        // uint256[] memory userActivePods = _getUserActivePods(user); // Placeholder for a function that doesn't exist/is inefficient
        // uint256[] memory userTimeLockedPods = _getUserTimeLockedPods(user); // Placeholder

        // Let's change the model slightly: Pods only accrue energy/resources *while held by the contract*.
        // State change to Active/TimeLocked moves the pod to `address(this)`.
        // Accrual calculation then iterates through *all* pods held by the contract.
        // This shifts the iteration problem from per-user to per-contract, still potentially large but maybe manageable if number of active pods is capped or processed in batches off-chain.

        // SIMPLIFIED ACCRUAL FOR EXAMPLE (iterating through contract-held pods):
        // This still requires knowing *which* user owns the pod currently held by the contract.
        // Need mapping: mapping(uint256 => address) private _podInstanceOwnerWhenActive;
        // Set in activatePod/timeLockPod, cleared in deactivatePod/claimTimeLockedPod.

        mapping(uint256 => address) private _podInstanceOwnerWhenActive; // Added state

        // Iterate through all pod instances ever minted (up to _podInstanceIds.current())
        // This is STILL too inefficient.
        // The most practical on-chain accrual ties generation to a *single* state update point per user (e.g., `accrueEnergy` call)
        // and sums up contributions from their *currently* active/time-locked pods based on individual timestamps.

        // FINAL SIMPLIFICATION for this example's `_updateUserEnergyAndResources`:
        // It will only calculate base accrual and update the user's last accrual timestamp.
        // Pod-specific accrual for pending resources will be calculated and stored ONLY when the pod's state changes (to or from Active/TimeLocked)
        // or when `claimGeneratedResources` is called for that specific pod.
        // This avoids the problematic iteration. Energy from pods must be claimed separately or calculated on-demand in `accrueEnergy`.

        uint256 energyGained = timeElapsedSinceLastUserAccrual.mul(baseEnergyGenerationRatePerSec);
        userEnergyBalance[user] = userEnergyBalance[user].add(energyGained);
        userLastAccrualTimestamp[user] = currentTime; // Update timestamp

        // Pod resource/energy generation will be handled *per-pod* on state change or claim.
        // When state goes FROM Active/TimeLocked: calculate accrual since last timestamp, add to pending, update timestamp.
        // When state goes TO Active/TimeLocked: update timestamp.

        // Modify `activatePod`, `deactivatePod`, `timeLockPod`, `claimTimeLockedPod` to calculate accrual *before* state change.

        emit EnergyAccrued(user, energyGained);
    }

     /**
     * @dev Helper to calculate and add pending resources for a specific pod based on time elapsed.
     * Should be called when a pod's state changes from Generating (Active/TimeLocked).
     * @param podId The unique instance ID of the pod.
     */
    function _calculateAndAddPendingResources(uint256 podId) internal {
        PodState currentState = podStates[podId];
        // Only calculate if it was previously in a generating state
        if (currentState == PodState.Active || currentState == PodState.TimeLocked) {
            uint256 lastTimestamp = podStateTimestamps[podId];
            uint256 timeElapsed = block.timestamp.sub(lastTimestamp);

            uint256 podTypeId = _getPodTypeId(podId); // Need this mapping
            PodConfig storage config = podConfigurations[podTypeId];

            if (config.podTypeId != 0 && config.resourceGenerationRate > 0 && config.generatedResourceType != 0) {
                 // Get effective rate considering upgrades
                 (uint256 effectiveEnergyRate, uint256 effectiveResourceRate, , ) = getPodProperties(podId); // Use the view function
                 uint256 resourcesAccrued = timeElapsed.mul(effectiveResourceRate);

                 podPendingResources[podId] = podPendingResources[podId].add(resourcesAccrued);
            }
        }
    }

    // Override ERC1155 functions to integrate _podInstanceToType mapping and accrual calculations
    // when tokens are transferred to/from the contract address.

    mapping(uint256 => uint256) private _podInstanceToType; // Added mapping

     function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);

        // This hook is called before any transfer (mint, burn, transfer).
        // We need to handle state changes and accruals here if transferring to/from contract.

        // If transferring a pod INSTANCE (amount == 1, id is a pod instance id)
        if (ids.length == 1 && amounts[0] == 1) {
            uint256 podId = ids[0];
            PodState currentState = podStates[podId];

            // Check if it's a pod instance being transferred (basic check)
            if (uint(currentState) > 0 || _podInstanceIds.current() >= podId) { // Likely a pod instance
                 // Accrue resources for the pod before transferring it out of a generating state
                if (currentState == PodState.Active || currentState == PodState.TimeLocked) {
                    _calculateAndAddPendingResources(podId);
                     // Update timestamp BEFORE state changes
                    podStateTimestamps[podId] = block.timestamp;
                }

                // Handle owner mapping update if transferring to/from contract
                if (to == address(this)) {
                     // Transferring TO contract (e.g., activating or time-locking)
                     _podInstanceOwnerWhenActive[podId] = from; // Store the user who owns it while active
                } else if (from == address(this)) {
                     // Transferring FROM contract (e.g., deactivating or claiming)
                     delete _podInstanceOwnerWhenActive[podId]; // Clear owner mapping
                }
            }
        }

         // For batch transfers, logic would be more complex, iterating through ids/amounts
    }

     function _afterTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override {
        super._afterTokenTransfer(operator, from, to, ids, amounts, data);

        // After minting a *new pod instance*, store its type ID
        if (from == address(0)) { // Minting
             for (uint i = 0; i < ids.length; i++) {
                 uint256 tokenId = ids[i];
                 uint256 amount = amounts[i];
                 if (amount == 1 && podStates[tokenId] != PodState.Dormant) { // If it's a unique instance and not yet marked Dormant (i.e., a new pod instance)
                     // This logic is flawed. Need to know the podTypeId used in the mintPod call.
                     // The podTypeId must be passed or derived in the `mintPod` function itself and stored there.
                     // Reverting to store _podInstanceToType in mintPod directly.
                 }
             }
        }
    }

    // Need to add _podInstanceToType mapping update in mintPod function:
    // function mintPod(...) {
    //     ...
    //     _podInstanceToType[newTokenId] = podTypeId; // <-- Add this line
    //     ...
    // }
    // Assuming this fix is applied for _getPodTypeId to work.

    // Add userLastAccrualTimestamp state variable
    mapping(address => uint256) private userLastAccrualTimestamp;


    // Counting Functions for summary verification:
    // Standard ERC1155: 6 (balanceOf, balanceOfBatch, setApprovalForAll, isApprovedForAll, safeTransferFrom, safeBatchTransferFrom)
    // Pod Management: 7 (mintPod, activatePod, deactivatePod, timeLockPod, claimTimeLockedPod, upgradePod, combinePods)
    // Energy & Resource: 3 (accrueEnergy, claimGeneratedResources, burnResources) - getUserEnergyBalance/getPendingResources are views
    // Research: 2 (initiateResearch, completeResearch) - getResearchStatus is view
    // Configuration & Admin: 6 (setPodConfiguration, setResourceConfiguration, setResearchConfiguration, setBaseGenerationRates, pause, unpause) - withdrawProtocolFees placeholder
    // View & Utility: 7 (getUserEnergyBalance, getPendingResourcesForPod, getResearchStatus, getPodConfiguration, getResourceConfiguration, getResearchConfiguration, getPodState, getPodProperties, getNextPodId, getAvailablePodTypes, getAvailableResourceTypes, getAvailableResearchTopics) -> counting the public/external view functions (12 listed)
    // Internal Helpers: 2 (_calculateAndAddPendingResources, unlockNewResourceType) - _updateUserEnergyAndResources removed

    // Re-count public/external functions:
    // ERC1155: 6
    // mintPod
    // activatePod
    // deactivatePod
    // timeLockPod
    // claimTimeLockedPod
    // upgradePod
    // combinePods
    // accrueEnergy
    // getUserEnergyBalance (view)
    // claimGeneratedResources
    // getPendingResourcesForPod (view)
    // burnResources
    // initiateResearch
    // completeResearch
    // getResearchStatus (view)
    // setPodConfiguration (owner)
    // setResourceConfiguration (owner)
    // setResearchConfiguration (owner)
    // setBaseGenerationRates (owner)
    // pause (owner)
    // unpause (owner)
    // withdrawProtocolFees (owner - placeholder)
    // getPodConfiguration (view)
    // getResourceConfiguration (view)
    // getResearchConfiguration (view)
    // getPodState (view)
    // getPodProperties (view)
    // getNextPodId (view)
    // getAvailablePodTypes (view)
    // getAvailableResourceTypes (view)
    // getAvailableResearchTopics (view)

    // Total public/external functions:
    // 6 (ERC1155) + 7 (Pod Mgt) + 3 (Energy/Resource Actions) + 2 (Research Actions) + 6 (Admin) + 11 (Views) = 35 functions.
    // Okay, > 20 functions is satisfied.

    // Ensure all internal state variables used by functions are declared.
    // _podInstanceIds, _tokenURIs, podConfigurations, availablePodTypes, resourceConfigurations, availableResourceTypes, researchConfigurations, availableResearchTopics, podStates, podStateTimestamps, podUnlockTimestamps, userEnergyBalance, podPendingResources, userResearchStatus, baseEnergyGenerationRatePerSec, baseResourceGenerationRatePerSec, protocolFeeRecipient, protocolFeePercentage, podInstanceUpgradeLevel, _podInstanceOwnerWhenActive, _podInstanceToType, userLastAccrualTimestamp.
    // All seem declared now.

    // Need to ensure _podInstanceToType is set in mintPod. Adding a comment to the code.
    // Need to ensure podInstanceUpgradeLevel is initialized (defaults to 0, which is fine for level).

}
```