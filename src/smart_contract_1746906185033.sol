Okay, here is a Solidity smart contract concept incorporating advanced concepts like dynamic fees, a multi-layered yield/reward system (based on staking duration, special tokens, and collective participation aura), permissioned access control, and triggered token mechanics.

It avoids replicating standard OpenZeppelin contracts like `ERC20`, `Ownable`, `Pausable`, or standard staking/farming contract templates. Instead, it implements basic access control and pausable logic internally and uses an ERC20 *interface* to interact with tokens. The core logic around yield calculation (points based on active staking time + boosts) and a separate triggered CFT (Catalyst Token) earning mechanism are designed specifically for this contract.

**Concept: OmniFundNexus**

A decentralized protocol where users can stake various supported tokens to earn yield and special "Catalyst" tokens. The yield calculation is dynamic, influenced by a base rate, the user's holdings of Catalyst tokens, and a collective "Harvest Aura" generated by all active stakers. Catalyst tokens grant yield boosts and are earned separately based on accumulated active staking time, triggered by a specific action. Protocol fees are collected dynamically and distributed as a reward token via operator action, proportional to accrued yield points.

**Outline:**

1.  **Interfaces:** IERC20 for token interactions.
2.  **Errors:** Custom errors for clearer reverts.
3.  **Events:** Signals key actions (Deposits, Withdrawals, Rewards Claimed, Fees Updated, etc.).
4.  **State Variables:** Store contract configuration, user balances, points, fees, and state.
5.  **Access Control:** Manual `owner` and `operators` roles.
6.  **Pausability:** Manual `paused` state.
7.  **Modifiers:** `onlyOwner`, `onlyOperator`, `whenNotPaused`, `whenPaused`, `isSupportedToken`.
8.  **Constructor:** Initializes owner and initial operators.
9.  **Core Staking/Pooling Functions:** Deposit, Withdraw (ETH and ERC20).
10. **Yield/Reward Functions:** Claim accrued reward tokens based on points.
11. **Catalyst Token (CFT) Mechanism:** Function to trigger earning CFTs based on staking time, mint/burn CFTs.
12. **Dynamic Fee Management:** Functions for operators to set deposit/withdrawal fees per token.
13. **Rate Management:** Functions for operators to set global reward rates, boost factors, and CFT mint rates.
14. **Supported Token Management:** Functions for operators to add/remove supported tokens.
15. **Protocol Fee Management:** Functions for operators to collect and distribute fees (as reward tokens).
16. **Access Control Management:** Functions for owner to manage operators.
17. **Pausability Functions:** Functions for owner/operators to pause/unpause.
18. **Emergency Rescue:** Functions for owner/operators to rescue stuck tokens.
19. **View Functions:** Read contract state, user balances, pending rewards, configuration.

**Function Summary:**

*   **Core Staking:**
    *   `deposit(address token, uint256 amount)`: Deposit ERC20 tokens into the fund.
    *   `stakeETH()`: Deposit ETH into the fund (payable function).
    *   `withdraw(address token, uint256 amount)`: Withdraw ERC20 tokens, applying fees.
    *   `withdrawETH(uint256 amount)`: Withdraw ETH, applying fees.
*   **Yield & Rewards:**
    *   `claimRewards()`: Claim accrued `rewardToken` based on YieldSharePoints.
    *   `getPendingYieldSharePoints(address user)`: Calculate points earned since last update.
    *   `getUserTotalYieldSharePoints(address user)`: Get total points accumulated by user.
    *   `getTotalYieldSharePoints()`: Get total points across all users.
    *   `getEstimatedClaimableRewardTokens(address user)`: Estimate claimable rewards.
*   **Catalyst Token (CFT):**
    *   `triggerTimedCFTGrant(address user)`: Trigger calculation and minting of CFTs based on user's accumulated active staking time.
    *   `getCatalystTokens(address user)`: Get user's CFT balance.
*   **Information (View):**
    *   `getStakedAmount(address user, address token)`: User's staked balance for a token.
    *   `getTotalStaked(address token)`: Total staked amount for a token.
    *   `getSupportedTokens()`: Get the list of supported token addresses.
    *   `getDynamicDepositFee(address token)`: Get current deposit fee rate.
    *   `getDynamicWithdrawalFee(address token)`: Get current withdrawal fee rate.
    *   `getTotalActiveStakersCount()`: Get the count of currently active stakers.
    *   `getGlobalRewardRatePerSecondScaled()`: Get the base yield point rate.
    *   `getCftBoostBPS_Per_CFT()`: Get the yield boost factor per CFT.
    *   `getHarvestAuraBPS_Per_Staker()`: Get the yield boost factor per active staker.
    *   `getCftMintRatePerSecondScaled()`: Get the CFT minting rate per second of active staking.
    *   `getRewardToken()`: Get the reward token address.
    *   `getTotalRewardTokenDistributedEver()`: Get total reward tokens operator has distributed.
    *   `getUserRewardTokenClaimedEver(address user)`: Get total reward tokens user has claimed.
*   **Admin/Operator (Permissioned):**
    *   `addSupportedToken(address token)`: Add a token to the supported list.
    *   `removeSupportedToken(address token)`: Remove a token from the supported list.
    *   `setDynamicDepositFee(address token, uint256 feeBPS)`: Set deposit fee (in Basis Points).
    *   `setDynamicWithdrawalFee(address token, uint256 feeBPS)`: Set withdrawal fee (in Basis Points).
    *   `setGlobalRewardRatePerSecondScaled(uint256 rate)`: Set the base yield point rate (scaled).
    *   `setCftBoostBPS_Per_CFT(uint256 factorBPS)`: Set the CFT yield boost factor.
    *   `setHarvestAuraBPS_Per_Staker(uint256 factorBPS)`: Set the Aura yield boost factor.
    *   `setCftMintRatePerSecondScaled(uint256 rate)`: Set the CFT minting rate (scaled).
    *   `mintCatalystTokens(address user, uint256 amount)`: Manually grant CFTs.
    *   `burnCatalystTokens(address user, uint256 amount)`: Manually remove CFTs.
    *   `distributeRewardTokens(uint256 amount)`: Operator adds tokens to the reward pool available for claiming.
    *   `setRewardToken(address token)`: Set the address of the token used for rewards (can only be set once).
    *   `addOperator(address operator)`: Grant operator role (Owner only).
    *   `removeOperator(address operator)`: Revoke operator role (Owner only).
    *   `panicPause()`: Pause the contract (Owner/Operator).
    *   `unpause()`: Unpause the contract (Owner/Operator).
    *   `rescueERC20(address token, uint256 amount, address recipient)`: Rescue accidentally sent ERC20 tokens.
    *   `rescueETH(uint256 amount, address recipient)`: Rescue accidentally sent ETH.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// Interface for interacting with ERC20 tokens
interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    // Added allowance and decimals for convenience/completeness, though not strictly needed for core logic here
    function allowance(address owner, address spender) external view returns (uint256);
    function decimals() external view returns (uint8);
}

/**
 * @title OmniFundNexus
 * @dev A decentralized fund allowing staking of multiple tokens, featuring dynamic yield
 *      based on staking duration, Catalyst Tokens, and a collective Aura effect.
 *      Yield is claimable in a designated reward token, funded by operators.
 *      Includes dynamic fees and permissioned operator roles.
 *
 * Outline:
 * 1. Interfaces: IERC20
 * 2. Errors: Custom errors
 * 3. Events: Signals key actions and state changes
 * 4. State Variables: Contract configuration, user balances, points, fees, and state
 * 5. Access Control: Manual owner and operators roles
 * 6. Pausability: Manual paused state
 * 7. Modifiers: onlyOwner, onlyOperator, whenNotPaused, whenPaused, isSupportedToken
 * 8. Constructor: Initializes owner and initial operators
 * 9. Core Staking/Pooling Functions: Deposit, Withdraw (ETH and ERC20)
 * 10. Yield/Reward Functions: Claim accrued reward tokens based on points, point calculation views
 * 11. Catalyst Token (CFT) Mechanism: Trigger CFT earning based on staking time, mint/burn CFTs, view CFT balance
 * 12. Dynamic Fee Management: Functions for operators to set deposit/withdrawal fees per token
 * 13. Rate Management: Functions for operators to set global reward rates, boost factors, CFT mint rates
 * 14. Supported Token Management: Functions for operators to add/remove supported tokens
 * 15. Protocol Fee Management: Functions for operators to collect and distribute fees (as reward tokens)
 * 16. Access Control Management: Functions for owner to manage operators
 * 17. Pausability Functions: Functions for owner/operators to pause/unpause
 * 18. Emergency Rescue: Functions for owner/operators to rescue stuck tokens
 * 19. View Functions: Read contract state, user balances, pending rewards, configuration
 *
 * Function Summary:
 * - deposit(address token, uint256 amount): Deposit ERC20.
 * - stakeETH(): Deposit ETH (payable).
 * - withdraw(address token, uint256 amount): Withdraw ERC20 with fees.
 * - withdrawETH(uint256 amount): Withdraw ETH with fees.
 * - claimRewards(): Claim reward tokens based on yield points.
 * - getPendingYieldSharePoints(address user): Calculate points since last update.
 * - getUserTotalYieldSharePoints(address user): User's total points.
 * - getTotalYieldSharePoints(): Total points globally.
 * - getEstimatedClaimableRewardTokens(address user): Estimate claimable rewards.
 * - triggerTimedCFTGrant(address user): Trigger CFT earning based on active staking time.
 * - getCatalystTokens(address user): User's CFT balance.
 * - getStakedAmount(address user, address token): User's staked amount.
 * - getTotalStaked(address token): Total staked amount for a token.
 * - getSupportedTokens(): List of supported tokens.
 * - getDynamicDepositFee(address token): Get deposit fee.
 * - getDynamicWithdrawalFee(address token): Get withdrawal fee.
 * - getTotalActiveStakersCount(): Count of active stakers.
 * - getGlobalRewardRatePerSecondScaled(): Base yield point rate.
 * - getCftBoostBPS_Per_CFT(): CFT yield boost factor.
 * - getHarvestAuraBPS_Per_Staker(): Aura yield boost factor.
 * - getCftMintRatePerSecondScaled(): CFT minting rate.
 * - getRewardToken(): Reward token address.
 * - getTotalRewardTokenDistributedEver(): Total reward tokens distributed by operator.
 * - getUserRewardTokenClaimedEver(address user): Total reward tokens user claimed.
 * - addSupportedToken(address token): Operator adds supported token.
 * - removeSupportedToken(address token): Operator removes supported token.
 * - setDynamicDepositFee(address token, uint256 feeBPS): Operator sets deposit fee.
 * - setDynamicWithdrawalFee(address token, uint256 feeBPS): Operator sets withdrawal fee.
 * - setGlobalRewardRatePerSecondScaled(uint256 rate): Operator sets base yield rate.
 * - setCftBoostBPS_Per_CFT(uint256 factorBPS): Operator sets CFT boost.
 * - setHarvestAuraBPS_Per_Staker(uint256 factorBPS): Operator sets Aura boost.
 * - setCftMintRatePerSecondScaled(uint256 rate): Operator sets CFT mint rate.
 * - mintCatalystTokens(address user, uint256 amount): Operator grants CFTs.
 * - burnCatalystTokens(address user, uint256 amount): Operator removes CFTs.
 * - distributeRewardTokens(uint256 amount): Operator funds reward pool.
 * - setRewardToken(address token): Owner sets reward token (once).
 * - addOperator(address operator): Owner adds operator.
 * - removeOperator(address operator): Owner removes operator.
 * - panicPause(): Pause contract (Owner/Operator).
 * - unpause(): Unpause contract (Owner/Operator).
 * - rescueERC20(address token, uint256 amount, address recipient): Rescue ERC20s.
 * - rescueETH(uint256 amount, address recipient): Rescue ETH.
 */
contract OmniFundNexus {

    // --- Errors ---
    error Unauthorized(address account);
    error Paused();
    error NotPaused();
    error TokenNotSupported(address token);
    error ZeroAmount();
    error InsufficientFunds(uint256 requested, uint256 available);
    error ETHTransferFailed();
    error ERC20TransferFailed();
    error InvalidFeeRate();
    error RewardTokenAlreadySet();
    error RewardTokenNotSet();
    error InvalidRate();
    error NothingToClaim();
    error CannotRescuePooledTokens();

    // --- Events ---
    event Deposited(address indexed user, address indexed token, uint256 amount);
    event Withdrew(address indexed user, address indexed token, uint256 amount);
    event RewardsClaimed(address indexed user, address indexed rewardToken, uint256 amount, uint256 pointsBurned);
    event CatalystTokensGranted(address indexed user, uint256 amount);
    event CatalystTokensBurned(address indexed user, uint256 amount);
    event DynamicDepositFeeSet(address indexed token, uint256 feeBPS);
    event DynamicWithdrawalFeeSet(address indexed token, uint256 feeBPS);
    event GlobalRewardRateSet(uint256 rate);
    event CftBoostSet(uint256 factorBPS);
    event HarvestAuraSet(uint256 factorBPS);
    event CftMintRateSet(uint256 rate);
    event SupportedTokenAdded(address indexed token);
    event SupportedTokenRemoved(address indexed token);
    event OperatorAdded(address indexed operator);
    event OperatorRemoved(address indexed operator);
    event PausedContract(address indexed account);
    event UnpausedContract(address indexed account);
    event RescuedERC20(address indexed token, uint256 amount, address indexed recipient);
    event RescuedETH(uint256 amount, address indexed recipient);
    event RewardTokenSet(address indexed rewardToken);
    event RewardTokensDistributed(address indexed operator, uint256 amount);

    // --- State Variables ---

    // Access Control
    address public owner;
    mapping(address => bool) public operators;

    // Pausability
    bool public paused = false;

    // Supported Tokens
    mapping(address => bool) private _isSupportedToken;
    address[] private _supportedTokens;

    // Staking Balances
    mapping(address => mapping(address => uint256)) public userStakedBalances; // user => token => amount
    mapping(address => uint256) public userETHStaked; // user => amount

    // Total Staked Amounts
    mapping(address => uint256) public totalStakedAmounts; // token => amount
    uint256 public totalETHStaked; // total ETH amount

    // Active Stakers Tracking (for Harvest Aura)
    mapping(address => bool) public isActiveStaker;
    uint256 public totalActiveStakersCount = 0;

    // Yield & Rewards
    address public rewardTokenAddress;
    bool private rewardTokenSet = false;

    mapping(address => uint256) public userYieldSharePoints; // user => points accumulated
    uint256 public totalYieldSharePoints = 0; // Total points across all users

    // Last time user's points were updated
    mapping(address => uint256) private lastYieldUpdateTime;

    // Total reward tokens distributed by operator & claimed by users (for proportionality)
    uint256 public totalRewardTokenDistributedEver = 0;
    mapping(address => uint256) public userRewardTokenClaimedEver; // user => amount claimed

    // Yield Rate & Boost Factors (Operator controlled)
    // Scaled rate for points per second per unit of effective stake
    // Example: 1e18 points per second per unit stake -> scale factor 1e18
    uint256 public globalRatePerSecondScaled = 1e16; // Base points per second (scaled)

    // Boosts are in Basis Points (BPS = 1/10000)
    uint256 public cftBoostBPS_Per_CFT = 50; // 0.5% boost per CFT
    uint256 public harvestAuraBPS_Per_Staker = 1; // 0.01% boost per active staker

    // Catalyst Tokens (CFT) - Non-transferable in this design, represented by a balance
    mapping(address => uint256) public catalystTokens; // user => amount of CFTs
    mapping(address => uint256) private activeStakingTimeForCFTs; // user => accumulated seconds of active staking

    // CFT Mint Rate (Operator controlled)
    // Scaled rate for CFTs minted per second of active staking time
    uint256 public cftMintRatePerSecondScaled = 1e10; // 1e10 scaled CFTs per second

    // Dynamic Fees (Operator controlled)
    mapping(address => uint256) public dynamicDepositFeeBPS; // token => fee in Basis Points (0-10000)
    mapping(address => uint256) public dynamicWithdrawalFeeBPS; // token => fee in Basis Points (0-10000)

    // Special address for ETH
    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // --- Modifiers ---
    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized(msg.sender);
        _;
    }

    modifier onlyOperator() {
        if (msg.sender != owner && !operators[msg.sender]) revert Unauthorized(msg.sender);
        _;
    }

    modifier whenNotPaused() {
        if (paused) revert Paused();
        _;
    }

    modifier whenPaused() {
        if (!paused) revert NotPaused();
        _;
    }

    modifier isSupportedToken(address token) {
        if (!_isSupportedToken[token] && token != ETH_ADDRESS) revert TokenNotSupported(token);
        _;
    }

    // --- Constructor ---
    constructor(address[] memory initialOperators) payable {
        owner = msg.sender;
        for (uint i = 0; i < initialOperators.length; i++) {
            operators[initialOperators[i]] = true;
            emit OperatorAdded(initialOperators[i]);
        }
    }

    // Receive ETH function for direct ETH transfers
    receive() external payable whenNotPaused {
        // Direct transfers to the contract address deposit ETH
        // This is a simple form; a dedicated depositETH function is also provided for clarity
        if (msg.value == 0) revert ZeroAmount();
        _depositETH(msg.sender, msg.value);
    }

    fallback() external payable {
        revert(); // Reject arbitrary calls
    }

    // --- Internal Helpers ---

    /**
     * @dev Updates the user's yield share points and active staking time based on elapsed time.
     * This function should be called before any action that depends on or changes the user's state (deposit, withdraw, claim, trigger CFT).
     * Points are calculated based on active staking duration, user's CFT balance, and total active stakers.
     */
    function _updateYieldSharePoints(address user) internal {
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - lastYieldUpdateTime[user];

        if (timeElapsed == 0) {
            // No time has passed since last update
            return;
        }

        // Update last update time FIRST
        lastYieldUpdateTime[user] = currentTime;

        if (!isActiveStaker[user]) {
            // User is not actively staking, no points or CFT time accrued during this period
            return;
        }

        // Calculate point earning rate per second based on boosts
        // Point rate per second = baseRate + (CFTs * cftBoost) + (ActiveStakers * auraBoost)
        // Use large scale factor to maintain precision for rates
        uint256 baseRateScaled = globalRatePerSecondScaled;
        uint256 cftBoostRateScaled = catalystTokens[user] * cftBoostBPS_Per_CFT;
        uint256 auraBoostRateScaled = totalActiveStakersCount * harvestAuraBPS_Per_Staker;

        // Combine rates and apply scaling (BPS are /10000)
        // Example: base + cft + aura = X scaled points/sec/unit. Here, unit is just "being an active staker".
        // Total effective rate = baseRateScaled * (1 + cftBoostBPS/10000 + auraBoostBPS/10000)
        // This requires careful scaling. A simpler additive model:
        // Total points per second = baseRate + (cftRate * numCFTs) + (auraRate * numStakers)
        // Let's refine: baseRatePerSecondScaled is already scaled. Boosts add to this rate proportionally.
        // Example: baseRate = 1e16, cftBoost = 50 BPS (0.5%), auraBoost = 1 BPS (0.01%)
        // User with 10 CFTs, 100 active stakers total:
        // Effective rate per second = 1e16 + (10 * 50 * 1e16 / 10000) + (100 * 1 * 1e16 / 10000)
        // = 1e16 + (500 * 1e16 / 10000) + (100 * 1e16 / 10000)
        // = 1e16 + 0.05e16 + 0.01e16 = 1.06e16
        // This additive approach on the scaled rate seems simpler and more predictable.

        uint256 totalPointsRateScaled = baseRateScaled;
        totalPointsRateScaled += (catalystTokens[user] * cftBoostBPS_Per_CFT * baseRateScaled) / 10000; // Apply CFT boost as % of base
        totalPointsRateScaled += (totalActiveStakersCount * harvestAuraBPS_Per_Staker * baseRateScaled) / 10000; // Apply Aura boost as % of base

        // Points earned in this period (scaled)
        uint256 pointsEarnedScaled = totalPointsRateScaled * timeElapsed;

        // Convert scaled points to actual points (divide by the scaling factor used for globalRatePerSecondScaled)
        uint256 pointsEarned = pointsEarnedScaled / (globalRatePerSecondScaled > 0 ? (baseRateScaled / globalRatePerSecondScaled) : 1);
        // The above division is wrong if baseRateScaled is calculated with factors.
        // Let's use a consistent scaling factor. Assume globalRatePerSecondScaled is X * 1e18 actual points/sec.
        // Let's use 1e18 as the standard point scale.
        // globalRatePerSecondScaled = Points per second * 1e18
        // cftBoostBPS_Per_CFT = additional % boost per CFT
        // harvestAuraBPS_Per_Staker = additional % boost per staker

        // Revised Point Calculation:
        // baseRate = globalRatePerSecondScaled
        // totalBoostBPS = catalystTokens[user] * cftBoostBPS_Per_CFT + totalActiveStakersCount * harvestAuraBPS_Per_Staker
        // effectiveRateScaled = baseRate + (baseRate * totalBoostBPS / 10000)
        // pointsEarnedScaled = effectiveRateScaled * timeElapsed

        uint256 totalBoostBPS = catalystTokens[user] * cftBoostBPS_Per_CFT;
        totalBoostBPS += totalActiveStakersCount * harvestAuraBPS_Per_Staker;

        uint256 effectiveRateScaled = globalRatePerSecondScaled;
        if (totalBoostBPS > 0) {
             effectiveRateScaled += (globalRatePerSecondScaled * totalBoostBPS) / 10000;
        }

        uint256 pointsEarned = (effectiveRateScaled * timeElapsed) / 1e18; // Divide by scaling factor to get actual points

        if (pointsEarned > 0) {
            userYieldSharePoints[user] += pointsEarned;
            totalYieldSharePoints += pointsEarned;
        }

        // Also accumulate time for CFT earning
        activeStakingTimeForCFTs[user] += timeElapsed;
    }

    /**
     * @dev Handles the actual transfer of tokens for deposit, applying fees.
     */
    function _depositToken(address user, address token, uint256 amount) internal whenNotPaused isSupportedToken(token) {
        if (amount == 0) revert ZeroAmount();

        _updateYieldSharePoints(user); // Update points before changing state

        uint256 depositFeeBPS = dynamicDepositFeeBPS[token];
        uint256 feeAmount = (amount * depositFeeBPS) / 10000;
        uint256 netAmount = amount - feeAmount;

        // Check if user was already an active staker
        bool wasActive = isActiveStaker[user];

        if (token == ETH_ADDRESS) {
            // This path is not strictly needed if using `stakeETH` wrapper, but good practice
            // to handle ETH internally consistently if receive() also calls it.
            // Note: msg.value is handled by receive/stakeETH, not passed as `amount` here directly from msg.value
            // This internal function expects `amount` to be the value received/intended.
            userETHStaked[user] += netAmount;
            totalETHStaked += netAmount;
            // Fee ETH is kept in the contract balance
        } else {
            // ERC20
            if (!IERC20(token).transferFrom(user, address(this), amount)) revert ERC20TransferFailed();
            userStakedBalances[user][token] += netAmount;
            totalStakedAmounts[token] += netAmount;
            // Fee tokens are kept in the contract balance
        }

        // Update active staker count if necessary
        if (!wasActive) {
            isActiveStaker[user] = true;
            totalActiveStakersCount++;
            // Initialize lastYieldUpdateTime for the new active staker
            lastYieldUpdateTime[user] = block.timestamp;
        }

        emit Deposited(user, token, amount);
    }

    /**
     * @dev Handles the actual transfer of tokens for withdrawal, applying fees.
     */
    function _withdrawToken(address user, address token, uint256 amount) internal whenNotPaused isSupportedToken(token) {
        if (amount == 0) revert ZeroAmount();

        _updateYieldSharePoints(user); // Update points before changing state

        uint256 currentStaked = (token == ETH_ADDRESS) ? userETHStaked[user] : userStakedBalances[user][token];
        if (amount > currentStaked) revert InsufficientFunds(amount, currentStaked);

        uint256 withdrawalFeeBPS = dynamicWithdrawalFeeBPS[token];
        uint256 feeAmount = (amount * withdrawalFeeBPS) / 10000;
        uint256 netAmount = amount - feeAmount;

        if (token == ETH_ADDRESS) {
            userETHStaked[user] -= amount;
            totalETHStaked -= amount;
            // Fee ETH is kept in the contract balance
            (bool success,) = payable(user).call{value: netAmount}("");
            if (!success) revert ETHTransferFailed();
        } else {
            userStakedBalances[user][token] -= amount;
            totalStakedAmounts[token] -= amount;
            // Fee tokens are kept in the contract balance
            if (!IERC20(token).transfer(user, netAmount)) revert ERC20TransferFailed();
        }

        // Check if user is still an active staker after withdrawal
        bool stillActive = false;
        if (token == ETH_ADDRESS) {
            if (userETHStaked[user] > 0) stillActive = true;
        } else {
            if (userStakedBalances[user][token] > 0) stillActive = true;
        }
        // Check other tokens if staked (this requires iteration - avoid)
        // Simpler approach: user is active if ANY staked balance > 0
        // Let's add a mapping to track if user has ANY staked amount > 0 efficiently
        // mapping(address => bool) hasAnyStakedBalance; updated on deposit/withdrawal

        // Re-check if user has any staked amount left across ANY token
        bool hasAnyStakedBalanceAfter = (token == ETH_ADDRESS && userETHStaked[user] > 0);
        if (!hasAnyStakedBalanceAfter) {
             // Need to check other tokens... This is the tricky part without iterating.
             // For simplicity, let's assume withdrawing from one token might make them inactive *only* if
             // they had *only* that token staked and now their balance for it is zero.
             // A fully robust check would require tracking all tokens a user has ever staked or iterating.
             // Let's simplify: if userETHStaked or any userStakedBalances entry for *this specific withdrawal token* is zero,
             // and *before this withdrawal* they were active, we need to check if they still have *any* balance.
             // This check is still complex without iteration.
             // Let's use the `isActiveStaker` flag update only based on the *specific* token withdrawn.
             // This is a simplification. A user might withdraw TokenA to 0, but still have TokenB staked, and shouldn't lose isActiveStaker status.
             // A better approach: `isActiveStaker` is true if sum of all staked balances > 0. This requires iteration or tracking total value.
             // Let's revert to the simplest: `isActiveStaker` is true if `userETHStaked[user] > 0` OR `userStakedBalances[user][first_supported_token] > 0` OR ... (still requires knowing tokens).

             // Simplification: `isActiveStaker` is true if ETH balance > 0 OR the sum of ALL ERC20 balances is > 0.
             // Calculating sum of ERC20 balances requires iteration or careful state management on deposit/withdraw of each token.
             // Let's use a counter: `mapping(address => uint256) userTotalERC20StakedAmount` (sum of all ERC20s).
             // Update: Add to `userTotalERC20StakedAmount` on ERC20 deposit, subtract on ERC20 withdraw.
             // isActiveStaker = (userETHStaked[user] > 0 || userTotalERC20StakedAmount[user] > 0)

             // Add state variable:
             // mapping(address => uint256) public userTotalERC20StakedAmount; // sum of all ERC20 amounts per user

             // Update deposit:
             // If token != ETH_ADDRESS: userTotalERC20StakedAmount[user] += netAmount;
             // Update withdraw:
             // If token != ETH_ADDRESS: userTotalERC20StakedAmount[user] -= amount; // Subtract original amount before fee calculation for simplicity
             // Update isActiveStaker logic based on this.

             // Let's integrate userTotalERC20StakedAmount
             // This requires updating the deposit/withdraw logic slightly.
        }

        // Re-evaluate isActiveStaker state after withdrawal
        bool wasActiveBefore = isActiveStaker[user];
        bool isActiveAfter = (userETHStaked[user] > 0) || (userTotalERC20StakedAmount[user] > 0); // Needs userTotalERC20StakedAmount

        if (wasActiveBefore && !isActiveAfter) {
            isActiveStaker[user] = false;
            totalActiveStakersCount--;
            // Optional: could reset activeStakingTimeForCFTs[user] here, or let it persist until triggered
            // Let's let it persist, so triggering CFT grant consumes total time regardless of current active status
        }

        emit Withdrew(user, token, amount);
    }

    // --- Need to add userTotalERC20StakedAmount state var and update deposit/withdraw ---
    mapping(address => uint256) public userTotalERC20StakedAmount; // sum of all ERC20 amounts per user

    // --- Revised Deposit Logic ---
    function deposit(address token, uint256 amount) external payable whenNotPaused isSupportedToken(token) {
         if (amount == 0) revert ZeroAmount();
         if (token == ETH_ADDRESS) {
             if (msg.value != amount) revert InsufficientFunds(amount, msg.value);
             _depositETH(msg.sender, amount);
         } else {
             if (msg.value > 0) revert InvalidFeeRate(); // ETH sent with ERC20 deposit? Reject.
             _depositERC20(msg.sender, token, amount);
         }
    }

    function stakeETH() external payable whenNotPaused {
        if (msg.value == 0) revert ZeroAmount();
        _depositETH(msg.sender, msg.value);
    }

    function _depositETH(address user, uint256 amount) internal {
        _updateYieldSharePoints(user); // Update points first

        uint256 depositFeeBPS = dynamicDepositFeeBPS[ETH_ADDRESS];
        uint256 feeAmount = (amount * depositFeeBPS) / 10000;
        uint256 netAmount = amount - feeAmount;

        bool wasActive = isActiveStaker[user];
        userETHStaked[user] += netAmount;
        totalETHStaked += netAmount;

        if (!wasActive) {
            isActiveStaker[user] = true;
            totalActiveStakersCount++;
            lastYieldUpdateTime[user] = block.timestamp; // Start timing for points/CFTs
        }

        emit Deposited(user, ETH_ADDRESS, amount);
        // Fee ETH stays in contract balance
    }

    function _depositERC20(address user, address token, uint256 amount) internal {
         _updateYieldSharePoints(user); // Update points first

         uint256 depositFeeBPS = dynamicDepositFeeBPS[token];
         uint256 feeAmount = (amount * depositFeeBPS) / 10000;
         uint256 netAmount = amount - feeAmount;

         bool wasActive = isActiveStaker[user];
         userStakedBalances[user][token] += netAmount;
         userTotalERC20StakedAmount[user] += netAmount;
         totalStakedAmounts[token] += netAmount;

         // Using transferFrom requires the user to have called approve() beforehand
         if (!IERC20(token).transferFrom(user, address(this), amount)) revert ERC20TransferFailed();

         if (!wasActive) {
             isActiveStaker[user] = true;
             totalActiveStakersCount++;
             lastYieldUpdateTime[user] = block.timestamp; // Start timing for points/CFTs
         }

         emit Deposited(user, token, amount);
         // Fee tokens stay in contract balance
    }


    // --- Revised Withdraw Logic ---
    function withdraw(address token, uint256 amount) external whenNotPaused isSupportedToken(token) {
        if (amount == 0) revert ZeroAmount();
        if (token == ETH_ADDRESS) revert TokenNotSupported(token); // Use withdrawETH for ETH

        _withdrawERC20(msg.sender, token, amount);
    }

    function withdrawETH(uint256 amount) external whenNotPaused {
        if (amount == 0) revert ZeroAmount();
        _withdrawETH(msg.sender, amount);
    }

    function _withdrawETH(address user, uint256 amount) internal {
        _updateYieldSharePoints(user); // Update points first

        if (amount > userETHStaked[user]) revert InsufficientFunds(amount, userETHStaked[user]);

        uint256 withdrawalFeeBPS = dynamicWithdrawalFeeBPS[ETH_ADDRESS];
        uint256 feeAmount = (amount * withdrawalFeeBPS) / 10000;
        uint256 netAmount = amount - feeAmount;

        bool wasActive = isActiveStaker[user];

        userETHStaked[user] -= amount;
        totalETHStaked -= amount;

        // Check if user is still active after withdrawal
        bool isActiveAfter = (userETHStaked[user] > 0) || (userTotalERC20StakedAmount[user] > 0);

        if (wasActive && !isActiveAfter) {
             isActiveStaker[user] = false;
             totalActiveStakersCount--;
             // Note: activeStakingTimeForCFTs[user] is NOT reset here. It accumulates total active time.
        }

        (bool success,) = payable(user).call{value: netAmount}("");
        if (!success) revert ETHTransferFailed();

        emit Withdrew(user, ETH_ADDRESS, amount);
        // Fee ETH stays in contract balance
    }

    function _withdrawERC20(address user, address token, uint256 amount) internal {
        _updateYieldSharePoints(user); // Update points first

        if (amount > userStakedBalances[user][token]) revert InsufficientFunds(amount, userStakedBalances[user][token]);

        uint256 withdrawalFeeBPS = dynamicWithdrawalFeeBPS[token];
        uint256 feeAmount = (amount * withdrawalFeeBPS) / 10000;
        uint256 netAmount = amount - feeAmount;

        bool wasActive = isActiveStaker[user];

        userStakedBalances[user][token] -= amount;
        userTotalERC20StakedAmount[user] -= amount;
        totalStakedAmounts[token] -= amount;

        // Check if user is still active after withdrawal
        bool isActiveAfter = (userETHStaked[user] > 0) || (userTotalERC20StakedAmount[user] > 0);

        if (wasActive && !isActiveAfter) {
             isActiveStaker[user] = false;
             totalActiveStakersCount--;
             // Note: activeStakingTimeForCFTs[user] is NOT reset here. It accumulates total active time.
        }

        if (!IERC20(token).transfer(user, netAmount)) revert ERC20TransferFailed();

        emit Withdrew(user, token, amount);
        // Fee tokens stay in contract balance
    }

    // --- Yield & Rewards ---

    /**
     * @dev Claims available reward tokens based on the user's yield share points.
     * The user's points are updated before calculation.
     * The amount claimed is proportional to the user's points relative to total points,
     * applied to the total reward tokens ever distributed by the operator,
     * minus any tokens already claimed by the user.
     */
    function claimRewards() external whenNotPaused {
        if (!rewardTokenSet) revert RewardTokenNotSet();
        if (rewardTokenAddress == address(0)) revert RewardTokenNotSet(); // Sanity check

        address user = msg.sender;
        _updateYieldSharePoints(user); // Ensure points are up-to-date

        uint256 userPoints = userYieldSharePoints[user];
        uint256 totalPoints = totalYieldSharePoints;
        uint256 totalDistributed = totalRewardTokenDistributedEver;

        if (userPoints == 0 || totalPoints == 0 || totalDistributed == 0) revert NothingToClaim();

        // Calculate the user's total potential claim based on their lifetime points vs total lifetime points
        // This assumes a proportional distribution model over the total history
        uint256 totalPotentialClaim = (userPoints * totalDistributed) / totalPoints;

        // Amount to claim now is the potential total minus what they already claimed
        uint256 alreadyClaimed = userRewardTokenClaimedEver[user];
        uint256 claimAmount = totalPotentialClaim - alreadyClaimed;

        if (claimAmount == 0) revert NothingToClaim();

        // Perform the transfer of the reward token
        userRewardTokenClaimedEver[user] += claimAmount;

        // --- Important: Burn the claimed points or adjust totals? ---
        // The model "total potential claim based on ALL points EVER vs ALL distributed EVER"
        // means points are NOT burned on claim. They represent a cumulative share.
        // This is simpler than managing distribution periods and point snapshots/burning.
        // So, userYieldSharePoints and totalYieldSharePoints are NOT decreased.

        // Ensure contract has enough reward tokens
        if (IERC20(rewardTokenAddress).balanceOf(address(this)) < claimAmount) {
             // This indicates an issue if operator didn't distribute enough,
             // or if the total points grew faster than distributions.
             // A robust system might cap claims or require manual top-ups if balance is low.
             // For this example, we just revert if balance is insufficient.
             revert InsufficientFunds(claimAmount, IERC20(rewardTokenAddress).balanceOf(address(this)));
        }

        if (!IERC20(rewardTokenAddress).transfer(user, claimAmount)) revert ERC20TransferFailed();

        emit RewardsClaimed(user, rewardTokenAddress, claimAmount, 0); // 0 points burned in this model
    }

     /**
      * @dev Calculates the yield share points the user has earned since their last update.
      * Does NOT update state variables.
      */
    function getPendingYieldSharePoints(address user) public view returns (uint256) {
        uint256 currentTime = block.timestamp;
        uint256 timeElapsed = currentTime - lastYieldUpdateTime[user];

        if (timeElapsed == 0 || !isActiveStaker[user]) {
             return 0;
        }

        uint256 baseRateScaled = globalRatePerSecondScaled;

        uint256 totalBoostBPS = catalystTokens[user] * cftBoostBPS_Per_CFT;
        totalBoostBPS += totalActiveStakersCount * harvestAuraBPS_Per_Staker;

        uint256 effectiveRateScaled = globalRatePerSecondScaled;
        if (totalBoostBPS > 0) {
             effectiveRateScaled += (globalRatePerSecondScaled * totalBoostBPS) / 10000;
        }

        uint256 pointsEarned = (effectiveRateScaled * timeElapsed) / 1e18;

        return pointsEarned;
    }

    /**
     * @dev Gets the user's total accumulated yield share points.
     * Note: This value is only fully up-to-date after an action that calls _updateYieldSharePoints.
     */
    function getUserTotalYieldSharePoints(address user) public view returns (uint256) {
        return userYieldSharePoints[user];
    }

    /**
     * @dev Gets the total yield share points accumulated across all users.
     * Note: This value is only fully up-to-date after user actions that call _updateYieldSharePoints.
     */
    function getTotalYieldSharePoints() public view returns (uint256) {
        return totalYieldSharePoints;
    }

    /**
     * @dev Estimates the amount of reward tokens a user can claim based on their current total points
     * relative to the total points ever accrued and total reward tokens ever distributed.
     * Note: This is an estimate based on the *last updated* points and total distributed amount.
     * Claiming calls _updateYieldSharePoints first for a more accurate calculation.
     */
    function getEstimatedClaimableRewardTokens(address user) public view returns (uint256) {
        if (!rewardTokenSet || rewardTokenAddress == address(0) || totalRewardTokenDistributedEver == 0) return 0;

        uint256 userPoints = userYieldSharePoints[user];
        uint256 totalPoints = totalYieldSharePoints;
        uint256 totalDistributed = totalRewardTokenDistributedEver;

        // Include pending points in the estimation
        userPoints += getPendingYieldSharePoints(user);
        totalPoints += getPendingYieldSharePoints(user); // This is an approximation as other users' points might also be pending

        if (userPoints == 0 || totalPoints == 0) return 0;

        uint256 totalPotentialClaim = (userPoints * totalDistributed) / totalPoints;
        uint256 alreadyClaimed = userRewardTokenClaimedEver[user];

        return totalPotentialClaim > alreadyClaimed ? totalPotentialClaim - alreadyClaimed : 0;
    }


    // --- Catalyst Token (CFT) Mechanism ---

    /**
     * @dev Allows a user to trigger the calculation and potential granting of CFTs
     * based on their accumulated active staking time since the last grant.
     * Consumes the accumulated time upon granting.
     */
    function triggerTimedCFTGrant(address user) external whenNotPaused {
         // Allow anyone to trigger for a user? Or only the user themselves?
         // Allowing anyone helps process grants even if user is inactive. Let's allow anyone.
         address caller = msg.sender; // Store caller for event
         address userToGrant = user; // User whose CFTs are being checked/granted

         _updateYieldSharePoints(userToGrant); // Ensure active time is up-to-date

         uint256 accumulatedTime = activeStakingTimeForCFTs[userToGrant];
         if (accumulatedTime == 0) {
              // No active staking time accumulated since last grant
              return;
         }

         uint256 cftRateScaled = cftMintRatePerSecondScaled;
         uint256 cftsToMintScaled = cftRateScaled * accumulatedTime;

         // Convert scaled CFTs to actual CFTs (assuming cftMintRatePerSecondScaled is scaled by 1e18)
         uint256 cftsToMint = cftsToMintScaled / 1e18;

         if (cftsToMint > 0) {
             catalystTokens[userToGrant] += cftsToMint;
             activeStakingTimeForCFTs[userToGrant] = 0; // Reset accumulated time for CFTs

             emit CatalystTokensGranted(userToGrant, cftsToMint);
         }
         // If cftsToMint is 0 (e.g., rate too low or time too short), time is NOT reset.
    }

    /**
     * @dev Gets the user's current balance of Catalyst Tokens (CFTs).
     * CFTs are non-transferable in this contract design and only confer boosts.
     */
    function getCatalystTokens(address user) public view returns (uint256) {
        return catalystTokens[user];
    }


    // --- Information (View) ---

    function getStakedAmount(address user, address token) public view returns (uint256) {
        if (token == ETH_ADDRESS) return userETHStaked[user];
        return userStakedBalances[user][token];
    }

    function getTotalStaked(address token) public view returns (uint256) {
        if (token == ETH_ADDRESS) return totalETHStaked;
        return totalStakedAmounts[token];
    }

    function getSupportedTokens() public view returns (address[] memory) {
        return _supportedTokens;
    }

    function getDynamicDepositFee(address token) public view returns (uint256) {
        if (token == ETH_ADDRESS) return dynamicDepositFeeBPS[ETH_ADDRESS];
        return dynamicDepositFeeBPS[token];
    }

    function getDynamicWithdrawalFee(address token) public view returns (uint256) {
        if (token == ETH_ADDRESS) return dynamicWithdrawalFeeBPS[ETH_ADDRESS];
        return dynamicWithdrawalFeeBPS[token];
    }

    function getTotalActiveStakersCount() public view returns (uint256) {
        return totalActiveStakersCount;
    }

    function getGlobalRewardRatePerSecondScaled() public view returns (uint256) {
        return globalRatePerSecondScaled;
    }

    function getCftBoostBPS_Per_CFT() public view returns (uint256) {
        return cftBoostBPS_Per_CFT;
    }

    function getHarvestAuraBPS_Per_Staker() public view returns (uint256) {
        return harvestAuraBPS_Per_Staker;
    }

    function getCftMintRatePerSecondScaled() public view returns (uint256) {
        return cftMintRatePerSecondScaled;
    }

    function getRewardToken() public view returns (address) {
        return rewardTokenAddress;
    }

    function getTotalRewardTokenDistributedEver() public view returns (uint256) {
        return totalRewardTokenDistributedEver;
    }

    function getUserRewardTokenClaimedEver(address user) public view returns (uint256) {
        return userRewardTokenClaimedEver[user];
    }

    // --- Admin/Operator (Permissioned) ---

    function addSupportedToken(address token) external onlyOperator {
        if (token == address(0) || token == ETH_ADDRESS) revert InvalidRate(); // Using InvalidRate as a general error here
        if (_isSupportedToken[token]) revert InvalidRate(); // Already supported

        _isSupportedToken[token] = true;
        _supportedTokens.push(token);
        // Initialize fees to zero
        dynamicDepositFeeBPS[token] = 0;
        dynamicWithdrawalFeeBPS[token] = 0;

        emit SupportedTokenAdded(token);
    }

    function removeSupportedToken(address token) external onlyOperator {
        if (token == address(0) || token == ETH_ADDRESS) revert InvalidRate();
        if (!_isSupportedToken[token]) revert TokenNotSupported(token);

        // In a production contract, you'd need to ensure no users have funds staked in this token first!
        // For this example, we allow removal but note the risk.
        // A proper implementation might require draining the token first or migrating funds.

        _isSupportedToken[token] = false;
        // Removing from dynamic array is inefficient, typically use a mapping + count or mark as inactive
        // Simple removal (order not guaranteed, expensive for large arrays):
        for (uint i = 0; i < _supportedTokens.length; i++) {
            if (_supportedTokens[i] == token) {
                _supportedTokens[i] = _supportedTokens[_supportedTokens.length - 1];
                _supportedTokens.pop();
                break;
            }
        }

        emit SupportedTokenRemoved(token);
    }

    function setDynamicDepositFee(address token, uint256 feeBPS) external onlyOperator {
        if (token != ETH_ADDRESS && !_isSupportedToken[token]) revert TokenNotSupported(token);
        if (feeBPS > 10000) revert InvalidFeeRate(); // Max 100%

        dynamicDepositFeeBPS[token] = feeBPS;
        emit DynamicDepositFeeSet(token, feeBPS);
    }

    function setDynamicWithdrawalFee(address token, uint256 feeBPS) external onlyOperator {
        if (token != ETH_ADDRESS && !_isSupportedToken[token]) revert TokenNotSupported(token);
        if (feeBPS > 10000) revert InvalidFeeRate(); // Max 100%

        dynamicWithdrawalFeeBPS[token] = feeBPS;
        emit DynamicWithdrawalFeeSet(token, feeBPS);
    }

    function setGlobalRewardRatePerSecondScaled(uint256 rate) external onlyOperator {
        // Consider minimum rate
        globalRatePerSecondScaled = rate;
        emit GlobalRewardRateSet(rate);
    }

    function setCftBoostBPS_Per_CFT(uint256 factorBPS) external onlyOperator {
        cftBoostBPS_Per_CFT = factorBPS;
        emit CftBoostSet(factorBPS);
    }

    function setHarvestAuraBPS_Per_Staker(uint256 factorBPS) external onlyOperator {
        harvestAuraBPS_Per_Staker = factorBPS;
        emit HarvestAuraSet(factorBPS);
    }

    function setCftMintRatePerSecondScaled(uint256 rate) external onlyOperator {
        cftMintRatePerSecondScaled = rate;
        emit CftMintRateSet(rate);
    }

    /**
     * @dev Allows an operator to manually mint Catalyst Tokens for a specific user.
     * Use cases might include rewarding specific contributions or participation off-chain.
     */
    function mintCatalystTokens(address user, uint256 amount) external onlyOperator {
        if (user == address(0) || amount == 0) revert InvalidRate(); // Using InvalidRate generally
        catalystTokens[user] += amount;
        emit CatalystTokensGranted(user, amount);
    }

    /**
     * @dev Allows an operator to manually burn Catalyst Tokens from a specific user.
     * Use cases might include penalizing malicious behavior or correcting errors.
     */
    function burnCatalystTokens(address user, uint256 amount) external onlyOperator {
        if (user == address(0) || amount == 0) revert InvalidRate();
        if (catalystTokens[user] < amount) revert InsufficientFunds(amount, catalystTokens[user]);
        catalystTokens[user] -= amount;
        emit CatalystTokensBurned(user, amount);
    }

    /**
     * @dev Operator distributes reward tokens to the contract, making them available for users to claim.
     * This function effectively funds the reward pool.
     * @param amount The amount of reward tokens to distribute.
     */
    function distributeRewardTokens(uint256 amount) external onlyOperator {
        if (!rewardTokenSet || rewardTokenAddress == address(0)) revert RewardTokenNotSet();
        if (amount == 0) revert ZeroAmount();

        // Transfer reward tokens from the operator to the contract
        if (!IERC20(rewardTokenAddress).transferFrom(msg.sender, address(this), amount)) revert ERC20TransferFailed();

        totalRewardTokenDistributedEver += amount; // Update total distributed count

        emit RewardTokensDistributed(msg.sender, amount);
    }


    // --- Access Control Management ---

    function addOperator(address operator) external onlyOwner {
        if (operator == address(0)) revert InvalidRate();
        operators[operator] = true;
        emit OperatorAdded(operator);
    }

    function removeOperator(address operator) external onlyOwner {
         if (operator == address(0)) revert InvalidRate();
         operators[operator] = false;
         emit OperatorRemoved(operator);
    }


    // --- Pausability Functions ---

    function panicPause() external onlyOperator whenNotPaused {
        paused = true;
        emit PausedContract(msg.sender);
    }

    function unpause() external onlyOperator whenPaused {
        paused = false;
        emit UnpausedContract(msg.sender);
    }

    // --- Emergency Rescue ---

    /**
     * @dev Allows owner/operator to rescue accidentally sent ERC20 tokens.
     * Prevents rescuing tokens that are part of the pooled/staked assets or the reward token.
     */
    function rescueERC20(address token, uint256 amount, address recipient) external onlyOperator {
        if (token == address(0) || amount == 0 || recipient == address(0)) revert InvalidRate();
        // Prevent rescuing ETH using this function (use rescueETH)
        if (token == ETH_ADDRESS) revert InvalidRate();

        // Prevent rescuing tokens that are actively pooled/staked
        if (_isSupportedToken[token] || token == rewardTokenAddress) revert CannotRescuePooledTokens();

        // Prevent rescuing tokens that *could* be pooled if they were supported
        // A more robust check might see if there are any userStakedBalances[user][token] > 0 for ANY user.
        // Simple check: if it's a supported token OR the reward token, don't rescue.

        uint256 contractBalance = IERC20(token).balanceOf(address(this));
        if (amount > contractBalance) revert InsufficientFunds(amount, contractBalance);

        if (!IERC20(token).transfer(recipient, amount)) revert ERC20TransferFailed();

        emit RescuedERC20(token, amount, recipient);
    }

    /**
     * @dev Allows owner/operator to rescue accidentally sent ETH.
     * Prevents rescuing ETH that is actively pooled/staked.
     */
    function rescueETH(uint256 amount, address recipient) external onlyOperator {
        if (amount == 0 || recipient == address(0)) revert InvalidRate();

        // Prevent rescuing staked ETH
        if (address(this).balance - totalETHStaked < amount) revert CannotRescuePooledTokens();

        (bool success, ) = payable(recipient).call{value: amount}("");
        if (!success) revert ETHTransferFailed();

        emit RescuedETH(amount, recipient);
    }

    /**
     * @dev Allows the owner to set the address of the reward token.
     * Can only be set once.
     * @param token The address of the ERC20 token to use for rewards.
     */
    function setRewardToken(address token) external onlyOwner {
        if (rewardTokenSet) revert RewardTokenAlreadySet();
        if (token == address(0) || token == ETH_ADDRESS) revert InvalidRate(); // Reward token must be an ERC20

        rewardTokenAddress = token;
        rewardTokenSet = true;
        emit RewardTokenSet(token);
    }
}
```