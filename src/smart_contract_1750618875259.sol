Okay, here is a Solidity smart contract called `QuantumVault`. The concept revolves around a vault that holds ERC20 and ERC721 assets and introduces dynamic "quantum states" and "ephemeral traits" to deposited positions, along with advanced deposit/withdrawal mechanics and a simple config amendment process.

It aims to be creative by adding layers of dynamic properties and interaction logic beyond a standard deposit/withdraw vault.

**Disclaimer:** This contract is for demonstration purposes and showcases advanced concepts. It is not audited or production-ready. Implementing such complex logic securely requires extensive testing and professional audits. Some features are simplified for concept illustration (e.g., oracle calls are simulated, complex yield calculation is represented simply).

---

**QuantumVault Contract Outline & Function Summary**

**Outline:**

1.  **Contract Details:** Pragmas, Imports, Errors.
2.  **State Variables:** Storage for positions, states, traits, configurations, access control, etc.
3.  **Enums & Structs:** Definitions for Position States, Token Types, Vault Positions, Ephemeral Traits, Withdrawal Details, Config Amendments, Access Roles.
4.  **Events:** Signaling key contract actions.
5.  **Modifiers:** Access control and state checks.
6.  **Core Vault Functionality:** Deposit and Withdrawal of ERC20 and ERC721 tokens.
7.  **Advanced Vault Mechanics:** Time-locked deposits, conditional withdrawals, scheduled withdrawals, entangled positions.
8.  **Dynamic State & Attributes:** Applying, resolving, and querying dynamic states and ephemeral traits on vault positions.
9.  **Internal Processes & Interactions:** Triggering state evolution, evolving position attributes, initiating simulated external protocol calls, yielding mechanisms.
10. **Access Control & Governance:** Setting roles, managing oracle addresses, proposing and finalizing contract configuration amendments.
11. **Utility & Information:** Retrieving contract state and user position details.
12. **Security & Maintenance:** Pausing, unpausing, emergency withdrawal, ownership transfer.

**Function Summary:**

1.  `constructor()`: Initializes the contract, sets owner and initial configurations.
2.  `depositERC20(address tokenAddress, uint256 amount)`: Deposits ERC20 tokens into the vault, creating a new position.
3.  `depositERC721(address tokenAddress, uint256 tokenId)`: Deposits an ERC721 token into the vault, creating a new position.
4.  `withdrawERC20(uint256 positionId, uint256 amount)`: Withdraws a specific amount of ERC20 tokens from a position, subject to state and locks.
5.  `withdrawERC721(uint256 positionId)`: Withdraws an ERC721 token from a position, subject to state and locks.
6.  `depositWithTimeLock(address tokenAddress, uint256 amount, uint256 unlockTimestamp)`: Deposits ERC20 with a time-based withdrawal lock.
7.  `depositERC721WithTimeLock(address tokenAddress, uint256 tokenId, uint256 unlockTimestamp)`: Deposits ERC721 with a time-based withdrawal lock.
8.  `withdrawWithCondition(uint256 positionId, bytes32 conditionIdentifier)`: Attempts withdrawal based on a predefined external condition being met (e.g., checked via oracle).
9.  `createScheduledWithdrawal(uint256 positionId, uint256 amountOrTokenId, uint256 scheduleTimestamp, TokenType tokenKind)`: Schedules a future automatic withdrawal.
10. `executeScheduledWithdrawal(uint256 withdrawalId)`: Executes a scheduled withdrawal when the time is met (callable by anyone, potentially a keeper).
11. `depositEntangledPosition(uint256 primaryPositionId, address tokenAddress, uint256 amountOrTokenId, TokenType tokenKind)`: Deposits assets linked to an existing position, creating an 'entangled' pair.
12. `applyEntropicState(uint256 positionId, PositionState newState)`: Applies a dynamic state (like Superposition) to a position (restricted access).
13. `collapseStateObserver(uint256 positionId)`: Transitions a position's state (like from Superposition to Resolved) based on internal logic or external trigger (restricted access).
14. `applyEphemeralTrait(uint256 positionId, bytes32 traitIdentifier, uint256 duration)`: Adds a temporary trait to a deposited NFT or position.
15. `getVaultPositionState(uint256 positionId)`: Retrieves the current dynamic state of a specific vault position.
16. `triggerStateEvolution()`: A function (callable by oracle/admin) to potentially evolve states of multiple positions based on time or external factors.
17. `evolvePositionAttributes(uint256 positionId)`: Internal or restricted function to modify a position's attributes based on its state or other factors.
18. `initiateProtocolInteraction(uint256 positionId, address targetContract)`: Simulates the vault interacting with another protocol using assets from a position.
19. `redeemVaultYield(uint256 positionId)`: Allows a user to claim hypothetical yield generated by their position (simplified).
20. `setAccessRole(address user, Role role)`: Assigns a specific role (Admin, Oracle, etc.) to an address.
21. `registerOracleAddress(address oracle)`: Whitelists an address capable of acting as an oracle for certain functions.
22. `proposeConfigAmendment(bytes32 parameterHash, bytes memory newValueEncoded)`: Initiates a process to change a contract configuration parameter.
23. `finalizeConfigAmendment(bytes32 parameterHash)`: Finalizes a proposed configuration change after a time delay or approval period.
24. `getERC20Balance(address tokenAddress)`: Gets the total balance of a specific ERC20 held by the vault.
25. `getUserVaultPositions(address user)`: Retrieves a list of position IDs owned by a specific user. (Note: Iterating mappings can be gas-intensive, conceptual here).
26. `getTotalERC721Types()`: Counts the number of unique ERC721 contract addresses holding tokens in the vault. (Note: Iterating sets/mappings can be gas-intensive, conceptual here).
27. `emergencyWithdraw(address tokenAddress)`: Allows owner/admin to pull out stuck ERC20 tokens.
28. `emergencyWithdrawERC721(address tokenAddress, uint256 tokenId)`: Allows owner/admin to pull out stuck ERC721 tokens.
29. `pauseContract()`: Pauses certain contract functions (deposit, withdrawal, etc.).
30. `unpauseContract()`: Unpauses the contract.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Address.sol"; // For safeTransferFrom (ERC721Holder needs this implicitly)
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Although 0.8+ has checked arithmetic, demonstrating SafeMath pattern

// Note: ERC721Holder is used to receive ERC721 tokens, but actual management logic is custom.

// Custom Errors
error QuantumVault__TokenTransferFailed();
error QuantumVault__ERC721NotOwnedByVault();
error QuantumVault__InvalidPositionId();
error QuantumVault__UnauthorizedRole(Role requiredRole);
error QuantumVault__NotPausableFunction();
error QuantumVault__PositionLocked();
error QuantumVault__InvalidAmount();
error QuantumVault__ConditionNotMet();
error QuantumVault__WithdrawalNotScheduled();
error QuantumVault__WithdrawalNotReady();
error QuantumVault__ScheduledWithdrawalExecuted();
error QuantumVault__PositionAlreadyEntangled();
error QuantumVault__PositionCannotBeEntangled(PositionState currentState);
error QuantumVault__InvalidStateTransition();
error QuantumVault__TraitDurationTooShort();
error QuantumVault__NotAnOracle();
error QuantumVault__ConfigAmendmentNotFound();
error QuantumVault__ConfigAmendmentNotReady();
error QuantumVault__ConfigAmendmentAlreadyFinalized();
error QuantumVault__InvalidConfigAmendmentValue();
error QuantumVault__PositionCannotBeRedeemed(PositionState currentState);


contract QuantumVault is Ownable, Pausable, ERC721Holder {
    using SafeMath for uint256;
    using Address for address;

    // --- State Variables ---

    // --- Enums & Structs ---

    enum Role {
        NONE,
        ADMIN,
        ORACLE
    }

    enum PositionState {
        ACTIVE, // Default state, standard operations allowed
        SUPERPOSITION, // Untradeable, may have unpredictable outcomes (conceptual)
        ENTANGLED, // Linked to another position, operations may affect linked pair
        RESOLVED, // State after Superposition collapse, potentially locked or altered
        LOCKED, // Temporarily locked (e.g., time-lock, condition)
        DEACTIVATED // Position closed or zeroed
    }

    enum TokenType {
        ERC20,
        ERC721
    }

    struct VaultPosition {
        uint256 positionId;
        address user; // Original depositor
        TokenType tokenKind;
        address tokenAddress;
        uint256 amountOrTokenId; // Amount for ERC20, tokenId for ERC721
        uint256 depositTimestamp;
        PositionState currentState;
        uint256 unlockTimestamp; // For time-locked positions
        uint256 linkedPositionId; // For ENTANGLED state
        bool isEntanglementPrimary; // True if this is the primary position in an entangled pair
    }

    struct EphemeralTrait {
        bytes32 traitIdentifier; // e.g., keccak256("SpeedBoost"), keccak256("ReducedTax")
        uint256 expiryTimestamp;
    }

    struct WithdrawalDetails {
        uint256 withdrawalId;
        uint256 positionId;
        uint256 amountOrTokenId;
        TokenType tokenKind;
        address recipient;
        uint256 scheduleTimestamp;
        bool executed;
    }

    struct ConfigAmendment {
        bytes32 parameterHash; // Identifier for the parameter
        bytes newValueEncoded; // New value (abi.encode)
        address proposer;
        uint256 proposalTimestamp;
        bool finalized;
        bool approved; // Simple approval mechanism (e.g., owner)
        uint256 gracePeriodEnd; // Time before it can be finalized
    }

    // Mappings & Arrays
    mapping(uint256 => VaultPosition) public vaultPositions;
    uint256 private _positionCounter;

    mapping(address => mapping(bytes32 => Role)) private _accessRoles; // user => featureHash => role

    mapping(address => bool) private _isOracle;

    mapping(uint256 => EphemeralTrait[]) public ephemeralTraits; // positionId => list of traits

    mapping(uint256 => WithdrawalDetails) public scheduledWithdrawals;
    uint256 private _withdrawalCounter;

    mapping(bytes32 => ConfigAmendment) public configAmendments;
    bytes32[] public activeConfigAmendments; // List of hashes for tracking

    // Example configuration parameters (simplified)
    uint256 public constant MIN_EPHEMERAL_TRAIT_DURATION = 1 days;
    uint256 public constant CONFIG_AMENDMENT_GRACE_PERIOD = 3 days;
    bytes32 public constant MIN_EPHEMERAL_TRAIT_DURATION_HASH = keccak256("MIN_EPHEMERAL_TRAIT_DURATION");


    // --- Events ---

    event PositionCreated(uint256 positionId, address user, TokenType tokenKind, address tokenAddress, uint256 amountOrTokenId, uint256 depositTimestamp);
    event PositionStateChanged(uint256 positionId, PositionState oldState, PositionState newState);
    event EphemeralTraitApplied(uint256 positionId, bytes32 traitIdentifier, uint256 expiryTimestamp);
    event WithdrawalScheduled(uint256 withdrawalId, uint256 positionId, address recipient, uint256 scheduleTimestamp);
    event WithdrawalExecuted(uint256 withdrawalId, uint256 positionId, uint256 amountOrTokenId, TokenType tokenKind);
    event EntanglementCreated(uint256 position1Id, uint256 position2Id);
    event PositionYieldRedeemed(uint256 positionId, address user, uint256 amount); // Simplified yield
    event AccessRoleSet(address user, bytes32 featureHash, Role role);
    event OracleRegistered(address oracle);
    event ConfigAmendmentProposed(bytes32 parameterHash, address proposer, uint256 proposalTimestamp);
    event ConfigAmendmentFinalized(bytes32 parameterHash, bytes newValueEncoded);
    event EmergencyWithdrawal(address indexed tokenAddress, uint256 amountOrTokenId);


    // --- Modifiers ---

    modifier onlyRole(Role requiredRole) {
        bytes32 featureHash = keccak256(abi.encodePacked(msg.sig));
        require(_accessRoles[msg.sender][featureHash] >= requiredRole || owner() == msg.sender, QuantumVault__UnauthorizedRole(requiredRole));
        _;
    }

    modifier onlyOracle() {
        require(_isOracle[msg.sender], QuantumVault__NotAnOracle());
        _;
    }

    modifier whenPositionExists(uint256 positionId) {
        require(vaultPositions[positionId].positionId != 0, QuantumVault__InvalidPositionId());
        _;
    }

    modifier whenPositionNotLocked(uint256 positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.unlockTimestamp <= block.timestamp, QuantumVault__PositionLocked());
        // Check other lock states if needed, e.g., require(pos.currentState != PositionState.LOCKED, ...)
        _;
    }


    // --- Constructor ---

    constructor() Ownable(msg.sender) Pausable(false) {
        _positionCounter = 0;
        _withdrawalCounter = 0;
        // Owner gets all roles by default or can set them explicitly
        _accessRoles[msg.sender][keccak256(abi.encodePacked("ALL"))] = Role.ADMIN; // Example of broad role
    }

    // --- Core Vault Functionality ---

    /// @notice Deposits ERC20 tokens into the vault.
    /// @param tokenAddress The address of the ERC20 token.
    /// @param amount The amount of tokens to deposit.
    function depositERC20(address tokenAddress, uint256 amount) external whenNotPaused {
        require(amount > 0, QuantumVault__InvalidAmount());
        require(tokenAddress != address(0), "Invalid token address");

        _positionCounter++;
        uint256 newPositionId = _positionCounter;

        vaultPositions[newPositionId] = VaultPosition({
            positionId: newPositionId,
            user: msg.sender,
            tokenKind: TokenType.ERC20,
            tokenAddress: tokenAddress,
            amountOrTokenId: amount,
            depositTimestamp: block.timestamp,
            currentState: PositionState.ACTIVE,
            unlockTimestamp: 0, // No initial time lock
            linkedPositionId: 0, // Not initially entangled
            isEntanglementPrimary: false
        });

        // Transfer tokens from sender to contract
        bool success = IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
        require(success, QuantumVault__TokenTransferFailed());

        emit PositionCreated(newPositionId, msg.sender, TokenType.ERC20, tokenAddress, amount, block.timestamp);
    }

    /// @notice Deposits an ERC721 token into the vault. Requires prior approval.
    /// @param tokenAddress The address of the ERC721 token contract.
    /// @param tokenId The ID of the token to deposit.
    function depositERC721(address tokenAddress, uint256 tokenId) external whenNotPaused {
        require(tokenAddress != address(0), "Invalid token address");

        _positionCounter++;
        uint256 newPositionId = _positionCounter;

        vaultPositions[newPositionId] = VaultPosition({
            positionId: newPositionId,
            user: msg.sender,
            tokenKind: TokenType.ERC721,
            tokenAddress: tokenAddress,
            amountOrTokenId: tokenId, // tokenId for ERC721
            depositTimestamp: block.timestamp,
            currentState: PositionState.ACTIVE,
            unlockTimestamp: 0, // No initial time lock
            linkedPositionId: 0, // Not initially entangled
            isEntanglementPrimary: false
        });

        // Transfer token from sender to contract
        // ERC721Holder's onERC721Received will be called if tokenAddress is ERC721
        IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId);

        emit PositionCreated(newPositionId, msg.sender, TokenType.ERC721, tokenAddress, tokenId, block.timestamp);
    }

    /// @notice Withdraws a specific amount of ERC20 tokens from a position.
    /// @param positionId The ID of the vault position.
    /// @param amount The amount to withdraw.
    function withdrawERC20(uint256 positionId, uint256 amount) external whenNotPaused whenPositionExists(positionId) whenPositionNotLocked(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];

        require(pos.user == msg.sender, "Not your position");
        require(pos.tokenKind == TokenType.ERC20, "Not an ERC20 position");
        require(pos.amountOrTokenId >= amount, QuantumVault__InvalidAmount());
        require(pos.currentState == PositionState.ACTIVE || pos.currentState == PositionState.RESOLVED, "Position state prevents withdrawal");
        // Add checks for ENTANGLED, SUPERPOSITION, etc., based on desired logic

        // Transfer tokens to user
        bool success = IERC20(pos.tokenAddress).transfer(msg.sender, amount);
        require(success, QuantumVault__TokenTransferFailed());

        pos.amountOrTokenId -= amount;

        if (pos.amountOrTokenId == 0) {
            pos.currentState = PositionState.DEACTIVATED; // Mark position as empty
            // Note: Position struct is not deleted to preserve history, but can be optimized
        }

        // Handle potential entanglement side effects (conceptual)
        if (pos.currentState == PositionState.ENTANGLED && pos.linkedPositionId != 0) {
             _handleEntanglementWithdrawalEffect(positionId, pos.linkedPositionId, amount, TokenType.ERC20);
        }
    }

    /// @notice Withdraws an ERC721 token from a position.
    /// @param positionId The ID of the vault position.
    function withdrawERC721(uint256 positionId) external whenNotPaused whenPositionExists(positionId) whenPositionNotLocked(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];

        require(pos.user == msg.sender, "Not your position");
        require(pos.tokenKind == TokenType.ERC721, "Not an ERC721 position");
        require(pos.amountOrTokenId != 0, "Position already withdrawn or empty"); // tokenId should not be 0
        require(pos.currentState == PositionState.ACTIVE || pos.currentState == PositionState.RESOLVED, "Position state prevents withdrawal");
        // Add checks for ENTANGLED, SUPERPOSITION, etc.

        uint256 tokenId = pos.amountOrTokenId;
        address tokenContract = pos.tokenAddress;

        // Reset tokenId in position state to 0 to mark as withdrawn
        pos.amountOrTokenId = 0;
        pos.currentState = PositionState.DEACTIVATED; // Mark position as empty

        // Transfer token to user
        IERC721(tokenContract).safeTransferFrom(address(this), msg.sender, tokenId);

        // Handle potential entanglement side effects (conceptual)
         if (pos.currentState == PositionState.ENTANGLED && pos.linkedPositionId != 0) {
             _handleEntanglementWithdrawalEffect(positionId, pos.linkedPositionId, tokenId, TokenType.ERC721);
         }
    }

    // Internal helper for entanglement effects
    function _handleEntanglementWithdrawalEffect(uint256 withdrawnPositionId, uint256 linkedPositionId, uint256 amountOrTokenId, TokenType tokenKind) internal {
        // This is a conceptual implementation. Real entanglement effects would be complex.
        // Example: Collapse the state of the linked position.
        VaultPosition storage linkedPos = vaultPositions[linkedPositionId];
        if (linkedPos.currentState == PositionState.SUPERPOSITION) {
             _transitionState(linkedPositionId, PositionState.RESOLVED);
        }
        // More complex effects could involve partial burning, state changes based on amount, etc.
        emit EntanglementCreated(withdrawnPositionId, linkedPositionId); // Re-using event for state change notification
    }


    // --- Advanced Vault Mechanics ---

    /// @notice Deposits ERC20 with a time lock.
    /// @param tokenAddress The address of the ERC20 token.
    /// @param amount The amount of tokens to deposit.
    /// @param unlockTimestamp The timestamp when the tokens can be withdrawn.
    function depositWithTimeLock(address tokenAddress, uint256 amount, uint256 unlockTimestamp) external whenNotPaused {
        require(amount > 0, QuantumVault__InvalidAmount());
        require(tokenAddress != address(0), "Invalid token address");
        require(unlockTimestamp > block.timestamp, "Unlock time must be in the future");

        _positionCounter++;
        uint256 newPositionId = _positionCounter;

        vaultPositions[newPositionId] = VaultPosition({
            positionId: newPositionId,
            user: msg.sender,
            tokenKind: TokenType.ERC20,
            tokenAddress: tokenAddress,
            amountOrTokenId: amount,
            depositTimestamp: block.timestamp,
            currentState: PositionState.LOCKED, // Initially locked by time
            unlockTimestamp: unlockTimestamp,
            linkedPositionId: 0,
            isEntanglementPrimary: false
        });

        bool success = IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
        require(success, QuantumVault__TokenTransferFailed());

        emit PositionCreated(newPositionId, msg.sender, TokenType.ERC20, tokenAddress, amount, block.timestamp);
        emit PositionStateChanged(newPositionId, PositionState.ACTIVE, PositionState.LOCKED); // Treat time-lock as a state change
    }

     /// @notice Deposits ERC721 with a time lock. Requires prior approval.
    /// @param tokenAddress The address of the ERC721 token contract.
    /// @param tokenId The ID of the token to deposit.
    /// @param unlockTimestamp The timestamp when the token can be withdrawn.
     function depositERC721WithTimeLock(address tokenAddress, uint256 tokenId, uint256 unlockTimestamp) external whenNotPaused {
        require(tokenAddress != address(0), "Invalid token address");
        require(unlockTimestamp > block.timestamp, "Unlock time must be in the future");

        _positionCounter++;
        uint256 newPositionId = _positionCounter;

         vaultPositions[newPositionId] = VaultPosition({
            positionId: newPositionId,
            user: msg.sender,
            tokenKind: TokenType.ERC721,
            tokenAddress: tokenAddress,
            amountOrTokenId: tokenId, // tokenId for ERC721
            depositTimestamp: block.timestamp,
            currentState: PositionState.LOCKED, // Initially locked by time
            unlockTimestamp: unlockTimestamp,
            linkedPositionId: 0,
            isEntanglementPrimary: false
        });

        IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId);

        emit PositionCreated(newPositionId, msg.sender, TokenType.ERC721, tokenAddress, tokenId, block.timestamp);
        emit PositionStateChanged(newPositionId, PositionState.ACTIVE, PositionState.LOCKED); // Treat time-lock as a state change
    }


    /// @notice Attempts withdrawal based on a predefined external condition.
    /// Condition logic is simplified and must be checked off-chain or via oracle.
    /// @param positionId The ID of the vault position.
    /// @param conditionIdentifier A hash identifying the condition (e.g., keccak256("AAPLPriceOver180")).
    function withdrawWithCondition(uint256 positionId, bytes32 conditionIdentifier) external whenNotPaused whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.user == msg.sender, "Not your position");
        require(pos.currentState != PositionState.SUPERPOSITION && pos.currentState != PositionState.ENTANGLED, "Position state prevents conditional withdrawal");
         require(pos.unlockTimestamp <= block.timestamp, QuantumVault__PositionLocked()); // Time lock still applies

        // --- Conceptual Condition Check ---
        // In a real contract, this would involve an Oracle pattern (Chainlink, etc.)
        // For demonstration, we'll use a simple internal state variable or require an oracle signature.
        // Let's assume there's a mapping `bytes32 => bool` or an oracle function call here.
        // require(_checkExternalCondition(conditionIdentifier), QuantumVault__ConditionNotMet());
        // --- End Conceptual Check ---

        // For THIS example, let's just require an oracle to trigger the withdrawal on behalf of the user
        // This simplifies the on-chain logic but shifts trust to the oracle.
        // A better pattern is for the user to call AFTER the oracle updates a state variable.
        revert("Conditional withdrawal requires oracle integration (conceptual)");

        // If condition check passed (in a real implementation):
        // uint256 amountToWithdraw = pos.amountOrTokenId;
        // TokenType kind = pos.tokenKind;
        // pos.amountOrTokenId = 0; // Mark as withdrawn
        // pos.currentState = PositionState.DEACTIVATED;

        // if (kind == TokenType.ERC20) {
        //     bool success = IERC20(pos.tokenAddress).transfer(msg.sender, amountToWithdraw);
        //     require(success, QuantumVault__TokenTransferFailed());
        // } else {
        //     IERC721(pos.tokenAddress).safeTransferFrom(address(this), msg.sender, amountToWithdraw); // amountToWithdraw is tokenId
        // }
    }

     /// @notice Schedules a future automatic withdrawal from a position.
     /// Anyone can execute it once the scheduleTimestamp is reached.
    /// @param positionId The ID of the vault position.
    /// @param amountOrTokenId Amount for ERC20, tokenId for ERC721.
    /// @param scheduleTimestamp The timestamp when the withdrawal can be executed.
    /// @param tokenKind The type of token (ERC20 or ERC721).
     function createScheduledWithdrawal(uint256 positionId, uint256 amountOrTokenId, uint256 scheduleTimestamp, TokenType tokenKind) external whenNotPaused whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.user == msg.sender, "Not your position");
        require(scheduleTimestamp > block.timestamp, "Schedule time must be in the future");
         require(pos.currentState == PositionState.ACTIVE || pos.currentState == PositionState.RESOLVED, "Position state prevents scheduling withdrawal");


        if (tokenKind == TokenType.ERC20) {
            require(pos.tokenKind == TokenType.ERC20, "Position is not ERC20");
             require(pos.amountOrTokenId >= amountOrTokenId, QuantumVault__InvalidAmount());
             require(amountOrTokenId > 0, QuantumVault__InvalidAmount());
        } else if (tokenKind == TokenType.ERC721) {
             require(pos.tokenKind == TokenType.ERC721, "Position is not ERC721");
             require(pos.amountOrTokenId == amountOrTokenId, "TokenId mismatch or already withdrawn"); // Must schedule withdrawal of the specific token ID
        } else {
             revert("Invalid token kind");
        }

        _withdrawalCounter++;
        uint256 newWithdrawalId = _withdrawalCounter;

        scheduledWithdrawals[newWithdrawalId] = WithdrawalDetails({
            withdrawalId: newWithdrawalId,
            positionId: positionId,
            amountOrTokenId: amountOrTokenId,
            tokenKind: tokenKind,
            recipient: msg.sender, // Scheduled withdrawal goes back to original owner
            scheduleTimestamp: scheduleTimestamp,
            executed: false
        });

        // Optionally mark the position or amount as 'pending withdrawal' to prevent double-spending
        // Not implemented here for simplicity, requires more complex state tracking per position.

        emit WithdrawalScheduled(newWithdrawalId, positionId, msg.sender, scheduleTimestamp);
     }

     /// @notice Executes a scheduled withdrawal if the schedule timestamp has passed.
     /// Can be called by anyone (facilitates keeper networks).
    /// @param withdrawalId The ID of the scheduled withdrawal.
     function executeScheduledWithdrawal(uint256 withdrawalId) external whenNotPaused {
        WithdrawalDetails storage details = scheduledWithdrawals[withdrawalId];
        require(details.withdrawalId != 0, QuantumVault__WithdrawalNotScheduled()); // Check if exists
        require(!details.executed, QuantumVault__ScheduledWithdrawalExecuted());
        require(details.scheduleTimestamp <= block.timestamp, QuantumVault__WithdrawalNotReady());

        VaultPosition storage pos = vaultPositions[details.positionId];
        require(pos.positionId != 0, QuantumVault__InvalidPositionId()); // Ensure position still exists

        // Need to re-check conditions from original position based on current state
        // Example: require(pos.currentState == PositionState.ACTIVE || pos.currentState == PositionState.RESOLVED, "Position state changed, cannot execute scheduled withdrawal");
         require(pos.unlockTimestamp <= block.timestamp, QuantumVault__PositionLocked()); // Time lock still applies

        details.executed = true;

        if (details.tokenKind == TokenType.ERC20) {
             require(pos.amountOrTokenId >= details.amountOrTokenId, QuantumVault__InvalidAmount());
             pos.amountOrTokenId -= details.amountOrTokenId;
             bool success = IERC20(pos.tokenAddress).transfer(details.recipient, details.amountOrTokenId);
             require(success, QuantumVault__TokenTransferFailed());
        } else if (details.tokenKind == TokenType.ERC721) {
             require(pos.tokenKind == TokenType.ERC721, "Scheduled withdrawal token kind mismatch");
             require(pos.amountOrTokenId == details.amountOrTokenId, "Scheduled ERC721 already withdrawn"); // Check if the specific token is still in the position
             pos.amountOrTokenId = 0; // Mark token as withdrawn from position state
             IERC721(pos.tokenAddress).safeTransferFrom(address(this), details.recipient, details.amountOrTokenId); // amountOrTokenId is the tokenId
        } else {
             revert("Unknown token kind in scheduled withdrawal");
        }

        // Update position state if empty after withdrawal
        if (pos.amountOrTokenId == 0 && pos.tokenKind == TokenType.ERC20) {
             pos.currentState = PositionState.DEACTIVATED;
        } else if (pos.amountOrTokenId == 0 && pos.tokenKind == TokenType.ERC721) {
            pos.currentState = PositionState.DEACTIVATED;
        }

        emit WithdrawalExecuted(withdrawalId, details.positionId, details.amountOrTokenId, details.tokenKind);
     }


     /// @notice Deposits assets and links them to an existing position, creating an 'entangled' state.
     /// This simulates concepts where withdrawal/state change of one affects the other.
    /// @param primaryPositionId The ID of the existing position to link to.
    /// @param tokenAddress The address of the token to deposit.
    /// @param amountOrTokenId Amount for ERC20, tokenId for ERC721.
    /// @param tokenKind The type of token.
     function depositEntangledPosition(uint256 primaryPositionId, address tokenAddress, uint256 amountOrTokenId, TokenType tokenKind) external whenNotPaused whenPositionExists(primaryPositionId) {
        VaultPosition storage primaryPos = vaultPositions[primaryPositionId];
        require(primaryPos.user == msg.sender, "Primary position not yours");
        require(primaryPos.linkedPositionId == 0, QuantumVault__PositionAlreadyEntangled());
        require(primaryPos.currentState != PositionState.SUPERPOSITION, QuantumVault__PositionCannotBeEntangled(primaryPos.currentState)); // Cannot entangle superposition

        // Deposit the new asset
        _positionCounter++;
        uint256 newPositionId = _positionCounter;

        vaultPositions[newPositionId] = VaultPosition({
            positionId: newPositionId,
            user: msg.sender,
            tokenKind: tokenKind,
            tokenAddress: tokenAddress,
            amountOrTokenId: amountOrTokenId,
            depositTimestamp: block.timestamp,
            currentState: PositionState.ENTANGLED, // New position is entangled
            unlockTimestamp: 0,
            linkedPositionId: primaryPositionId, // Linked back to primary
            isEntanglementPrimary: false // This is the secondary leg
        });

        // Update the primary position to be entangled and link to the new position
        primaryPos.currentState = PositionState.ENTANGLED;
        primaryPos.linkedPositionId = newPositionId;
        primaryPos.isEntanglementPrimary = true;

        // Transfer tokens based on kind
        if (tokenKind == TokenType.ERC20) {
             require(amountOrTokenId > 0, QuantumVault__InvalidAmount());
             bool success = IERC20(tokenAddress).transferFrom(msg.sender, address(this), amountOrTokenId);
             require(success, QuantumVault__TokenTransferFailed());
        } else if (tokenKind == TokenType.ERC721) {
             require(amountOrTokenId > 0, "Invalid token ID"); // TokenId > 0
             IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), amountOrTokenId);
        } else {
             revert("Invalid token kind");
        }

        emit PositionCreated(newPositionId, msg.sender, tokenKind, tokenAddress, amountOrTokenId, block.timestamp);
        emit PositionStateChanged(newPositionId, PositionState.ACTIVE, PositionState.ENTANGLED); // New position state change
        emit PositionStateChanged(primaryPositionId, primaryPos.currentState, PositionState.ENTANGLED); // Primary position state change
        emit EntanglementCreated(primaryPositionId, newPositionId);
     }


    // --- Dynamic State & Attributes ---

    /// @notice Applies a dynamic state (like SUPERPOSITION) to a position. Restricted access.
    /// @param positionId The ID of the vault position.
    /// @param newState The state to apply.
    function applyEntropicState(uint256 positionId, PositionState newState) external whenNotPaused onlyRole(Role.ADMIN) whenPositionExists(positionId) {
        // Only allow specific state transitions via this function
        require(newState == PositionState.SUPERPOSITION || newState == PositionState.LOCKED, QuantumVault__InvalidStateTransition());
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.currentState != newState, "Position is already in this state");
        require(pos.currentState != PositionState.DEACTIVATED, "Cannot change state of a deactivated position");

        _transitionState(positionId, newState);
    }

    /// @notice Transitions a position's state (like from SUPERPOSITION to RESOLVED). Restricted access.
    /// Could be triggered by time, external event, or oracle.
    /// @param positionId The ID of the vault position.
    function collapseStateObserver(uint256 positionId) external whenNotPaused onlyOracle whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.currentState == PositionState.SUPERPOSITION, "Position is not in Superposition");

        // --- Conceptual Logic ---
        // This is where "quantum" outcome would be determined.
        // Could be probabilistic, based on external data, time, etc.
        // For example:
        // if (block.timestamp % 2 == 0) {
        //     _transitionState(positionId, PositionState.RESOLVED); // Common outcome
        // } else {
        //     _transitionState(positionId, PositionState.LOCKED); // Rare outcome
        //     pos.unlockTimestamp = block.timestamp + 30 days; // Apply a lock
        // }
         _transitionState(positionId, PositionState.RESOLVED); // Simple transition for example
        // --- End Conceptual Logic ---
    }

     /// @notice Adds a temporary trait to a deposited NFT or position. Restricted access.
     /// @param positionId The ID of the vault position (must be ERC721 position for NFT traits, or can be any position for general traits).
     /// @param traitIdentifier A hash identifying the trait (e.g., keccak256("Agile")).
     /// @param duration The duration the trait is active in seconds.
     function applyEphemeralTrait(uint256 positionId, bytes32 traitIdentifier, uint256 duration) external whenNotPaused onlyRole(Role.ADMIN) whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.currentState != PositionState.DEACTIVATED, "Cannot apply traits to a deactivated position");
        require(duration >= MIN_EPHEMERAL_TRAIT_DURATION, TraitDurationTooShort());

        // Check if trait already exists and update expiry, or add new
        bool found = false;
        for (uint i = 0; i < ephemeralTraits[positionId].length; i++) {
            if (ephemeralTraits[positionId][i].traitIdentifier == traitIdentifier) {
                ephemeralTraits[positionId][i].expiryTimestamp = block.timestamp + duration;
                found = true;
                break;
            }
        }

        if (!found) {
             ephemeralTraits[positionId].push(EphemeralTrait({
                traitIdentifier: traitIdentifier,
                expiryTimestamp: block.timestamp + duration
            }));
        }

        emit EphemeralTraitApplied(positionId, traitIdentifier, block.timestamp + duration);
     }

    /// @notice Retrieves the current dynamic state of a specific vault position.
    /// @param positionId The ID of the vault position.
    /// @return The current PositionState of the position.
    function getVaultPositionState(uint256 positionId) external view whenPositionExists(positionId) returns (PositionState) {
        return vaultPositions[positionId].currentState;
    }

    // Internal helper to transition state
    function _transitionState(uint256 positionId, PositionState newState) internal {
        VaultPosition storage pos = vaultPositions[positionId];
        PositionState oldState = pos.currentState;
        pos.currentState = newState;
        emit PositionStateChanged(positionId, oldState, newState);
    }


    // --- Internal Processes & Interactions ---

    /// @notice A function callable by oracle/admin to trigger state changes based on time or external factors.
    /// Iterating over all positions can be gas-intensive for many positions.
    function triggerStateEvolution() external whenNotPaused onlyOracle {
        // This is a conceptual function. Iterating all positions is expensive.
        // In practice, this would likely process a limited batch or rely on external keepers
        // calling `collapseStateObserver` or similar for specific positions.

        uint256 latestPositionId = _positionCounter;
        for (uint256 i = 1; i <= latestPositionId; i++) {
            VaultPosition storage pos = vaultPositions[i];
            if (pos.positionId != 0 && pos.currentState == PositionState.SUPERPOSITION) {
                // Example: Auto-collapse superposition after a certain time
                if (pos.depositTimestamp + 7 days <= block.timestamp) {
                    _transitionState(i, PositionState.RESOLVED); // Auto-resolve after a week
                }
            }
            // Check and remove expired ephemeral traits (also potentially gas heavy)
            // Requires careful implementation or external triggering for efficiency
            _cleanExpiredTraits(i);
        }
        // More complex evolution logic here...
    }

     /// @notice Internal or restricted function to modify a position's attributes.
     /// Could be called by `triggerStateEvolution` or other state-changing functions.
     /// @param positionId The ID of the vault position.
     function evolvePositionAttributes(uint256 positionId) internal whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];

        // --- Conceptual Attribute Evolution ---
        // Example: Apply effects based on current state or active traits.
        // if (pos.currentState == PositionState.RESOLVED) {
        //     // Maybe add a permanent (or long-lasting) trait after resolving superposition
        //     applyEphemeralTrait(positionId, keccak256("PostResolutionBonus"), 365 days);
        // }

        // Example: Trait effects (conceptual)
        // for (uint i = 0; i < ephemeralTraits[positionId].length; i++) {
        //     if (ephemeralTraits[positionId][i].expiryTimestamp > block.timestamp) {
        //         bytes32 trait = ephemeralTraits[positionId][i].traitIdentifier;
        //         if (trait == keccak256("YieldBoost")) {
        //             // Add bonus yield to a separate yield-tracking mechanism
        //             // _addYield(positionId, calculatedBonus);
        //         }
        //     }
        // }
        // --- End Conceptual Evolution ---
     }

     // Internal helper to clean up expired traits (can be gas-intensive)
     function _cleanExpiredTraits(uint256 positionId) internal {
        EphemeralTrait[] storage traits = ephemeralTraits[positionId];
        uint k = 0;
        for (uint i = 0; i < traits.length; ++i) {
            if (traits[i].expiryTimestamp > block.timestamp) {
                if (k != i) {
                    traits[k] = traits[i];
                }
                k++;
            }
        }
        // Resize the array if elements were removed
        if (k < traits.length) {
            assembly {
                mstore(traits.slot, k)
            }
        }
     }

     /// @notice Simulates the vault interacting with another predefined protocol contract.
     /// Restricted access, demonstrates potential for structured protocol interaction.
    /// @param positionId The ID of the vault position providing assets (conceptual).
    /// @param targetContract The address of the target protocol contract.
     function initiateProtocolInteraction(uint256 positionId, address targetContract) external whenNotPaused onlyRole(Role.ADMIN) whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        // Example: Allow interaction only if position is ACTIVE or RESOLVED
        require(pos.currentState == PositionState.ACTIVE || pos.currentState == PositionState.RESOLVED, "Position state prevents external interaction");
        require(targetContract.isContract(), "Target is not a contract");

        // --- Conceptual Interaction ---
        // This would involve transferring assets to the target contract and calling a specific function.
        // For simplicity, this is a placeholder event.
        // Example:
        // if (pos.tokenKind == TokenType.ERC20) {
        //     IERC20(pos.tokenAddress).transfer(targetContract, pos.amountOrTokenId); // Transfer full amount
        //     // Then call a function on targetContract:
        //     // (bool success, bytes memory data) = targetContract.call(abi.encodeWithSignature("doSomething(uint256)", pos.amountOrTokenId));
        //     // require(success, "Protocol interaction failed");
        //     // pos.currentState = PositionState.LOCKED; // Lock position while assets are external
        // }
        // --- End Conceptual Interaction ---

        emit PositionStateChanged(positionId, pos.currentState, PositionState.LOCKED); // Simulate locking position for interaction
        pos.currentState = PositionState.LOCKED; // Lock the position
        pos.unlockTimestamp = type(uint256).max; // Lock indefinitely until explicitly unlocked (not implemented)

        // Placeholder event for simulated interaction
        emit PositionCreated(0, address(this), pos.tokenKind, pos.tokenAddress, pos.amountOrTokenId, block.timestamp); // Re-using event for simulation
        emit PositionStateChanged(0, PositionState.ACTIVE, PositionState.DEACTIVATED); // Re-using event for simulation
        emit EmergencyWithdrawal(targetContract, 0); // Re-using event as a placeholder for 'interaction initiated'
     }

    /// @notice Allows a user to claim hypothetical yield generated by their position.
    /// Yield calculation and accumulation mechanism is simplified/conceptual here.
    /// @param positionId The ID of the vault position.
    function redeemVaultYield(uint256 positionId) external whenNotPaused whenPositionExists(positionId) {
        VaultPosition storage pos = vaultPositions[positionId];
        require(pos.user == msg.sender, "Not your position");
        require(pos.currentState != PositionState.SUPERPOSITION && pos.currentState != PositionState.ENTANGLED && pos.currentState != PositionState.LOCKED, QuantumVault__PositionCannotBeRedeemed(pos.currentState));
        require(pos.tokenKind == TokenType.ERC20, "Yield redemption only for ERC20 positions (conceptual)");

        // --- Conceptual Yield Calculation ---
        // In a real contract, yield would accumulate based on state, time, traits, external interaction.
        // This requires separate mappings/logic to track yield per position.
        // For simplicity, let's assume a small fixed yield per redemption (bad practice, just for demo).
        uint256 claimedYield = 1 ether; // Example: 1 ether of the deposited token (very basic)

        // Check if vault has enough tokens (the claimed yield comes from the vault's holdings)
         address tokenAddress = pos.tokenAddress;
        require(IERC20(tokenAddress).balanceOf(address(this)) >= claimedYield, "Vault has insufficient yield tokens");

        // Transfer yield to user
        bool success = IERC20(tokenAddress).transfer(msg.sender, claimedYield);
        require(success, QuantumVault__TokenTransferFailed());

        // In a real system, you would deduct the claimed yield from the user's accumulated yield balance.
        // Example: _userYield[positionId] -= claimedYield;

        emit PositionYieldRedeemed(positionId, msg.sender, claimedYield);
    }


    // --- Access Control & Governance ---

    /// @notice Assigns a specific role to an address for a particular feature or globally.
    /// @param user The address to assign the role to.
    /// @param role The role to assign (NONE, ADMIN, ORACLE).
    function setAccessRole(address user, bytes32 featureHash, Role role) external onlyOwner whenNotPaused {
        require(user != address(0), "Invalid address");
        _accessRoles[user][featureHash] = role;
        emit AccessRoleSet(user, featureHash, role);
    }

    /// @notice Registers an address as an oracle.
    /// @param oracle The address to register.
    function registerOracleAddress(address oracle) external onlyOwner whenNotPaused {
        require(oracle != address(0), "Invalid address");
        _isOracle[oracle] = true;
        emit OracleRegistered(oracle);
    }

     /// @notice Proposes an amendment to a contract configuration parameter.
     /// @param parameterHash Hash identifier of the parameter (e.g., keccak256("MIN_TRAIT_DURATION")).
     /// @param newValueEncoded The new value ABI-encoded (e.g., `abi.encode(newDuration)`).
     function proposeConfigAmendment(bytes32 parameterHash, bytes memory newValueEncoded) external whenNotPaused onlyOwner {
         // Prevent proposing amendments for parameters that are already active or have pending proposals
         // Simplified check: check if finalized or proposed
         require(configAmendments[parameterHash].proposalTimestamp == 0 || configAmendments[parameterHash].finalized, "Amendment already proposed or active");

         configAmendments[parameterHash] = ConfigAmendment({
             parameterHash: parameterHash,
             newValueEncoded: newValueEncoded,
             proposer: msg.sender,
             proposalTimestamp: block.timestamp,
             finalized: false,
             approved: false, // Requires explicit owner approval before grace period (simplified)
             gracePeriodEnd: block.timestamp + CONFIG_AMENDMENT_GRACE_PERIOD // Configurable grace period
         });

         activeConfigAmendments.push(parameterHash); // Add to tracking list (can be gas-intensive over time)

         emit ConfigAmendmentProposed(parameterHash, msg.sender, block.timestamp);
     }

     /// @notice Finalizes a proposed configuration change after the grace period has passed and it's approved.
     /// @param parameterHash Hash identifier of the parameter.
     function finalizeConfigAmendment(bytes32 parameterHash) external whenNotPaused onlyOwner {
        ConfigAmendment storage amendment = configAmendments[parameterHash];
        require(amendment.proposalTimestamp != 0, QuantumVault__ConfigAmendmentNotFound());
        require(!amendment.finalized, QuantumVault__ConfigAmendmentAlreadyFinalized());
        require(amendment.approved, "Amendment not approved by owner"); // Simplified approval
        require(block.timestamp >= amendment.gracePeriodEnd, QuantumVault__ConfigAmendmentNotReady());

        // --- Apply the Configuration Change ---
        // This requires decoding newValueEncoded and applying it based on parameterHash
        if (parameterHash == MIN_EPHEMERAL_TRAIT_DURATION_HASH) {
            uint256 newDuration = abi.decode(amendment.newValueEncoded, (uint256));
            // Assuming MIN_EPHEMERAL_TRAIT_DURATION is a state variable, this would set it.
            // As it's 'constant' in this example, this would require contract upgrade or a different structure.
            // For a real contract, this constant would be a state variable: `uint256 public minEphemeralTraitDuration;`
            // And here you would set: `minEphemeralTraitDuration = newDuration;`
             revert("Cannot change constant parameter via amendment in this example"); // Indicate this needs state variable
        } else {
            revert(QuantumVault__InvalidConfigAmendmentValue()); // Handle unknown parameters
        }
        // --- End Apply Change ---

        amendment.finalized = true;

        // Remove from active list (potentially gas-intensive)
        // Find index and swap with last, then pop.
        uint256 indexToRemove = type(uint256).max;
        for(uint i = 0; i < activeConfigAmendments.length; i++) {
            if (activeConfigAmendments[i] == parameterHash) {
                indexToRemove = i;
                break;
            }
        }
        if (indexToRemove != type(uint256).max) {
             if (indexToRemove != activeConfigAmendments.length - 1) {
                activeConfigAmendments[indexToRemove] = activeConfigAmendments[activeConfigAmendments.length - 1];
            }
            activeConfigAmendments.pop();
        }


        emit ConfigAmendmentFinalized(parameterHash, amendment.newValueEncoded);
     }

     // Function for owner to approve a config amendment (simplified)
     function approveConfigAmendment(bytes32 parameterHash) external onlyOwner whenNotPaused {
         ConfigAmendment storage amendment = configAmendments[parameterHash];
         require(amendment.proposalTimestamp != 0 && !amendment.finalized, "Amendment not found or already finalized");
         amendment.approved = true;
     }


    // --- Utility & Information ---

    /// @notice Gets the total balance of a specific ERC20 token held by the vault.
    /// @param tokenAddress The address of the ERC20 token.
    /// @return The total balance.
    function getERC20Balance(address tokenAddress) external view returns (uint256) {
        return IERC20(tokenAddress).balanceOf(address(this));
    }

    /// @notice Retrieves a list of position IDs owned by a specific user.
    /// WARNING: Iterating over all positions can be very gas-intensive for many users/positions.
    /// This is conceptual; efficient implementation requires mapping user => positionIds.
    /// @param user The user's address.
    /// @return An array of position IDs owned by the user.
    function getUserVaultPositions(address user) external view returns (uint256[] memory) {
        uint256[] memory userPositions = new uint256[](_positionCounter); // Overallocate
        uint256 count = 0;
        // This loop is highly inefficient for many positions
        for (uint256 i = 1; i <= _positionCounter; i++) {
            if (vaultPositions[i].user == user && vaultPositions[i].positionId != 0 && vaultPositions[i].currentState != PositionState.DEACTIVATED) {
                userPositions[count] = i;
                count++;
            }
        }
        // Resize the array
        uint256[] memory result = new uint256[](count);
        for(uint256 i = 0; i < count; i++) {
            result[i] = userPositions[i];
        }
        return result;
    }

    /// @notice Counts the number of unique ERC721 contract addresses with tokens currently in the vault.
    /// WARNING: Iterating over all positions is gas-intensive. Conceptual.
    /// @return The count of unique ERC721 contracts.
    function getTotalERC721Types() external view returns (uint256) {
         mapping(address => bool) uniqueContracts;
         uint256 count = 0;
        // This loop is highly inefficient for many positions
         for (uint256 i = 1; i <= _positionCounter; i++) {
             if (vaultPositions[i].positionId != 0 && vaultPositions[i].tokenKind == TokenType.ERC721 && vaultPositions[i].amountOrTokenId != 0) { // Check if NFT is still in position
                 address contractAddress = vaultPositions[i].tokenAddress;
                 if (!uniqueContracts[contractAddress]) {
                     uniqueContracts[contractAddress] = true;
                     count++;
                 }
             }
         }
         return count;
    }


    // --- Security & Maintenance ---

    /// @notice Allows the owner to withdraw stuck ERC20 tokens in emergency.
    /// @param tokenAddress The address of the ERC20 token.
    function emergencyWithdraw(address tokenAddress) external onlyOwner whenPaused {
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, "No balance to withdraw");
        bool success = IERC20(tokenAddress).transfer(owner(), balance);
        require(success, QuantumVault__TokenTransferFailed());
        emit EmergencyWithdrawal(tokenAddress, balance);
    }

     /// @notice Allows the owner to withdraw a stuck ERC721 token in emergency.
     /// @param tokenAddress The address of the ERC721 token contract.
     /// @param tokenId The ID of the token.
     function emergencyWithdrawERC721(address tokenAddress, uint256 tokenId) external onlyOwner whenPaused {
         // Check if the vault actually holds this specific token
         address currentOwner = IERC721(tokenAddress).ownerOf(tokenId);
         require(currentOwner == address(this), QuantumVault__ERC721NotOwnedByVault());

         IERC721(tokenAddress).safeTransferFrom(address(this), owner(), tokenId);
         emit EmergencyWithdrawal(tokenAddress, tokenId);
     }

    /// @notice Pauses the contract, disabling certain functions.
    function pauseContract() external onlyOwner whenNotPaused {
        _pause();
    }

    /// @notice Unpauses the contract, re-enabling functions.
    function unpauseContract() external onlyOwner whenPaused {
        _unpause();
    }

    // Override required for ERC721Holder
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public override returns (bytes4) {
        // This function is called when an ERC721 is transferred *to* this contract.
        // The deposit functions handle the actual position creation.
        // We return the ERC721 received magic value to acknowledge receipt.
        // operator is the address that caused the transfer (often msg.sender of safeTransferFrom)
        // from is the address the token was transferred from
        // tokenId is the id of the token being transferred
        // data is arbitrary data sent with the transfer
        return this.onERC721Received.selector;
    }

    // Helper function to demonstrate retrieval of ephemeral traits (public view)
     function getEphemeralTraits(uint256 positionId) external view whenPositionExists(positionId) returns (EphemeralTrait[] memory) {
         // Clean up expired traits conceptually for the view, though state isn't changed
        EphemeralTrait[] storage currentTraits = ephemeralTraits[positionId];
        uint k = 0;
        for (uint i = 0; i < currentTraits.length; ++i) {
            if (currentTraits[i].expiryTimestamp > block.timestamp) {
                 // This is a view function, cannot modify state (k != i optimization skipped)
                k++;
            }
        }

         EphemeralTrait[] memory activeTraits = new EphemeralTrait[](k);
         k = 0;
         for (uint i = 0; i < currentTraits.length; ++i) {
            if (currentTraits[i].expiryTimestamp > block.timestamp) {
                activeTraits[k] = currentTraits[i];
                k++;
            }
         }
         return activeTraits;
     }

     // Overriding the default Ownable transferOwnership to add a check
     function transferOwnership(address newOwner) public override onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
         // Optional: Add a time lock or acceptance process for ownership transfer
        super.transferOwnership(newOwner);
    }

    // Add any internal functions needed for logic separation
}
```