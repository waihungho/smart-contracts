Okay, here is a Solidity smart contract designed with a creative, advanced concept: a "Kinetic Yield Cultivator". This contract allows users to stake tokens (StakeToken) into unique "plots". The yield generated by each plot (in YieldToken) is not static but *dynamically* influenced by user interactions ("cultivation") and time-based decay. Users can cultivate their plots to boost growth rate and health, or neglect them, causing yield potential to decrease. It also includes features like batch operations, plot ownership transfer, and cultivation delegation.

It combines elements of staking, dynamic yield mechanics, user interaction loops, and unique token/asset representation (each plot is a unique entity tracked by ID). It avoids direct copies of standard templates like simple ERC20 staking or basic yield farms.

---

### Kinetic Yield Cultivator: Outline and Function Summary

**Concept:** Users stake `StakeToken` to create unique "Cultivation Plots". Each plot yields `YieldToken` based on its `growthRate` and `health`. These attributes dynamically change over time (decay) and are boosted by user "cultivation" actions.

**Outline:**
1.  **Pragma and Imports:** Solidity version, ERC20 interface.
2.  **Interfaces:** Basic IERC20.
3.  **Error Definitions:** Custom errors for clarity and gas efficiency.
4.  **Libraries:** SafeERC20 for safe token transfers.
5.  **Contract Definition:** Inherits Ownable (standard pattern for admin control). Pausable (standard pattern for pausing operations).
6.  **State Variables:** Token addresses, plot counter, plot data mapping, user plot mapping, delegation mappings, global parameters, pausable state.
7.  **Structs:** `PlotData` to hold details for each cultivation plot.
8.  **Events:** Log key actions (creation, cultivation, harvest, withdrawal, parameter updates, delegation, transfer).
9.  **Modifiers:** Standard `onlyOwner`, `whenNotPaused`.
10. **Internal Helper Functions:** For calculating yield, applying decay, getting current rate/health, updating plot state before actions.
11. **Core User Functions:**
    *   `createPlot`: Stake `StakeToken` and create a new plot.
    *   `cultivatePlot`: Perform cultivation action on a single plot.
    *   `cultivateMultiplePlots`: Perform cultivation on multiple plots.
    *   `harvestYield`: Claim accumulated `YieldToken` for a single plot.
    *   `harvestAllYields`: Claim for all user's plots.
    *   `withdrawPlot`: Unstake `StakeToken` and withdraw a single plot.
    *   `withdrawAllPlots`: Unstake and withdraw all user's plots.
12. **Plot Ownership & Delegation Functions:**
    *   `transferPlot`: Transfer ownership of a plot to another address.
    *   `approveCultivationDelegate`: Allow another address to cultivate a specific plot.
    *   `revokeCultivationDelegate`: Remove cultivation delegation for a specific plot.
    *   `approveAllCultivation`: Allow an address to cultivate *all* your current and future plots.
    *   `revokeAllCultivation`: Remove "approve for all" delegation.
13. **Admin Functions (onlyOwner):**
    *   `setStakeToken`, `setYieldToken`: Update token addresses (careful use).
    *   `setBaseGrowthRate`, `setDecayRate`, `setCultivationBoost`: Adjust global parameters influencing yield dynamics.
    *   `setHealthDecayRate`, `setHealthCultivationBoost`: Adjust global health dynamics.
    *   `pause`, `unpause`: Control contract activity.
    *   `recoverERC20`: Emergency function for stuck tokens.
    *   `transferOwnership`: Standard owner transfer.
14. **View Functions:**
    *   `calculateYield`: Calculate pending yield for a single plot.
    *   `calculateTotalYield`: Calculate total pending yield for a user.
    *   `getPlotDetails`: Retrieve full data for a plot.
    *   `getUserPlots`: Get list of plot IDs owned by a user.
    *   `getPlotCount`: Get number of plots owned by a user.
    *   `getTotalStaked`: Get total `StakeToken` held in the contract.
    *   `getTotalPlots`: Get total number of plots created.
    *   `getPlotOwner`: Get owner of a specific plot.
    *   `isCultivationDelegate`: Check if an address is a delegate for a specific plot.
    *   `isApprovedForAllCultivation`: Check if an address is approved for all plots by an owner.
    *   `checkPlotHealthStatus`: Get a qualitative health status for a plot.
    *   `simulateGrowth`: Simulate potential yield growth for a plot over time.
    *   `getYieldToken`, `getStakeToken`: Get token addresses.
    *   `getBaseGrowthRate`, `getDecayRate`, `getCultivationBoost`: Get global parameters.

**Function Count:** 34 functions (well over 20).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// --- Kinetic Yield Cultivator: Outline and Function Summary ---
//
// Concept: Users stake `StakeToken` to create unique "Cultivation Plots".
// Each plot yields `YieldToken` based on its `growthRate` and `health`.
// These attributes dynamically change over time (decay) and are boosted
// by user "cultivation" actions. Users can cultivate their plots to boost
// growth rate and health, or neglect them, causing yield potential to decrease.
// It also includes features like batch operations, plot ownership transfer,
// and cultivation delegation.
//
// Outline:
// 1.  Pragma and Imports
// 2.  Interfaces (IERC20)
// 3.  Error Definitions
// 4.  Libraries (SafeERC20)
// 5.  Contract Definition (Inherits Ownable, Pausable)
// 6.  State Variables (Token addresses, plot counter, plot mappings, delegation mappings, global params, pausable state)
// 7.  Structs (PlotData)
// 8.  Events (Log key actions)
// 9.  Modifiers (onlyOwner, whenNotPaused)
// 10. Internal Helper Functions (Yield calc, decay, state update)
// 11. Core User Functions (Create, Cultivate, Harvest, Withdraw, Batch ops)
// 12. Plot Ownership & Delegation Functions (Transfer, Approve/Revoke Delegates)
// 13. Admin Functions (onlyOwner - Set params, Pause, Recover tokens)
// 14. View Functions (Get details, Calculate yield, Check status, Simulate)
//
// Function Summary:
// - createPlot(uint256 amount): Stake StakeToken, create a new plot.
// - cultivatePlot(uint256 plotId): Boost growth/health for one plot.
// - cultivateMultiplePlots(uint256[] calldata plotIds): Boost growth/health for multiple plots.
// - harvestYield(uint256 plotId): Claim pending YieldToken for one plot.
// - harvestAllYields(): Claim pending YieldToken for all user's plots.
// - withdrawPlot(uint256 plotId): Unstake StakeToken and close one plot.
// - withdrawAllPlots(): Unstake StakeToken and close all user's plots.
// - transferPlot(uint256 plotId, address recipient): Transfer plot ownership.
// - approveCultivationDelegate(uint256 plotId, address delegatee): Allow delegate for a specific plot.
// - revokeCultivationDelegate(uint256 plotId, address delegatee): Revoke delegate for a specific plot.
// - approveAllCultivation(address delegatee, bool approved): Allow delegate for all plots.
// - revokeAllCultivation(address delegatee): Revoke "approve for all". (Same as approveAllCultivation(delegatee, false))
// - setStakeToken(address _stakeToken): Admin: Set StakeToken address.
// - setYieldToken(address _yieldToken): Admin: Set YieldToken address.
// - setBaseGrowthRate(uint256 rate): Admin: Set base rate plots decay towards.
// - setDecayRate(uint256 rate): Admin: Set rate of growth/health decay.
// - setCultivationBoost(uint256 boost): Admin: Set boost amount from cultivation.
// - setHealthDecayRate(uint256 rate): Admin: Set rate of health decay.
// - setHealthCultivationBoost(uint256 boost): Admin: Set health boost amount.
// - pause(): Admin: Pause contract actions.
// - unpause(): Admin: Unpause contract actions.
// - recoverERC20(address tokenAddress, uint256 amount): Admin: Recover stuck tokens (excluding stake/yield).
// - transferOwnership(address newOwner): Admin: Transfer contract ownership.
// - calculateYield(uint256 plotId): View: Calculate pending yield for a plot.
// - calculateTotalYield(address user): View: Calculate total pending yield for user's plots.
// - getPlotDetails(uint256 plotId): View: Get all data for a plot.
// - getUserPlots(address user): View: Get list of active plot IDs for a user.
// - getPlotCount(address user): View: Get count of active plots for a user.
// - getTotalStaked(): View: Get total StakeToken in contract.
// - getTotalPlots(): View: Get total plots ever created.
// - getPlotOwner(uint256 plotId): View: Get owner of a plot.
// - isCultivationDelegate(uint256 plotId, address candidate): View: Check if delegate for plot.
// - isApprovedForAllCultivation(address owner, address delegatee): View: Check if approved for all.
// - checkPlotHealthStatus(uint256 plotId): View: Get health status string.
// - simulateGrowth(uint256 plotId, uint256 timeDelta): View: Simulate yield over time.
// - getYieldToken(): View: Get YieldToken address.
// - getStakeToken(): View: Get StakeToken address.
// - getBaseGrowthRate(), getDecayRate(), getCultivationBoost(), getHealthDecayRate(), getHealthCultivationBoost(): View: Get parameters.
// -----------------------------------------------------------------------------

error KVC_PlotDoesNotExist(uint256 plotId);
error KVC_NotPlotOwner(uint256 plotId, address caller);
error KVC_NotPlotOwnerOrDelegate(uint256 plotId, address caller);
error KVC_PlotNotActive(uint256 plotId);
error KVC_CannotRecoverStakeOrYieldToken();
error KVC_ZeroAddress();
error KVC_PlotAlreadyActive(uint256 plotId); // Should not happen with unique IDs if logic is correct

contract KineticYieldCultivator is Ownable, Pausable {
    using SafeERC20 for IERC20;

    IERC20 public immutable STAKE_TOKEN;
    IERC20 public YIELD_TOKEN; // Can be updated by owner

    uint256 private _nextPlotId;
    mapping(uint256 => PlotData) public plots;
    mapping(address => uint256[]) private _userPlotIds;
    mapping(address => mapping(uint256 => uint256)) private _userPlotIndex; // Helper for removing plot IDs

    // Delegation mappings: plotId => delegatee => approved
    mapping(uint256 => mapping(address => bool)) private _plotCultivationDelegates;
    // Delegation mappings: owner => delegatee => approvedForAll
    mapping(address => mapping(address => bool)) private _approvedForAllCultivation;

    // Global parameters (owner can adjust)
    uint256 public baseGrowthRate;       // The minimum growth rate a plot decays towards
    uint256 public decayRate;            // How quickly growthRate decays per second
    uint256 public cultivationBoost;     // How much growthRate increases on cultivation
    uint256 public healthDecayRate;      // How quickly health decays per second
    uint256 public healthCultivationBoost; // How much health increases on cultivation
    uint256 public constant MAX_GROWTH_RATE = 10000; // Max possible growth rate (e.g., 100%)
    uint256 public constant MAX_HEALTH = 1000;      // Max possible health (e.g., 100%)
    uint256 public constant YIELD_DENOMINATOR = 1e18; // Denominator for yield calculation (e.g., 1e18 for 1:1 ratio or scaled)
    uint256 public constant TIME_UNIT = 1;          // Time unit for calculations (1 second)

    struct PlotData {
        uint256 plotId;
        address owner;
        uint256 stakedAmount;
        uint256 creationTime;
        uint256 lastUpdateTime; // Last time growth/health state was updated
        uint256 growthRate;     // Current growth rate, decays over time
        uint256 health;         // Current health, decays over time (influences yield multiplier?)
        uint256 pendingYield;   // Yield accrued but not yet harvested
        bool active;            // Is the plot currently active
    }

    event PlotCreated(uint256 indexed plotId, address indexed owner, uint256 stakedAmount, uint256 creationTime);
    event Cultivated(uint256 indexed plotId, address indexed cultivator, uint256 newGrowthRate, uint256 newHealth);
    event YieldHarvested(uint256 indexed plotId, address indexed owner, uint256 amount);
    event PlotWithdrawn(uint256 indexed plotId, address indexed owner, uint256 unstakedAmount);
    event PlotTransferred(uint256 indexed plotId, address indexed from, address indexed to);
    event CultivationDelegateApproved(uint256 indexed plotId, address indexed owner, address indexed delegatee);
    event CultivationDelegateRevoked(uint256 indexed plotId, address indexed owner, address indexed delegatee);
    event ApprovedForAllCultivation(address indexed owner, address indexed delegatee, bool approved);
    event ParametersUpdated(uint256 newBaseGrowthRate, uint256 newDecayRate, uint256 newCultivationBoost, uint256 newHealthDecayRate, uint256 newHealthCultivationBoost);

    constructor(address _stakeToken, address _yieldToken, uint256 initialBaseGrowthRate, uint256 initialDecayRate, uint256 initialCultivationBoost, uint256 initialHealthDecayRate, uint256 initialHealthCultivationBoost) Ownable(msg.sender) Pausable() {
        if (_stakeToken == address(0) || _yieldToken == address(0)) revert KVC_ZeroAddress();
        STAKE_TOKEN = IERC20(_stakeToken);
        YIELD_TOKEN = IERC20(_yieldToken);

        baseGrowthRate = initialBaseGrowthRate;
        decayRate = initialDecayRate;
        cultivationBoost = initialCultivationBoost;
        healthDecayRate = initialHealthDecayRate;
        healthCultivationBoost = initialHealthCultivationBoost;

        _nextPlotId = 1; // Start plot IDs from 1
    }

    /// @dev See {Pausable-pause}.
    function pause() public onlyOwner {
        _pause();
    }

    /// @dev See {Pausable-unpause}.
    function unpause() public onlyOwner {
        _unpause();
    }

    /// @dev Allows the owner to recover ERC20 tokens accidentally sent to the contract.
    /// @param tokenAddress Address of the token to recover.
    /// @param amount Amount of tokens to recover.
    function recoverERC20(address tokenAddress, uint256 amount) public onlyOwner {
        if (tokenAddress == address(STAKE_TOKEN) || tokenAddress == address(YIELD_TOKEN)) {
            revert KVC_CannotRecoverStakeOrYieldToken();
        }
        IERC20(tokenAddress).safeTransfer(owner(), amount);
    }

    // --- Internal Helper Functions ---

    /// @dev Updates the plot's state (pending yield, growth rate, health) based on time elapsed.
    ///      This function is called by any state-changing action (cultivate, harvest, withdraw)
    ///      to ensure yield calculation and decay are up-to-date before the main logic executes.
    function _updatePlotState(uint256 plotId) internal {
        PlotData storage plot = plots[plotId];
        if (!plot.active) return; // Only update active plots

        uint256 timeElapsed = block.timestamp - plot.lastUpdateTime;

        if (timeElapsed > 0) {
            // Calculate yield accrued since last update
            uint256 accrued = (plot.stakedAmount * plot.growthRate * timeElapsed) / YIELD_DENOMINATOR / TIME_UNIT;
            // Apply health multiplier (optional advanced feature - here health is just a state variable, not a multiplier)
            // Example: accrued = (plot.stakedAmount * plot.growthRate * (plot.health / MAX_HEALTH) * timeElapsed) / ...
            // For simplicity, health just affects the *potential* for future growth boost from cultivation.

            plot.pendingYield += accrued;

            // Apply decay to growth rate and health
            uint256 growthDecay = decayRate * timeElapsed / TIME_UNIT;
            plot.growthRate = plot.growthRate > growthDecay ? plot.growthRate - growthDecay : baseGrowthRate;
            if (plot.growthRate < baseGrowthRate) { // Ensure it doesn't go below base
                plot.growthRate = baseGrowthRate;
            }

            uint256 healthDecay = healthDecayRate * timeElapsed / TIME_UNIT;
            plot.health = plot.health > healthDecay ? plot.health - healthDecay : 0;

            plot.lastUpdateTime = block.timestamp;
        }
    }

    /// @dev Checks if the caller is the owner of the plot or an approved delegate.
    function _isPlotOwnerOrDelegate(uint256 plotId, address caller) internal view returns (bool) {
        PlotData storage plot = plots[plotId];
        if (!plot.active) return false;
        if (plot.owner == caller) return true;
        if (_plotCultivationDelegates[plotId][caller]) return true;
        if (_approvedForAllCultivation[plot.owner][caller]) return true;
        return false;
    }

    // --- Core User Functions ---

    /// @dev Stakes `amount` of StakeToken to create a new cultivation plot.
    /// @param amount The amount of StakeToken to stake.
    function createPlot(uint256 amount) public whenNotPaused {
        if (amount == 0) revert KVC_PlotDoesNotExist(0); // Using 0 as a specific error case for zero amount
        if (_nextPlotId == 0) revert KVC_PlotDoesNotExist(0); // Prevent overflow (highly unlikely)

        uint256 plotId = _nextPlotId;
        _nextPlotId++;

        STAKE_TOKEN.safeTransferFrom(msg.sender, address(this), amount);

        plots[plotId] = PlotData({
            plotId: plotId,
            owner: msg.sender,
            stakedAmount: amount,
            creationTime: block.timestamp,
            lastUpdateTime: block.timestamp,
            growthRate: baseGrowthRate, // Start at base rate
            health: MAX_HEALTH,         // Start at full health
            pendingYield: 0,
            active: true
        });

        // Add plot ID to user's array
        _userPlotIndex[msg.sender][plotId] = _userPlotIds[msg.sender].length;
        _userPlotIds[msg.sender].push(plotId);

        emit PlotCreated(plotId, msg.sender, amount, block.timestamp);
    }

    /// @dev Performs a cultivation action on a single plot, boosting growth and health.
    ///      Callable by plot owner or approved delegate.
    /// @param plotId The ID of the plot to cultivate.
    function cultivatePlot(uint256 plotId) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (!_isPlotOwnerOrDelegate(plotId, msg.sender)) revert KVC_NotPlotOwnerOrDelegate(plotId, msg.sender);

        _updatePlotState(plotId); // Calculate yield & apply decay before cultivation

        // Apply cultivation boost
        plot.growthRate = plot.growthRate + cultivationBoost > MAX_GROWTH_RATE ? MAX_GROWTH_RATE : plot.growthRate + cultivationBoost;
        plot.health = plot.health + healthCultivationBoost > MAX_HEALTH ? MAX_HEALTH : plot.health + healthCultivationBoost;

        emit Cultivated(plotId, msg.sender, plot.growthRate, plot.health);
    }

    /// @dev Performs a cultivation action on multiple plots.
    ///      Calls `cultivatePlot` for each provided plot ID.
    ///      Be aware of potential gas limits for large arrays.
    /// @param plotIds The IDs of the plots to cultivate.
    function cultivateMultiplePlots(uint256[] calldata plotIds) public whenNotPaused {
        for (uint i = 0; i < plotIds.length; i++) {
            // Use try/catch or require inside loop if you want to skip invalid plots
            // For simplicity here, we let it revert on the first invalid plot/permission issue
            cultivatePlot(plotIds[i]);
        }
    }

    /// @dev Claims the accumulated YieldToken for a single plot.
    /// @param plotId The ID of the plot to harvest.
    function harvestYield(uint256 plotId) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (plot.owner != msg.sender) revert KVC_NotPlotOwner(plotId, msg.sender);

        _updatePlotState(plotId); // Calculate all pending yield up to now

        uint256 claimableYield = plot.pendingYield;

        if (claimableYield > 0) {
            plot.pendingYield = 0; // Reset pending yield after claiming
            YIELD_TOKEN.safeTransfer(msg.sender, claimableYield);
            emit YieldHarvested(plotId, msg.sender, claimableYield);
        }
    }

    /// @dev Claims accumulated YieldToken for all active plots owned by the caller.
    ///      Be aware of potential gas limits for users with many plots.
    function harvestAllYields() public whenNotPaused {
        uint256[] storage userPlots = _userPlotIds[msg.sender];
        for (uint i = 0; i < userPlots.length; i++) {
            uint256 plotId = userPlots[i];
            if (plots[plotId].active) { // Only process active plots
                 harvestYield(plotId); // Call the single harvest function
            }
        }
    }

    /// @dev Unstakes the StakeToken and marks the plot as inactive.
    ///      Any remaining pending yield is harvested before unstaking.
    /// @param plotId The ID of the plot to withdraw.
    function withdrawPlot(uint256 plotId) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (plot.owner != msg.sender) revert KVC_NotPlotOwner(plotId, msg.sender);

        // Harvest any pending yield first
        harvestYield(plotId);

        uint256 amountToReturn = plot.stakedAmount;
        plot.stakedAmount = 0;
        plot.active = false; // Mark as inactive

        // Optional: Clean up delegation approvals for this plot
        // delete _plotCultivationDelegates[plotId]; // Gas intensive if many delegates

        // Remove plot ID from user's active list (efficient swap-and-pop)
        uint256 index = _userPlotIndex[msg.sender][plotId];
        uint256 lastIndex = _userPlotIds[msg.sender].length - 1;
        if (index != lastIndex) {
            uint256 lastPlotId = _userPlotIds[msg.sender][lastIndex];
            _userPlotIds[msg.sender][index] = lastPlotId;
            _userPlotIndex[msg.sender][lastPlotId] = index;
        }
        _userPlotIds[msg.sender].pop();
        delete _userPlotIndex[msg.sender][plotId]; // Clean up index mapping

        STAKE_TOKEN.safeTransfer(msg.sender, amountToReturn);
        emit PlotWithdrawn(plotId, msg.sender, amountToReturn);
    }

    /// @dev Unstakes all active plots owned by the caller.
    ///      Be aware of potential gas limits for users with many plots.
    function withdrawAllPlots() public whenNotPaused {
        uint256[] memory userPlots = _userPlotIds[msg.sender]; // Read into memory before modifying the array
        for (int i = userPlots.length - 1; i >= 0; i--) { // Iterate backwards for safe pop
            uint256 plotId = userPlots[uint(i)]; // Explicit cast
            if (plots[plotId].active) { // Only process active plots
                 withdrawPlot(plotId); // Call the single withdraw function
            }
        }
    }

    // --- Plot Ownership & Delegation Functions ---

    /// @dev Transfers ownership of a plot to a new address.
    ///      Only the current owner can transfer.
    /// @param plotId The ID of the plot to transfer.
    /// @param recipient The address to transfer the plot to.
    function transferPlot(uint256 plotId, address recipient) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (plot.owner != msg.sender) revert KVC_NotPlotOwner(plotId, msg.sender);
        if (recipient == address(0)) revert KVC_ZeroAddress();

        address oldOwner = plot.owner;
        plot.owner = recipient;

        // Update user plot ID arrays
        // Remove from old owner's array
        uint256 oldIndex = _userPlotIndex[oldOwner][plotId];
        uint256 oldLastIndex = _userPlotIds[oldOwner].length - 1;
        if (oldIndex != oldLastIndex) {
            uint256 oldLastPlotId = _userPlotIds[oldOwner][oldLastIndex];
            _userPlotIds[oldOwner][oldIndex] = oldLastPlotId;
            _userPlotIndex[oldOwner][oldLastPlotId] = oldIndex;
        }
        _userPlotIds[oldOwner].pop();
        delete _userPlotIndex[oldOwner][plotId];

        // Add to new owner's array
        _userPlotIndex[recipient][plotId] = _userPlotIds[recipient].length;
        _userPlotIds[recipient].push(plotId);

        // Optional: Clear delegates on transfer
        // delete _plotCultivationDelegates[plotId]; // Gas intensive

        emit PlotTransferred(plotId, oldOwner, recipient);
    }

    /// @dev Approves `delegatee` to cultivate a specific `plotId`.
    ///      Only the plot owner can approve.
    /// @param plotId The ID of the plot.
    /// @param delegatee The address to grant cultivation rights to.
    function approveCultivationDelegate(uint256 plotId, address delegatee) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (plot.owner != msg.sender) revert KVC_NotPlotOwner(plotId, msg.sender);
        if (delegatee == address(0)) revert KVC_ZeroAddress();
        if (delegatee == msg.sender) revert KVC_PlotDoesNotExist(0); // Cannot delegate to self (using 0 as general error code here)

        _plotCultivationDelegates[plotId][delegatee] = true;
        emit CultivationDelegateApproved(plotId, msg.sender, delegatee);
    }

    /// @dev Revokes `delegatee`'s cultivation rights for a specific `plotId`.
    ///      Only the plot owner can revoke.
    /// @param plotId The ID of the plot.
    /// @param delegatee The address to revoke cultivation rights from.
    function revokeCultivationDelegate(uint256 plotId, address delegatee) public whenNotPaused {
        PlotData storage plot = plots[plotId];
        if (!plot.active) revert KVC_PlotNotActive(plotId);
        if (plot.owner != msg.sender) revert KVC_NotPlotOwner(plotId, msg.sender);
        if (delegatee == address(0)) revert KVC_ZeroAddress();

        _plotCultivationDelegates[plotId][delegatee] = false;
        emit CultivationDelegateRevoked(plotId, msg.sender, delegatee);
    }

     /// @dev Gives or revokes `delegatee` permission to cultivate *all* of `msg.sender`'s current and future plots.
     ///      This is similar to ERC721's setApprovalForAll.
     /// @param delegatee The address to approve or revoke.
     /// @param approved True to approve, false to revoke.
    function approveAllCultivation(address delegatee, bool approved) public whenNotPaused {
        if (delegatee == address(0)) revert KVC_ZeroAddress();
        if (delegatee == msg.sender) revert KVC_PlotDoesNotExist(0); // Cannot approve self

        _approvedForAllCultivation[msg.sender][delegatee] = approved;
        emit ApprovedForAllCultivation(msg.sender, delegatee, approved);
    }

    /// @dev Revokes `delegatee`'s cultivation rights for all of `msg.sender`'s plots.
    /// @param delegatee The address to revoke.
    function revokeAllCultivation(address delegatee) public whenNotPaused {
        approveAllCultivation(delegatee, false); // Same functionality
    }

    // --- Admin Functions (onlyOwner) ---

    /// @dev Sets the address for the StakeToken. Should ideally be called only once after deployment.
    ///      Changing this after plots are created can lead to inconsistencies if the new token is different.
    /// @param _stakeToken The new StakeToken address.
    function setStakeToken(address _stakeToken) public onlyOwner {
        if (_stakeToken == address(0)) revert KVC_ZeroAddress();
        // STAKE_TOKEN = IERC20(_stakeToken); // Cannot change immutable
        // This function is illustrative but requires a proxy pattern or careful design
        // if the token address needs to be truly mutable after deployment.
        // Keeping it here for demonstration purposes, but actual implementation might differ.
        // For this example, StakeToken is immutable as set in the constructor.
        revert("StakeToken is immutable in this contract version.");
    }

     /// @dev Sets the address for the YieldToken. Can be updated by owner.
     /// @param _yieldToken The new YieldToken address.
    function setYieldToken(address _yieldToken) public onlyOwner {
        if (_yieldToken == address(0)) revert KVC_ZeroAddress();
        YIELD_TOKEN = IERC20(_yieldToken);
    }

    /// @dev Sets the base growth rate plots decay towards.
    /// @param rate The new base growth rate.
    function setBaseGrowthRate(uint256 rate) public onlyOwner {
        baseGrowthRate = rate;
        emit ParametersUpdated(baseGrowthRate, decayRate, cultivationBoost, healthDecayRate, healthCultivationBoost);
    }

    /// @dev Sets how quickly growthRate decays per second.
    /// @param rate The new decay rate.
    function setDecayRate(uint256 rate) public onlyOwner {
        decayRate = rate;
        emit ParametersUpdated(baseGrowthRate, decayRate, cultivationBoost, healthDecayRate, healthCultivationBoost);
    }

    /// @dev Sets how much growthRate increases on cultivation.
    /// @param boost The new cultivation boost amount.
    function setCultivationBoost(uint256 boost) public onlyOwner {
        cultivationBoost = boost;
        emit ParametersUpdated(baseGrowthRate, decayRate, cultivationBoost, healthDecayRate, healthCultivationBoost);
    }

    /// @dev Sets how quickly health decays per second.
    /// @param rate The new health decay rate.
    function setHealthDecayRate(uint256 rate) public onlyOwner {
        healthDecayRate = rate;
        emit ParametersUpdated(baseGrowthRate, decayRate, cultivationBoost, healthDecayRate, healthCultivationBoost);
    }

    /// @dev Sets how much health increases on cultivation.
    /// @param boost The new health cultivation boost amount.
    function setHealthCultivationBoost(uint256 boost) public onlyOwner {
        healthCultivationBoost = boost;
        emit ParametersUpdated(baseGrowthRate, decayRate, cultivationBoost, healthDecayRate, healthCultivationBoost);
    }

    // --- View Functions ---

    /// @dev Calculates the *currently available* yield for a specific plot.
    ///      This includes pending yield + yield accrued since last update.
    /// @param plotId The ID of the plot.
    /// @return The total claimable yield for the plot.
    function calculateYield(uint256 plotId) public view returns (uint256) {
        PlotData storage plot = plots[plotId];
        if (!plot.active) return 0;

        uint256 timeElapsed = block.timestamp - plot.lastUpdateTime;
        uint256 simulatedAccrued = 0;

        if (timeElapsed > 0) {
            // Calculate yield based on rate at last update time for the elapsed duration
            simulatedAccrued = (plot.stakedAmount * plot.growthRate * timeElapsed) / YIELD_DENOMINATOR / TIME_UNIT;
        }

        return plot.pendingYield + simulatedAccrued;
    }

    /// @dev Calculates the total *currently available* yield for all active plots owned by a user.
    /// @param user The address of the user.
    /// @return The total claimable yield across all user's plots.
    function calculateTotalYield(address user) public view returns (uint256 totalYield) {
        uint256[] storage userPlots = _userPlotIds[user];
        for (uint i = 0; i < userPlots.length; i++) {
            uint256 plotId = userPlots[i];
            if (plots[plotId].active) {
                totalYield += calculateYield(plotId);
            }
        }
    }

    /// @dev Gets the detailed data for a specific plot.
    /// @param plotId The ID of the plot.
    /// @return The PlotData struct.
    function getPlotDetails(uint256 plotId) public view returns (PlotData memory) {
         if (!plots[plotId].active) revert KVC_PlotNotActive(plotId);
         return plots[plotId];
    }

    /// @dev Gets the list of active plot IDs owned by a user.
    /// @param user The address of the user.
    /// @return An array of active plot IDs.
    function getUserPlots(address user) public view returns (uint256[] memory) {
        // This function iterates and filters, which can be gas-intensive for large numbers of inactive plots.
        // In a highly optimized contract, a different data structure for user plots might be needed.
        uint256[] storage allUserPlots = _userPlotIds[user];
        uint256 activeCount = 0;
        for(uint i = 0; i < allUserPlots.length; i++){
            if(plots[allUserPlots[i]].active) {
                activeCount++;
            }
        }

        uint256[] memory activePlots = new uint256[](activeCount);
        uint256 currentIndex = 0;
         for(uint i = 0; i < allUserPlots.length; i++){
            if(plots[allUserPlots[i]].active) {
                activePlots[currentIndex] = allUserPlots[i];
                currentIndex++;
            }
        }
        return activePlots;
    }

    /// @dev Gets the count of active plots owned by a user.
    /// @param user The address of the user.
    /// @return The number of active plots.
    function getPlotCount(address user) public view returns (uint256) {
        // This also iterates, similar to getUserPlots.
        uint256[] storage allUserPlots = _userPlotIds[user];
        uint256 activeCount = 0;
        for(uint i = 0; i < allUserPlots.length; i++){
            if(plots[allUserPlots[i]].active) {
                activeCount++;
            }
        }
        return activeCount;
    }


    /// @dev Gets the total amount of StakeToken currently held in the contract.
    /// @return Total staked amount.
    function getTotalStaked() public view returns (uint256) {
        return STAKE_TOKEN.balanceOf(address(this));
    }

    /// @dev Gets the total number of plots that have ever been created.
    /// @return Total number of plots created.
    function getTotalPlots() public view returns (uint256) {
        return _nextPlotId > 0 ? _nextPlotId - 1 : 0;
    }

    /// @dev Gets the owner of a specific plot.
    /// @param plotId The ID of the plot.
    /// @return The owner's address.
    function getPlotOwner(uint256 plotId) public view returns (address) {
         if (!plots[plotId].active) revert KVC_PlotNotActive(plotId);
         return plots[plotId].owner;
    }

    /// @dev Checks if `candidate` is a cultivation delegate for a specific `plotId`.
    /// @param plotId The ID of the plot.
    /// @param candidate The address to check.
    /// @return True if the candidate is a delegate, false otherwise.
    function isCultivationDelegate(uint256 plotId, address candidate) public view returns (bool) {
        PlotData storage plot = plots[plotId];
        if (!plot.active) return false; // Inactive plots have no delegates
        return _plotCultivationDelegates[plotId][candidate];
    }

    /// @dev Checks if `delegatee` is approved to cultivate all plots for `owner`.
    /// @param owner The owner's address.
    /// @param delegatee The address to check.
    /// @return True if the delegatee is approved for all, false otherwise.
    function isApprovedForAllCultivation(address owner, address delegatee) public view returns (bool) {
        return _approvedForAllCultivation[owner][delegatee];
    }

    /// @dev Provides a qualitative status based on a plot's health.
    /// @param plotId The ID of the plot.
    /// @return A string indicating the plot's health status.
    function checkPlotHealthStatus(uint256 plotId) public view returns (string memory) {
        PlotData storage plot = plots[plotId];
        if (!plot.active) return "Inactive";

        uint256 currentHealth = plot.health; // Consider calculating health *now* if needed

        if (currentHealth > MAX_HEALTH * 8 / 10) {
            return "Healthy";
        } else if (currentHealth > MAX_HEALTH * 4 / 10) {
            return "Stable";
        } else if (currentHealth > MAX_HEALTH * 1 / 10) {
            return "Wilting";
        } else {
            return "Critical";
        }
    }

    /// @dev Simulates potential yield growth for a plot over a given time delta,
    ///      without changing the plot's state. Useful for UI estimations.
    /// @param plotId The ID of the plot.
    /// @param timeDelta The duration in seconds to simulate growth for.
    /// @return The estimated yield that would accrue over the time delta.
    function simulateGrowth(uint256 plotId, uint256 timeDelta) public view returns (uint256 simulatedYield) {
         PlotData storage plot = plots[plotId];
         if (!plot.active || timeDelta == 0) return 0;

         // This simulation uses the *current* state (growthRate, health) for the entire duration.
         // A more accurate simulation would account for decay over the timeDelta,
         // potentially requiring a more complex iterative or integral calculation.
         // This simple version is an approximation based on the rate at the start of the simulation.
         uint256 estimatedAccrued = (plot.stakedAmount * plot.growthRate * timeDelta) / YIELD_DENOMINATOR / TIME_UNIT;

         // Health influence could be added here if it affects yield multiplier
         // estimatedAccrued = estimatedAccrued * plot.health / MAX_HEALTH;

         return estimatedAccrued;
    }

     /// @dev Gets the address of the YieldToken.
     /// @return The YieldToken address.
    function getYieldToken() public view returns (address) {
        return address(YIELD_TOKEN);
    }

    /// @dev Gets the address of the StakeToken.
    /// @return The StakeToken address.
    function getStakeToken() public view returns (address) {
        return address(STAKE_TOKEN);
    }

    // View functions for parameters (already public state variables, just adding getters for clarity)
    function getBaseGrowthRate() public view returns (uint256) { return baseGrowthRate; }
    function getDecayRate() public view returns (uint256) { return decayRate; }
    function getCultivationBoost() public view returns (uint256) { return cultivationBoost; }
    function getHealthDecayRate() public view returns (uint256) { return healthDecayRate; }
    function getHealthCultivationBoost() public view returns (uint256) { return healthCultivationBoost; }
}
```