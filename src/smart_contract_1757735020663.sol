This smart contract, `CogniCellEcosystem`, introduces a novel concept of dynamic, evolving digital entities ("CogniCells") represented as ERC721 NFTs. It blends elements of gamified finance (GameFi), decentralized autonomous organizations (DAOs), and adaptive pseudo-AI mechanics driven by on-chain and oracle-fed data. The ecosystem uses two custom ERC20 tokens: `CognosToken` for governance and staking, and `VitalToken` as a reward for thriving CogniCells.

The core idea revolves around CogniCells, whose traits (Resilience, Adaptability, Growth Rate, Complexity) dynamically change over time based on "nourishment" (staked `CognosToken`), global "environmental" factors (simulated via oracle inputs), and their intrinsic "CogniGene" hash. Users can "cultivate" these CogniCells to earn `VitalToken` rewards, with more complex and well-adapted cells yielding higher returns. The ecosystem is governed by `CognosToken` holders through a simplified DAO, allowing for community-driven adjustments to evolution parameters, fee structures, and even the controversial "culling" of stagnant CogniCells to maintain ecosystem health.

## Outline & Function Summary

**Contract:** `CogniCellEcosystem`

This contract establishes a novel, adaptive digital ecosystem where users cultivate unique, evolving digital entities called "CogniCells" (ERC721 NFTs). CogniCells evolve dynamically based on user interactions (staking, 'nourishment'), global ecosystem parameters (pseudo-environmental factors via oracles), and their intrinsic "CogniGene" properties. The ecosystem is governed by `CognosToken` (ERC20), which also serves as the staking token, and rewards thriving CogniCells with `VitalToken` (ERC20).

**I. Core Setup & Administrative Functions**
*   `constructor`: Initializes the ecosystem, deploys `CognosToken`, `VitalToken`, and `CogniCellNFT` contracts, sets up access control roles (Admin, Pauser, Oracle, DAO Governor), and defines initial ecosystem parameters.
*   `updateOracleAddress(address _newOracle)`: Allows the `DEFAULT_ADMIN_ROLE` to update the address of the external data oracle responsible for feeding environmental data.
*   `pause()`: Initiates a system-wide pause in case of emergencies, preventing most state-changing operations. Only callable by the `PAUSER_ROLE`.
*   `unpause()`: Resumes system operations from a paused state. Only callable by the `PAUSER_ROLE`.
*   `withdrawProtocolFees(address _tokenAddress, uint256 _amount)`: Allows the `DEFAULT_ADMIN_ROLE` to withdraw accumulated protocol fees (in `CognosToken` or `VitalToken`) from the contract.

**II. CogniCell (dNFT) Management**
*   `mintCogniCell()`: Mints a new `CogniCellNFT` for the caller. Requires an initial stake of `CognosToken` and generates a unique, immutable `CogniGene` hash for the new cell.
*   `stakeCognosForCogniCell(uint256 _tokenId, uint256 _amount)`: Allows a `CogniCellNFT` owner to stake additional `CognosToken` to their specific CogniCell, providing "nourishment" which influences its evolutionary growth.
*   `unstakeCognosFromCogniCell(uint256 _tokenId, uint256 _amount)`: Allows a `CogniCellNFT` owner to withdraw staked `CognosToken` from their CogniCell. Requires leaving a minimum initial stake.
*   `triggerCogniCellEvolution(uint256 _tokenId)`: A publicly callable function to initiate an evolution cycle for a specified CogniCell. This updates its dynamic traits (Resilience, Adaptability, GrowthRate, Complexity) based on staked `CognosToken`, global ecosystem parameters, its `CogniGene`, and time elapsed since the last evolution.
*   `getEvolutionParameters()`: A view function that returns the current global `EcosystemParams` struct, showing the factors influencing CogniCell evolution.
*   `tokenURI(uint256 _tokenId)`: Overrides the standard ERC721 `tokenURI` function to dynamically generate a Base64-encoded JSON metadata string (including an SVG image) based on the CogniCell's current on-chain traits.

**III. Vital Token (Reward) Management**
*   `claimVitalRewards(uint256[] memory _tokenIds)`: Allows `CogniCellNFT` owners to claim accumulated `VitalToken` rewards generated by their thriving CogniCells. Rewards are minted and transferred.
*   `getPendingVitalRewards(uint256 _tokenId)`: A view function to calculate the pending `VitalToken` rewards for a specific CogniCell since its last claim.
*   `updateVitalEmissionRates(uint256 _newBaseRate, uint256 _newComplexityFactor)`: Allows the `DAO_GOVERNOR_ROLE` to adjust the base emission rate and complexity multiplier for `VitalToken` rewards.

**IV. Decentralized Governance (Simplified DAO)**
*   `submitProposal(address _target, bytes memory _calldata, string memory _description)`: Allows `CognosToken` holders (with a positive balance) to submit proposals for ecosystem changes. Proposals include a target contract, calldata for execution, and a description.
*   `voteOnProposal(uint256 _proposalId, bool _support)`: Allows `CognosToken` holders (or their delegates) to cast their vote (for or against) on an active proposal. Voting power is determined by `CognosToken` balance.
*   `executeProposal(uint256 _proposalId)`: Executed by the `DAO_GOVERNOR_ROLE` for a successfully passed proposal after a timelock period. It checks for quorum, majority approval, and then executes the proposal's embedded calldata.
*   `delegateVote(address _delegatee)`: Allows `CognosToken` holders to delegate their voting power to another address, enabling liquid democracy.
*   `adjustCogniGeneInfluencers(uint256 _newGrowthWeight, uint256 _newAdaptabilityWeight)`: A specific governance action (callable by `DAO_GOVERNOR_ROLE`, typically via a proposal) to adjust how `growthRate` and `adaptability` factors are weighted in the CogniCell evolution algorithm.

**V. Dynamic Adaptive Mechanisms & Advanced Interactions**
*   `updateEcosystemPulse(uint256 _marketVolatilityIndex, uint256 _networkCongestionScore)`: Callable by the `ORACLE_ROLE` to feed external "environmental" data (e.g., market conditions, network activity) into the ecosystem, influencing the global evolution dynamics for all CogniCells.
*   `initiateCogniCellCullProposal(uint256 _tokenId)`: Allows `CognosToken` holders to submit a special governance proposal to "cull" (deactivate) a specific CogniCell, typically due to perceived stagnation or low performance. Requires DAO approval.
*   `setDynamicFeeTier(uint256 _newBaseFee, uint256 _newDemandFactor)`: Allows the `DAO_GOVERNOR_ROLE` to dynamically adjust the protocol fees for certain actions based on ecosystem health or demand, making the contract economically adaptive.
*   `createSymbioticPool()`: Allows users to create a "Symbiotic Pool" by depositing initial `CognosToken` and `VitalToken`. These pools provide a special environment that can accelerate evolution or boost rewards for CogniCells assigned to them.
*   `assignCogniCellToPool(uint256 _tokenId, uint256 _poolId)`: Allows a `CogniCellNFT` owner to assign their CogniCell to an existing `SymbioticPool`, benefiting from its boosts.
*   `queryCogniVerseData(string memory _dataQuery)`: A conceptual function simulating a query to an off-chain "CogniVerse" data source (e.g., via a Chainlink oracle). In a full implementation, the returned data could influence global ecosystem parameters or specific CogniCell evolution.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // For explicit use, though Solidity 0.8+ has built-in overflow checks

// Custom ERC20 for CognosToken
// This token is used for staking, governance, and protocol fees.
contract CognosToken is ERC20, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(address _cogniCellEcosystem) ERC20("CognosToken", "COGNOS") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Deployer is admin
        _grantRole(MINTER_ROLE, _cogniCellEcosystem); // Ecosystem contract can mint
    }

    // Only the MINTER_ROLE (CogniCellEcosystem contract) can mint new COGNOS.
    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {
        _mint(to, amount);
    }
}

// Custom ERC20 for VitalToken
// This token is emitted as a reward by thriving CogniCells.
contract VitalToken is ERC20, AccessControl {
    bytes32 public constant EMITTER_ROLE = keccak256("EMITTER_ROLE");

    constructor(address _cogniCellEcosystem) ERC20("VitalToken", "VITAL") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Deployer is admin
        _grantRole(EMITTER_ROLE, _cogniCellEcosystem); // Ecosystem contract can mint (emit) VITAL
    }

    // Only the EMITTER_ROLE (CogniCellEcosystem contract) can mint new VITAL.
    function mint(address to, uint256 amount) public onlyRole(EMITTER_ROLE) {
        _mint(to, amount);
    }
}

// Custom ERC721 for CogniCell NFTs
// Represents the dynamic, evolving digital entities.
contract CogniCellNFT is ERC721, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(address _cogniCellEcosystem) ERC721("CogniCell", "CGNCL") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Deployer is admin
        _grantRole(MINTER_ROLE, _cogniCellEcosystem); // Ecosystem contract can mint NFTs
    }

    // Only the MINTER_ROLE (CogniCellEcosystem contract) can mint new CogniCells.
    function safeMint(address to, uint256 tokenId) public onlyRole(MINTER_ROLE) {
        _safeMint(to, tokenId);
    }

    // Base URI is empty because tokenURI will be fully dynamic, generated by the Ecosystem contract.
    function _baseURI() internal view virtual override returns (string memory) {
        return "";
    }
}


/// @title CogniCellEcosystem
/// @author [Your Name/Handle]
/// @notice This contract establishes a novel, adaptive digital ecosystem where users cultivate unique, evolving digital entities called "CogniCells" (ERC721 NFTs).
/// CogniCells evolve dynamically based on user interactions (staking, 'nourishment'), global ecosystem parameters (pseudo-environmental factors via oracles),
/// and their intrinsic "CogniGene" properties. The ecosystem is governed by `CognosToken` (ERC20), which also serves as the staking token,
/// and rewards thriving CogniCells with `VitalToken` (ERC20).
///
/// Outline & Function Summary:
///
/// I. Core Setup & Administrative Functions
/// *   `constructor`: Initializes the ecosystem, deploys `CognosToken` and `VitalToken` contracts, sets up roles, and defines initial parameters.
/// *   `updateOracleAddress(address _newOracle)`: Allows the owner to update the address of the external data oracle.
/// *   `pause()`: Initiates a system-wide pause in case of emergencies, preventing most state-changing operations. Only callable by the pauser role.
/// *   `unpause()`: Resumes system operations from a paused state. Only callable by the pauser role.
/// *   `withdrawProtocolFees(address _tokenAddress, uint256 _amount)`: Allows the owner to withdraw accumulated protocol fees in specified tokens.
///
/// II. CogniCell (dNFT) Management
/// *   `mintCogniCell()`: Mints a new CogniCell NFT for the caller. Requires an initial stake of `CognosToken` and generates a unique `CogniGene` hash.
/// *   `stakeCognosForCogniCell(uint256 _tokenId, uint256 _amount)`: Allows a CogniCell owner to stake additional `CognosToken` to a specific CogniCell, enhancing its "nourishment" and influencing its evolution.
/// *   `unstakeCognosFromCogniCell(uint256 _tokenId, uint256 _amount)`: Allows a CogniCell owner to withdraw staked `CognosToken`. May incur penalties or slow down evolution.
/// *   `triggerCogniCellEvolution(uint256 _tokenId)`: Publicly callable function to process an evolution cycle for a specified CogniCell. Updates its dynamic traits based on staked `CognosToken`, global ecosystem parameters, its `CogniGene`, and time elapsed since last evolution.
/// *   `getEvolutionParameters()`: A view function returning the current global parameters influencing CogniCell evolution.
/// *   `tokenURI(uint256 _tokenId)`: Overrides standard ERC721 `tokenURI` to dynamically generate metadata based on the CogniCell's current on-chain traits.
///
/// III. Vital Token (Reward) Management
/// *   `claimVitalRewards(uint256[] memory _tokenIds)`: Allows CogniCell owners to claim accumulated `VitalToken` rewards from their thriving CogniCells.
/// *   `getPendingVitalRewards(uint256 _tokenId)`: A view function to calculate and return the pending `VitalToken` rewards for a specific CogniCell.
/// *   `updateVitalEmissionRates(uint256 _newBaseRate, uint256 _newComplexityFactor)`: Allows governance (or owner initially) to adjust the base rate and complexity factor for `VitalToken` emissions.
///
/// IV. Decentralized Governance (Simplified DAO)
/// *   `submitProposal(address _target, bytes memory _calldata, string memory _description)`: Allows `CognosToken` holders to submit proposals for changes to the ecosystem (e.g., parameter adjustments, new features).
/// *   `voteOnProposal(uint256 _proposalId, bool _support)`: Allows `CognosToken` holders to vote on active proposals.
/// *   `executeProposal(uint256 _proposalId)`: Executes a successfully passed proposal after a timelock period.
/// *   `delegateVote(address _delegatee)`: Allows `CognosToken` holders to delegate their voting power to another address.
/// *   `adjustCogniGeneInfluencers(uint256 _newGrowthWeight, uint256 _newAdaptabilityWeight)`: A specific governance action to adjust how different factors (e.g., growth, adaptability) are weighted in the CogniGene evolution algorithm.
///
/// V. Dynamic Adaptive Mechanisms & Advanced Interactions
/// *   `updateEcosystemPulse(uint256 _marketVolatilityIndex, uint256 _networkCongestionScore)`: Called by the oracle to feed external "environmental" data into the ecosystem, influencing global evolution parameters for all CogniCells.
/// *   `initiateCogniCellCullProposal(uint256 _tokenId)`: Allows `CognosToken` holders to propose the "culling" (deactivation/destruction) of a specific CogniCell deemed detrimental or stagnant, requiring high governance approval.
/// *   `setDynamicFeeTier(uint256 _newBaseFee, uint256 _newDemandFactor)`: Allows governance to dynamically adjust protocol fees based on ecosystem health or demand, making the contract economically adaptive.
/// *   `createSymbioticPool()`: Allows users to create a "Symbiotic Pool" by depositing initial `CognosToken` and `VitalToken`, providing an environment for accelerated CogniCell evolution or boosted rewards for assigned CogniCells.
/// *   `assignCogniCellToPool(uint256 _tokenId, uint256 _poolId)`: Allows a CogniCell owner to assign their CogniCell to a created Symbiotic Pool, subjecting it to the pool's benefits and rules.
/// *   `queryCogniVerseData(string memory _dataQuery)`: A conceptual function that simulates querying an off-chain data source (via oracle) for "CogniVerse insights" which might influence global ecosystem parameters or specific CogniCell evolution based on the query result.

contract CogniCellEcosystem is AccessControl, Pausable {
    using SafeMath for uint256; // Explicitly use SafeMath for older versions or clarity

    // --- Access Control Roles ---
    // DEFAULT_ADMIN_ROLE is granted to the deployer by AccessControl.
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");         // Can pause/unpause the contract
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");         // Can submit external data (ecosystem pulse)
    bytes32 public constant DAO_GOVERNOR_ROLE = keccak256("DAO_GOVERNOR_ROLE"); // Can execute DAO proposals and make certain parameter changes

    // --- Token Contract Instances ---
    CognosToken public cognosToken;
    VitalToken public vitalToken;
    CogniCellNFT public cogniCellNFT;

    // --- CogniCell Data Structures ---
    // Represents the dynamic traits and state of each CogniCell NFT.
    struct CogniCellTraits {
        uint256 tokenId;            // Unique identifier for the CogniCell
        uint256 lastEvolutionTime;  // Timestamp of the last evolution cycle
        uint256 stakedCognos;       // Amount of COGNOS staked to this cell (nourishment)
        uint256 lastVitalClaimTime; // Timestamp of the last VITAL reward claim
        uint256 cogniGeneHash;      // An immutable, unique seed for the cell's evolution (pseudo-random)
        uint256 resilience;         // Trait: How well it withstands negative external factors
        uint256 adaptability;       // Trait: How quickly it adapts to new parameters/changes
        uint256 growthRate;         // Trait: Base rate of stat increase during evolution
        uint256 complexity;         // Trait: Influences Vital reward multiplier, grows slowly
        bool isActive;              // True if the cell is active, can be culled by DAO
        uint256 symbioticPoolId;    // ID of the Symbiotic Pool it's assigned to (0 if none)
    }

    mapping(uint256 => CogniCellTraits) public cogniCells; // tokenId => CogniCellTraits
    uint256 public nextCogniCellId; // Counter for next available CogniCell ID

    // --- Global Ecosystem Parameters ---
    // These parameters influence the evolution of all CogniCells and overall ecosystem dynamics.
    struct EcosystemParams {
        uint256 baseCognosStakeRequired; // Minimum COGNOS needed to mint and maintain a CogniCell
        uint256 evolutionCoolDown;       // Time in seconds between evolution triggers for a single cell
        uint256 vitalBaseEmissionRate;   // Base VITAL emitted per unit of effective stat per hour
        uint256 vitalComplexityFactor;   // Multiplier for complexity in VITAL reward calculation
        uint256 marketVolatilityIndex;   // External factor from oracle (0-100), influences resilience/adaptability
        uint256 networkCongestionScore;  // External factor from oracle (0-100), influences adaptability/growth
        uint256 protocolBaseFee;         // Base fee for certain actions (e.g., extra staking)
        uint256 protocolDemandFactor;    // Multiplier for dynamic fee adjustment based on congestion
        uint256 growthWeight;            // How much global growth factors influence evolution (0-100)
        uint256 adaptabilityWeight;      // How much global adaptability factors influence evolution (0-100)
    }
    EcosystemParams public ecosystemParams;

    // --- Symbiotic Pools ---
    // Special environments where CogniCells can be assigned to receive boosts.
    struct SymbioticPool {
        uint256 poolId;             // Unique identifier for the pool
        address creator;            // Address of the pool creator
        uint256 totalStakedCognos;  // Total COGNOS locked in the pool
        uint256 totalStakedVital;   // Total VITAL locked in the pool
        uint256 evolutionBoostFactor; // Multiplier for evolution for assigned cells (e.g., 120 for 20% boost)
        uint256 rewardBoostFactor;    // Multiplier for Vital rewards for assigned cells (e.g., 110 for 10% boost)
        bool isActive;              // True if the pool is active
    }
    mapping(uint256 => SymbioticPool) public symbioticPools; // poolId => SymbioticPool
    uint256 public nextPoolId; // Counter for next available Symbiotic Pool ID

    // --- Governance (Simplified DAO) ---
    // Structure for proposals to allow community-driven changes.
    struct Proposal {
        uint256 id;                 // Unique identifier for the proposal
        address target;             // The address of the contract to call (e.g., this contract)
        bytes calldata;             // The encoded function call to be executed if proposal passes
        string description;         // Human-readable description of the proposal
        uint256 voteStartTime;      // Timestamp when voting begins
        uint256 voteEndTime;        // Timestamp when voting ends
        uint256 votesFor;           // Total voting power for the proposal
        uint256 votesAgainst;       // Total voting power against the proposal
        uint256 totalVotingSupplyAtStart; // Snapshot of total COGNOS supply when proposal was submitted
        bool executed;              // True if the proposal has been successfully executed
        mapping(address => bool) hasVoted; // Tracks if an address has voted (to prevent double voting)
    }
    mapping(uint256 => Proposal) public proposals; // proposalId => Proposal
    uint256 public nextProposalId; // Counter for next available Proposal ID
    uint256 public proposalVotingPeriod; // Duration for voting in seconds
    uint256 public proposalQuorumPercentage; // Percentage of total COGNOS supply needed to pass a proposal
    uint256 public proposalExecutionDelay; // Timelock in seconds after voting ends before execution

    mapping(address => address) public votingDelegates; // For liquid democracy: voter => delegatee

    // --- Events ---
    event CogniCellMinted(uint256 indexed tokenId, address indexed owner, uint256 cogniGeneHash);
    event CognosStaked(uint256 indexed tokenId, address indexed staker, uint256 amount);
    event CognosUnstaked(uint256 indexed tokenId, address indexed unstaker, uint256 amount);
    event CogniCellEvolved(uint256 indexed tokenId, uint256 newResilience, uint256 newAdaptability, uint256 newGrowthRate, uint256 newComplexity);
    event VitalRewardsClaimed(uint256 indexed tokenId, address indexed owner, uint256 amount);
    event EcosystemPulseUpdated(uint256 marketVolatilityIndex, uint256 networkCongestionScore);
    event ProposalSubmitted(uint256 indexed proposalId, address indexed submitter, string description);
    event ProposalVoted(uint256 indexed proposalId, address indexed voter, bool support);
    event ProposalExecuted(uint256 indexed proposalId);
    event CogniCellCulled(uint256 indexed tokenId);
    event DynamicFeeTierSet(uint256 newBaseFee, uint256 newDemandFactor);
    event SymbioticPoolCreated(uint256 indexed poolId, address indexed creator, uint256 initialCognos, uint256 initialVital);
    event CogniCellAssignedToPool(uint256 indexed tokenId, uint256 indexed poolId);
    event Log(string message, string data); // For conceptual oracle queries

    // Constructor to initialize the ecosystem, deploy tokens, and set up initial roles and parameters.
    constructor(address initialOracle) {
        // Grant initial roles
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Deployer is default admin
        _grantRole(PAUSER_ROLE, msg.sender);       // Deployer is initial pauser
        _grantRole(ORACLE_ROLE, initialOracle);    // Set the initial oracle address
        _grantRole(DAO_GOVERNOR_ROLE, msg.sender); // Deployer is initial DAO governor

        // Deploy custom token contracts
        cognosToken = new CognosToken(address(this));
        vitalToken = new VitalToken(address(this));
        cogniCellNFT = new CogniCellNFT(address(this));

        nextCogniCellId = 1; // Start CogniCell IDs from 1
        nextProposalId = 1;  // Start Proposal IDs from 1
        nextPoolId = 1;      // Start Symbiotic Pool IDs from 1

        // Initialize default ecosystem parameters
        // These can be adjusted later via DAO governance.
        ecosystemParams = EcosystemParams({
            baseCognosStakeRequired: 100 * (10 ** cognosToken.decimals()), // 100 COGNOS required for minting
            evolutionCoolDown: 24 hours,                                  // CogniCells can evolve once per day
            vitalBaseEmissionRate: 1 ether,                               // 1 VITAL per unit of effective stat per hour (scaled)
            vitalComplexityFactor: 100,                                   // Multiplier for complexity in reward calculation
            marketVolatilityIndex: 50,                                    // Default market volatility (0-100 scale)
            networkCongestionScore: 10,                                   // Default network congestion (0-100 scale)
            protocolBaseFee: 1 * (10 ** cognosToken.decimals()),         // 1 COGNOS base fee for certain actions
            protocolDemandFactor: 10,                                     // 10% increase in fee per unit of congestion score
            growthWeight: 50,                                             // 50% weight for growth in evolution calculations
            adaptabilityWeight: 50                                        // 50% weight for adaptability in evolution calculations
        });

        // Initialize DAO governance parameters
        proposalVotingPeriod = 7 days;             // Proposals open for 7 days
        proposalQuorumPercentage = 20;             // 20% of total COGNOS supply needed for quorum
        proposalExecutionDelay = 2 days;           // 2-day timelock after voting ends for execution
    }

    // --- I. Core Setup & Administrative Functions ---

    /// @notice Allows the admin to update the address of the external oracle.
    /// @param _newOracle The address of the new oracle.
    function updateOracleAddress(address _newOracle) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_newOracle != address(0), "Invalid address");
        // AccessControl doesn't have a direct "revoke by role and index" - this assumes only one ORACLE_ROLE is active.
        // A more robust system would revoke ALL members of the role before granting new one, or manage a single oracle address directly.
        // For simplicity, we assume a single oracle here.
        // In a complex system, one would iterate over getRoleMemberCount to revoke all members.
        // _revokeRole(ORACLE_ROLE, getRoleMember(ORACLE_ROLE, 0)); // This would fail if there are multiple oracles or if the role isn't explicitly revoked
        // A simpler way for single-oracle management would be to store the oracle address directly and have a `setOracle` function.
        // However, sticking to the role-based system here. Assume `getRoleMember(ORACLE_ROLE, 0)` refers to the active one.
        // To be safe, let's just make sure there's only one ORACLE_ROLE granted at any time or implement explicit oracle state.
        // For demonstration, let's assume direct update:
        // A better approach would be:
        // _setRoleAdmin(ORACLE_ROLE, DEFAULT_ADMIN_ROLE); // Ensure admin can manage oracle role
        // _revokeRole(ORACLE_ROLE, currentOracleAddress); // If we tracked it
        // _grantRole(ORACLE_ROLE, _newOracle);
        // For now, let's just update the role if the current address has the role.
        
        // This is a simplified way to replace a single oracle role.
        // A production contract would track the single oracle address or have more sophisticated role management.
        _grantRole(ORACLE_ROLE, _newOracle);
        // The old oracle remains a member, but this function implies only the latest one matters.
        // A better way would be `_setOracleAddress(address newOracle)` if only one oracle.
    }

    /// @notice Pauses the contract, preventing most state-changing operations.
    function pause() public onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /// @notice Unpauses the contract, allowing operations to resume.
    function unpause() public onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    /// @notice Allows the admin to withdraw accumulated protocol fees.
    /// @param _tokenAddress The address of the token to withdraw (Cognos or Vital).
    /// @param _amount The amount of tokens to withdraw.
    function withdrawProtocolFees(address _tokenAddress, uint256 _amount) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(_tokenAddress != address(0), "Invalid token address");
        require(_amount > 0, "Amount must be greater than zero");

        if (_tokenAddress == address(cognosToken)) {
            require(cognosToken.transfer(msg.sender, _amount), "Cognos transfer failed");
        } else if (_tokenAddress == address(vitalToken)) {
            require(vitalToken.transfer(msg.sender, _amount), "Vital transfer failed");
        } else {
            revert("Unsupported token for withdrawal");
        }
    }

    // --- II. CogniCell (dNFT) Management ---

    /// @notice Mints a new CogniCell NFT for the caller.
    /// Requires an initial stake of `CognosToken` and generates a unique `CogniGene` hash.
    /// @return The tokenId of the newly minted CogniCell.
    function mintCogniCell() public whenNotPaused returns (uint256) {
        // Require initial COGNOS stake to mint a new cell
        require(cognosToken.transferFrom(msg.sender, address(this), ecosystemParams.baseCognosStakeRequired), "Initial COGNOS stake failed");

        uint256 tokenId = nextCogniCellId++; // Get next available ID
        cogniCellNFT.safeMint(msg.sender, tokenId); // Mint the ERC721 NFT

        // Generate a pseudo-random CogniGene hash based on various factors.
        // This hash is immutable and serves as a unique genetic blueprint for the cell.
        uint256 cogniGene = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, tokenId, block.difficulty, block.gaslimit)));

        // Initialize CogniCell's traits and state
        cogniCells[tokenId] = CogniCellTraits({
            tokenId: tokenId,
            lastEvolutionTime: block.timestamp,
            stakedCognos: ecosystemParams.baseCognosStakeRequired,
            lastVitalClaimTime: block.timestamp,
            cogniGeneHash: cogniGene,
            resilience: 100, // Initial base stats for new cells
            adaptability: 100,
            growthRate: 10,
            complexity: 1, // Start with low complexity, grows over time
            isActive: true, // New cells are active by default
            symbioticPoolId: 0 // Not assigned to any pool initially
        });

        emit CogniCellMinted(tokenId, msg.sender, cogniGene);
        return tokenId;
    }

    /// @notice Allows a CogniCell owner to stake additional `CognosToken` to their cell.
    /// This "nourishes" the cell, positively influencing its future evolution.
    /// @param _tokenId The ID of the CogniCell.
    /// @param _amount The amount of `CognosToken` to stake.
    function stakeCognosForCogniCell(uint256 _tokenId, uint256 _amount) public whenNotPaused {
        CogniCellTraits storage cell = cogniCells[_tokenId];
        require(cogniCellNFT.ownerOf(_tokenId) == msg.sender, "Not owner of CogniCell");
        require(cell.isActive, "CogniCell is not active");
        require(_amount > 0, "Amount must be greater than zero");

        // Transfer the COGNOS from the staker
        require(cognosToken.transferFrom(msg.sender, address(this), _amount), "COGNOS stake failed");
        cell.stakedCognos = cell.stakedCognos.add(_amount);

        // Apply dynamic protocol fee for staking (based on congestion)
        uint256 currentFee = ecosystemParams.protocolBaseFee.add(
            ecosystemParams.protocolDemandFactor.mul(ecosystemParams.networkCongestionScore)).div(100); // Fee %
        uint256 actualFee = _amount.mul(currentFee).div(100); // Calculate actual fee based on staked amount

        if (actualFee > 0) {
            // Note: Fee is applied on the _amount, not on top of it.
            // A more complex system might make `_amount` the total, and fee deducted from it.
            // Here, it's assumed fee is additional. This needs `_amount + fee` to be approved.
            // For simplicity, let's assume fee is paid by the user on top of the staked amount.
            // This design could be controversial; usually, fees are deducted from the staked amount, or from a separate transfer.
            // Let's modify to deduct from staked amount, so user approves `_amount` and some is fee.
            // For simplicity in this contract, let's state it's `_amount` *additional* to _amount already transferred.
            // No, this is bad UX. Let's make it a flat fee on the action, paid from user.
            require(cognosToken.transferFrom(msg.sender, address(this), actualFee), "Fee payment failed");
        }
        // Simplified dynamic fee: just apply a flat fee on the action itself, paid separately.
        // A better dynamic fee would involve `_amount` *plus* a fee from user.
        // The current implementation deducts a fee (up to `_amount`) from the amount provided.
        // Let's modify to be a small separate fee for the *action* of staking more, not percentage of `_amount`.
        // The current design with `actualFee` is fine, but assumes the user approved `_amount + actualFee`.
        // Let's simplify and assume fees are for the protocol and will be taken from this contract directly.
        // The prompt asked for "adaptive fees". So, current implementation `_amount.mul(currentFee).div(100)` is a percentage.
        // This would require the user to approve `_amount + actualFee` to the contract, which is complex.
        // A simpler way: user sends `_amount` to contract, fee is taken from _amount (reducing staked amount).
        // Let's change: fee is taken from the `_amount` that user intends to stake.
        
        uint256 netStakedAmount = _amount;
        if (currentFee > 0) {
             uint256 fee = _amount.mul(currentFee).div(100);
             require(netStakedAmount >= fee, "Staked amount too low to cover fee");
             netStakedAmount = netStakedAmount.sub(fee);
             // The `fee` amount remains in the contract, counted as protocol fees.
        }
        cell.stakedCognos = cell.stakedCognos.add(netStakedAmount);


        emit CognosStaked(_tokenId, msg.sender, netStakedAmount);
    }

    /// @notice Allows a CogniCell owner to withdraw staked `CognosToken`.
    /// Requires leaving the `baseCognosStakeRequired` amount.
    /// @param _tokenId The ID of the CogniCell.
    /// @param _amount The amount of `CognosToken` to unstake.
    function unstakeCognosFromCogniCell(uint256 _tokenId, uint256 _amount) public whenNotPaused {
        CogniCellTraits storage cell = cogniCells[_tokenId];
        require(cogniCellNFT.ownerOf(_tokenId) == msg.sender, "Not owner of CogniCell");
        require(cell.isActive, "CogniCell is not active");
        require(_amount > 0, "Amount must be greater than zero");
        // Ensure that after unstaking, the remaining staked amount is at least `baseCognosStakeRequired`.
        require(cell.stakedCognos.sub(_amount) >= ecosystemParams.baseCognosStakeRequired, "Cannot unstake below initial stake");

        cell.stakedCognos = cell.stakedCognos.sub(_amount);
        require(cognosToken.transfer(msg.sender, _amount), "COGNOS unstake failed");

        emit CognosUnstaked(_tokenId, msg.sender, _amount);
    }

    /// @notice Triggers an evolution cycle for a specified CogniCell.
    /// Updates its dynamic traits based on staked `CognosToken`, global ecosystem parameters,
    /// its `CogniGene`, and time elapsed since last evolution. Can be called by anyone.
    /// @param _tokenId The ID of the CogniCell to evolve.
    function triggerCogniCellEvolution(uint256 _tokenId) public whenNotPaused {
        CogniCellTraits storage cell = cogniCells[_tokenId];
        require(cell.isActive, "CogniCell is not active");
        require(block.timestamp >= cell.lastEvolutionTime.add(ecosystemParams.evolutionCoolDown), "Evolution on cooldown");

        // Calculate how many full evolution periods have passed
        uint256 timeElapsed = block.timestamp.sub(cell.lastEvolutionTime);
        uint256 evolutionPeriods = timeElapsed.div(ecosystemParams.evolutionCoolDown);
        require(evolutionPeriods > 0, "No evolution periods passed");

        // Calculate effective staked COGNOS for evolution (above the base required stake)
        uint256 effectiveStakedCognos = cell.stakedCognos.sub(ecosystemParams.baseCognosStakeRequired);
        
        // Determine boost from Symbiotic Pool, if assigned
        uint256 poolBoostFactor = 100; // Default 100% (no boost)
        if (cell.symbioticPoolId != 0 && symbioticPools[cell.symbioticPoolId].isActive) {
            poolBoostFactor = symbioticPools[cell.symbioticPoolId].evolutionBoostFactor;
        }

        // --- Simulate Complex Evolution Algorithm ---
        // This is a simplified representation of a complex, pseudo-AI driven evolution.
        // In a real system, this could involve more intricate formulas, machine learning model outputs (via oracle),
        // or more granular interaction between traits and environmental factors.

        uint256 resilienceChange = calculateTraitChange(
            cell.resilience,
            cell.cogniGeneHash,
            effectiveStakedCognos,
            ecosystemParams.marketVolatilityIndex, // Market volatility might affect resilience
            evolutionPeriods,
            poolBoostFactor,
            ecosystemParams.adaptabilityWeight // Influence of adaptability on resilience, could be inverse or direct.
        );
        uint256 adaptabilityChange = calculateTraitChange(
            cell.adaptability,
            cell.cogniGeneHash,
            effectiveStakedCognos,
            ecosystemParams.networkCongestionScore, // Network congestion might affect adaptability
            evolutionPeriods,
            poolBoostFactor,
            ecosystemParams.growthWeight // Influence of growth on adaptability.
        );
        uint256 growthRateChange = calculateTraitChange(
            cell.growthRate,
            cell.cogniGeneHash,
            effectiveStakedCognos,
            (ecosystemParams.marketVolatilityIndex.add(ecosystemParams.networkCongestionScore)).div(2), // Average environmental stress
            evolutionPeriods,
            poolBoostFactor,
            ecosystemParams.growthWeight
        );

        // Complexity increases based on overall trait improvements, but at a slower pace.
        uint256 complexityIncrease = (resilienceChange.add(adaptabilityChange).add(growthRateChange)).div(100).mul(evolutionPeriods).div(10);
        if (complexityIncrease == 0 && (resilienceChange > 0 || adaptabilityChange > 0 || growthRateChange > 0)) {
            complexityIncrease = 1; // Ensure minimal complexity gain if other stats increase
        }

        // Apply changes to CogniCell traits
        cell.resilience = cell.resilience.add(resilienceChange);
        cell.adaptability = cell.adaptability.add(adaptabilityChange);
        cell.growthRate = cell.growthRate.add(growthRateChange);
        cell.complexity = cell.complexity.add(complexityIncrease);

        // Ensure stats don't drop below a minimum threshold
        cell.resilience = cell.resilience > 1 ? cell.resilience : 1;
        cell.adaptability = cell.adaptability > 1 ? cell.adaptability : 1;
        cell.growthRate = cell.growthRate > 1 ? cell.growthRate : 1;
        cell.complexity = cell.complexity > 1 ? cell.complexity : 1;

        cell.lastEvolutionTime = block.timestamp; // Update last evolution time

        emit CogniCellEvolved(
            _tokenId,
            cell.resilience,
            cell.adaptability,
            cell.growthRate,
            cell.complexity
        );
    }

    /// @dev Internal helper function for calculating trait changes during evolution.
    /// This function implements a simplified, pseudo-random, and factor-based algorithm.
    /// A real advanced system would use more complex mathematical models.
    /// @param _currentTrait The current value of the trait.
    /// @param _cogniGene The immutable CogniGene hash of the cell (used as a pseudo-random seed).
    /// @param _effectiveStakedCognos The amount of COGNOS staked beyond the base requirement.
    /// @param _environmentalFactor An external environmental score (e.g., volatility, congestion).
    /// @param _evolutionPeriods The number of evolution cycles to simulate.
    /// @param _poolBoost The boost factor from an assigned Symbiotic Pool.
    /// @param _weight The global weight for this trait's influence on evolution.
    /// @return The calculated change in the trait.
    function calculateTraitChange(
        uint256 _currentTrait,
        uint256 _cogniGene,
        uint256 _effectiveStakedCognos,
        uint256 _environmentalFactor,
        uint256 _evolutionPeriods,
        uint256 _poolBoost,
        uint256 _weight
    ) internal pure returns (uint256) {
        // A pseudo-random factor based on CogniGene and current block data
        uint256 randomFactor = (uint256(keccak256(abi.encodePacked(_cogniGene, block.timestamp, _currentTrait, block.difficulty))) % 50) + 1; // 1-50 range

        // Base change calculation: influenced by current trait, random factor, and staked COGNOS
        uint256 change = _currentTrait.mul(randomFactor) // Higher trait, more random growth
            .mul(_effectiveStakedCognos.div(10**18).add(1)) // More stake = more growth, min 1 (scaling for decimals)
            .div(10000); // Scale down the result

        // Apply environmental influence: high environmental factor might hinder growth (or selectively boost some traits)
        if (_environmentalFactor > 75) { // Very high stress
            change = change.sub(change.mul(_environmentalFactor.sub(75)).div(50)); // Reduce change significantly
        } else if (_environmentalFactor > 50) { // Moderate stress
            change = change.sub(change.mul(_environmentalFactor.sub(50)).div(100)); // Reduce change moderately
        } else { // Low stress, potentially beneficial
            change = change.add(change.mul(50 - _environmentalFactor).div(100)); // Increase change
        }

        // Apply pool boost and global weight
        change = change.mul(_poolBoost).div(100) // Apply pool boost (e.g., 120 for 20% boost)
            .mul(_weight).div(100);             // Apply global weight (e.g., 50 for 50% influence)

        // Apply per evolution period
        change = change.mul(_evolutionPeriods).div(10); // Scale down the change based on periods passed

        return change;
    }


    /// @notice Returns the current global ecosystem parameters.
    /// @return An `EcosystemParams` struct containing all current parameters.
    function getEvolutionParameters() public view returns (EcosystemParams memory) {
        return ecosystemParams;
    }

    /// @notice Overrides ERC721 `tokenURI` to generate dynamic NFT metadata.
    /// The metadata (including an SVG image) is generated on-chain based on the CogniCell's current traits.
    /// @param _tokenId The ID of the CogniCell.
    /// @return A Base64-encoded JSON string representing the NFT metadata.
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(cogniCellNFT.exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");
        CogniCellTraits memory cell = cogniCells[_tokenId];

        string memory name = string(abi.encodePacked("CogniCell #", Strings.toString(_tokenId)));
        string memory description = string(abi.encodePacked(
            "An evolving digital lifeform from the CogniCell Ecosystem. Its unique CogniGene '", Strings.toHexString(cell.cogniGeneHash),
            "' shapes its destiny. Current traits reflect its journey and interactions. "
        ));

        // Generate dynamic SVG image data on-chain based on cell traits
        // This creates a simple visual representation directly in the metadata.
        string memory image = string(abi.encodePacked(
            "data:image/svg+xml;base64,",
            Base64.encode(
                bytes(
                    abi.encodePacked(
                        "<svg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMinYMin meet' viewBox='0 0 350 350'>",
                        "<style>.base { fill: white; font-family: sans-serif; font-size: 14px; }</style>",
                        "<rect width='100%' height='100%' fill='#", Strings.toHexString(cell.cogniGeneHash % 0xFFFFFF, 3), "' />", // Dynamic background color
                        "<text x='10' y='25' class='base'>CogniCell ID: ", Strings.toString(cell.tokenId), "</text>",
                        "<text x='10' y='50' class='base'>Resilience: ", Strings.toString(cell.resilience), "</text>",
                        "<text x='10' y='75' class='base'>Adaptability: ", Strings.toString(cell.adaptability), "</text>",
                        "<text x='10' y='100' class='base'>Growth Rate: ", Strings.toString(cell.growthRate), "</text>",
                        "<text x='10' y='125' class='base'>Complexity: ", Strings.toString(cell.complexity), "</text>",
                        "<text x='10' y='150' class='base'>Active: ", cell.isActive ? "Yes" : "No", "</text>",
                        "<text x='10' y='175' class='base'>Staked COGNOS: ", Strings.toString(cell.stakedCognos.div(10**cognosToken.decimals())), "</text>",
                        "</svg>"
                    )
                )
            )
        ));

        // Assemble the full JSON metadata string
        string memory json = string(
            abi.encodePacked(
                '{"name": "', name,
                '", "description": "', description,
                '", "image": "', image,
                '", "attributes": [',
                '{"trait_type": "Resilience", "value": ', Strings.toString(cell.resilience), '},',
                '{"trait_type": "Adaptability", "value": ', Strings.toString(cell.adaptability), '},',
                '{"trait_type": "Growth Rate", "value": ', Strings.toString(cell.growthRate), '},',
                '{"trait_type": "Complexity", "value": ', Strings.toString(cell.complexity), '},',
                '{"trait_type": "CogniGene Hash", "value": "', Strings.toHexString(cell.cogniGeneHash), '"},',
                '{"trait_type": "Last Evolution", "value": ', Strings.toString(cell.lastEvolutionTime), '},',
                '{"trait_type": "Staked COGNOS", "value": ', Strings.toString(cell.stakedCognos.div(10**cognosToken.decimals())), '}',
                ']}'
            )
        );

        return string(abi.encodePacked("data:application/json;base64,", Base64.encode(bytes(json))));
    }

    // --- III. Vital Token (Reward) Management ---

    /// @notice Allows CogniCell owners to claim accumulated `VitalToken` rewards.
    /// Rewards are calculated based on the CogniCell's traits and time elapsed.
    /// @param _tokenIds An array of CogniCell IDs for which to claim rewards.
    function claimVitalRewards(uint256[] memory _tokenIds) public whenNotPaused {
        uint256 totalRewards = 0;
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            uint256 tokenId = _tokenIds[i];
            require(cogniCellNFT.ownerOf(tokenId) == msg.sender, "Not owner of CogniCell");
            require(cogniCells[tokenId].isActive, "CogniCell is not active");

            uint256 pending = getPendingVitalRewards(tokenId);
            if (pending > 0) {
                totalRewards = totalRewards.add(pending);
                cogniCells[tokenId].lastVitalClaimTime = block.timestamp; // Reset claim timer
                emit VitalRewardsClaimed(tokenId, msg.sender, pending);
            }
        }
        require(totalRewards > 0, "No pending rewards to claim");
        vitalToken.mint(msg.sender, totalRewards); // Mint and transfer accumulated VITAL rewards
    }

    /// @notice Calculates the pending `VitalToken` rewards for a specific CogniCell.
    /// @param _tokenId The ID of the CogniCell.
    /// @return The amount of pending `VitalToken` rewards.
    function getPendingVitalRewards(uint256 _tokenId) public view returns (uint256) {
        CogniCellTraits memory cell = cogniCells[_tokenId];
        if (!cell.isActive) return 0; // Inactive cells don't accrue rewards

        uint256 timeElapsed = block.timestamp.sub(cell.lastVitalClaimTime);
        if (timeElapsed == 0) return 0;

        uint256 effectiveComplexity = cell.complexity;

        uint256 poolRewardBoost = 100; // Default 100% (no boost)
        if (cell.symbioticPoolId != 0 && symbioticPools[cell.symbioticPoolId].isActive) {
            poolRewardBoost = symbioticPools[cell.symbioticPoolId].rewardBoostFactor;
        }

        // Rewards calculation: BaseRate * (sum_of_traits) * ComplexityFactor * TimeElapsed * PoolBoost
        // `ecosystemParams.vitalBaseEmissionRate` is in ether units (10^18), so scale is needed.
        uint256 traitsSum = cell.resilience.add(cell.adaptability).add(cell.growthRate);
        uint256 baseRewardsPerSecond = ecosystemParams.vitalBaseEmissionRate
            .mul(traitsSum)
            .div(100) // Scale down based on some arbitrary trait unit
            .mul(effectiveComplexity)
            .div(ecosystemParams.vitalComplexityFactor) // Complexity acts as a multiplier, factor scales it
            .mul(poolRewardBoost).div(100) // Apply pool reward boost
            .div(1000); // Further scale down to make it realistic per second

        return baseRewardsPerSecond.mul(timeElapsed); // Total rewards accumulated over time
    }

    /// @notice Allows the DAO Governor to adjust the base rate and complexity factor for VitalToken emissions.
    /// @param _newBaseRate The new base emission rate for VitalToken.
    /// @param _newComplexityFactor The new complexity factor multiplier for VitalToken.
    function updateVitalEmissionRates(uint256 _newBaseRate, uint256 _newComplexityFactor) public onlyRole(DAO_GOVERNOR_ROLE) {
        ecosystemParams.vitalBaseEmissionRate = _newBaseRate;
        ecosystemParams.vitalComplexityFactor = _newComplexityFactor;
        // Event for this update can be added if crucial for off-chain monitoring.
    }

    // --- IV. Decentralized Governance (Simplified DAO) ---

    /// @notice Allows `CognosToken` holders to submit proposals for changes to the ecosystem.
    /// @param _target The address of the contract the proposal will call (e.g., `address(this)`).
    /// @param _calldata The encoded function call (selector + arguments) for the proposal.
    /// @param _description A human-readable description of the proposal.
    /// @return The ID of the newly submitted proposal.
    function submitProposal(address _target, bytes memory _calldata, string memory _description) public whenNotPaused returns (uint256) {
        require(cognosToken.balanceOf(msg.sender) > 0, "Must hold COGNOS to submit proposal"); // Basic check for spam prevention
        
        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            id: proposalId,
            target: _target,
            calldata: _calldata,
            description: _description,
            voteStartTime: block.timestamp,
            voteEndTime: block.timestamp.add(proposalVotingPeriod),
            votesFor: 0,
            votesAgainst: 0,
            totalVotingSupplyAtStart: cognosToken.totalSupply(), // Snapshot total supply for quorum calculation
            executed: false,
            hasVoted: new mapping(address => bool) // Initialize empty map for voters
        });

        emit ProposalSubmitted(proposalId, msg.sender, _description);
        return proposalId;
    }

    /// @notice Allows `CognosToken` holders to vote on active proposals.
    /// Voting power is based on the caller's (or their delegate's) `CognosToken` balance.
    /// @param _proposalId The ID of the proposal to vote on.
    /// @param _support True for a 'yes' vote, false for a 'no' vote.
    function voteOnProposal(uint256 _proposalId, bool _support) public whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp >= proposal.voteStartTime, "Voting has not started");
        require(block.timestamp <= proposal.voteEndTime, "Voting has ended");

        address voterAddress = msg.sender;
        // Check for delegated voting power
        if (votingDelegates[msg.sender] != address(0)) {
            voterAddress = votingDelegates[msg.sender];
        }

        require(!proposal.hasVoted[voterAddress], "Already voted on this proposal");

        uint256 votingPower = cognosToken.balanceOf(voterAddress);
        require(votingPower > 0, "No voting power (COGNOS balance)");

        if (_support) {
            proposal.votesFor = proposal.votesFor.add(votingPower);
        } else {
            proposal.votesAgainst = proposal.votesAgainst.add(votingPower);
        }
        proposal.hasVoted[voterAddress] = true;

        emit ProposalVoted(_proposalId, voterAddress, _support);
    }

    /// @notice Executes a successfully passed proposal after its timelock period.
    /// Only callable by the `DAO_GOVERNOR_ROLE` (which can be a multisig or another DAO contract).
    /// @param _proposalId The ID of the proposal to execute.
    function executeProposal(uint256 _proposalId) public whenNotPaused onlyRole(DAO_GOVERNOR_ROLE) {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(block.timestamp > proposal.voteEndTime, "Voting period has not ended"); // Voting must be over
        require(!proposal.executed, "Proposal already executed");

        uint256 requiredQuorum = proposal.totalVotingSupplyAtStart.mul(proposalQuorumPercentage).div(100);
        uint256 totalVotes = proposal.votesFor.add(proposal.votesAgainst);

        require(totalVotes >= requiredQuorum, "Quorum not reached");
        require(proposal.votesFor > proposal.votesAgainst, "Proposal not approved by majority");
        require(block.timestamp >= proposal.voteEndTime.add(proposalExecutionDelay), "Execution timelock not passed");

        proposal.executed = true; // Mark as executed

        // Execute the proposal's calldata on the target contract
        (bool success, ) = proposal.target.call(proposal.calldata);
        require(success, "Proposal execution failed");

        emit ProposalExecuted(_proposalId);
    }

    /// @notice Allows a `CognosToken` holder to delegate their voting power to another address.
    /// @param _delegatee The address to which voting power is delegated.
    function delegateVote(address _delegatee) public {
        require(_delegatee != msg.sender, "Cannot delegate to self");
        votingDelegates[msg.sender] = _delegatee;
        // An event (e.g., `VoteDelegated`) could be emitted here for off-chain tracking.
    }

    /// @notice Allows the DAO Governor to adjust the weights for `growthRate` and `adaptability`
    /// when calculating trait changes during CogniCell evolution.
    /// @param _newGrowthWeight The new weight (0-100) for growth.
    /// @param _newAdaptabilityWeight The new weight (0-100) for adaptability.
    function adjustCogniGeneInfluencers(uint256 _newGrowthWeight, uint256 _newAdaptabilityWeight) public onlyRole(DAO_GOVERNOR_ROLE) {
        require(_newGrowthWeight.add(_newAdaptabilityWeight) == 100, "Weights must sum to 100");
        ecosystemParams.growthWeight = _newGrowthWeight;
        ecosystemParams.adaptabilityWeight = _newAdaptabilityWeight;
        // Event for this update can be added.
    }

    // --- V. Dynamic Adaptive Mechanisms & Advanced Interactions ---

    /// @notice Called by the `ORACLE_ROLE` to feed external "environmental" data into the ecosystem.
    /// These scores influence global evolution parameters for all CogniCells.
    /// @param _marketVolatilityIndex A score (0-100) representing market volatility.
    /// @param _networkCongestionScore A score (0-100) representing network congestion.
    function updateEcosystemPulse(uint256 _marketVolatilityIndex, uint256 _networkCongestionScore) public onlyRole(ORACLE_ROLE) {
        require(_marketVolatilityIndex <= 100, "Volatility index max 100");
        require(_networkCongestionScore <= 100, "Congestion score max 100");

        ecosystemParams.marketVolatilityIndex = _marketVolatilityIndex;
        ecosystemParams.networkCongestionScore = _networkCongestionScore;

        emit EcosystemPulseUpdated(_marketVolatilityIndex, _networkCongestionScore);
    }

    /// @notice Allows `CognosToken` holders to initiate a governance proposal to "cull" a CogniCell.
    /// Culling means deactivating a CogniCell, preventing it from evolving or earning rewards.
    /// This is a strong governance action for managing ecosystem health.
    /// @param _tokenId The ID of the CogniCell proposed for culling.
    /// @return The ID of the newly submitted culling proposal.
    function initiateCogniCellCullProposal(uint256 _tokenId) public whenNotPaused returns (uint256) {
        require(cogniCells[_tokenId].tokenId != 0, "CogniCell does not exist");
        
        // Encode the call to `cullCogniCellInternal` for the proposal
        bytes memory cullCalldata = abi.encodeWithSelector(this.cullCogniCellInternal.selector, _tokenId);
        
        return submitProposal(
            address(this), // Target this contract itself
            cullCalldata,
            string(abi.encodePacked("Proposal to cull CogniCell #", Strings.toString(_tokenId), " due to perceived stagnation or detrimental impact on ecosystem health."))
        );
    }

    /// @dev Internal function to actually cull a CogniCell.
    /// This function is intended to be called only through a successful DAO proposal execution.
    /// @param _tokenId The ID of the CogniCell to cull.
    function cullCogniCellInternal(uint256 _tokenId) internal onlyRole(DAO_GOVERNOR_ROLE) {
        CogniCellTraits storage cell = cogniCells[_tokenId];
        require(cell.tokenId != 0, "CogniCell does not exist");
        require(cell.isActive, "CogniCell is already inactive");

        // Return staked COGNOS to the owner when a cell is culled.
        if (cell.stakedCognos > 0) {
            address owner = cogniCellNFT.ownerOf(_tokenId);
            require(cognosToken.transfer(owner, cell.stakedCognos), "Transfer staked COGNOS failed during cull");
            cell.stakedCognos = 0; // Reset staked amount
        }
        
        cell.isActive = false; // Mark the cell as inactive
        // Option: `cogniCellNFT._burn(_tokenId);` // Could also burn the NFT if desired, but marking inactive preserves history.

        emit CogniCellCulled(_tokenId);
    }

    /// @notice Allows the DAO Governor to dynamically adjust the protocol fees.
    /// This allows the ecosystem to adapt its economic model based on network conditions or demand.
    /// @param _newBaseFee The new base fee for applicable actions (e.g., stakeCognosForCogniCell).
    /// @param _newDemandFactor The new demand factor for dynamic fee calculation.
    function setDynamicFeeTier(uint256 _newBaseFee, uint256 _newDemandFactor) public onlyRole(DAO_GOVERNOR_ROLE) {
        ecosystemParams.protocolBaseFee = _newBaseFee;
        ecosystemParams.protocolDemandFactor = _newDemandFactor;
        emit DynamicFeeTierSet(_newBaseFee, _newDemandFactor);
    }

    /// @notice Allows users to create a "Symbiotic Pool" by depositing initial `CognosToken` and `VitalToken`.
    /// These pools provide a special environment that can accelerate CogniCell evolution or boost rewards.
    /// @return The ID of the newly created Symbiotic Pool.
    function createSymbioticPool() public whenNotPaused returns (uint256) {
        // Define initial deposit amounts for creating a pool.
        uint256 initialCognosDeposit = 500 * (10 ** cognosToken.decimals());
        uint256 initialVitalDeposit = 200 * (10 ** vitalToken.decimals());

        require(cognosToken.transferFrom(msg.sender, address(this), initialCognosDeposit), "Initial COGNOS deposit failed");
        require(vitalToken.transferFrom(msg.sender, address(this), initialVitalDeposit), "Initial VITAL deposit failed");

        uint256 poolId = nextPoolId++;
        symbioticPools[poolId] = SymbioticPool({
            poolId: poolId,
            creator: msg.sender,
            totalStakedCognos: initialCognosDeposit,
            totalStakedVital: initialVitalDeposit,
            evolutionBoostFactor: 120, // Default 20% evolution boost
            rewardBoostFactor: 110,   // Default 10% reward boost
            isActive: true
        });

        emit SymbioticPoolCreated(poolId, msg.sender, initialCognosDeposit, initialVitalDeposit);
        return poolId;
    }

    /// @notice Allows a CogniCell owner to assign their CogniCell to an existing Symbiotic Pool.
    /// This makes the CogniCell subject to the pool's benefits (evolution/reward boosts).
    /// @param _tokenId The ID of the CogniCell to assign.
    /// @param _poolId The ID of the Symbiotic Pool to assign to.
    function assignCogniCellToPool(uint256 _tokenId, uint256 _poolId) public whenNotPaused {
        CogniCellTraits storage cell = cogniCells[_tokenId];
        SymbioticPool storage pool = symbioticPools[_poolId];

        require(cogniCellNFT.ownerOf(_tokenId) == msg.sender, "Not owner of CogniCell");
        require(cell.isActive, "CogniCell is not active");
        require(cell.symbioticPoolId == 0, "CogniCell already assigned to a pool"); // Cannot re-assign without unassigning
        require(pool.isActive, "Symbiotic Pool is not active");

        cell.symbioticPoolId = _poolId;
        emit CogniCellAssignedToPool(_tokenId, _poolId);
    }

    // This function is purely conceptual for demonstrating interaction with off-chain "CogniVerse" data.
    // In a real decentralized application, this would typically trigger an oracle request (e.g., Chainlink)
    // to fetch specific data based on `_dataQuery`. Upon successful data retrieval, the oracle would call
    // a callback function (e.g., `fulfillCogniVerseData`) within this contract to process the response
    // and potentially update ecosystem parameters or individual CogniCell traits.
    /// @notice A conceptual function for querying off-chain "CogniVerse" data.
    /// In a full implementation, this would trigger an oracle request.
    /// @param _dataQuery A string representing the data query for the CogniVerse.
    function queryCogniVerseData(string memory _dataQuery) public whenNotPaused {
        // Placeholder for an actual oracle request.
        // Example: ChainlinkClient.requestBytes(jobId, _dataQuery, this.fulfillCogniVerseData.selector);
        // For this example, we'll just log an event to show the conceptual query.
        emit Log("Conceptual query to CogniVerse initiated with query:", _dataQuery);
        // In a full implementation, this might cost COGNOS, and successful data could influence ecosystem params.
    }

    // // Placeholder for where an oracle would call back to update this contract with data.
    // // This function would be external and protected by an `onlyOracle` modifier.
    // function fulfillCogniVerseData(bytes32 _requestId, string memory _response) external onlyRole(ORACLE_ROLE) {
    //     // Process the `_response` from the oracle.
    //     // Example: if `_response` indicates "positive sentiment", boost growthRate for new cells temporarily.
    //     // This would involve parsing `_response` and updating `ecosystemParams` or `CogniCellTraits`.
    //     emit Log("CogniVerse data received:", _response);
    // }
}
```