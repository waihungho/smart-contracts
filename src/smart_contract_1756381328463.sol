This smart contract, `GaiaGenesisProtocol`, creates a decentralized, self-sustaining on-chain ecosystem. It blends advanced concepts like **dynamic NFTs**, **on-chain simulation**, **resource management**, **Chainlink VRF for provable randomness**, and **Chainlink Automation for time-based progression**. Users interact with "Lifeforms" (ERC721 NFTs) that possess evolving genetic traits and influence an on-chain environment using "BioEssence" (ERC20 token).

---

## Contract: GaiaGenesisProtocol

**Description:**
`GaiaGenesisProtocol` is an advanced, dynamic NFT ecosystem where unique digital "Lifeforms" exist as ERC721 tokens. These Lifeforms possess evolving genetic traits that influence their survival, resource generation, and interaction within an on-chain simulated environment. Users can mint genesis Lifeforms, breed new generations, attempt to evolve or mutate existing Lifeforms, and cultivate the ecosystem by managing `BioEssence` (an ERC20 resource token). The protocol leverages Chainlink VRF for secure randomness in trait generation and evolution, and Chainlink Automation for periodic ecosystem advancements, simulating a living, breathing digital world. It's a blend of dynamic NFTs, on-chain gaming, resource management, and decentralized autonomous world concepts.

**Core Components:**
1.  **Lifeform (ERC721):** Unique NFTs with dynamic traits stored directly on-chain. Traits determine resource generation, survival, and interaction outcomes.
2.  **BioEssence (ERC20):** The primary resource token. It's used for minting, breeding, evolving Lifeforms, and cultivating the environment. Lifeforms also generate BioEssence.
3.  **Ecosystem Simulation:** Global environmental parameters (e.g., `nutrientLevel`, `energyFlow`) that dynamically change over time and influence Lifeforms.
4.  **Chainlink VRF:** Provides provably random numbers essential for trait generation during minting/breeding/evolution, and for resolving stochastic events within the simulation.
5.  **Chainlink Automation:** Enables the `advanceEpoch()` function to be called periodically, ensuring the ecosystem progresses autonomously without manual intervention.

---

**Function Summary (25 Functions):**

**I. Core Lifeform (ERC721) Management**
1.  `mintInitialLifeform()`: Mints a new genesis Lifeform NFT for the caller. Requires BioEssence payment. Traits are randomized using VRF.
2.  `breedLifeforms(uint256 parent1Id, uint256 parent2Id)`: Allows owners to breed two compatible Lifeforms (owned by the caller or approved), consuming `BioEssence` and minting a new Lifeform NFT with inherited and mutated traits. Requires VRF.
3.  `evolveLifeform(uint256 lifeformId)`: Initiates an attempt to evolve a specific Lifeform, consuming `BioEssence`. Evolution outcomes (trait changes) are influenced by environmental conditions and VRF.
4.  `mutateLifeform(uint256 lifeformId)`: Triggers a more drastic and random mutation event for a Lifeform, consuming `BioEssence` and using VRF. It can introduce entirely new traits or significantly alter existing ones.
5.  `burnLifeform(uint256 lifeformId)`: Allows the owner to permanently destroy a Lifeform NFT, potentially recovering some `BioEssence` based on its "fitness" score or age.
6.  `getTokenURI(uint256 lifeformId)`: Returns the dynamic metadata URI for a Lifeform NFT, reflecting its current traits and ecosystem status. (Standard ERC721 override)
7.  `transferFrom(address from, address to, uint256 tokenId)`: Standard ERC721 function to transfer ownership of a Lifeform.
8.  `approve(address to, uint256 tokenId)`: Standard ERC721 function to approve an address to manage a specific Lifeform.
9.  `setApprovalForAll(address operator, bool approved)`: Standard ERC721 function to approve an operator for all caller's Lifeforms.
10. `getApproved(uint256 tokenId)`: Standard ERC721 function to check the approved address for a Lifeform.
11. `isApprovedForAll(address owner, address operator)`: Standard ERC721 function to check if an operator is approved for an owner.

**II. BioEssence (ERC20) Resource Management**
12. `claimResourceGeneration(uint256 lifeformId)`: Allows the owner of a Lifeform to claim accumulated `BioEssence` generated by that Lifeform based on its traits, age, and ecosystem conditions.
13. `stakeBioEssence(uint256 amount)`: Users can stake `BioEssence` to earn potential future rewards or gain influence within the ecosystem (e.g., for future governance features).
14. `unstakeBioEssence(uint256 amount)`: Allows users to unstake their `BioEssence` after a predefined cool-down period.
15. `getBioEssenceBalance(address user)`: Returns the `BioEssence` balance for a given address. (Standard ERC20 getter)

**III. Ecosystem Simulation & Environment Management**
16. `cultivateEnvironment(uint256 amount)`: Users can contribute `BioEssence` to directly improve global environmental conditions (e.g., increase `nutrientLevel`, boost `energyFlow`), benefiting all Lifeforms.
17. `advanceEpoch()`: **(Chainlink Automation Compatible)** A core function callable periodically by authorized Chainlink Keepers. This function progresses the ecosystem's internal clock (`currentEpoch`), triggers Lifeform aging, calculates resource consumption/generation, updates environmental decay/growth, and resolves Lifeform interactions.
18. `queryEnvironmentalConditions()`: Returns a snapshot of the current global environmental parameters.
19. `resolveLifeformInteractions(uint256 randomNumber)`: (Internal, called by `advanceEpoch`) Handles dynamic interactions between Lifeforms within the ecosystem (e.g., competition for resources, symbiotic relationships), potentially affecting their traits, health, or survival status. Uses a random number passed from `advanceEpoch`.

**IV. Chainlink VRF Integration**
20. `requestRandomness(uint256 _callbackGasLimit, uint32 _numWords)`: (Internal helper) Initiates a VRF request with specified gas limit and number of random words.
21. `requestRandomnessForAction(bytes32 _key, uint256 _callbackGasLimit, uint32 _numWords)`: Public function to request randomness specifically tied to an action (e.g., a specific Lifeform's evolution). Stores a mapping to link the request ID to the action.
22. `fulfillRandomness(bytes32 requestId, uint256[] memory randomWords)`: **(VRF Callback)** The Chainlink VRF callback function. It processes the requested randomness and applies it to pending operations (like trait generation during mint/breed/evolve/mutate). It must correctly interpret `requestId` to determine which action to resolve.

**V. Protocol Administration & Governance (Owner/Pausable)**
23. `setProtocolFee(uint256 newFee)`: Allows the contract owner to adjust the `BioEssence` fee required for certain protocol actions (e.g., breeding, evolution, minting).
24. `pause()`: Allows the contract owner to pause core contract functionalities (e.g., minting, breeding, staking) in case of an emergency or upgrade.
25. `unpause()`: Allows the contract owner to unpause the contract's functionalities.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol";

// ERC20 for BioEssence resource token
contract BioEssenceToken is ERC20, Ownable {
    constructor(address initialOwner) ERC20("BioEssence", "BIO") Ownable(initialOwner) {}

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) public onlyOwner {
        _burn(from, amount);
    }
}

contract GaiaGenesisProtocol is ERC721Enumerable, ERC721URIStorage, Ownable, Pausable, VRFConsumerBaseV2, AutomationCompatibleInterface {
    using Counters for Counters.Counter;
    Counters.Counter private _lifeformIds;

    // --- Chainlink VRF Configuration ---
    bytes32 private immutable i_keyHash;
    uint64 private immutable i_subscriptionId;
    uint32 private immutable i_callbackGasLimit;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUM_RANDOM_WORDS = 2; // For various uses: traits, evolution, interactions

    // --- BioEssence Token ---
    BioEssenceToken public bioEssence;

    // --- Lifeform Data Structures ---
    struct Lifeform {
        uint256 id;
        uint256 generation;      // 0 for genesis, >0 for bred
        uint256 parent1Id;       // 0 for genesis
        uint256 parent2Id;       // 0 for genesis
        uint8 health;            // 0-100, impacts survival and resource generation
        uint8 strength;          // 0-100, impacts interactions and resource extraction
        uint8 agility;           // 0-100, impacts evasion and resource acquisition
        uint8 intelligence;      // 0-100, impacts learning and adaptation
        uint8 age;               // Current age in epochs
        uint8 maxAge;            // Max age before decay/death
        uint256 lastClaimEpoch;  // Last epoch when resources were claimed
        uint256 accumulatedBioEssence; // BioEssence generated but not yet claimed
    }

    mapping(uint256 => Lifeform) public lifeforms;
    mapping(bytes32 => RequestType) public s_requests; // Map VRF request IDs to their type
    mapping(bytes32 => uint256) public s_requestAssociatedId; // Map VRF request IDs to Lifeform ID or other context
    mapping(address => uint256) public stakedBioEssence; // For staking feature
    mapping(address => uint256) public lastUnstakeEpoch; // For unstaking cooldown

    enum RequestType { None, Mint, Breed, Evolve, Mutate, AdvanceEpoch }

    // --- Ecosystem Parameters ---
    uint256 public currentEpoch;
    uint8 public nutrientLevel;      // 0-100, impacts Lifeform health and resource generation
    uint8 public energyFlow;         // 0-100, impacts Lifeform growth and evolution
    uint256 public protocolFee;      // Fee in BioEssence for certain actions

    // --- Constants ---
    uint256 public constant MIN_INITIAL_LIFEFORM_FEE = 100 * (10 ** 18); // Example: 100 BIO
    uint256 public constant MIN_BREED_FEE = 50 * (10 ** 18); // Example: 50 BIO
    uint256 public constant MIN_EVOLVE_MUTATE_FEE = 75 * (10 ** 18); // Example: 75 BIO
    uint256 public constant RESOURCE_GENERATION_FACTOR = 10; // How much BIO per epoch per 'fitness' point
    uint256 public constant STAKING_COOLDOWN_EPOCHS = 5; // Epochs to wait after unstaking

    // --- Events ---
    event LifeformMinted(uint256 indexed lifeformId, address indexed owner, uint256 generation, uint256 requestRandomnessId);
    event LifeformBred(uint256 indexed lifeformId, address indexed owner, uint256 parent1, uint256 parent2, uint256 requestRandomnessId);
    event LifeformEvolved(uint256 indexed lifeformId, uint256 requestRandomnessId);
    event LifeformMutated(uint256 indexed lifeformId, uint256 requestRandomnessId);
    event LifeformBurned(uint256 indexed lifeformId, address indexed owner);
    event ResourcesClaimed(uint256 indexed lifeformId, address indexed owner, uint256 amount);
    event EnvironmentalConditionsUpdated(uint256 indexed epoch, uint8 newNutrientLevel, uint8 newEnergyFlow);
    event EpochAdvanced(uint256 indexed newEpoch);
    event BioEssenceStaked(address indexed user, uint256 amount);
    event BioEssenceUnstaked(address indexed user, uint256 amount);
    event ProtocolFeeUpdated(uint256 newFee);

    // --- Constructor ---
    constructor(
        address _vrfCoordinator,
        bytes32 _keyHash,
        uint64 _subscriptionId,
        uint32 _callbackGasLimit,
        address _bioEssenceTokenAddress
    )
        ERC721("GaiaGenesis Lifeform", "GAIALF")
        ERC721URIStorage()
        Ownable(msg.sender)
        Pausable()
        VRFConsumerBaseV2(_vrfCoordinator)
    {
        i_keyHash = _keyHash;
        i_subscriptionId = _subscriptionId;
        i_callbackGasLimit = _callbackGasLimit;
        bioEssence = BioEssenceToken(_bioEssenceTokenAddress);

        // Initialize environmental conditions
        nutrientLevel = 50;
        energyFlow = 50;
        currentEpoch = 0;
        protocolFee = 10 * (10 ** 18); // Default fee 10 BIO
    }

    // --- Modifiers ---
    modifier onlyLifeformOwnerOrApproved(uint256 _lifeformId) {
        require(_isApprovedOrOwner(msg.sender, _lifeformId), "Not owner or approved");
        _;
    }

    // --- I. Core Lifeform (ERC721) Management ---

    function mintInitialLifeform() public payable whenNotPaused {
        require(bioEssence.balanceOf(msg.sender) >= MIN_INITIAL_LIFEFORM_FEE + protocolFee, "Insufficient BioEssence or Protocol Fee");
        bioEssence.transferFrom(msg.sender, address(this), MIN_INITIAL_LIFEFORM_FEE + protocolFee);

        // Request randomness for initial traits
        bytes32 requestId = _requestRandomness(i_callbackGasLimit, NUM_RANDOM_WORDS);
        s_requests[requestId] = RequestType.Mint;
        s_requestAssociatedId[requestId] = _lifeformIds.current(); // Store next ID for callback
        emit LifeformMinted(0, msg.sender, 0, uint256(requestId)); // ID will be assigned in fulfillRandomness
    }

    function breedLifeforms(uint256 parent1Id, uint256 parent2Id)
        public
        whenNotPaused
        onlyLifeformOwnerOrApproved(parent1Id)
        onlyLifeformOwnerOrApproved(parent2Id)
    {
        require(ownerOf(parent1Id) == ownerOf(parent2Id), "Parents must have same owner");
        require(bioEssence.balanceOf(msg.sender) >= MIN_BREED_FEE + protocolFee, "Insufficient BioEssence or Protocol Fee");
        bioEssence.transferFrom(msg.sender, address(this), MIN_BREED_FEE + protocolFee);

        // Request randomness for offspring traits
        bytes32 requestId = _requestRandomness(i_callbackGasLimit, NUM_RANDOM_WORDS);
        s_requests[requestId] = RequestType.Breed;
        s_requestAssociatedId[requestId] = (parent1Id << 128) | parent2Id; // Pack parent IDs
        emit LifeformBred(0, msg.sender, parent1Id, parent2Id, uint256(requestId)); // ID assigned in fulfillRandomness
    }

    function evolveLifeform(uint256 lifeformId) public whenNotPaused onlyLifeformOwnerOrApproved(lifeformId) {
        require(lifeforms[lifeformId].health > 0, "Lifeform is deceased");
        require(bioEssence.balanceOf(msg.sender) >= MIN_EVOLVE_MUTATE_FEE + protocolFee, "Insufficient BioEssence or Protocol Fee");
        bioEssence.transferFrom(msg.sender, address(this), MIN_EVOLVE_MUTATE_FEE + protocolFee);

        bytes32 requestId = _requestRandomness(i_callbackGasLimit, NUM_RANDOM_WORDS);
        s_requests[requestId] = RequestType.Evolve;
        s_requestAssociatedId[requestId] = lifeformId;
        emit LifeformEvolved(lifeformId, uint256(requestId));
    }

    function mutateLifeform(uint256 lifeformId) public whenNotPaused onlyLifeformOwnerOrApproved(lifeformId) {
        require(lifeforms[lifeformId].health > 0, "Lifeform is deceased");
        require(bioEssence.balanceOf(msg.sender) >= MIN_EVOLVE_MUTATE_FEE + protocolFee, "Insufficient BioEssence or Protocol Fee");
        bioEssence.transferFrom(msg.sender, address(this), MIN_EVOLVE_MUTATE_FEE + protocolFee);

        bytes32 requestId = _requestRandomness(i_callbackGasLimit, NUM_RANDOM_WORDS);
        s_requests[requestId] = RequestType.Mutate;
        s_requestAssociatedId[requestId] = lifeformId;
        emit LifeformMutated(lifeformId, uint256(requestId));
    }

    function burnLifeform(uint256 lifeformId) public whenNotPaused onlyLifeformOwnerOrApproved(lifeformId) {
        _burn(lifeformId);
        _lifeformIds.decrement(); // Adjust counter as an NFT is removed

        // Optionally refund some BioEssence based on fitness, age, etc.
        // For simplicity, no refund here.
        emit LifeformBurned(lifeformId, msg.sender);
    }

    // Standard ERC721 functions (getTokenURI is overriden below)
    function transferFrom(address from, address to, uint256 tokenId) public override(ERC721, ERC721Enumerable) whenNotPaused {
        super.transferFrom(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override(ERC721, ERC721Enumerable) whenNotPaused {
        super.approve(to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public override(ERC721, ERC721Enumerable) whenNotPaused {
        super.setApprovalForAll(operator, approved);
    }

    function getApproved(uint256 tokenId) public view override(ERC721, ERC721Enumerable) returns (address) {
        return super.getApproved(tokenId);
    }

    function isApprovedForAll(address owner, address operator) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.isApprovedForAll(owner, operator);
    }

    // Dynamic Metadata URI
    function _baseURI() internal pure override returns (string memory) {
        return "https://gaia.genesis.io/api/lifeform/"; // Placeholder base URI for dynamic metadata
    }

    function getTokenURI(uint256 lifeformId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        require(_exists(lifeformId), "ERC721URIStorage: URI query for nonexistent token");
        // In a real dApp, this would point to an off-chain API that renders JSON
        // based on the lifeforms[lifeformId] data, reflecting its current traits.
        return string(abi.encodePacked(_baseURI(), Strings.toString(lifeformId), ".json"));
    }

    // --- II. BioEssence (ERC20) Resource Management ---

    function claimResourceGeneration(uint256 lifeformId) public whenNotPaused onlyLifeformOwnerOrApproved(lifeformId) {
        Lifeform storage lf = lifeforms[lifeformId];
        require(lf.health > 0, "Lifeform is deceased");
        require(lf.accumulatedBioEssence > 0, "No BioEssence accumulated");

        uint256 amount = lf.accumulatedBioEssence;
        lf.accumulatedBioEssence = 0;
        bioEssence.mint(msg.sender, amount); // Mint new BioEssence for the user

        emit ResourcesClaimed(lifeformId, msg.sender, amount);
    }

    function stakeBioEssence(uint256 amount) public whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        require(bioEssence.balanceOf(msg.sender) >= amount, "Insufficient BioEssence balance");

        bioEssence.transferFrom(msg.sender, address(this), amount);
        stakedBioEssence[msg.sender] += amount;

        emit BioEssenceStaked(msg.sender, amount);
    }

    function unstakeBioEssence(uint256 amount) public whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        require(stakedBioEssence[msg.sender] >= amount, "Insufficient staked BioEssence");
        require(currentEpoch >= lastUnstakeEpoch[msg.sender] + STAKING_COOLDOWN_EPOCHS, "Unstaking cooldown in effect");

        stakedBioEssence[msg.sender] -= amount;
        bioEssence.mint(msg.sender, amount); // Mint BioEssence back to the user
        lastUnstakeEpoch[msg.sender] = currentEpoch; // Reset cooldown

        emit BioEssenceUnstaked(msg.sender, amount);
    }

    function getBioEssenceBalance(address user) public view returns (uint256) {
        return bioEssence.balanceOf(user);
    }

    // --- III. Ecosystem Simulation & Environment Management ---

    function cultivateEnvironment(uint256 amount) public whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        require(bioEssence.balanceOf(msg.sender) >= amount, "Insufficient BioEssence balance");

        bioEssence.transferFrom(msg.sender, address(this), amount);

        // Increase nutrientLevel and energyFlow proportionally
        // Max cap at 100
        nutrientLevel = uint8(Math.min(100, nutrientLevel + (amount / (10 ** 18)) / 100)); // Example scaling
        energyFlow = uint8(Math.min(100, energyFlow + (amount / (10 ** 18)) / 100)); // Example scaling

        emit EnvironmentalConditionsUpdated(currentEpoch, nutrientLevel, energyFlow);
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        // Only trigger if a significant amount of time (e.g., 1 hour, or 100 blocks) has passed
        // For a simple demo, we'll assume it's always ready to advance
        upkeepNeeded = true;
    }

    function performUpkeep(bytes calldata /* performData */) external override whenNotPaused {
        // This function is called by Chainlink Automation.
        // It's critical to ensure this cannot be griefed or called too frequently.
        // The checkUpkeep function handles frequency.
        // For demo, we just advance the epoch directly.
        advanceEpoch();
    }

    function advanceEpoch() public whenNotPaused {
        // Restrict to owner or authorized keeper (e.g., Chainlink Automation address)
        // For this example, only owner can call manually, or Chainlink Automation via performUpkeep
        require(msg.sender == owner() || msg.sender == address(0x_CHAINLINK_KEEPER_ADDRESS_HERE_), "Not authorized to advance epoch"); // Replace with actual Keeper address in production

        currentEpoch++;

        // Decay environmental conditions slowly
        if (currentEpoch % 5 == 0) { // Every 5 epochs, decay
            if (nutrientLevel > 1) nutrientLevel--;
            if (energyFlow > 1) energyFlow--;
        }

        // --- Lifeform Updates ---
        // Iterate through all lifeforms (not scalable for many NFTs, but fine for demo)
        for (uint256 i = 0; i < _lifeformIds.current(); i++) {
            uint256 lifeformId = ERC721Enumerable.tokenByIndex(i); // Get ID by index
            Lifeform storage lf = lifeforms[lifeformId];

            if (lf.health == 0) continue; // Skip deceased lifeforms

            // Age lifeform
            lf.age++;
            if (lf.age >= lf.maxAge) {
                lf.health = 0; // Lifeform dies of old age
                // Can trigger burn or specific "death" event here
                continue;
            }

            // Health decay/gain based on environment
            if (lf.health > 0) {
                int256 healthChange = int256(nutrientLevel) - 50; // Example: above 50 nutrientLevel increases health
                lf.health = uint8(Math.min(100, Math.max(0, int256(lf.health) + healthChange / 10))); // Cap health between 0-100
            }

            // If health hits 0, the lifeform dies
            if (lf.health == 0) {
                // Trigger death event or special logic here
                continue;
            }

            // Resource Generation
            uint256 fitnessScore = calculateLifeformFitness(lifeformId);
            uint256 generatedAmount = fitnessScore * RESOURCE_GENERATION_FACTOR;
            lf.accumulatedBioEssence += generatedAmount;
        }

        // Resolve interactions (uses randomness which might require VRF if complex)
        // For simplicity, we pass a pseudo-random seed from currentEpoch, but a VRF call
        // for `AdvanceEpoch` could be made if interactions need provable randomness.
        resolveLifeformInteractions(currentEpoch);

        emit EpochAdvanced(currentEpoch);
    }

    function queryEnvironmentalConditions() public view returns (uint256, uint8, uint8) {
        return (currentEpoch, nutrientLevel, energyFlow);
    }

    // Internal helper for interactions, could be more complex
    function resolveLifeformInteractions(uint256 _randomNumber) internal {
        // Placeholder for complex interaction logic.
        // Example: If two lifeforms are in the same 'biome' (not implemented here),
        // or have conflicting traits, one might lose health, or one might gain.
        // This is where a real "simulation" would happen.
        // For a smart contract, this needs to be deterministic or use VRF.
        // (uint256(_randomNumber) % 100) can be used as a 'dice roll'.

        // Current implementation is a stub.
    }

    // Calculates a lifeform's overall "fitness" based on its traits and environment.
    // Higher fitness means more resource generation and better survival.
    function calculateLifeformFitness(uint256 lifeformId) public view returns (uint256) {
        Lifeform storage lf = lifeforms[lifeformId];
        if (lf.health == 0) return 0;

        uint256 fitness = lf.strength + lf.agility + lf.intelligence;

        // Environmental boost/penalty
        fitness = (fitness * nutrientLevel) / 50; // Nutrient level affects fitness
        fitness = (fitness * energyFlow) / 50;   // Energy flow affects fitness

        return fitness;
    }

    // --- IV. Chainlink VRF Integration ---

    // Internal helper for requesting randomness
    function _requestRandomness(uint256 _callbackGasLimit, uint32 _numWords) internal returns (bytes32 requestId) {
        requestId = requestRandomWords(i_keyHash, i_subscriptionId, REQUEST_CONFIRMATIONS, _callbackGasLimit, _numWords);
        return requestId;
    }

    // Public function to request randomness for specific actions
    function requestRandomnessForAction(bytes32 _key, uint256 _callbackGasLimit, uint32 _numWords)
        public
        returns (bytes32 requestId)
    {
        // This function can be used by external systems or governance to request randomness for custom events.
        // For internal contract actions, _requestRandomness is called directly.
        requestId = _requestRandomness(_callbackGasLimit, _numWords);
        s_requests[requestId] = RequestType.None; // Generic request type, specific action defined by _key
        // Store _key in s_requestAssociatedId or another mapping if needed to link external actions.
        // This function is less critical for the core ecosystem logic, which uses specific VRF calls.
        return requestId;
    }

    function fulfillRandomness(bytes32 requestId, uint256[] memory randomWords) internal override {
        require(s_requests[requestId] != RequestType.None, "request not found");

        uint256 rand1 = randomWords[0];
        uint256 rand2 = randomWords[1];

        if (s_requests[requestId] == RequestType.Mint) {
            uint256 newId = _lifeformIds.current();
            _lifeformIds.increment();
            _safeMint(owner(), newId);

            lifeforms[newId] = Lifeform({
                id: newId,
                generation: 0,
                parent1Id: 0,
                parent2Id: 0,
                health: uint8(50 + (rand1 % 50)), // Initial health 50-99
                strength: uint8(1 + (rand1 % 100)),
                agility: uint8(1 + (rand2 % 100)),
                intelligence: uint8(1 + (rand1 % 100)),
                age: 0,
                maxAge: uint8(75 + (rand2 % 25)), // Max age 75-99 epochs
                lastClaimEpoch: currentEpoch,
                accumulatedBioEssence: 0
            });
            // Update tokenURI (could point to an off-chain API generating metadata based on traits)
            _setTokenURI(newId, string(abi.encodePacked(_baseURI(), Strings.toString(newId))));

            emit LifeformMinted(newId, owner(), 0, uint256(requestId));

        } else if (s_requests[requestId] == RequestType.Breed) {
            (uint256 parent1Id, uint256 parent2Id) = _unpackParentIds(s_requestAssociatedId[requestId]);
            address _owner = ownerOf(parent1Id); // Assuming same owner for both parents

            Lifeform storage p1 = lifeforms[parent1Id];
            Lifeform storage p2 = lifeforms[parent2Id];

            uint256 newId = _lifeformIds.current();
            _lifeformIds.increment();
            _safeMint(_owner, newId);

            // Simple trait inheritance and mutation
            lifeforms[newId] = Lifeform({
                id: newId,
                generation: Math.max(p1.generation, p2.generation) + 1,
                parent1Id: parent1Id,
                parent2Id: parent2Id,
                health: uint8(Math.max(p1.health, p2.health) / 2 + (rand1 % 50)), // Average + random boost
                strength: uint8((p1.strength + p2.strength) / 2 + (rand1 % 10)),
                agility: uint8((p1.agility + p2.agility) / 2 + (rand2 % 10)),
                intelligence: uint8((p1.intelligence + p2.intelligence) / 2 + (rand1 % 10)),
                age: 0,
                maxAge: uint8(Math.max(p1.maxAge, p2.maxAge) + (rand2 % 10)),
                lastClaimEpoch: currentEpoch,
                accumulatedBioEssence: 0
            });
            _setTokenURI(newId, string(abi.encodePacked(_baseURI(), Strings.toString(newId))));

            emit LifeformBred(newId, _owner, parent1Id, parent2Id, uint256(requestId));

        } else if (s_requests[requestId] == RequestType.Evolve) {
            uint256 lifeformId = s_requestAssociatedId[requestId];
            Lifeform storage lf = lifeforms[lifeformId];

            // Evolution logic: improve one trait significantly, or slightly all
            if (rand1 % 3 == 0) lf.strength = uint8(Math.min(100, lf.strength + (rand2 % 20)));
            else if (rand1 % 3 == 1) lf.agility = uint8(Math.min(100, lf.agility + (rand2 % 20)));
            else lf.intelligence = uint8(Math.min(100, lf.intelligence + (rand2 % 20)));

            lf.health = uint8(Math.min(100, lf.health + (rand1 % 10))); // Small health boost
            _setTokenURI(lifeformId, string(abi.encodePacked(_baseURI(), Strings.toString(lifeformId)))); // Update URI

            emit LifeformEvolved(lifeformId, uint256(requestId));

        } else if (s_requests[requestId] == RequestType.Mutate) {
            uint256 lifeformId = s_requestAssociatedId[requestId];
            Lifeform storage lf = lifeforms[lifeformId];

            // Drastic mutation: potentially large change or new "hidden" trait (if implemented)
            uint256 mutationType = rand1 % 4;
            if (mutationType == 0) lf.strength = uint8(rand2 % 100);
            else if (mutationType == 1) lf.agility = uint8(rand2 % 100);
            else if (mutationType == 2) lf.intelligence = uint8(rand2 % 100);
            else lf.maxAge = uint8(75 + (rand2 % 25)); // Change max age

            lf.health = uint8(Math.min(100, lf.health + (rand1 % 5))); // Small health change
            _setTokenURI(lifeformId, string(abi.encodePacked(_baseURI(), Strings.toString(lifeformId)))); // Update URI

            emit LifeformMutated(lifeformId, uint256(requestId));
        }

        delete s_requests[requestId];
        delete s_requestAssociatedId[requestId];
    }

    // Helper to unpack parent IDs from a single uint256
    function _unpackParentIds(uint256 packedIds) private pure returns (uint256 parent1Id, uint256 parent2Id) {
        parent1Id = packedIds >> 128;
        parent2Id = packedIds & type(uint128).max;
    }


    // --- V. Protocol Administration & Governance (Owner/Pausable) ---

    function setProtocolFee(uint256 newFee) public onlyOwner {
        protocolFee = newFee;
        emit ProtocolFeeUpdated(newFee);
    }

    function withdrawProtocolFees() public onlyOwner {
        uint256 balance = bioEssence.balanceOf(address(this));
        require(balance > 0, "No fees to withdraw");
        // Only withdraw fees, not staked BioEssence or generated for Lifeforms
        // This would require a more explicit accounting of fee vs other funds
        // For simplicity, it withdraws all contract's BioEssence
        bioEssence.transfer(owner(), balance);
    }

    function pause() public onlyOwner {
        _pause();
    }

    function unpause() public onlyOwner {
        _unpause();
    }
}

// Utility Math contract for min/max
library Math {
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }
}
```