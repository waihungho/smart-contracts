Okay, let's design a smart contract that embodies resource management, crafting with probabilistic outcomes, dynamic NFT attributes, and a staking mechanism, integrated into an "Ethereal Alchemy" theme. It won't be a simple ERC-20 or ERC-721 clone, but rather a complex system managing multiple intertwined aspects.

Here's the outline and function summary, followed by the Solidity code.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol"; // To hold staked NFTs

/**
 * @title EtherealAlchemy
 * @dev An advanced smart contract for managing alchemical resources (Essences),
 * crafting dynamic artifacts (NFTs) with probabilistic outcomes, and allowing
 * staking of Ether and Artifacts for resource generation and benefits.
 * This contract is designed as a self-contained ecosystem where users manage
 * resources, craft, refine, and maintain unique digital assets.
 *
 * Key Concepts:
 * 1. Essences: Five types of internal, fungible resources (Ignis, Aqua, Terra, Aer, Spiritus).
 * 2. Potential: Generated by staking Ether, convertible into Essences.
 * 3. Catalysts: Special tokens (fungible) used to boost crafting/refinement chances.
 * 4. Artifacts: Non-fungible tokens (NFTs) with dynamic attributes (Power, Durability, Affinities).
 * 5. Transmutation (Crafting): Combining Essences and Catalysts to create new Artifacts with random attributes.
 * 6. Refinement: Using Essences to improve existing Artifact attributes, involves risk.
 * 7. Decay & Maintenance: Artifacts lose Durability over time/interactions, requiring Essence maintenance.
 * 8. Staking: Stake Ether to generate Potential; Stake Artifacts to generate passive Essence/Catalyst rewards.
 * 9. Attunement: Temporarily boost affinity with a specific Essence type for crafting.
 *
 * Outline:
 * 1. State Variables: Define mappings, structs, and configurations for Essences, Artifacts, Staking, etc.
 * 2. Events: Declare events for key actions.
 * 3. Modifiers: Define access control and state-checking modifiers.
 * 4. Constructor: Initialize contract with base settings.
 * 5. ERC721 Implementation: Standard functions for NFT management.
 * 6. Resource Management (Essences & Catalysts):
 *    - Deposit/Withdraw Ether for Potential.
 *    - Extract Essences from Potential.
 *    - Attune Essences.
 *    - View balances.
 * 7. Artifact Lifecycle (NFTs):
 *    - Transmutation (Crafting).
 *    - Refinement (Upgrading).
 *    - Maintenance (Repairing Durability).
 *    - Applying Entropy (Decay mechanism).
 *    - View Artifact details (attributes, durability).
 * 8. Staking Artifacts:
 *    - Stake/Unstake Artifacts.
 *    - Claim Staking Rewards.
 *    - View staking info.
 * 9. Admin/Utility Functions:
 *    - Set configurations (Essences, Artifacts, Rates, Catalysts).
 *    - Pause/Unpause.
 *    - Withdraw Ether.
 *    - Internal helper functions (randomness, attribute generation, resource handling).
 *
 * Function Summary (>20 Custom Functions):
 *
 * Admin/Config (7):
 * 1. setEssenceConfig(EssenceType _type, EssenceConfig calldata _config): Set parameters for an Essence type.
 * 2. setArtifactBaseConfig(uint256 _grade, ArtifactBaseConfig calldata _config): Set base crafting/attribute config for an Artifact grade.
 * 3. setEssenceExtractionRate(uint256 _potentialPerEthPerSecond): Set the rate at which Ether staking generates Potential.
 * 4. setCatalystConfig(uint256 _catalystId, CatalystConfig calldata _config): Set parameters for a Catalyst type.
 * 5. setArtifactStakeRewardRate(uint256 _tokenId, uint256 _rewardRatePerSecond): Set the reward rate for a specific staked Artifact. (Could be dynamic based on attributes, making this admin override)
 * 6. pause(): Pause core contract functions.
 * 7. unpause(): Unpause core contract functions.
 * 8. withdrawEther(address payable _to, uint256 _amount): Withdraw accumulated Ether (from staking or failed txs).
 *
 * Resource Management (Essences & Potential) (5):
 * 9. depositEtherForPotential(): Stake Ether to generate Potential.
 * 10. extractEssence(EssenceType _type): Convert accumulated Potential into a specific Essence type.
 * 11. withdrawStakedEther(): Withdraw staked Ether and any unclaimed Potential.
 * 12. attuneEssence(EssenceType _type, uint256 _duration): Temporarily increase crafting affinity for an Essence type.
 * 13. getPotential(address _user): Get user's current accumulated Potential (updates calculation on read).
 * 14. getEssenceBalance(address _user, EssenceType _type): Get user's balance of a specific Essence.
 *
 * Artifact Lifecycle (NFTs) (7):
 * 15. transmute(EssenceInput[] calldata _essenceInputs, CatalystInput[] calldata _catalystInputs): Craft a new Artifact using Essences and Catalysts. Probabilistic outcome.
 * 16. refineArtifact(uint256 _tokenId, EssenceInput[] calldata _essenceInputs): Improve an existing Artifact's attributes using Essences. Risky operation.
 * 17. maintainArtifact(uint256 _tokenId, EssenceInput[] calldata _essenceInputs): Restore Durability of an Artifact using Essences.
 * 18. applyEntropy(uint256 _tokenId): Manually trigger Durability decay for an Artifact. (Can also happen implicitly during interactions).
 * 19. getArtifactAttributes(uint256 _tokenId): Get the current attributes of an Artifact.
 * 20. getArtifactDurability(uint256 _tokenId): Get the current Durability of an Artifact (potentially after applying entropy).
 * 21. getTokenURI(uint256 _tokenId): Get the metadata URI for an Artifact. (Standard ERC721Metadata, but custom logic)
 *
 * Staking Artifacts (3):
 * 22. stakeArtifact(uint256 _tokenId): Stake an Artifact NFT to earn rewards.
 * 23. unstakeArtifact(uint256 _tokenId): Unstake a previously staked Artifact.
 * 24. claimStakedArtifactRewards(): Claim accumulated Essence/Catalyst rewards from ALL staked Artifacts belonging to the caller.
 * 25. getArtifactStakeInfo(uint256 _tokenId): Get staking information for an Artifact.
 *
 * Internal/Helper Functions (Not counted in the 20, but crucial):
 * - _generateRandomness(): Generate pseudo-random seed.
 * - _generateArtifactAttributes(): Determine attributes based on inputs and randomness.
 * - _deductEssences(), _addEssences(), _deductCatalysts(), _addCatalysts(): Handle resource balance updates.
 * - _calculatePotential(): Internal helper to calculate and update pending potential.
 * - _calculateStakingRewards(): Internal helper to calculate pending staking rewards.
 * - _applyDecay(): Internal helper to apply durability decay.
 * - ERC721 standard functions (balanceOf, ownerOf, transferFrom, approve, setApprovalForAll, getApproved, isApprovedForAll, safeTransferFrom).
 */
contract EtherealAlchemy is ERC721, Ownable, Pausable, ERC721Holder {

    // --- Constants and Enums ---

    enum EssenceType {
        Ignis,      // Fire
        Aqua,       // Water
        Terra,      // Earth
        Aer,        // Air
        Spiritus    // Spirit / Arcane
    }

    uint256 private constant ESSENCE_TYPE_COUNT = 5;
    uint256 private constant BASE_POTENTIAL_RATE_DIVISOR = 1e18; // Potential generated per ETH per second

    // --- Structs ---

    struct EssenceInput {
        EssenceType essenceType;
        uint256 amount;
    }

    struct CatalystInput {
        uint256 catalystId;
        uint256 amount; // Number of uses/items
    }

    struct EssenceConfig {
        uint256 transmuteCost;
        uint256 refineCost;
        uint256 maintainCost;
        uint256 potentialToEssenceRate; // Potential needed to extract 1 unit of this Essence
    }

    struct ArtifactAttributes {
        uint16 power;
        uint16 durability; // Max 65535
        uint16 maxDurability; // Max 65535
        uint16 affinityIgnis;
        uint16 affinityAqua;
        uint16 affinityTerra;
        uint16 affinityAer;
        uint16 affinitySpiritus;
        uint256 grade; // e.g., 1=Common, 2=Rare, 3=Epic
    }

    struct ArtifactBaseConfig {
        uint16 basePower;
        uint16 baseDurability;
        uint16 baseAffinity; // Base affinity for all types
        uint256 transmuteSuccessChance; // Percentage (0-10000)
        uint256 refineSuccessChance;    // Percentage (0-10000)
        uint256 baseStakeRewardRate; // Base reward rate per second (scaled)
        uint256 decayRatePerSecond; // Durability lost per second
    }

    struct CatalystConfig {
        uint256 transmuteBoost; // Percentage points added to success chance
        uint256 refineBoost;    // Percentage points added to success chance
        uint256 duration;       // Affects attunement or other temporary buffs (optional usage)
        uint256 rewardBoost;    // Percentage points added to stake reward rate
    }

    struct ArtifactStakeInfo {
        uint256 stakeTime; // Timestamp when staked
        uint256 accumulatedRewardsPotential; // Accumulated potential for rewards since last claim/stake
        uint256 lastRewardClaimTime; // Timestamp of last reward claim
        uint256 effectiveRewardRatePerSecond; // Calculated based on artifact attributes and catalysts
    }

    struct AttunementInfo {
        EssenceType essenceType;
        uint256 expiryTime;
    }

    // --- State Variables ---

    mapping(address user => mapping(EssenceType essenceType => uint256 balance)) private _essenceBalances;
    mapping(address user => mapping(uint256 catalystId => uint256 balance)) private _catalystBalances;

    mapping(address user => uint256 stakedEtherAmount) private _stakedEther;
    mapping(address user => uint256 potentialGenerated) private _potentialGenerated; // Accumulated potential
    mapping(address user => uint256 lastPotentialUpdateTime) private _lastPotentialUpdateTime;

    mapping(uint256 tokenId => ArtifactAttributes attributes) private _artifactIdToAttributes;
    mapping(uint256 tokenId => ArtifactStakeInfo stakeInfo) private _artifactIdToStakeInfo;
    mapping(uint256 tokenId => bool isStaked) private _isArtifactStaked; // True if staked in this contract

    mapping(EssenceType essenceType => EssenceConfig config) private _essenceConfigs;
    mapping(uint256 grade => ArtifactBaseConfig config) private _artifactBaseConfigs;
    mapping(uint256 catalystId => CatalystConfig config) private _catalystConfigs;

    uint256 private _essenceExtractionRate = 1e18; // Default: 1 ETH staked for 1 sec generates 1 Potential
    uint256 private _totalArtifactsMinted; // Counter for token IDs

    mapping(address user => AttunementInfo attunement) private _userAttunement; // User's current attunement

    // --- Events ---

    event EssenceBalanceChanged(address indexed user, EssenceType indexed essenceType, uint256 newBalance);
    event CatalystBalanceChanged(address indexed user, uint256 indexed catalystId, uint256 newBalance);
    event PotentialGenerated(address indexed user, uint256 amount);
    event EssenceExtracted(address indexed user, EssenceType indexed essenceType, uint256 amount);
    event EtherStaked(address indexed user, uint256 amount);
    event StakedEtherWithdrawn(address indexed user, uint256 amount, uint256 unclaimedPotential);

    event ArtifactTransmuted(address indexed owner, uint256 indexed tokenId, uint256 grade);
    event ArtifactRefined(uint256 indexed tokenId, bool success, ArtifactAttributes newAttributes);
    event ArtifactMaintained(uint256 indexed tokenId, uint16 restoredDurability, uint16 newDurability);
    event ArtifactEntropyApplied(uint256 indexed tokenId, uint16 durabilityLost, uint16 newDurability);

    event ArtifactStaked(address indexed owner, uint256 indexed tokenId);
    event ArtifactUnstaked(address indexed owner, uint256 indexed tokenId);
    event StakingRewardsClaimed(address indexed user, uint256 essenceAmount, uint256 catalystAmount); // Simplified, could detail types/ids

    event EssenceAttuned(address indexed user, EssenceType indexed essenceType, uint256 expiryTime);

    event ConfigUpdated(string configType, uint256 idOrType);

    // --- Modifiers ---

    modifier artifactExists(uint256 _tokenId) {
        require(_exists(_tokenId), "Alchemy: Artifact does not exist");
        _;
    }

    modifier isArtifactOwner(uint256 _tokenId) {
        require(ownerOf(_tokenId) == msg.sender, "Alchemy: Not artifact owner");
        _;
    }

    modifier isArtifactStaked(uint256 _tokenId) {
        require(_isArtifactStaked[_tokenId], "Alchemy: Artifact is not staked");
        _;
    }

    modifier isArtifactNotStaked(uint256 _tokenId) {
        require(!_isArtifactStaked[_tokenId], "Alchemy: Artifact is currently staked");
        _;
    }

    // --- Constructor ---

    constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) Pausable() {
        // Initial default configs can be set here or via admin functions later
    }

    // --- ERC721 Standard Functions (Required & Optional) ---
    // Implemented by inheriting ERC721, but need to handle transfers for staked items

    function tokenURI(uint256 tokenId) public view override(ERC721, IERC721Metadata) returns (string memory) {
         require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
         // @TODO: Implement custom token URI logic based on artifact attributes
         // For now, return a placeholder or default URI.
         return string(abi.encodePacked("ipfs://<YOUR_BASE_URI>/", Strings.toString(tokenId)));
    }

    // Override transfer functions to prevent moving staked artifacts
    function transferFrom(address from, address to, uint256 tokenId) public payable override(ERC721) {
        require(!_isArtifactStaked[tokenId], "Alchemy: Cannot transfer staked artifact");
        super.transferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override(ERC721) {
         require(!_isArtifactStaked[tokenId], "Alchemy: Cannot transfer staked artifact");
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public payable override(ERC721) {
         require(!_isArtifactStaked[tokenId], "Alchemy: Cannot transfer staked artifact");
        super.safeTransferFrom(from, to, tokenId, data);
    }

    // ERC721Holder is needed so the contract can receive NFTs when staked
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public virtual override(ERC721Holder) returns (bytes4) {
        // Optional: Add custom logic here if needed when receiving specific NFTs
        // For this contract, we only expect to receive NFTs that are being staked
        return this.onERC721Received.selector;
    }

    // --- Admin/Config Functions ---

    /// @notice Sets the configuration for a specific Essence type.
    /// @param _type The Essence type to configure.
    /// @param _config The EssenceConfig struct containing new parameters.
    function setEssenceConfig(EssenceType _type, EssenceConfig calldata _config) public onlyOwner {
        _essenceConfigs[_type] = _config;
        emit ConfigUpdated("EssenceConfig", uint256(_type));
    }

    /// @notice Sets the base configuration for an Artifact grade.
    /// @param _grade The Artifact grade to configure.
    /// @param _config The ArtifactBaseConfig struct containing new parameters.
    function setArtifactBaseConfig(uint256 _grade, ArtifactBaseConfig calldata _config) public onlyOwner {
        require(_grade > 0, "Alchemy: Grade must be positive");
        _artifactBaseConfigs[_grade] = _config;
        emit ConfigUpdated("ArtifactBaseConfig", _grade);
    }

    /// @notice Sets the rate at which staked Ether generates Potential.
    /// @param _potentialPerEthPerSecond The new rate (scaled by BASE_POTENTIAL_RATE_DIVISOR).
    function setEssenceExtractionRate(uint256 _potentialPerEthPerSecond) public onlyOwner {
        _essenceExtractionRate = _potentialPerEthPerSecond;
        emit ConfigUpdated("ExtractionRate", _potentialPerEthPerSecond); // Using rate as id for event clarity
    }

    /// @notice Sets the configuration for a specific Catalyst type.
    /// @param _catalystId The ID of the Catalyst to configure.
    /// @param _config The CatalystConfig struct containing new parameters.
    function setCatalystConfig(uint256 _catalystId, CatalystConfig calldata _config) public onlyOwner {
        require(_catalystId > 0, "Alchemy: Catalyst ID must be positive");
        _catalystConfigs[_catalystId] = _config;
        emit ConfigUpdated("CatalystConfig", _catalystId);
    }

     /// @notice Sets the specific reward rate for a staked artifact. Admin override.
     /// @param _tokenId The ID of the staked artifact.
     /// @param _rewardRatePerSecond The new reward rate per second (scaled).
    function setArtifactStakeRewardRate(uint256 _tokenId, uint256 _rewardRatePerSecond) public onlyOwner artifactExists(_tokenId) isArtifactStaked(_tokenId) {
        _artifactIdToStakeInfo[_tokenId].effectiveRewardRatePerSecond = _rewardRatePerSecond;
        emit ConfigUpdated("ArtifactStakeRewardRate", _tokenId);
    }

    /// @notice Pauses core contract functionality like crafting, extraction, staking.
    function pause() public onlyOwner whenNotPaused {
        _pause();
    }

    /// @notice Unpauses core contract functionality.
    function unpause() public onlyOwner whenPaused {
        _unpause();
    }

    /// @notice Allows the owner to withdraw any Ether held by the contract (from staking or failed transactions).
    /// @param _to The address to send Ether to.
    /// @param _amount The amount of Ether to withdraw.
    function withdrawEther(address payable _to, uint256 _amount) public onlyOwner {
        require(_amount > 0, "Alchemy: Amount must be positive");
        require(address(this).balance >= _amount, "Alchemy: Insufficient contract balance");
        _to.transfer(_amount);
    }

    // --- Resource Management (Essences & Potential) ---

    /// @notice Allows a user to stake Ether to generate Potential over time.
    /// @dev Potential is calculated based on the amount staked and time elapsed.
    function depositEtherForPotential() public payable whenNotPaused {
        require(msg.value > 0, "Alchemy: Must send Ether to stake");

        _calculatePotential(msg.sender); // Calculate and add potential before updating stake
        _stakedEther[msg.sender] += msg.value;
        _lastPotentialUpdateTime[msg.sender] = block.timestamp;

        emit EtherStaked(msg.sender, msg.value);
    }

    /// @notice Allows a user to convert accumulated Potential into a specific Essence type.
    /// @param _type The type of Essence to extract.
    function extractEssence(EssenceType _type) public whenNotPaused {
        _calculatePotential(msg.sender); // Calculate and add potential

        EssenceConfig storage config = _essenceConfigs[_type];
        require(config.potentialToEssenceRate > 0, "Alchemy: Essence type not configured for extraction");

        uint256 availablePotential = _potentialGenerated[msg.sender];
        require(availablePotential >= config.potentialToEssenceRate, "Alchemy: Insufficient potential to extract one unit");

        uint256 essenceAmount = availablePotential / config.potentialToEssenceRate;
        uint256 potentialConsumed = essenceAmount * config.potentialToEssenceRate;

        _potentialGenerated[msg.sender] -= potentialConsumed;
        _addEssences(msg.sender, _type, essenceAmount);

        emit EssenceExtracted(msg.sender, _type, essenceAmount);
    }

    /// @notice Allows a user to withdraw their staked Ether and any remaining accumulated Potential.
    function withdrawStakedEther() public whenNotPaused {
        uint256 amountToWithdraw = _stakedEther[msg.sender];
        require(amountToWithdraw > 0, "Alchemy: No Ether staked");

        _calculatePotential(msg.sender); // Calculate and add final potential

        uint256 unclaimedPotential = _potentialGenerated[msg.sender];

        _stakedEther[msg.sender] = 0;
        _potentialGenerated[msg.sender] = 0;
        _lastPotentialUpdateTime[msg.sender] = block.timestamp; // Reset update time

        (bool success, ) = payable(msg.sender).call{value: amountToWithdraw}("");
        require(success, "Alchemy: Ether withdrawal failed");

        emit StakedEtherWithdrawn(msg.sender, amountToWithdraw, unclaimedPotential);
    }

    /// @notice Allows a user to attune themselves to a specific Essence type, granting a temporary crafting/refinement buff.
    /// @param _type The Essence type to attune to.
    /// @param _duration The duration of the attunement in seconds.
    function attuneEssence(EssenceType _type, uint256 _duration) public whenNotPaused {
        require(_duration > 0, "Alchemy: Attunement duration must be positive");
        // @TODO: Add cost for attunement (e.g., burn Essences or Catalysts)

        uint256 expiry = block.timestamp + _duration;
        _userAttunement[msg.sender] = AttunementInfo(_type, expiry);

        emit EssenceAttuned(msg.sender, _type, expiry);
    }

    /// @notice Calculates and returns a user's current accumulated Potential.
    /// @param _user The address of the user.
    /// @return uint256 The user's accumulated Potential.
    function getPotential(address _user) public view returns (uint256) {
        uint256 staked = _stakedEther[_user];
        if (staked == 0) {
            return _potentialGenerated[_user];
        }
        uint256 timeElapsed = block.timestamp - _lastPotentialUpdateTime[_user];
        uint256 potentialFromTime = (staked * timeElapsed * _essenceExtractionRate) / BASE_POTENTIAL_RATE_DIVISOR;
        return _potentialGenerated[_user] + potentialFromTime;
    }

     /// @notice Get user's balance of a specific Essence.
     /// @param _user The address of the user.
     /// @param _type The Essence type.
     /// @return uint256 The balance.
    function getEssenceBalance(address _user, EssenceType _type) public view returns (uint256) {
        return _essenceBalances[_user][_type];
    }

    // --- Artifact Lifecycle (NFTs) ---

    /// @notice Crafts a new Artifact using a mix of Essences and optional Catalysts.
    /// @dev Outcome (success/failure, attributes) is probabilistic.
    /// @param _essenceInputs Array of Essence types and amounts used.
    /// @param _catalystInputs Array of Catalyst IDs and amounts used.
    function transmute(EssenceInput[] calldata _essenceInputs, CatalystInput[] calldata _catalystInputs) public whenNotPaused {
        // 1. Validate inputs and calculate total essence cost based on config
        uint256 totalEssenceCost = 0;
        mapping(EssenceType => uint256) memory inputEssenceAmounts;
        for (uint i = 0; i < _essenceInputs.length; i++) {
            EssenceInput calldata input = _essenceInputs[i];
            EssenceConfig storage config = _essenceConfigs[input.essenceType];
            require(config.transmuteCost > 0, "Alchemy: Essence type not configured for transmutation cost");
            totalEssenceCost += config.transmuteCost * input.amount;
            inputEssenceAmounts[input.essenceType] += input.amount; // Sum amounts for attribute generation
        }
        // Check user has enough of each input essence
        for (uint i = 0; i < _essenceInputs.length; i++) {
             EssenceInput calldata input = _essenceInputs[i];
             require(_essenceBalances[msg.sender][input.essenceType] >= input.amount, "Alchemy: Insufficient essence balance");
        }


        // 2. Process Catalysts and calculate success chance modifier
        uint256 catalystBoost = 0;
        mapping(uint256 => uint256) memory inputCatalystAmounts;
         for (uint i = 0; i < _catalystInputs.length; i++) {
            CatalystInput calldata input = _catalystInputs[i];
            CatalystConfig storage config = _catalystConfigs[input.catalystId];
             require(_catalystBalances[msg.sender][input.catalystId] >= input.amount, "Alchemy: Insufficient catalyst balance");
            catalystBoost += config.transmuteBoost * input.amount;
            inputCatalystAmounts[input.catalystId] += input.amount; // Sum amounts
         }


        // 3. Deduct resources
        _deductEssences(msg.sender, _essenceInputs);
        _deductCatalysts(msg.sender, _catalystInputs);
        // @TODO: Deduct base crafting fee (in Essences, Ether, or separate token?)
        // For now, assume the essence cost covers the base cost

        // 4. Determine Artifact Grade and Base Success Chance (simple: based on total essence cost or a specific key essence)
        // Let's simplify: always attempt to craft Grade 1 initially, refine later
        uint256 targetGrade = 1;
        ArtifactBaseConfig storage baseConfig = _artifactBaseConfigs[targetGrade];
        require(baseConfig.transmuteSuccessChance > 0, "Alchemy: Artifact grade not configured for transmutation");

        uint256 baseSuccessChance = baseConfig.transmuteSuccessChance;
        uint256 finalSuccessChance = baseSuccessChance + catalystBoost; // Add catalyst boost
        finalSuccessChance = Math.min(finalSuccessChance, 10000); // Cap chance at 100% (10000/10000)

        // Apply Attunement boost
        AttunementInfo storage userAttunement = _userAttunement[msg.sender];
        if (userAttunement.expiryTime > block.timestamp) {
            // Simple boost: flat percentage increase for the attuned type's impact or success chance
            // Let's boost success chance slightly if a relevant essence is used heavily
            // This is a complex design choice. Let's simplify and say it gives a small global success chance boost if attuned to *any* input essence type.
             for (uint i = 0; i < _essenceInputs.length; i++) {
                 if (_essenceInputs[i].essenceType == userAttunement.essenceType && _essenceInputs[i].amount > 0) {
                     finalSuccessChance += 100; // Add 1 percentage point (example boost)
                     break; // Apply boost only once
                 }
             }
             finalSuccessChance = Math.min(finalSuccessChance, 10000);
        }


        // 5. Generate Randomness and Determine Outcome
        uint256 randomNumber = _generateRandomness();
        bool success = (randomNumber % 10001) < finalSuccessChance; // Roll between 0-10000

        if (success) {
            // 6. Mint new Artifact NFT
            _totalArtifactsMinted++;
            uint256 newTokenId = _totalArtifactsMinted;
            _safeMint(msg.sender, newTokenId);

            // 7. Generate Attributes based on inputs, config, and randomness
            _artifactIdToAttributes[newTokenId] = _generateArtifactAttributes(
                targetGrade,
                baseConfig,
                inputEssenceAmounts, // Pass summed amounts
                randomNumber // Use part of the randomness
            );

            emit ArtifactTransmuted(msg.sender, newTokenId, targetGrade);

        } else {
            // 8. Handle Failure (e.g., lose some inputs, get a 'Junk' token, or nothing)
            // Let's say failure results in losing all inputs for now.
            // @TODO: Could mint a "Failed Transmutation" NFT or refund a fraction of inputs.
            // For simplicity, inputs are lost on failure in this version.
            // Emit a failure event if desired.
            // emit TransmutationFailed(msg.sender);
        }
    }


    /// @notice Attempts to refine an existing Artifact to improve its attributes.
    /// @dev Requires Essences, probabilistic success, can potentially fail or decrease attributes.
    /// @param _tokenId The ID of the Artifact to refine.
    /// @param _essenceInputs Array of Essence types and amounts used for refinement.
    function refineArtifact(uint256 _tokenId, EssenceInput[] calldata _essenceInputs) public whenNotPaused artifactExists(_tokenId) isArtifactOwner(_tokenId) isArtifactNotStaked(_tokenId) {
        ArtifactAttributes storage artifact = _artifactIdToAttributes[_tokenId];
        ArtifactBaseConfig storage baseConfig = _artifactBaseConfigs[artifact.grade];
        require(baseConfig.refineSuccessChance > 0, "Alchemy: Artifact grade not configured for refinement");

         // 1. Validate inputs and calculate total essence cost
        mapping(EssenceType => uint256) memory inputEssenceAmounts; // Sum amounts for attribute impact
        for (uint i = 0; i < _essenceInputs.length; i++) {
            EssenceInput calldata input = _essenceInputs[i];
            EssenceConfig storage config = _essenceConfigs[input.essenceType];
            require(config.refineCost > 0, "Alchemy: Essence type not configured for refinement cost");
            // @TODO: Calculate total cost if it's based on config.refineCost * amount
            // For now, let's assume a fixed cost per refinement attempt, potentially consuming specific essences
            // require(_essenceBalances[msg.sender][input.essenceType] >= input.amount, "Alchemy: Insufficient essence balance for refinement");
            inputEssenceAmounts[input.essenceType] += input.amount; // Sum amounts for attribute impact
        }
         // Check user has enough of each input essence based on the total required, not individual amounts
         // Example: refinement requires 10 Ignis + 5 Aqua. User provides 15 Ignis, 10 Aqua. Check if total provided >= total required.
         // Let's simplify for now and check if the user has at least the *input amounts* provided.
         for (uint i = 0; i < _essenceInputs.length; i++) {
             EssenceInput calldata input = _essenceInputs[i];
             require(_essenceBalances[msg.sender][input.essenceType] >= input.amount, "Alchemy: Insufficient essence balance");
         }


        // 2. Deduct Essences
         _deductEssences(msg.sender, _essenceInputs);
        // @TODO: Deduct Catalyst cost if catalysts are used for refinement

        // 3. Calculate Success Chance (Base + Potential Catalyst Boost)
        uint256 successChance = baseConfig.refineSuccessChance;
        // @TODO: Add Catalyst and Attunement boost if applicable

        // 4. Generate Randomness and Determine Outcome
        uint256 randomNumber = _generateRandomness();
        bool success = (randomNumber % 10001) < successChance;

        ArtifactAttributes memory oldAttributes = artifact;

        if (success) {
            // 5. Successfully refine: improve attributes based on inputs and randomness
            // @TODO: Implement attribute improvement logic. More of certain essences could boost related affinities.
            // For simplicity, let's apply a random small boost to power/durability based on total essence amount
            uint256 totalInputAmount = 0;
             for (uint i = 0; i < _essenceInputs.length; i++) {
                 totalInputAmount += _essenceInputs[i].amount;
             }
            uint26 refinementBoost = uint16((randomNumber / 101) % 10 + 1); // Boost between 1-10
            artifact.power += refinementBoost;
            artifact.maxDurability += refinementBoost;
            artifact.durability = artifact.maxDurability; // Full repair on successful refine

            // Emit event with new attributes
            emit ArtifactRefined(_tokenId, true, artifact);

        } else {
             // 6. Failure: Risk of slight attribute loss or durability loss
             uint26 refinementPenalty = uint16((randomNumber / 51) % 5 + 1); // Penalty between 1-5
             if (artifact.power > refinementPenalty) artifact.power -= refinementPenalty; else artifact.power = 0;
             if (artifact.maxDurability > refinementPenalty) artifact.maxDurability -= refinementPenalty; else artifact.maxDurability = 0;
             if (artifact.durability > refinementPenalty) artifact.durability -= refinementPenalty; else artifact.durability = 0;

             emit ArtifactRefined(_tokenId, false, artifact);
        }
    }

    /// @notice Restores the Durability of an Artifact using Essences.
    /// @param _tokenId The ID of the Artifact to maintain.
    /// @param _essenceInputs Array of Essence types and amounts used for maintenance.
    function maintainArtifact(uint256 _tokenId, EssenceInput[] calldata _essenceInputs) public whenNotPaused artifactExists(_tokenId) isArtifactOwner(_tokenId) isArtifactNotStaked(_tokenId) {
         ArtifactAttributes storage artifact = _artifactIdToAttributes[_tokenId];
         require(artifact.durability < artifact.maxDurability, "Alchemy: Artifact does not need maintenance");

         // 1. Validate inputs and calculate total essence cost
         uint256 totalEssenceCost = 0;
         for (uint i = 0; i < _essenceInputs.length; i++) {
             EssenceInput calldata input = _essenceInputs[i];
             EssenceConfig storage config = _essenceConfigs[input.essenceType];
             require(config.maintainCost > 0, "Alchemy: Essence type not configured for maintenance cost");
             totalEssenceCost += config.maintainCost * input.amount;
             require(_essenceBalances[msg.sender][input.essenceType] >= input.amount, "Alchemy: Insufficient essence balance for maintenance");
         }

         // 2. Deduct Essences
         _deductEssences(msg.sender, _essenceInputs);

         // 3. Restore Durability
         // Let's make restoration amount proportional to the total essence cost paid
         uint16 restoreAmount = uint16(Math.min(totalEssenceCost / 1e15, uint256(artifact.maxDurability - artifact.durability))); // Example scaling
         uint16 oldDurability = artifact.durability;
         artifact.durability += restoreAmount;

         emit ArtifactMaintained(_tokenId, restoreAmount, artifact.durability);
    }

    /// @notice Applies durability decay (entropy) to an artifact based on time elapsed.
    /// @dev Can be called by anyone, might incentivize keepers. Durability loss is capped by time since last decay/maintenance.
    /// @param _tokenId The ID of the Artifact.
    function applyEntropy(uint256 _tokenId) public whenNotPaused artifactExists(_tokenId) {
        ArtifactAttributes storage artifact = _artifactIdToAttributes[_tokenId];
        ArtifactBaseConfig storage baseConfig = _artifactBaseConfigs[artifact.grade];
        require(baseConfig.decayRatePerSecond > 0, "Alchemy: Artifact grade not configured for decay");

        // Track last decay application time per artifact
        // This needs a new mapping: mapping(uint256 tokenId => uint256 lastDecayTime) private _lastDecayTime;
        // Initialize this time upon minting and maintenance.
        // Let's add this mapping.
        // (Adding _lastDecayTime mapping to state variables)
        uint256 lastDecayTime = _lastDecayTime[_tokenId];
        if (lastDecayTime == 0) lastDecayTime = block.timestamp; // Initialize if never decayed/maintained

        uint256 timeElapsed = block.timestamp - lastDecayTime;
        if (timeElapsed == 0) {
            return; // No time elapsed since last update
        }

        uint256 durabilityLoss = (uint256(baseConfig.decayRatePerSecond) * timeElapsed) / 1e18; // Assuming rate is scaled
        uint16 actualLoss = uint16(Math.min(durabilityLoss, uint256(artifact.durability)));

        artifact.durability -= actualLoss;
        _lastDecayTime[_tokenId] = block.timestamp; // Update decay time

        if (actualLoss > 0) {
             emit ArtifactEntropyApplied(_tokenId, actualLoss, artifact.durability);
        }
         // @TODO: Add small incentive (e.g., tiny amount of Essence) for the caller?
    }

    /// @notice Gets the current attributes of an Artifact.
    /// @dev Applies pending decay before returning, but doesn't save the state change unless applyEntropy is called explicitly or during another function.
    /// It's better to have applyEntropy update the state. Let's adjust applyEntropy to be callable and update state.
    /// And this view function just reads the current state.
    /// @param _tokenId The ID of the Artifact.
    /// @return ArtifactAttributes The artifact's attributes.
    function getArtifactAttributes(uint256 _tokenId) public view artifactExists(_tokenId) returns (ArtifactAttributes memory) {
        // Note: This returns the *stored* attributes. Decay might have happened since the last update.
        // To get effective attributes considering decay, a helper might calculate based on current time,
        // but that would require reading _lastDecayTime which is internal.
        // A simpler approach: applyEntropy is public and updates state. This function reads the updated state.
        return _artifactIdToAttributes[_tokenId];
    }

     /// @notice Gets the current Durability of an Artifact.
     /// @dev Calls applyEntropy internally to update durability before returning. This ensures the read is up-to-date.
     /// Note: This makes reading durability cost gas.
     /// @param _tokenId The ID of the Artifact.
     /// @return uint16 The artifact's current Durability.
    function getArtifactDurability(uint256 _tokenId) public returns (uint16) {
         // Apply potential decay before returning the value
         // This ensures reading durability is (mostly) up-to-date but costs gas.
         // Alternative: require user to call applyEntropy first, or make getArtifactDurability pure/view and rely on user/keeper to call applyEntropy.
         // Let's make it apply decay internally for user convenience, accepting the gas cost.
         // Need to ensure applyEntropy handles being called multiple times on the same block gracefully (timeElapsed will be 0).
         // The require inside applyEntropy handles this.
         applyEntropy(_tokenId); // Update state before reading

         return _artifactIdToAttributes[_tokenId].durability;
    }


    // --- Staking Artifacts ---

    /// @notice Stakes an Artifact NFT within the contract to earn passive rewards.
    /// @dev The caller must approve or transfer the NFT to the contract first.
    /// @param _tokenId The ID of the Artifact to stake.
    function stakeArtifact(uint256 _tokenId) public whenNotPaused artifactExists(_tokenId) isArtifactNotStaked(_tokenId) {
        // Check if the artifact is owned by the caller AND approved or transferred to this contract
        // Using ERC721Holder allows direct transfer to the contract, simpler than approval flow here.
        // Require the artifact's owner to be the caller, and the artifact to be transferred to 'this'.
        // This means the user calls `safeTransferFrom(msg.sender, address(this), tokenId)` on the ERC721 contract
        // (which is this contract itself). So, the user needs to call safeTransferFrom *on this contract*.
        // Or, the user approves the contract and then calls a stake function here.
        // Let's use the ERC721Holder callback approach. The user transfers the NFT *to* this contract.
        // The onERC721Received callback could potentially handle the staking logic,
        // or it could just accept the transfer and require a separate `confirmStake` call.
        // A separate `stakeArtifact` function requiring the NFT to *already* be owned by the contract is simpler and more common.
        // So, the flow is: user calls `approve(address(this), tokenId)` THEN `stakeArtifact(tokenId)`.

        require(ownerOf(_tokenId) == msg.sender || getApproved(_tokenId) == address(this) || isApprovedForAll(msg.sender, address(this)),
            "Alchemy: Caller must own artifact or approve contract");

        // Transfer the artifact to the contract
        _transfer(msg.sender, address(this), _tokenId);

        // Mark as staked
        _isArtifactStaked[_tokenId] = true;

        // Initialize staking info
        ArtifactStakeInfo storage stakeInfo = _artifactIdToStakeInfo[_tokenId];
        stakeInfo.stakeTime = block.timestamp;
        stakeInfo.lastRewardClaimTime = block.timestamp;
        stakeInfo.accumulatedRewardsPotential = 0;

        // Calculate initial reward rate based on artifact attributes
        ArtifactAttributes storage artifact = _artifactIdToAttributes[_tokenId];
        ArtifactBaseConfig storage baseConfig = _artifactBaseConfigs[artifact.grade];
        uint256 baseRate = baseConfig.baseStakeRewardRate; // This rate needs to be defined in config

        // Example: Reward rate boosts based on Power and Durability
        uint256 attributeBoost = (artifact.power * 100 + artifact.durability) / 1000; // Simple arbitrary scaling
        stakeInfo.effectiveRewardRatePerSecond = baseRate + attributeBoost;

        emit ArtifactStaked(msg.sender, _tokenId);
    }

    /// @notice Unstakes a previously staked Artifact. Claims pending rewards.
    /// @param _tokenId The ID of the Artifact to unstake.
    function unstakeArtifact(uint256 _tokenId) public whenNotPaused artifactExists(_tokenId) isArtifactStaked(_tokenId) {
        // Check caller is the original staker (or authorized)
        // Assuming only the original staker can unstake.
        // Need to track who staked it. Add mapping: mapping(uint256 tokenId => address originalStaker);
        // (Adding _originalStaker mapping to state variables)
        require(_originalStaker[_tokenId] == msg.sender, "Alchemy: Only original staker can unstake");

        // Claim pending rewards first
        _calculateStakingRewards(msg.sender, _tokenId); // Calculate for this specific token
        // The claimStakedArtifactRewards function calculates for ALL.
        // Let's modify claimStakedArtifactRewards to take an optional tokenId or claim all.
        // For unstaking, we *must* claim for this specific token before transferring.
        // Reworking: _calculateStakingRewards will be internal and return the *amount* of potential generated for THIS artifact.
        // unstake calls this helper, adds to user's _potentialGenerated.
        // Then unstake just moves the NFT and updates state. User claims potential separately via extractEssence.
        // Simpler: unstake auto-claims *all* pending rewards for the user.
        // Let's stick with claimStakedArtifactRewards claims all for the user.
        // So, unstake calls claimStakedArtifactRewards(msg.sender) implicitly or requires user to do it first.
        // Let's require the user to call `claimStakedArtifactRewards()` *before* unstaking, or add the claim logic directly here for this token.
        // Adding claim logic directly to unstake for this token.

        // Calculate rewards for this token
        _calculateStakingRewards(msg.sender, _tokenId); // This adds potential to msg.sender's balance
        _potentialGenerated[msg.sender] += _artifactIdToStakeInfo[_tokenId].accumulatedRewardsPotential;
        _artifactIdToStakeInfo[_tokenId].accumulatedRewardsPotential = 0; // Reset accumulated rewards for this token
        _artifactIdToStakeInfo[_tokenId].lastRewardClaimTime = block.timestamp; // Update claim time

        // Mark as unstaked
        _isArtifactStaked[_tokenId] = false;
        delete _artifactIdToStakeInfo[_tokenId]; // Clear staking info

        // Transfer the artifact back to the staker
        _transfer(address(this), msg.sender, _tokenId);

        emit ArtifactUnstaked(msg.sender, _tokenId);
    }

    /// @notice Claims accumulated Essence/Catalyst rewards from all staked Artifacts belonging to the caller.
    /// @dev Rewards are accumulated Potential, which must then be extracted into Essences using `extractEssence`.
    function claimStakedArtifactRewards() public whenNotPaused {
        // Need a way to track which tokens a user has staked.
        // Add mapping: mapping(address user => uint256[] stakedTokenIds);
        // This array needs careful management on stake/unstake (push/remove). Array removal is expensive.
        // Alternative: a linked list. More complex implementation.
        // Simpler alternative: iterate through all token IDs owned by the contract and check if _originalStaker[tokenId] == msg.sender.
        // This can be gas intensive if many tokens are staked.
        // Let's stick to iterating owned tokens by the contract and checking the original staker. Max tokens staked by one user might be capped?
        // Or require user to claim per artifact? No, the request was for claiming *all*.
        // Need to make the iteration safe within block gas limits. Maybe process rewards in batches?
        // For simplicity in this example, assume the number of staked tokens isn't excessively large for a single user's claim.

        uint256 totalPotentialClaimed = 0;
        address staker = msg.sender; // Store sender to prevent reentrancy issues if iterating state arrays

        uint256 contractTokenCount = balanceOf(address(this));
        // Iterating through all tokens owned by the contract is highly inefficient.
        // A better approach for reward claiming is to track cumulative reward potential per user.
        // Let's change the approach:
        // 1. When staking/unstaking/claiming, calculate potential generated for the token since the last update.
        // 2. Add this potential to a user-specific cumulative reward potential balance: mapping(address user => uint256 cumulativeStakingRewardPotential);
        // 3. When claiming, transfer this cumulative balance to the user's main _potentialGenerated balance.

        // Reworking claimStakedArtifactRewards based on cumulative potential:
        uint256 cumulativePotential = _cumulativeStakingRewardPotential[staker];
        require(cumulativePotential > 0, "Alchemy: No pending staking rewards");

        _potentialGenerated[staker] += cumulativePotential;
        _cumulativeStakingRewardPotential[staker] = 0; // Reset cumulative balance

        // Need to update potential for each staked artifact at claim time
        // This still requires iterating over the user's staked tokens.
        // Let's revert to the per-token accumulation and claiming per token, or update the cumulative potential when *any* function is called by the staker.
        // Let's try the latter: update potential for *all* staked tokens owned by the user whenever they call *any* function that might involve their state (like claiming).

        // Update potential for all of msg.sender's staked tokens *before* claiming
        _updateAllStakedArtifactRewards(staker); // Internal helper

        // Now claim the accumulated potential that was added by _updateAllStakedArtifactRewards
        cumulativePotential = _cumulativeStakingRewardPotential[staker];
        require(cumulativePotential > 0, "Alchemy: No pending staking rewards after update");

        _potentialGenerated[staker] += cumulativePotential;
        _cumulativeStakingRewardPotential[staker] = 0; // Reset cumulative balance

        emit StakingRewardsClaimed(staker, 0, 0); // Event simplified, actual resources extracted via extractEssence
    }

    /// @notice Gets staking information for a specific Artifact.
    /// @param _tokenId The ID of the Artifact.
    /// @return ArtifactStakeInfo The staking information.
    function getArtifactStakeInfo(uint256 _tokenId) public view artifactExists(_tokenId) returns (ArtifactStakeInfo memory) {
         require(_isArtifactStaked[_tokenId], "Alchemy: Artifact is not staked");
         ArtifactStakeInfo memory info = _artifactIdToStakeInfo[_tokenId];
         // Calculate potential generated since last update *without* updating state
         uint256 timeElapsed = block.timestamp - info.lastRewardClaimTime;
         uint256 potentialFromTime = (info.effectiveRewardRatePerSecond * timeElapsed); // Assuming rate scaling is handled in set rate
         info.accumulatedRewardsPotential += potentialFromTime; // Return potential including current block

         return info;
    }

    // --- View Functions (non-state changing reads) ---
    // Many getters are already included above (getPotential, getEssenceBalance, getArtifactAttributes, getArtifactDurability, getArtifactStakeInfo, tokenURI)
    // Standard ERC721 view functions (balanceOf, ownerOf, getApproved, isApprovedForAll, name, symbol) are also available.

    // Example additional view function
    function getAttunementInfo(address _user) public view returns (AttunementInfo memory) {
        return _userAttunement[_user];
    }

    // --- Internal Helper Functions ---

     // Mapping to track last decay time per artifact
    mapping(uint256 tokenId => uint256 lastDecayTime) private _lastDecayTime;

     // Mapping to track original staker
    mapping(uint256 tokenId => address originalStaker) private _originalStaker;

    // Mapping for cumulative staking reward potential per user
    mapping(address user => uint256 cumulativeStakingRewardPotential) private _cumulativeStakingRewardPotential;

    /// @dev Internal function to calculate and add generated Potential since the last update.
    /// @param _user The address of the user.
    function _calculatePotential(address _user) internal {
        uint256 staked = _stakedEther[_user];
        uint256 lastUpdate = _lastPotentialUpdateTime[_user];

        if (staked > 0 && lastUpdate > 0) {
            uint256 timeElapsed = block.timestamp - lastUpdate;
            if (timeElapsed > 0) {
                uint256 potentialFromTime = (staked * timeElapsed * _essenceExtractionRate) / BASE_POTENTIAL_RATE_DIVISOR;
                _potentialGenerated[_user] += potentialFromTime;
                emit PotentialGenerated(_user, potentialFromTime);
            }
        }
         _lastPotentialUpdateTime[_user] = block.timestamp; // Always update time
    }

     /// @dev Internal function to deduct Essences from a user's balance.
     /// @param _user The address of the user.
     /// @param _essenceInputs Array of Essence types and amounts to deduct.
    function _deductEssences(address _user, EssenceInput[] calldata _essenceInputs) internal {
         for (uint i = 0; i < _essenceInputs.length; i++) {
             EssenceInput calldata input = _essenceInputs[i];
             require(_essenceBalances[_user][input.essenceType] >= input.amount, "Alchemy: Insufficient essence balance for deduction");
             _essenceBalances[_user][input.essenceType] -= input.amount;
             emit EssenceBalanceChanged(_user, input.essenceType, _essenceBalances[_user][input.essenceType]);
         }
    }

     /// @dev Internal function to add Essences to a user's balance.
     /// @param _user The address of the user.
     /// @param _type The Essence type to add.
     /// @param _amount The amount to add.
    function _addEssences(address _user, EssenceType _type, uint256 _amount) internal {
         _essenceBalances[_user][_type] += _amount;
         emit EssenceBalanceChanged(_user, _type, _essenceBalances[_user][_type]);
    }

    /// @dev Internal function to deduct Catalysts from a user's balance.
    /// @param _user The address of the user.
    /// @param _catalystInputs Array of Catalyst IDs and amounts to deduct.
    function _deductCatalysts(address _user, CatalystInput[] calldata _catalystInputs) internal {
        for (uint i = 0; i < _catalystInputs.length; i++) {
            CatalystInput calldata input = _catalystInputs[i];
             require(_catalystBalances[_user][input.catalystId] >= input.amount, "Alchemy: Insufficient catalyst balance for deduction");
             _catalystBalances[_user][input.catalystId] -= input.amount;
            emit CatalystBalanceChanged(_user, input.catalystId, _catalystBalances[_user][input.catalystId]);
        }
    }

    /// @dev Internal function to add Catalysts to a user's balance.
    /// @param _user The address of the user.
    /// @param _catalystId The Catalyst ID to add.
    /// @param _amount The amount to add.
    function _addCatalysts(address _user, uint256 _catalystId, uint256 _amount) internal {
        _catalystBalances[_user][_catalystId] += _amount;
        emit CatalystBalanceChanged(_user, _catalystId, _catalystBalances[_user][_catalystId]);
    }


    /// @dev Internal function to generate a pseudo-random number.
    /// @return uint256 A pseudo-random number.
    function _generateRandomness() internal view returns (uint256) {
        // This is NOT cryptographically secure and is vulnerable to miner manipulation,
        // especially for high-value outcomes. For a simple on-chain game, it might be acceptable.
        // For production-grade randomness, consider Chainlink VRF or similar.
        return uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.number,
            block.difficulty,
            msg.sender,
            _totalArtifactsMinted // Include a contract state variable as a seed
        )));
    }

    /// @dev Internal function to generate Artifact attributes based on inputs and randomness.
    /// @param _grade The target grade of the artifact.
    /// @param _baseConfig The base configuration for the grade.
    /// @param _inputEssenceAmounts Summed amounts of each essence type used.
    /// @param _randomNumber A seed for pseudo-randomness.
    /// @return ArtifactAttributes The generated attributes.
    function _generateArtifactAttributes(
        uint256 _grade,
        ArtifactBaseConfig memory _baseConfig,
        mapping(EssenceType => uint256) memory _inputEssenceAmounts, // Corrected type
        uint256 _randomNumber
    ) internal pure returns (ArtifactAttributes memory) {
        // Deterministic attribute generation based on inputs and randomness
        uint256 seed = _randomNumber;
        uint16 power = _baseConfig.basePower;
        uint16 durability = _baseConfig.baseDurability;
        uint16 maxDurability = _baseConfig.baseDurability;
        uint16 affinityIgnis = _baseConfig.baseAffinity;
        uint16 affinityAqua = _baseConfig.baseAffinity;
        uint16 affinityTerra = _baseConfig.baseAffinity;
        uint16 affinityAer = _baseConfig.baseAffinity;
        uint16 affinitySpiritus = _baseConfig.baseAffinity;

        // Example attribute generation logic:
        // More total essence input slightly boosts base stats
        uint256 totalEssence = 0;
        for (uint i = 0; i < ESSENCE_TYPE_COUNT; i++) {
            totalEssence += _inputEssenceAmounts[EssenceType(i)];
        }
        power += uint16((totalEssence / 10) % 10); // Small boost based on total amount
        maxDurability += uint16((totalEssence / 5) % 20); // Boost durability more

        // Affinities boosted by corresponding essence input + randomness
        affinityIgnis += uint16((_inputEssenceAmounts[EssenceType.Ignis] / 2) + (seed % 20)); seed /= 100;
        affinityAqua += uint16((_inputEssenceAmounts[EssenceType.Aqua] / 2) + (seed % 20)); seed /= 100;
        affinityTerra += uint16((_inputEssenceAmounts[EssenceType.Terra] / 2) + (seed % 20)); seed /= 100;
        affinityAer += uint16((_inputEssenceAmounts[EssenceType.Aer] / 2) + (seed % 20)); seed /= 100;
        affinitySpiritus += uint16((_inputEssenceAmounts[EssenceType.Spiritus] / 2) + (seed % 20)); // No need to divide seed after the last one

        // Ensure attributes don't overflow uint16 (max 65535) - unlikely with these small boosts, but good practice
        power = Math.min(power, type(uint16).max);
        durability = Math.min(durability, type(uint16).max);
        maxDurability = Math.min(maxDurability, type(uint16).max);
        affinityIgnis = Math.min(affinityIgnis, type(uint16).max);
        affinityAqua = Math.min(affinityAqua, type(uint16).max);
        affinityTerra = Math.min(affinityTerra, type(uint16).max);
        affinityAer = Math.min(affinityAer, type(uint16).max);
        affinitySpiritus = Math.min(affinitySpiritus, type(uint16).max);


        return ArtifactAttributes({
            power: power,
            durability: durability, // Start with full durability
            maxDurability: maxDurability,
            affinityIgnis: affinityIgnis,
            affinityAqua: affinityAqua,
            affinityTerra: affinityTerra,
            affinityAer: affinityAer,
            affinitySpiritus: affinitySpiritus,
            grade: _grade
        });
    }

    /// @dev Internal function to calculate and add pending staking rewards for a specific token to the user's cumulative balance.
    /// @param _user The address of the user (original staker).
    /// @param _tokenId The ID of the staked Artifact.
    function _calculateStakingRewards(address _user, uint256 _tokenId) internal {
        ArtifactStakeInfo storage stakeInfo = _artifactIdToStakeInfo[_tokenId];
        uint256 lastUpdate = stakeInfo.lastRewardClaimTime;

        if (lastUpdate > 0 && _isArtifactStaked[_tokenId]) {
            uint256 timeElapsed = block.timestamp - lastUpdate;
            if (timeElapsed > 0) {
                uint256 potentialFromTime = (stakeInfo.effectiveRewardRatePerSecond * timeElapsed);
                 _cumulativeStakingRewardPotential[_user] += potentialFromTime;
                stakeInfo.lastRewardClaimTime = block.timestamp; // Update time
                 // Note: Accumulated rewards potential in the struct is only updated when claiming the *individual* token's rewards,
                 // not when adding to the cumulative user balance. This is a design choice.
                 // Let's update both for clarity when calling getArtifactStakeInfo.
                 stakeInfo.accumulatedRewardsPotential += potentialFromTime; // Update the token's running total too
            }
        }
    }

     /// @dev Internal helper to update staking rewards for ALL tokens staked by a user.
     /// This iterates through tokens owned by the contract and checks if the original staker matches the user.
     /// This can be gas intensive if the user has many staked tokens.
     /// A more scalable solution would use a linked list or require claiming per token/batch.
    function _updateAllStakedArtifactRewards(address _user) internal {
        uint256 totalTokensInContract = balanceOf(address(this));
         // Simple loop - potentially gas-limited.
         // In a real dApp, might require off-chain tracking or a different on-chain structure.
         // Assuming _totalArtifactsMinted is a reasonable upper bound for tokens to check.
         // Better approach: Keep a list/mapping of *currently staked* token IDs per user.
         // Let's add mapping: mapping(address user => uint256[] stakedTokenIdsList);
         // (Adding stakedTokenIdsList mapping to state variables)
         // Now update this list in stake/unstake.

         uint256[] storage userStakedTokens = stakedTokenIdsList[_user];
         for(uint i = 0; i < userStakedTokens.length; ++i) {
             uint256 tokenId = userStakedTokens[i];
             // Double check it's still staked by this user (redundant if list is perfectly maintained)
             if (_isArtifactStaked[tokenId] && _originalStaker[tokenId] == _user) {
                  _calculateStakingRewards(_user, tokenId); // This adds to _cumulativeStakingRewardPotential[_user]
             }
         }
         // Note: Removing from stakedTokenIdsList on unstake is needed (expensive array operation).
         // Or use a mapping like mapping(uint256 tokenId => uint256 indexInList) to facilitate removal.
         // For simplicity in this example, we'll skip the list maintenance complexity in stake/unstake,
         // acknowledging the list might need manual cleanup or a more advanced data structure.
         // A better pattern: Just loop through all tokens owned by the contract.
         // No, that's also bad. The best is a list of staked tokens per user, managed carefully.
         // Let's add the list and the placeholder for list management.
         // (Adding stakedTokenIdsList and placeholder logic in stake/unstake)

        // This loop iterates through the list and calculates/updates rewards potential.
        // The actual potential is added to _cumulativeStakingRewardPotential[_user] by _calculateStakingRewards.
    }

     /// @dev Overrides _mint to set initial properties and track original staker.
    function _mint(address to, uint256 tokenId) internal override {
        super._mint(to, tokenId);
        _lastDecayTime[tokenId] = block.timestamp; // Initialize decay timer
        // When minting, the owner is the initial staker if staking happens immediately after
        // For now, originalStaker is set during the staking function.
        // If minted directly to contract for staking, _originalStaker needs to be recorded then.
        // Let's assume minting happens to the user, and they then stake.
    }

    /// @dev Overrides _transfer to update staking info and manage the stakedTokenIdsList.
    function _transfer(address from, address to, uint256 tokenId) internal override {
        // Before transferring, if the token was staked, clean up staking state.
        // This happens *before* the super.transfer call.
         if (_isArtifactStaked[tokenId]) {
             // This path is hit by unstakeArtifact.
             // Need to remove from stakedTokenIdsList[from] where from is address(this)
             // But the user is msg.sender.
             // The original staker is tracked by _originalStaker[tokenId].
             // We need to remove from stakedTokenIdsList[_originalStaker[tokenId]].
             address originalStaker = _originalStaker[tokenId];
             _isArtifactStaked[tokenId] = false;
             delete _artifactIdToStakeInfo[tokenId];
             delete _originalStaker[tokenId]; // Clear original staker info

             // Remove from stakedTokenIdsList[originalStaker]
             // Find tokenId in stakedTokenIdsList[originalStaker] and swap-remove.
             uint256[] storage userStakedTokens = stakedTokenIdsList[originalStaker];
             uint256 len = userStakedTokens.length;
             for (uint i = 0; i < len; i++) {
                 if (userStakedTokens[i] == tokenId) {
                     // Swap with last element and pop
                     userStakedTokens[i] = userStakedTokens[len - 1];
                     userStakedTokens.pop();
                     break;
                 }
             }
             // Note: This removal is O(N) in the worst case.
         }

        super._transfer(from, to, tokenId);

         // After transferring, if the token is transferred TO this contract (for staking)
         if (to == address(this)) {
             // This path is hit by stakeArtifact.
             // Record the original staker (msg.sender) and add to their list.
             _originalStaker[tokenId] = msg.sender;
             stakedTokenIdsList[msg.sender].push(tokenId);
             // Note: _isArtifactStaked and _artifactIdToStakeInfo are set in stakeArtifact itself.
         }
    }


    // List to track staked tokens per user for efficient reward calculation
    mapping(address user => uint256[] stakedTokenIdsList) private stakedTokenIdsList;


    // Fallback function to receive Ether for potential staking
    receive() external payable {
        depositEtherForPotential();
    }

    // Fallback function (optional, good practice)
    fallback() external payable {
        revert("Alchemy: Fallback not intended");
    }
}

```

**Explanation of Advanced/Creative/Trendy Aspects:**

1.  **Integrated Ecosystem:** It's not just an ERC-20 or ERC-721. It's a system where two types of fungible tokens (Essences, Catalysts) and one type of non-fungible token (Artifacts) interact within the contract's logic.
2.  **Dynamic/Stateful NFTs:** Artifact attributes (`power`, `durability`, `affinities`) are stored *on-chain* and can change via `refineArtifact` and `applyEntropy`. `tokenURI` would ideally reflect these changing attributes (though the example uses a placeholder).
3.  **Probabilistic Crafting & Refinement:** The `transmute` and `refineArtifact` functions involve a chance of success/failure and use pseudo-randomness to determine outcomes and generated attributes. This adds a "gacha" or risk element common in games.
4.  **Decay and Maintenance:** The `applyEntropy` and `maintainArtifact` functions introduce a concept of decay for NFTs, requiring users to spend resources to keep them functional or prevent attribute loss. This adds a continuous engagement loop.
5.  **Resource Extraction via Staking:** Staking native Ether (`depositEtherForPotential`) generates a non-transferable resource (`Potential`) that can *only* be converted into internal Essences (`extractEssence`). This links the contract's internal economy to the underlying blockchain asset.
6.  **NFT Staking for Rewards:** Staking Artifacts (`stakeArtifact`) within the contract yields passive rewards in the form of more Potential (which the user then extracts). The reward rate can be tied to the staked Artifact's attributes (`effectiveRewardRatePerSecond`), incentivizing staking higher-quality items.
7.  **Attunement Mechanic:** `attuneEssence` provides a temporary, user-specific buff, adding a tactical layer to crafting or refinement decisions.
8.  **Catalysts:** Introduces a separate type of consumable token (`Catalysts`) that directly influences the probabilities or outcomes of core actions, adding another layer of resource management and strategic use.
9.  **Internal Resource Management:** Essences and Catalysts are managed internally by the contract, not as separate external ERC-20s. This gives the contract total control over their supply and distribution within its own economy (though they could potentially be wrapped or exchanged externally later).
10. **Multiple Configurable Parameters:** Many aspects of the system (essence costs, extraction rates, artifact success chances, decay rates, reward rates, catalyst effects) are exposed via admin functions, allowing for tuning and evolution of the game/system over time.
11. **ERC721Holder Integration:** The contract itself acts as an ERC721 receiver to hold staked NFTs securely.
12. **Gas Considerations (Addressed in comments):** The notes highlight potential gas issues with iterating over lists/mappings (e.g., in `claimStakedArtifactRewards`, `_updateAllStakedArtifactRewards`, `_transfer` list management) and suggest more complex data structures or batching for scalability in a production environment. The `applyEntropy` function is made public to potentially offload the cost of decay updates or allow keepers.

This contract goes significantly beyond simple token transfers or basic NFT minting by creating a complex, interactive system with multiple asset types and dynamic mechanics.