Okay, let's design a complex, interactive smart contract focusing on resource generation, crafting/synthesis with dynamic outcomes, and feature unlocking based on user activity within the protocol.

We'll call it "The Alchemist's Crucible". Users will stake a base token to generate "Essence" (an internal resource), use Essence to "Synthesize" unique "Artifacts" (represented by structs), which have dynamic properties and can be further refined or used to unlock protocol features or boost Essence generation. It incorporates time-based resource generation, state-dependent logic, pseudo-randomness for outcomes, and tiered access.

It avoids direct duplication of standard ERC-20/ERC-721 implementations by managing the 'Essence' resource and 'Artifacts' state internally, rather than relying on external, transferable tokens (though it interacts with a standard ERC-20 for staking). The complex interactions between staking, essence, artifacts, and unlocking features provide the depth.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

// --- Outline and Function Summary ---
//
// Contract: The Alchemist's Crucible
// Description: A complex protocol for staking, resource generation (Essence),
//              dynamic artifact synthesis, refinement, and feature unlocking.
//              Users stake a base token to earn Essence over time. Essence is
//              used to synthesize unique Artifacts with varying properties.
//              Artifacts can be infused to improve stats, deconstructed for
//              resources, or staked to boost Essence generation or unlock features.
//
// Core Concepts:
// - Staking: Lock base tokens (`IERC20`) to earn time-based Essence.
// - Essence: Internal, non-transferable resource generated by staking. Used as crafting fuel.
// - Artifacts: Unique, dynamic on-chain items represented by structs. Have properties (Level, Purity, Affinity).
// - Synthesis: Process using Essence and potentially other resources/artifacts to create new Artifacts. Outcome influenced by inputs and pseudo-randomness.
// - Refinement: Infusing Artifacts with Essence to improve properties.
// - Deconstruction: Burning Artifacts to recover some Essence or resources.
// - Artifact Staking: Staking artifacts to gain benefits (e.g., Essence generation boosts, unlocking features).
// - Feature Unlocking: Specific actions or conditions unlock new abilities or recipes within the protocol.
// - Pseudo-Randomness: Using block data for outcomes in synthesis and refinement (with security considerations noted).
//
// Data Structures:
// - Artifact: struct { id, owner, level, purity, affinity, isStaked, stakedAt }
// - Recipe: struct { essenceCost, minArtifactLevelRequirement, successChanceBasis, outputLevelRange, outputPurityRange, outputAffinityRange }
//
// State Variables:
// - owner: Contract owner (for admin functions).
// - baseToken: Address of the ERC20 token used for staking.
// - essenceAccrualRatePerTokenPerSecond: Rate of Essence generation per staked base token.
// - stakedBaseTokens: Mapping { user => amount staked }.
// - lastEssenceClaimTime: Mapping { user => timestamp of last claim/stake update }.
// - userEssenceBalance: Mapping { user => available Essence for spending }.
// - artifactCounter: Counter for unique artifact IDs.
// - artifacts: Mapping { artifactId => Artifact struct }.
// - userArtifacts: Mapping { user => array of owned artifactIds }.
// - stakedArtifacts: Mapping { artifactId => bool (is staked) }.
// - synthesisRecipes: Mapping { recipeId => Recipe struct }.
// - unlockedFeatures: Mapping { featureId => bool (is unlocked) }.
//
// Events:
// - BaseTokensStaked(user, amount, totalStaked)
// - BaseTokensUnstaked(user, amount, remainingStaked)
// - EssenceClaimed(user, amount)
// - ArtifactSynthesized(user, artifactId, level, purity, affinity)
// - ArtifactInfused(user, artifactId, propertyType, oldValue, newValue)
// - ArtifactDeconstructed(user, artifactId, recoveredEssence)
// - ArtifactStaked(user, artifactId)
// - ArtifactUnstaked(user, artifactId)
// - FeatureUnlocked(featureId, unlocker)
// - RecipeAdded(recipeId, details)
// - AccrualRateUpdated(newRate)
// - Paused(account)
// - Unpaused(account)
// - OwnershipTransferred(previousOwner, newOwner)
//
// Functions (Total: 25):
// 1.  constructor(address _baseTokenAddress, uint256 _initialAccrualRate)
// 2.  stakeBaseTokens(uint256 amount): Stake base tokens, calculate/credit pending Essence.
// 3.  unstakeBaseTokens(uint256 amount): Unstake base tokens, calculate/credit pending Essence.
// 4.  claimEssence(): Claim accrued Essence without changing stake.
// 5.  getAvailableEssence(address user): View pending Essence for a user.
// 6.  getUserEssenceBalance(address user): View spendable Essence balance for a user.
// 7.  synthesizeArtifact(uint256 recipeId): Use Essence (and potentially staked artifacts) based on a recipe to create a new Artifact.
// 8.  defineSynthesisRecipe(uint256 recipeId, Recipe memory recipeDetails): Owner function to add/update a synthesis recipe.
// 9.  getSynthesisRecipe(uint256 recipeId): View details of a synthesis recipe.
// 10. getArtifactDetails(uint256 artifactId): View details of a specific Artifact.
// 11. getUserArtifactIds(address user): View list of artifact IDs owned by a user.
// 12. infuseArtifact(uint256 artifactId, uint8 propertyType, uint256 essenceAmount): Spend Essence to improve an Artifact property (Level, Purity, Affinity).
// 13. deconstructArtifact(uint256 artifactId): Burn an Artifact to recover some Essence.
// 14. stakeArtifact(uint256 artifactId): Stake an owned Artifact.
// 15. unstakeArtifact(uint256 artifactId): Unstake a staked Artifact.
// 16. getArtifactStakingBoost(uint256 artifactId): View the potential Essence boost from a staked Artifact (based on its properties).
// 17. unlockFeature(uint256 featureId, address potentialUnlocker): Internal or owner-triggered function to unlock a feature based on criteria.
// 18. isFeatureUnlocked(uint256 featureId): View if a specific feature ID is unlocked.
// 19. setEssenceAccrualRate(uint256 newRate): Owner function to update the global accrual rate.
// 20. setRecipeActiveStatus(uint256 recipeId, bool isActive): Owner function to activate/deactivate recipes.
// 21. getRecipeActiveStatus(uint256 recipeId): View if a recipe is active.
// 22. getTotalStakedBaseTokens(): View total base tokens staked in the contract.
// 23. getTotalEssenceMinted(): View total Essence ever accrued by users.
// 24. getTotalArtifactsSynthesized(): View total artifacts created.
// 25. transferOwnership(address newOwner): Standard Ownable function.
// 26. pause(): Owner function to pause staking/synthesis.
// 27. unpause(): Owner function to unpause.
// 28. paused(): View if the contract is paused.

// Note on Randomness: The contract uses block data (`block.timestamp`, `blockhash`)
// mixed with user inputs for pseudo-randomness. This is *predictable* to sophisticated
// attackers (miners can influence block contents/timing) and *should NOT be used* for
// outcomes with high financial value or where fairness is critical in a production
// environment without a secure oracle solution like Chainlink VRF. This implementation
// is for demonstrating the *concept* of on-chain variable outcomes.

// Note on Gas Costs: Complex state updates (like adding to userArtifacts array) can
// be expensive. Real-world optimization might involve linked lists or external indexing.

// Note on Essence: Essence is tracked internally per user (`userEssenceBalance`).
// It is not an external ERC20 token that can be transferred between users outside
// this contract's logic. This simplifies state management and avoids potential
// reentrancy issues if Essence transfers were involved in crafting.

---

contract AlchemistsCrucible is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IERC20 public immutable baseToken;

    // --- State Variables ---

    // Staking & Essence
    uint256 public essenceAccrualRatePerTokenPerSecond;
    mapping(address => uint256) public stakedBaseTokens;
    mapping(address => uint256) public lastEssenceClaimTime;
    mapping(address => uint256) public userEssenceBalance; // Spendable Essence
    uint256 public totalEssenceMinted; // For tracking/analytics

    // Artifacts
    struct Artifact {
        uint256 id;
        address owner;
        uint8 level; // 0-255
        uint8 purity; // 0-100, influences success/output
        uint8 affinity; // 0-100, influences boosts/recipes
        bool isStaked;
        uint256 stakedAt; // Timestamp when staked
    }
    uint256 private artifactCounter; // Starts at 1
    mapping(uint256 => Artifact) public artifacts;
    mapping(address => uint256[]) public userArtifacts; // Array of artifact IDs owned by user
    mapping(uint256 => bool) public stakedArtifacts; // Maps artifact ID to its staked status

    // Synthesis Recipes
    struct Recipe {
        uint256 essenceCost;
        uint8 minArtifactLevelRequirement; // Min level required if staking artifact for this recipe
        uint8 successChanceBasis; // Base chance % out of 100. Modified by artifact properties.
        uint8 outputLevelMin; // Range for output artifact properties
        uint8 outputLevelMax;
        uint8 outputPurityMin;
        uint8 outputPurityMax;
        uint8 outputAffinityMin;
        uint8 outputAffinityMax;
        bool isActive; // Can this recipe be used?
    }
    mapping(uint256 => Recipe) public synthesisRecipes; // recipeId => Recipe details
    uint256[] public availableRecipeIds; // List of recipe IDs that exist

    // Feature Unlocking
    mapping(uint256 => bool) public unlockedFeatures; // featureId => bool (is unlocked)
    // Define feature IDs (e.g., 1: Enhanced_Accrual_Tier_1, 2: Advanced_Synthesis_Recipe_Access)
    uint256 public constant FEATURE_ENHANCED_ACCRUAL_TIER_1 = 1;
    uint256 public constant FEATURE_ADVANCED_SYNTHESIS_RECIPES = 2;
    // Add more feature IDs as needed...

    // Contract State
    bool private _paused;

    // --- Events ---

    event BaseTokensStaked(address indexed user, uint256 amount, uint256 totalStaked);
    event BaseTokensUnstaked(address indexed user, uint256 amount, uint256 remainingStaked);
    event EssenceClaimed(address indexed user, uint256 amount);
    event ArtifactSynthesized(address indexed user, uint256 indexed artifactId, uint8 level, uint8 purity, uint8 affinity);
    event ArtifactInfused(address indexed user, uint256 indexed artifactId, uint8 propertyType, uint8 oldValue, uint8 newValue); // propertyType: 0=Level, 1=Purity, 2=Affinity
    event ArtifactDeconstructed(address indexed user, uint256 indexed artifactId, uint256 recoveredEssence);
    event ArtifactStaked(address indexed user, uint256 indexed artifactId);
    event ArtifactUnstaked(address indexed user, uint256 indexed artifactId);
    event FeatureUnlocked(uint256 indexed featureId, address indexed unlocker);
    event RecipeAdded(uint256 indexed recipeId, bool isActive);
    event AccrualRateUpdated(uint256 newRate);
    event RecipeActiveStatusUpdated(uint256 indexed recipeId, bool isActive);
    event Paused(address account);
    event Unpaused(address account);

    // --- Modifiers ---

    modifier whenNotPaused() {
        require(!_paused, "Pausable: paused");
        _;
    }

    modifier whenPaused() {
        require(_paused, "Pausable: not paused");
        _;
    }

    modifier onlyArtifactOwner(uint256 artifactId) {
        require(artifacts[artifactId].owner == msg.sender, "Not artifact owner");
        _;
    }

    modifier artifactExists(uint256 artifactId) {
        require(artifacts[artifactId].owner != address(0), "Artifact does not exist"); // owner == address(0) implies struct is default/empty
        _;
    }

    modifier isRecipeActive(uint256 recipeId) {
        require(synthesisRecipes[recipeId].isActive, "Recipe is not active");
        _;
    }

    // --- Constructor ---

    constructor(address _baseTokenAddress, uint256 _initialAccrualRate) Ownable(msg.sender) {
        require(_baseTokenAddress != address(0), "Base token address cannot be zero");
        baseToken = IERC20(_baseTokenAddress);
        essenceAccrualRatePerTokenPerSecond = _initialAccralRate;
        _paused = false; // Start unpaused
    }

    // --- Internal Helpers ---

    // Calculate pending Essence for a user since their last claim/stake update
    function _calculatePendingEssence(address user) internal view returns (uint256) {
        uint256 stakedAmount = stakedBaseTokens[user];
        uint256 lastClaim = lastEssenceClaimTime[user];
        uint256 rate = essenceAccrualRatePerTokenPerSecond;

        if (stakedAmount == 0 || rate == 0 || lastClaim >= block.timestamp) {
            return 0;
        }

        // Simple linear accrual for now. Could be modified based on staked duration, artifact boosts etc.
        uint256 timeElapsed = block.timestamp - lastClaim;

        // --- Artifact Staking Boost Calculation ---
        uint256 boostMultiplier = 1000; // Base multiplier (1000 = 1x)
        uint256 boostAdditive = 0; // Base additive

        // Find and apply boosts from staked artifacts owned by the user
        // NOTE: Iterating through userArtifacts in a view function like this can be gas expensive for users with many artifacts.
        // A more gas-efficient approach would be to pre-calculate and store the total boost.
        for (uint i = 0; i < userArtifacts[user].length; i++) {
            uint256 artifactId = userArtifacts[user][i];
            if (stakedArtifacts[artifactId]) {
                Artifact storage artifact = artifacts[artifactId];
                // Example boost logic: Purity adds to multiplier, Affinity adds to additive.
                boostMultiplier += artifact.purity * 10; // 10% boost per 10 purity
                boostAdditive += artifact.affinity * 100; // 100 Essence per Affinity per second (example scale)
            }
        }
        // --- End Boost Calculation ---

        uint256 accrued = (stakedAmount * rate * timeElapsed * boostMultiplier) / 1000; // Apply multiplier
        accrued += boostAdditive * timeElapsed; // Apply additive

        // --- Feature Based Boost ---
        if (unlockedFeatures[FEATURE_ENHANCED_ACCRUAL_TIER_1]) {
             // Example: Add a protocol-wide boost if feature is unlocked
             accrued = (accrued * 120) / 100; // 20% additional boost
        }
         // --- End Feature Based Boost ---


        return accrued;
    }

     // Internal function to add pending Essence to user's balance
    function _creditPendingEssence(address user) internal {
        uint256 pendingEssence = _calculatePendingEssence(user);
        if (pendingEssence > 0) {
            userEssenceBalance[user] += pendingEssence;
            totalEssenceMinted += pendingEssence;
            emit EssenceClaimed(user, pendingEssence); // Re-use event for consistency
        }
        lastEssenceClaimTime[user] = block.timestamp;
    }

    // Generate pseudo-random number using block data and user inputs
    function _pseudoRandom(uint256 maxValue, address user, uint256 salt) internal view returns (uint256) {
        // WARNING: This is NOT secure randomness for high-value applications.
        // Miners can influence block.timestamp and blockhash.
        // Use Chainlink VRF or similar in production for true unpredictability.
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp,
            block.difficulty, // Or block.prevrandao in PoS
            block.coinbase,
            block.gaslimit,
            block.number,
            msg.sender,
            user,
            salt,
            userEssenceBalance[user], // Include some user state
            artifactCounter // Include global state
        )));
        // Use blockhash from a recent, but not current, block to reduce miner influence window
         seed = uint256(keccak256(abi.encodePacked(seed, blockhash(block.number - 1))));

        return seed % (maxValue + 1); // Result is 0 to maxValue
    }

    // Internal function to create a new artifact
    function _createArtifact(address owner, uint8 level, uint8 purity, uint8 affinity) internal returns (uint256) {
        artifactCounter++;
        uint256 newId = artifactCounter;
        artifacts[newId] = Artifact({
            id: newId,
            owner: owner,
            level: level,
            purity: purity,
            affinity: affinity,
            isStaked: false,
            stakedAt: 0
        });
        userArtifacts[owner].push(newId); // Add artifact ID to user's list
        emit ArtifactSynthesized(owner, newId, level, purity, affinity);
        return newId;
    }

    // Internal function to remove artifact ID from user's list
    // NOTE: Removing from arbitrary index in dynamic array is O(N), expensive.
    // For many artifacts, better to use a mapping or linked list pattern.
    function _removeArtifactFromUserList(address user, uint256 artifactId) internal {
        uint256[] storage artifactList = userArtifacts[user];
        for (uint i = 0; i < artifactList.length; i++) {
            if (artifactList[i] == artifactId) {
                artifactList[i] = artifactList[artifactList.length - 1];
                artifactList.pop();
                return;
            }
        }
        // Should not happen if artifactId is valid and owned
    }

    // --- Staking Functions ---

    /// @notice Stakes base tokens to earn Essence.
    /// @param amount The amount of base tokens to stake.
    function stakeBaseTokens(uint256 amount) external whenNotPaused nonReentrant {
        require(amount > 0, "Stake amount must be greater than 0");

        _creditPendingEssence(msg.sender); // Credit pending Essence before changing stake

        stakedBaseTokens[msg.sender] += amount;
        baseToken.safeTransferFrom(msg.sender, address(this), amount);

        emit BaseTokensStaked(msg.sender, amount, stakedBaseTokens[msg.sender]);
    }

    /// @notice Unstakes base tokens and claims pending Essence.
    /// @param amount The amount of base tokens to unstake.
    function unstakeBaseTokens(uint256 amount) external whenNotPaused nonReentrant {
        require(amount > 0, "Unstake amount must be greater than 0");
        require(stakedBaseTokens[msg.sender] >= amount, "Not enough staked tokens");

        _creditPendingEssence(msg.sender); // Credit pending Essence before changing stake

        stakedBaseTokens[msg.sender] -= amount;
        baseToken.safeTransfer(msg.sender, amount);

        emit BaseTokensUnstaked(msg.sender, amount, stakedBaseTokens[msg.sender]);
    }

    /// @notice Claims pending Essence without changing staked amount.
    function claimEssence() external whenNotPaused nonReentrant {
        _creditPendingEssence(msg.sender);
        // The event is emitted within _creditPendingEssence
    }

    // --- Essence & Balance View Functions ---

    /// @notice Gets the amount of Essence currently accrued but not yet added to the spendable balance.
    /// @param user The address to check.
    /// @return The amount of pending Essence.
    function getAvailableEssence(address user) external view returns (uint256) {
        return _calculatePendingEssence(user);
    }

    /// @notice Gets the user's spendable Essence balance.
    /// @param user The address to check.
    /// @return The user's spendable Essence balance.
    function getUserEssenceBalance(address user) external view returns (uint256) {
        return userEssenceBalance[user];
    }

    // --- Artifact Synthesis Functions ---

    /// @notice Synthesizes a new Artifact based on a recipe. Requires spending Essence.
    /// Can optionally require staking a minimum level artifact (not implemented in v1, but added to recipe struct).
    /// Outcome properties are influenced by pseudo-randomness.
    /// @param recipeId The ID of the synthesis recipe to use.
    function synthesizeArtifact(uint256 recipeId) external whenNotPaused nonReentrant isRecipeActive(recipeId) {
        Recipe storage recipe = synthesisRecipes[recipeId];
        require(userEssenceBalance[msg.sender] >= recipe.essenceCost, "Not enough Essence");

        // Deduct Essence cost
        userEssenceBalance[msg.sender] -= recipe.essenceCost;

        // --- Pseudo-random outcome generation ---
        // Add user-specific salt to make outcomes slightly less predictable globally
        uint256 salt = userArtifacts[msg.sender].length + block.timestamp; // Example salt

        // Determine success chance (example: base chance from recipe, slightly boosted by user's highest purity staked artifact)
        // Find highest purity staked artifact by user (if any)
        uint8 maxStakedPurity = 0;
         for (uint i = 0; i < userArtifacts[msg.sender].length; i++) {
            uint256 artifactId = userArtifacts[msg.sender][i];
            if (stakedArtifacts[artifactId]) {
                maxStakedPurity = Math.max(maxStakedPurity, artifacts[artifactId].purity);
            }
        }
        uint8 effectiveSuccessChance = recipe.successChanceBasis + (maxStakedPurity / 10); // +1% chance per 10 staked purity

        uint256 successRoll = _pseudoRandom(100, msg.sender, salt + 1); // Roll between 0 and 100

        uint8 outputLevel;
        uint8 outputPurity;
        uint8 outputAffinity;

        if (successRoll <= effectiveSuccessChance) {
            // Success! Generate properties within the recipe's defined ranges
            outputLevel = uint8(_pseudoRandom(recipe.outputLevelMax - recipe.outputLevelMin, msg.sender, salt + 2) + recipe.outputLevelMin);
            outputPurity = uint8(_pseudoRandom(recipe.outputPurityMax - recipe.outputPurityMin, msg.sender, salt + 3) + recipe.outputPurityMin);
            outputAffinity = uint8(_pseudoRandom(recipe.outputAffinityMax - recipe.outputAffinityMin, msg.sender, salt + 4) + recipe.outputAffinityMin);

        } else {
            // Failure! Generate properties in a lower range, maybe fixed values for failed attempts
            outputLevel = uint8(_pseudoRandom(recipe.outputLevelMin, msg.sender, salt + 5)); // Lower levels
            outputPurity = uint8(_pseudoRandom(recipe.outputPurityMin / 2, msg.sender, salt + 6)); // Lower purity
            outputAffinity = uint8(_pseudoRandom(recipe.outputAffinityMin / 2, msg.sender, salt + 7)); // Lower affinity

            // Optionally, could add a chance to lose inputs or artifact on critical failure.
        }
         // Ensure values are within 0-255 (for uint8) and 0-100 (for Purity/Affinity semantics)
        outputPurity = Math.min(outputPurity, 100);
        outputAffinity = Math.min(outputAffinity, 100);


        _createArtifact(msg.sender, outputLevel, outputPurity, outputAffinity);
    }

    /// @notice Allows the owner to define or update a synthesis recipe.
    /// @param recipeId The ID of the recipe.
    /// @param recipeDetails The details of the recipe.
    function defineSynthesisRecipe(uint256 recipeId, Recipe memory recipeDetails) external onlyOwner {
         // Basic validation (could be more extensive)
        require(recipeDetails.outputLevelMin <= recipeDetails.outputLevelMax, "Invalid level range");
        require(recipeDetails.outputPurityMin <= recipeDetails.outputPurityMax && recipeDetails.outputPurityMax <= 100, "Invalid purity range");
        require(recipeDetails.outputAffinityMin <= recipeDetails.outputAffinityMax && recipeDetails.outputAffinityMax <= 100, "Invalid affinity range");
        require(recipeDetails.successChanceBasis <= 100, "Invalid success chance basis");

        bool isNewRecipe = synthesisRecipes[recipeId].essenceCost == 0 && synthesisRecipes[recipeId].successChanceBasis == 0; // Check if recipe exists

        synthesisRecipes[recipeId] = recipeDetails;

        if(isNewRecipe) {
             availableRecipeIds.push(recipeId); // Add to list of available recipes if new
        }

        emit RecipeAdded(recipeId, recipeDetails.isActive);
    }

    /// @notice Gets the details of a synthesis recipe.
    /// @param recipeId The ID of the recipe.
    /// @return The Recipe struct details.
    function getSynthesisRecipe(uint256 recipeId) external view returns (Recipe memory) {
        return synthesisRecipes[recipeId];
    }

    /// @notice Gets the list of all defined recipe IDs.
    /// @return An array of recipe IDs.
    function getAvailableRecipeIds() external view returns (uint256[] memory) {
        return availableRecipeIds;
    }


    // --- Artifact Management & Refinement Functions ---

    /// @notice Gets the details of a specific artifact.
    /// @param artifactId The ID of the artifact.
    /// @return The Artifact struct details.
    function getArtifactDetails(uint256 artifactId) external view artifactExists(artifactId) returns (Artifact memory) {
        return artifacts[artifactId];
    }

    /// @notice Gets the list of artifact IDs owned by a user.
    /// @param user The address to check.
    /// @return An array of artifact IDs.
    function getUserArtifactIds(address user) external view returns (uint256[] memory) {
        return userArtifacts[user];
    }

    /// @notice Spends Essence to infuse an Artifact and improve one of its properties.
    /// Outcome improvement and Essence cost might depend on current property value and pseudo-randomness.
    /// @param artifactId The ID of the artifact to infuse.
    /// @param propertyType The property to infuse (0=Level, 1=Purity, 2=Affinity).
    /// @param essenceAmount The amount of Essence to spend on infusion.
    function infuseArtifact(uint256 artifactId, uint8 propertyType, uint256 essenceAmount) external whenNotPaused nonReentrant onlyArtifactOwner(artifactId) artifactExists(artifactId) {
        require(!stakedArtifacts[artifactId], "Cannot infuse staked artifact");
        require(userEssenceBalance[msg.sender] >= essenceAmount, "Not enough Essence");
        require(propertyType <= 2, "Invalid property type"); // 0, 1, or 2

        Artifact storage artifact = artifacts[artifactId];
        userEssenceBalance[msg.sender] -= essenceAmount;

        uint8 oldValue;
        uint8 newValue;
        uint256 salt = artifactId + block.timestamp + essenceAmount; // Example salt

        // --- Infusion Logic (Example) ---
        // Improvement is based on Essence spent and a bit of randomness.
        // Diminishing returns or higher costs for higher values might be implemented.
        uint256 potentialImprovement = (essenceAmount / 1000) + _pseudoRandom(uint256(essenceAmount / 500), msg.sender, salt); // Example calculation

        if (propertyType == 0) { // Level
            oldValue = artifact.level;
            // Cap Level at 255 (uint8 max)
            uint256 newLevel = uint256(artifact.level) + potentialImprovement;
            artifact.level = uint8(Math.min(newLevel, 255));
            newValue = artifact.level;
        } else if (propertyType == 1) { // Purity
            oldValue = artifact.purity;
             // Cap Purity at 100
            uint256 newPurity = uint256(artifact.purity) + potentialImprovement;
            artifact.purity = uint8(Math.min(newPurity, 100));
            newValue = artifact.purity;
        } else { // Affinity
            oldValue = artifact.affinity;
             // Cap Affinity at 100
            uint256 newAffinity = uint256(artifact.affinity) + potentialImprovement;
            artifact.affinity = uint8(Math.min(newAffinity, 100));
            newValue = artifact.affinity;
        }

        emit ArtifactInfused(msg.sender, artifactId, propertyType, oldValue, newValue);
    }

     /// @notice Deconstructs an Artifact, burning it and recovering some Essence.
     /// Recovered Essence amount might depend on artifact properties.
     /// @param artifactId The ID of the artifact to deconstruct.
    function deconstructArtifact(uint256 artifactId) external whenNotPaused nonReentrant onlyArtifactOwner(artifactId) artifactExists(artifactId) {
        require(!stakedArtifacts[artifactId], "Cannot deconstruct staked artifact");

        Artifact storage artifact = artifacts[artifactId];

        // --- Essence Recovery Logic (Example) ---
        // Recovery based on Level, Purity, and Affinity
        uint26 recoveryAmount = uint256(artifact.level) * 10 + uint256(artifact.purity) * 50 + uint256(artifact.affinity) * 50;
        // Add some randomness to recovery
        recoveryAmount += _pseudoRandom(recoveryAmount / 5, msg.sender, artifactId); // Recover up to 20% more randomly

        userEssenceBalance[msg.sender] += recoveryAmount;

        // Remove artifact state
        delete artifacts[artifactId];
        _removeArtifactFromUserList(msg.sender, artifactId);

        emit ArtifactDeconstructed(msg.sender, artifactId, recoveryAmount);
    }

    /// @notice Stakes an artifact. Staked artifacts can provide boosts or unlock features.
    /// @param artifactId The ID of the artifact to stake.
    function stakeArtifact(uint256 artifactId) external whenNotPaused nonReentrant onlyArtifactOwner(artifactId) artifactExists(artifactId) {
        require(!stakedArtifacts[artifactId], "Artifact is already staked");

        Artifact storage artifact = artifacts[artifactId];
        artifact.isStaked = true;
        artifact.stakedAt = block.timestamp;
        stakedArtifacts[artifactId] = true; // Use separate mapping for quick check

        // Potential logic here: Check if staking this artifact unlocks a feature
        _checkAndUnlockFeatures(msg.sender);

        emit ArtifactStaked(msg.sender, artifactId);
    }

    /// @notice Unstakes a staked artifact.
    /// @param artifactId The ID of the artifact to unstake.
    function unstakeArtifact(uint256 artifactId) external whenNotPaused nonReentrant onlyArtifactOwner(artifactId) artifactExists(artifactId) {
        require(stakedArtifacts[artifactId], "Artifact is not staked");

        Artifact storage artifact = artifacts[artifactId];
        artifact.isStaked = false;
        artifact.stakedAt = 0;
        stakedArtifacts[artifactId] = false;

         // Potential logic here: Check if unstaking affects any feature unlocks
         // (e.g., a feature requires *continuous* staking of certain artifacts)
        _checkAndUnlockFeatures(msg.sender);


        emit ArtifactUnstaked(msg.sender, artifactId);
    }

     /// @notice Gets the potential Essence generation boost provided by a specific artifact if staked.
     /// @param artifactId The ID of the artifact.
     /// @return boostMultiplier (scaled by 1000, 1000 = 1x), boostAdditive (per second)
    function getArtifactStakingBoost(uint256 artifactId) external view artifactExists(artifactId) returns (uint256 boostMultiplier, uint256 boostAdditive) {
         Artifact storage artifact = artifacts[artifactId];
         // Example boost logic (matches _calculatePendingEssence):
         boostMultiplier = uint256(artifact.purity) * 10; // 10% boost per 10 purity
         boostAdditive = uint256(artifact.affinity) * 100; // 100 Essence per Affinity per second
         return (boostMultiplier, boostAdditive);
    }

    // --- Feature Unlocking Functions ---

    /// @notice Internal logic to check if staking/user state unlocks any features.
    /// Can be called after staking artifacts, synthesizing high-level artifacts, etc.
    function _checkAndUnlockFeatures(address user) internal {
        // Example Unlock Criteria:
        // FEATURE_ENHANCED_ACCRUAL_TIER_1 (ID 1): Unlocked if user has staked at least 5 artifacts with Purity > 80.
        uint26 highPurityStakedCount = 0;
         for (uint i = 0; i < userArtifacts[user].length; i++) {
            uint256 artifactId = userArtifacts[user][i];
            if (stakedArtifacts[artifactId]) {
                Artifact storage artifact = artifacts[artifactId];
                if (artifact.purity > 80) {
                    highPurityStakedCount++;
                }
            }
        }
        if (!unlockedFeatures[FEATURE_ENHANCED_ACCRUAL_TIER_1] && highPurityStakedCount >= 5) {
             _unlockFeature(FEATURE_ENHANCED_ACCRUAL_TIER_1, user);
        }

        // FEATURE_ADVANCED_SYNTHESIS_RECIPES (ID 2): Unlocked if total protocol staked base tokens > 1,000,000
        if (!unlockedFeatures[FEATURE_ADVANCED_SYNTHESIS_RECIPES] && getTotalStakedBaseTokens() >= 1_000_000 ether) { // Assuming Base Token has 18 decimals
             _unlockFeature(FEATURE_ADVANCED_SYNTHESIS_RECIPES, address(0)); // Unlocked by protocol state, not specific user
             // Owner would then need to enable the advanced recipes via setRecipeActiveStatus
        }

        // Add more feature checks here...
    }

    /// @notice Unlocks a specific feature. Can be triggered by owner or internal logic.
    /// @param featureId The ID of the feature to unlock.
    /// @param unlocker The address or context that caused the unlock (can be address(0) for protocol unlocks).
    function _unlockFeature(uint256 featureId, address unlocker) internal {
        if (!unlockedFeatures[featureId]) {
            unlockedFeatures[featureId] = true;
            emit FeatureUnlocked(featureId, unlocker);
        }
    }

    /// @notice Allows owner to manually unlock a feature (e.g., for admin purposes or specific events).
    /// @param featureId The ID of the feature to unlock.
    function ownerUnlockFeature(uint256 featureId) external onlyOwner {
         _unlockFeature(featureId, msg.sender);
    }


    /// @notice Checks if a specific feature ID is unlocked.
    /// @param featureId The ID of the feature to check.
    /// @return True if the feature is unlocked, false otherwise.
    function isFeatureUnlocked(uint256 featureId) external view returns (bool) {
        return unlockedFeatures[featureId];
    }

    // --- Admin & Configuration Functions ---

    /// @notice Allows the owner to update the global Essence accrual rate.
    /// @param newRate The new rate per base token per second.
    function setEssenceAccrualRate(uint256 newRate) external onlyOwner {
         // Credit pending Essence for all users before changing rate (gas intensive if many users!)
         // A real-world solution would likely update a global rate and use a calculation
         // based on the rate *at the time of staking/last claim*.
         // For simplicity here, we just update the rate directly.
        essenceAccrualRatePerTokenPerSecond = newRate;
        emit AccrualRateUpdated(newRate);
    }

    /// @notice Allows the owner to set the active status of a synthesis recipe.
    /// Recipes might require certain features to be unlocked before they can be activated.
    /// @param recipeId The ID of the recipe.
    /// @param isActive The new active status.
    function setRecipeActiveStatus(uint256 recipeId, bool isActive) external onlyOwner {
        // Example: Require FEATURE_ADVANCED_SYNTHESIS_RECIPES for certain recipe IDs
        if (recipeId >= 100) { // Arbitrary example: Recipe IDs 100+ are "advanced"
            require(unlockedFeatures[FEATURE_ADVANCED_SYNTHESIS_RECIPES], "Advanced recipe requires feature unlock");
        }

        synthesisRecipes[recipeId].isActive = isActive;
        emit RecipeActiveStatusUpdated(recipeId, isActive);
    }

    /// @notice Gets the active status of a recipe.
    /// @param recipeId The ID of the recipe.
    /// @return True if the recipe is active, false otherwise.
    function getRecipeActiveStatus(uint256 recipeId) external view returns (bool) {
        return synthesisRecipes[recipeId].isActive;
    }

    /// @notice Pauses the contract, preventing staking and synthesis.
    function pause() external onlyOwner whenNotPaused {
        _paused = true;
        emit Paused(msg.sender);
    }

    /// @notice Unpauses the contract.
    function unpause() external onlyOwner whenPaused {
        _paused = false;
        emit Unpaused(msg.sender);
    }

    /// @notice Checks if the contract is paused.
    /// @return True if paused, false otherwise.
    function paused() external view returns (bool) {
        return _paused;
    }

    // --- Global View Functions ---

    /// @notice Gets the total amount of base tokens currently staked in the contract.
    /// @return The total amount of staked base tokens.
    function getTotalStakedBaseTokens() public view returns (uint256) {
        // NOTE: This is not the sum of all stakedBaseTokens[user], but the balance of the contract
        // that *should* equal the sum if no tokens were transferred out or lost.
        // Using contract balance is simpler but assumes no external loss.
        // For accuracy, would need to iterate or maintain a running sum.
        return baseToken.balanceOf(address(this));
    }

    /// @notice Gets the total amount of Essence ever minted (accrued) by users.
    /// @return The total minted Essence.
    function getTotalEssenceMinted() external view returns (uint256) {
        return totalEssenceMinted;
    }

    /// @notice Gets the total number of unique artifacts ever synthesized.
    /// @return The total artifact count.
    function getTotalArtifactsSynthesized() external view returns (uint256) {
        return artifactCounter;
    }

    // --- ERC-20 utils ---
     // Allow owner to recover ERC20 tokens accidentally sent to the contract,
     // excluding the baseToken which is part of the protocol's state.
    function recoverERC20(address tokenAddress, uint256 amount) external onlyOwner {
        require(tokenAddress != address(baseToken), "Cannot recover the base token");
        IERC20(tokenAddress).safeTransfer(msg.sender, amount);
    }
}

// Helper library for min/max (needed for uint8 caps)
library Math {
    function max(uint8 a, uint8 b) internal pure returns (uint8) {
        return a >= b ? a : b;
    }
     function min(uint8 a, uint8 b) internal pure returns (uint8) {
        return a <= b ? a : b;
    }
}

```