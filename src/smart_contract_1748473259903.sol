Okay, let's design an interesting, advanced, and creative smart contract.

Concept: **Chronicle of Echoes**

This contract creates unique digital artifacts called "Echoes" (ERC-721 NFTs). Each Echo is initially minted with a core phrase and generative parameters. Users can interact with these Echoes by adding "Fragments" (hashed data) or performing a "Resonate" action. These interactions affect the Echo's "Resonance Score", which decays over time. A higher Resonance Score indicates a more "lively" or "remembered" Echo. New Echoes can be procedurally generated by combining properties from existing ones, influenced by their Resonance Scores and added Fragments.

It combines:
*   **Dynamic NFTs:** Echo attributes (Resonance Score) change over time and based on user interaction.
*   **Generative Art/Content (Parameters On-chain):** Stores parameters (`generationData`) used by off-chain rendering engines to create unique visual/auditory representations.
*   **Time-Based Mechanics:** Resonance Score decays over time, incentivizing interaction.
*   **User-Contributed Data (Hashed):** Stores hashes of user-provided data ("Fragments") on-chain, implying off-chain storage (like IPFS) for the actual content, linking it to the Echo.
*   **Procedural Generation:** Logic to combine existing Echo data to generate new ones.
*   **Gamification Elements:** Resonance score acts as a 'health' or 'popularity' metric.
*   **On-Chain Data Structures:** Complex mappings to track fragments per echo, fragments per user, resonance, etc.

---

## ChronicleOfEchoes Smart Contract Outline

1.  **Title:** ChronicleOfEchoes
2.  **Concept:** Dynamic, generative ERC-721 NFTs ("Echoes") whose attributes (Resonance Score) change based on time decay and user interactions (adding Fragments, Resonating). New Echoes can be generated from existing ones.
3.  **Inheritance:** ERC721Enumerable, ERC721URIStorage, Ownable, Pausable.
4.  **State Variables:**
    *   Token counter.
    *   Mappings for Echo data (core phrase, generation data, creation time, last resonance time, resonance score).
    *   Mappings for fragments (hashes added to an echo, hashes added by a user).
    *   Mapping for user resonance cooldowns.
    *   Parameters for resonance decay and boosts.
    *   Minting fees and withdrawal address.
5.  **Events:**
    *   `EchoCreated`
    *   `FragmentAdded`
    *   `Resonated`
    *   `EchoGenerated`
    *   `ResonanceParametersUpdated`
6.  **Functions (at least 20 total, including inherited and helper):**
    *   **Core ERC721 (Inherited/Standard):** `balanceOf`, `ownerOf`, `approve`, `getApproved`, `setApprovalForAll`, `isApprovedForAll`, `transferFrom`, `safeTransferFrom` (x2), `supportsInterface`, `tokenURI`.
    *   **Enumerable (Inherited/Standard):** `totalSupply`, `tokenOfOwnerByIndex`, `tokenByIndex`.
    *   **Pausable (Inherited/Standard):** `paused`, `pause`, `unpause`.
    *   **Ownable (Inherited/Standard):** `owner`, `transferOwnership`, `renounceOwnership`.
    *   **Chronicle Logic (Custom - Public/External):**
        *   `createEcho`: Mint a new Echo.
        *   `addFragmentToEcho`: Add a fragment hash to an Echo.
        *   `resonateWithEcho`: Interact with an Echo to boost resonance.
        *   `generateNewEchoFromEchoes`: Create a new Echo from parents.
        *   `getEchoAttributes`: Get all dynamic attributes of an Echo.
        *   `getFragmentHashesForEcho`: Get fragment hashes for an Echo.
        *   `getFragmentsAddedByUser`: Get fragment hashes added by a user.
        *   `getEchoGenerationData`: Get off-chain generation parameters.
        *   `getEchoCorePhrase`: Get the core phrase.
    *   **Chronicle Logic (Custom - Owner Only):**
        *   `updateResonanceParameters`: Adjust decay/boost rates.
        *   `setEchoGenerationData`: Update generation data for an Echo (use with caution, or remove if data should be immutable after mint). Let's keep it for potential dynamic updates via owner or complex logic.
        *   `withdrawFunds`: Withdraw collected fees.
        *   `burnEcho`: Remove an Echo (admin cleanup/mechanic).
    *   **Chronicle Logic (Custom - View/Pure Helpers):**
        *   `calculateCurrentResonance`: Calculate resonance considering decay.
        *   `getTimeSinceLastResonance`: Calculate time elapsed since last ping.
        *   `getUserResonanceCooldown`: Check user's cooldown for resonating with a specific echo.
        *   `getEchoCount`: Total number of echoes (alias for `totalSupply`).

---

## Function Summary

1.  `constructor(string memory name, string memory symbol, address initialOwner, address payable fundsRecipient)`: Initializes the contract, ERC721 details, owner, and sets the recipient for minting fees.
2.  `createEcho(string memory corePhrase, bytes memory generationData) payable`: Mints a new Echo NFT. Requires a minting fee. Stores the initial core phrase and data for off-chain generation. Sets initial resonance.
3.  `addFragmentToEcho(uint256 tokenId, bytes32 fragmentHash)`: Allows a user to add a unique fragment hash to a specific Echo. Increases fragment count and boosts the Echo's resonance. Requires the hash to be new for that Echo.
4.  `resonateWithEcho(uint256 tokenId)`: Allows a user to interact with an Echo, significantly boosting its resonance. Subject to a per-user cooldown per Echo.
5.  `generateNewEchoFromEchoes(uint256[] memory parentTokenIds, string memory newCorePhrasePart, bytes memory newGenerationSeed) payable`: Mints a new Echo NFT based on one or more parent Echoes. The new Echo's properties (like generation data seed) can be influenced by the parents. Requires a potentially higher fee. Implements simple on-chain 'mixing' logic.
6.  `getEchoAttributes(uint256 tokenId) view returns (...)`: Retrieves the core dynamic attributes of an Echo: creation time, last resonance time, current resonance score, fragment count, and owner.
7.  `getFragmentHashesForEcho(uint256 tokenId) view returns (bytes32[] memory)`: Returns all fragment hashes that have been added to a specific Echo.
8.  `getFragmentsAddedByUser(address user) view returns (bytes32[] memory)`: Returns all unique fragment hashes that a specific user has ever added to *any* Echo.
9.  `getEchoGenerationData(uint256 tokenId) view returns (bytes memory)`: Returns the `bytes` data intended to be used by an off-chain process to render the Echo's visual/auditory form.
10. `getEchoCorePhrase(uint256 tokenId) view returns (string memory)`: Returns the immutable core phrase set during the Echo's creation.
11. `calculateCurrentResonance(uint256 tokenId) view returns (uint256)`: Internal/Pure helper (exposed via `getEchoAttributes`) to calculate the Echo's current resonance score based on the stored score, last resonance time, and decay parameters.
12. `getTimeSinceLastResonance(uint256 tokenId) view returns (uint256)`: Pure helper (exposed via `getEchoAttributes`) to calculate the time elapsed since the last Resonance action for an Echo.
13. `getUserResonanceCooldown(address user, uint256 tokenId) view returns (uint48)`: Returns the timestamp when a specific user can next `resonateWithEcho` for a given Echo.
14. `updateResonanceParameters(uint256 newDecayPerUnit, uint256 newDecayTimeUnit, uint256 newBoostFragment, uint256 newBoostPing, uint48 newUserPingCooldown) onlyOwner`: Allows the owner to adjust the parameters governing resonance decay, resonance boosts from actions, and user ping cooldown.
15. `setEchoGenerationData(uint256 tokenId, bytes memory newData) onlyOwner`: Allows the owner to update the generation data for an existing Echo.
16. `withdrawFunds()`: Allows the configured funds recipient to withdraw collected ETH minting fees.
17. `burnEcho(uint256 tokenId) onlyOwner`: Allows the owner to burn/destroy an Echo NFT.
18. `getEchoCount() view returns (uint256)`: Returns the total number of Echoes minted (wrapper for `totalSupply`).
19. `_beforeTokenTransfer(address from, address to, uint256 tokenId)`: Internal override from ERC721Enumerable to handle state updates before transfers.
20. `tokenURI(uint256 tokenId) view override returns (string memory)`: Returns a URI pointing to the metadata JSON for an Echo, which should include its dynamic attributes and generation data.

*(Note: The inherited ERC721, Enumerable, Ownable, Pausable functions easily bring the total count well over 20).*

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

// Outline:
// 1. Title: ChronicleOfEchoes
// 2. Concept: Dynamic, generative ERC-721 NFTs ("Echoes") with time-based resonance decay and user interaction boosts (Fragments, Resonate). New Echoes generated from parents.
// 3. Inheritance: ERC721Enumerable, ERC721URIStorage, Ownable, Pausable.
// 4. State Variables: Token data mappings, fragment mappings, resonance parameters, fees.
// 5. Events: EchoCreated, FragmentAdded, Resonated, EchoGenerated, ResonanceParametersUpdated.
// 6. Functions: Core ERC721 (13), Enumerable (3), Ownable (3), Pausable (2), Custom Chronicle Logic (10+ Public/View, 5+ Owner). Total >= 20.

// Function Summary:
// 1. constructor: Initialize contract, ERC721, owner, fee recipient.
// 2. createEcho: Mint a new Echo NFT with core data and generation parameters (payable).
// 3. addFragmentToEcho: Add a unique fragment hash to an Echo, boost resonance.
// 4. resonateWithEcho: Interact with an Echo, boost resonance (subject to cooldown).
// 5. generateNewEchoFromEchoes: Mint a new Echo based on parent Echoes (payable).
// 6. getEchoAttributes: Get dynamic attributes (creation time, last resonance, current resonance, fragment count, owner).
// 7. getFragmentHashesForEcho: Get all fragment hashes for an Echo.
// 8. getFragmentsAddedByUser: Get all fragment hashes added by a user across all Echoes.
// 9. getEchoGenerationData: Get the raw bytes for off-chain generation.
// 10. getEchoCorePhrase: Get the initial immutable core phrase.
// 11. calculateCurrentResonance: Helper to calculate current resonance including decay.
// 12. getTimeSinceLastResonance: Helper to calculate time since last resonance action.
// 13. getUserResonanceCooldown: Get timestamp when user can next ping.
// 14. updateResonanceParameters: Owner: Adjust resonance mechanics parameters.
// 15. setEchoGenerationData: Owner: Update generation data for an Echo.
// 16. withdrawFunds: Fee recipient: Withdraw accumulated ETH.
// 17. burnEcho: Owner: Burn an Echo NFT.
// 18. getEchoCount: Total number of Echoes (alias for totalSupply).
// 19. _beforeTokenTransfer: ERC721 hook for state updates before transfers.
// 20. tokenURI: ERC721 standard function to get metadata URI (includes dynamic data).

contract ChronicleOfEchoes is ERC721Enumerable, ERC721URIStorage, Ownable, Pausable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdCounter;

    // --- State Variables ---

    struct EchoData {
        string corePhrase;
        bytes generationData; // Data/seed for off-chain procedural generation
        uint64 creationTime;
        uint64 lastResonanceTime; // Use uint64 for timestamps within realistic range
        uint256 resonanceScore;
        uint256 fragmentCount;
    }

    // Maps token ID to its data
    mapping(uint256 => EchoData) private _echoes;

    // Maps token ID to a list of fragment hashes added to it
    mapping(uint256 => bytes32[]) private _fragmentHashesForEcho;
    // Helper mapping to check if a fragment hash has already been added to a specific echo
    mapping(uint256 => mapping(bytes32 => bool)) private _echoHasFragment;

    // Maps user address to a list of unique fragment hashes they've added anywhere
    mapping(address => bytes32[]) private _fragmentsAddedByUser;
    // Helper mapping to check if a user has already added a specific fragment hash
    mapping(address => mapping(bytes32 => bool)) private _userAddedFragment;

    // Maps user address and token ID to the timestamp they can next resonate
    mapping(address => mapping(uint256 => uint48)) private _lastResonancePingTime; // Use uint48 for shorter timestamps

    // Resonance Parameters (Owner can update)
    uint256 public resonanceDecayPerUnit; // Amount resonance decays per time unit
    uint256 public resonanceDecayTimeUnit; // Time unit for decay (e.g., 1 day in seconds)
    uint256 public resonanceBoostFragment; // Resonance boost from adding a fragment
    uint256 public resonanceBoostPing; // Resonance boost from resonating
    uint48 public userResonancePingCooldown; // Cooldown for resonating per user per echo

    // Minting fees
    uint256 public createEchoFee;
    uint256 public generateEchoFee;
    address payable public fundsRecipient;

    // --- Events ---

    event EchoCreated(uint256 indexed tokenId, address indexed creator, string corePhrase, bytes generationData, uint256 initialResonance);
    event FragmentAdded(uint256 indexed tokenId, address indexed contributor, bytes32 fragmentHash, uint256 newResonance);
    event Resonated(uint256 indexed tokenId, address indexed pinger, uint256 newResonance);
    event EchoGenerated(uint256 indexed tokenId, address indexed creator, uint256[] parentTokenIds, string corePhrasePart, bytes generationSeed, uint256 initialResonance);
    event ResonanceParametersUpdated(uint256 decayPerUnit, uint256 decayTimeUnit, uint256 boostFragment, uint256 boostPing, uint48 userPingCooldown);
    event FundsWithdrawn(address indexed recipient, uint256 amount);

    // --- Modifiers ---

    modifier isValidEcho(uint256 tokenId) {
        require(_exists(tokenId), "Chronicle: Invalid token ID");
        _;
    }

    // --- Constructor ---

    constructor(
        string memory name,
        string memory symbol,
        address initialOwner,
        address payable fundsRecipient_
    ) ERC721(name, symbol) Ownable(initialOwner) Pausable(false) {
        fundsRecipient = fundsRecipient_;

        // Set initial reasonable default parameters
        resonanceDecayPerUnit = 10; // Decay by 10 points
        resonanceDecayTimeUnit = 1 days; // Every day
        resonanceBoostFragment = 100; // Boost by 100 for fragment
        resonanceBoostPing = 50; // Boost by 50 for ping
        userResonancePingCooldown = 1 days; // Users can ping an echo once per day

        createEchoFee = 0.01 ether;
        generateEchoFee = 0.05 ether;

        emit ResonanceParametersUpdated(
            resonanceDecayPerUnit,
            resonanceDecayTimeUnit,
            resonanceBoostFragment,
            resonanceBoostPing,
            userResonancePingCooldown
        );
    }

    // --- ERC721 / Enumerable / URIStorage Overrides ---

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }

    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token");

        // Construct a URI that points to an external service
        // This service will fetch token data using the getter functions
        // and generate the metadata JSON including dynamic properties.
        // Example: ipfs://[CID]/metadata/{tokenId} or https://api.chronicleofechoes.com/metadata/{tokenId}
        // For this example, we'll return a placeholder, but a real implementation
        // would use a base URI and append the tokenId.

        string memory baseURI = _baseURI(); // Should be set externally or in constructor
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId))) : "";
    }

    // Override to potentially integrate dynamic attributes into base URI if needed
    // (Less common, tokenURI is preferred for dynamic metadata)
    // function _baseURI() internal view virtual override returns (string memory) {
    //    return "ipfs://YOUR_IPFS_CID/"; // Or your API endpoint base
    // }

    // --- Pausable Overrides ---

    function pause() public onlyOwner whenNotPaused {
        _pause();
    }

    function unpause() public onlyOwner whenPaused {
        _unpause();
    }

    // --- Chronicle Logic Functions ---

    /// @notice Mints a new Echo NFT with initial data.
    /// @param corePhrase The foundational text/idea of the Echo.
    /// @param generationData Data or seed for off-chain content generation (e.g., bytes representing parameters).
    function createEcho(string memory corePhrase, bytes memory generationData) public payable whenNotPaused returns (uint256) {
        require(msg.value >= createEchoFee, "Chronicle: Insufficient funds to create Echo");

        _tokenIdCounter.increment();
        uint256 newItemId = _tokenIdCounter.current();

        _safeMint(msg.sender, newItemId);
        _setTokenURI(newItemId, ""); // URI will be generated by off-chain service via tokenURI getter

        _echoes[newItemId] = EchoData({
            corePhrase: corePhrase,
            generationData: generationData,
            creationTime: uint64(block.timestamp),
            lastResonanceTime: uint64(block.timestamp),
            resonanceScore: resonanceBoostPing, // Give a small initial boost
            fragmentCount: 0
        });

        emit EchoCreated(newItemId, msg.sender, corePhrase, generationData, resonanceBoostPing);

        return newItemId;
    }

    /// @notice Adds a unique fragment hash to an existing Echo, boosting its resonance.
    /// @param tokenId The ID of the Echo to add the fragment to.
    /// @param fragmentHash A hash (e.g., keccak256) of the fragment content. Actual content is stored off-chain.
    function addFragmentToEcho(uint256 tokenId, bytes32 fragmentHash) public whenNotPaused isValidEcho(tokenId) {
        // Ensure the fragment hash hasn't been added to this specific echo yet
        require(!_echoHasFragment[tokenId][fragmentHash], "Chronicle: Fragment already added to this Echo");

        _fragmentHashesForEcho[tokenId].push(fragmentHash);
        _echoHasFragment[tokenId][fragmentHash] = true;

        // Check if the user has added this specific fragment hash before (across all echoes)
        if (!_userAddedFragment[msg.sender][fragmentHash]) {
            _fragmentsAddedByUser[msg.sender].push(fragmentHash);
            _userAddedFragment[msg.sender][fragmentHash] = true;
        }

        EchoData storage echo = _echoes[tokenId];
        echo.fragmentCount++;
        // Update resonance: Calculate current resonance, then add the boost
        echo.resonanceScore = calculateCurrentResonance(tokenId);
        echo.resonanceScore += resonanceBoostFragment;
        echo.lastResonanceTime = uint64(block.timestamp); // Interaction also updates last resonance time

        emit FragmentAdded(tokenId, msg.sender, fragmentHash, echo.resonanceScore);
    }

    /// @notice Allows a user to interact with an Echo, boosting its resonance, subject to a cooldown.
    /// @param tokenId The ID of the Echo to resonate with.
    function resonateWithEcho(uint256 tokenId) public whenNotPaused isValidEcho(tokenId) {
        // Check per-user per-echo cooldown
        require(block.timestamp >= _lastResonancePingTime[msg.sender][tokenId], "Chronicle: Resonance cooldown in effect for this Echo");

        EchoData storage echo = _echoes[tokenId];

        // Update resonance: Calculate current resonance, then add the boost
        echo.resonanceScore = calculateCurrentResonance(tokenId);
        echo.resonanceScore += resonanceBoostPing;
        echo.lastResonanceTime = uint64(block.timestamp);

        // Set cooldown timestamp
        _lastResonancePingTime[msg.sender][tokenId] = uint48(block.timestamp + userResonancePingCooldown);

        emit Resonated(tokenId, msg.sender, echo.resonanceScore);
    }

    /// @notice Mints a new Echo NFT by combining properties from one or more parent Echoes.
    /// @param parentTokenIds The IDs of the parent Echoes.
    /// @param newCorePhrasePart An additional string part for the new Echo's core phrase.
    /// @param newGenerationSeed New seed or data to combine with parent data for generation.
    function generateNewEchoFromEchoes(uint256[] memory parentTokenIds, string memory newCorePhrasePart, bytes memory newGenerationSeed) public payable whenNotPaused returns (uint256) {
        require(msg.value >= generateEchoFee, "Chronicle: Insufficient funds to generate Echo");
        require(parentTokenIds.length > 0, "Chronicle: Must specify at least one parent Echo");

        bytes memory combinedGenerationData = newGenerationSeed;
        string memory combinedCorePhrase = newCorePhrasePart;
        uint256 totalParentResonance = 0;

        for (uint i = 0; i < parentTokenIds.length; i++) {
            uint256 parentId = parentTokenIds[i];
            require(_exists(parentId), "Chronicle: Invalid parent token ID");

            EchoData storage parentEcho = _echoes[parentId];

            // Simple logic: Concatenate generation data, concatenate core phrases
            // More complex logic could involve hashing, XORing, or selecting based on resonance
            combinedGenerationData = abi.encodePacked(combinedGenerationData, parentEcho.generationData);
            combinedCorePhrase = string(abi.encodePacked(combinedCorePhrase, parentEcho.corePhrase));

            // Calculate parent resonance for potential influence on new echo's initial state or generation
            totalParentResonance += calculateCurrentResonance(parentId);
        }

        _tokenIdCounter.increment();
        uint256 newItemId = _tokenIdCounter.current();

        _safeMint(msg.sender, newItemId);
        _setTokenURI(newItemId, ""); // URI will be generated by off-chain service

        // Initial resonance for the new echo could be influenced by parent resonance
        uint256 initialResonance = resonanceBoostPing + (totalParentResonance / parentTokenIds.length / 10); // Example: small boost from average parent resonance

        _echoes[newItemId] = EchoData({
            corePhrase: combinedCorePhrase, // Use the combined phrase
            generationData: combinedGenerationData, // Use combined generation data
            creationTime: uint64(block.timestamp),
            lastResonanceTime: uint64(block.timestamp),
            resonanceScore: initialResonance,
            fragmentCount: 0 // New echoes start with no fragments
        });

        emit EchoGenerated(newItemId, msg.sender, parentTokenIds, newCorePhrasePart, newGenerationSeed, initialResonance);

        return newItemId;
    }

    /// @notice Retrieves the dynamic attributes of an Echo.
    /// @param tokenId The ID of the Echo.
    /// @return creationTime The timestamp of creation.
    /// @return lastResonanceTime The timestamp of the last resonance action.
    /// @return currentResonanceScore The resonance score after applying decay.
    /// @return fragmentCount The number of fragments added.
    /// @return owner The current owner of the Echo.
    function getEchoAttributes(uint256 tokenId) public view isValidEcho(tokenId) returns (
        uint64 creationTime,
        uint64 lastResonanceTime,
        uint256 currentResonanceScore,
        uint256 fragmentCount,
        address owner
    ) {
        EchoData storage echo = _echoes[tokenId];
        return (
            echo.creationTime,
            echo.lastResonanceTime,
            calculateCurrentResonance(tokenId), // Calculate current score including decay
            echo.fragmentCount,
            ERC721.ownerOf(tokenId) // Use inherited ownerOf
        );
    }

    /// @notice Returns all fragment hashes added to a specific Echo.
    /// @param tokenId The ID of the Echo.
    /// @return An array of fragment hashes.
    function getFragmentHashesForEcho(uint256 tokenId) public view isValidEcho(tokenId) returns (bytes32[] memory) {
        return _fragmentHashesForEcho[tokenId];
    }

    /// @notice Returns all unique fragment hashes added by a specific user across all Echoes.
    /// @param user The address of the user.
    /// @return An array of fragment hashes.
    function getFragmentsAddedByUser(address user) public view returns (bytes32[] memory) {
        return _fragmentsAddedByUser[user];
    }

    /// @notice Returns the raw generation data bytes for an Echo.
    /// @param tokenId The ID of the Echo.
    /// @return The generation data bytes.
    function getEchoGenerationData(uint256 tokenId) public view isValidEcho(tokenId) returns (bytes memory) {
        return _echoes[tokenId].generationData;
    }

    /// @notice Returns the immutable core phrase of an Echo.
    /// @param tokenId The ID of the Echo.
    /// @return The core phrase string.
    function getEchoCorePhrase(uint256 tokenId) public view isValidEcho(tokenId) returns (string memory) {
        return _echoes[tokenId].corePhrase;
    }

    /// @notice Calculates the current resonance score for an Echo, accounting for time decay.
    /// @param tokenId The ID of the Echo.
    /// @return The calculated current resonance score.
    function calculateCurrentResonance(uint256 tokenId) public view isValidEcho(tokenId) returns (uint256) {
        EchoData storage echo = _echoes[tokenId];
        uint256 timeSinceLastResonance = block.timestamp - echo.lastResonanceTime;

        if (timeSinceLastResonance == 0 || resonanceDecayTimeUnit == 0) {
            return echo.resonanceScore; // No time passed or decay is off
        }

        uint256 timeUnitsPassed = timeSinceLastResonance / resonanceDecayTimeUnit;
        uint256 decayAmount = timeUnitsPassed * resonanceDecayPerUnit;

        // Ensure resonance doesn't go below zero
        if (decayAmount >= echo.resonanceScore) {
            return 0;
        } else {
            return echo.resonanceScore - decayAmount;
        }
    }

    /// @notice Calculates the time elapsed since the last resonance action for an Echo.
    /// @param tokenId The ID of the Echo.
    /// @return The time elapsed in seconds.
    function getTimeSinceLastResonance(uint256 tokenId) public view isValidEcho(tokenId) returns (uint256) {
        return block.timestamp - _echoes[tokenId].lastResonanceTime;
    }

    /// @notice Gets the timestamp when a user can next resonate with a specific Echo.
    /// @param user The user's address.
    /// @param tokenId The ID of the Echo.
    /// @return The timestamp when cooldown ends.
    function getUserResonanceCooldown(address user, uint256 tokenId) public view returns (uint48) {
        return _lastResonancePingTime[user][tokenId];
    }


    // --- Owner Functions ---

    /// @notice Allows the owner to update the parameters governing resonance decay and boosts.
    /// @param newDecayPerUnit New amount resonance decays per time unit.
    /// @param newDecayTimeUnit New time unit for decay (in seconds).
    /// @param newBoostFragment New resonance boost from adding a fragment.
    /// @param newBoostPing New resonance boost from resonating.
    /// @param newUserPingCooldown New cooldown for resonating per user per echo (in seconds).
    function updateResonanceParameters(
        uint256 newDecayPerUnit,
        uint256 newDecayTimeUnit,
        uint256 newBoostFragment,
        uint256 newBoostPing,
        uint48 newUserPingCooldown
    ) public onlyOwner {
        resonanceDecayPerUnit = newDecayPerUnit;
        resonanceDecayTimeUnit = newDecayTimeUnit;
        resonanceBoostFragment = newBoostFragment;
        resonanceBoostPing = newBoostPing;
        userResonancePingCooldown = newUserPingCooldown;

        emit ResonanceParametersUpdated(
            resonanceDecayPerUnit,
            resonanceDecayTimeUnit,
            resonanceBoostFragment,
            resonanceBoostPing,
            userResonancePingCooldown
        );
    }

     /// @notice Allows the owner to update the fee required to create a new Echo.
    /// @param newFee The new fee in wei.
    function setCreateEchoFee(uint256 newFee) public onlyOwner {
        createEchoFee = newFee;
    }

     /// @notice Allows the owner to update the fee required to generate a new Echo from parents.
    /// @param newFee The new fee in wei.
    function setGenerateEchoFee(uint256 newFee) public onlyOwner {
        generateEchoFee = newFee;
    }

    /// @notice Allows the owner to update the generation data for an existing Echo.
    /// @dev This could be used for updates, evolutions, or fixing issues. Use carefully as it affects off-chain rendering.
    /// @param tokenId The ID of the Echo to update.
    /// @param newData The new generation data bytes.
    function setEchoGenerationData(uint256 tokenId, bytes memory newData) public onlyOwner isValidEcho(tokenId) {
        _echoes[tokenId].generationData = newData;
        // Note: tokenURI does not automatically update on state change,
        // the off-chain service serving the URI must query the latest data.
    }

    /// @notice Allows the funds recipient to withdraw collected ETH fees.
    function withdrawFunds() public {
        require(msg.sender == fundsRecipient, "Chronicle: Only funds recipient can withdraw");
        uint256 balance = address(this).balance;
        require(balance > 0, "Chronicle: No funds to withdraw");

        (bool success, ) = fundsRecipient.call{value: balance}("");
        require(success, "Chronicle: Withdrawal failed");

        emit FundsWithdrawn(fundsRecipient, balance);
    }

    /// @notice Allows the owner to burn/destroy an Echo NFT.
    /// @param tokenId The ID of the Echo to burn.
    function burnEcho(uint256 tokenId) public onlyOwner isValidEcho(tokenId) {
        // ERC721 burn handles ownership and supply tracking.
        // We might want to clean up our custom mappings if storage is critical,
        // but for simplicity and gas, leaving stale mapping entries is often acceptable.
        // E.g., delete _echoes[tokenId]; delete _fragmentHashesForEcho[tokenId]; etc.
        // However, checking _exists(tokenId) is the primary way to know if it's valid.

        _burn(tokenId);
        // Consider adding cleanup for mappings here if state needs to be completely removed.
        // E.g., delete _echoes[tokenId];
        // For simplicity in this example, we rely on isValidEcho checks.
    }

    // --- View Functions ---

    /// @notice Returns the total number of Echoes minted.
    function getEchoCount() public view returns (uint256) {
        return totalSupply(); // Alias for ERC721Enumerable's totalSupply
    }

    // Other standard view functions inherited:
    // balanceOf(address owner)
    // ownerOf(uint256 tokenId)
    // getApproved(uint256 tokenId)
    // isApprovedForAll(address owner, address operator)
    // tokenOfOwnerByIndex(address owner, uint256 index)
    // tokenByIndex(uint256 index)
    // paused()
    // owner()
    // supportsInterface(bytes4 interfaceId)

    // Note: transferFrom, safeTransferFrom, approve, setApprovalForAll are also inherited public functions.
    // renounceOwnership, transferOwnership are inherited public functions.
}
```

**Explanation of Advanced Concepts & Creativity:**

1.  **Dynamic State & Time Decay:** The `resonanceScore` of an Echo is not static. It's a dynamic attribute calculated on the fly using `calculateCurrentResonance`, which factors in the time elapsed since the last interaction (`lastResonanceTime`) and a configurable `resonanceDecayRate`. This incentivizes users to keep interacting with Echoes they value.
2.  **User-Influenced Evolution (Fragments):** `addFragmentToEcho` allows users to contribute data (represented by a hash on-chain) to an Echo. This increases the `fragmentCount` and boosts resonance. The hash implies off-chain storage, a common pattern for larger data like text or images associated with NFTs. The `_echoHasFragment` and `_userAddedFragment` mappings ensure uniqueness per echo and track user contributions globally.
3.  **Procedural Generation (Parameterized On-Chain):** The `generationData` field and the `generateNewEchoFromEchoes` function hint at off-chain procedural content generation. The contract stores the *parameters* or *seed* data (`generationData`) on-chain. The `generateNewEchoFromEchoes` function provides basic on-chain logic (like concatenation) to combine these parameters from parent tokens, creating a new set of parameters for the child Echo. An off-chain application would read this `generationData` from the contract to render the unique visual/auditory/textual representation of the Echo.
4.  **Interaction Cooldowns:** The `resonateWithEcho` function includes a per-user, per-token cooldown (`userResonancePingCooldown`) enforced by `_lastResonancePingTime`. This prevents spam and encourages users to spread their interactions across different Echoes.
5.  **Complex Mapping Usage:** The contract uses multiple levels of mappings (`mapping(uint256 => mapping(bytes32 => bool))`, `mapping(address => mapping(uint256 => uint48))`) to track detailed relationships between echoes, fragments, users, and time, enabling the custom mechanics.
6.  **On-Chain Parameters:** Resonance decay and boost values are stored as public state variables and can be updated by the owner (`updateResonanceParameters`), allowing the game/chronicle mechanics to be tuned over time.
7.  **Metadata URI pointing to Dynamic Data:** The `tokenURI` function points to an external service. This service is expected to query the contract's view functions (`getEchoAttributes`, `getEchoGenerationData`, etc.) to build the dynamic metadata JSON according to ERC721 standards, reflecting the Echo's current state (especially the calculated `currentResonanceScore`).

This contract goes beyond a standard ERC-721 by incorporating internal mechanics that affect the token's perceived value and attributes based on time and user interaction, while also including features that hook into external systems for content generation and metadata. It provides a framework for a dynamic, evolving digital collectible ecosystem.