Okay, let's design an interesting, advanced, and creative smart contract. We'll create a **"Decentralized Skill Tree & Yield Fund"**.

**Concept:** Users stake a specific token into the contract. Staking not only earns them a share of the yield generated by the fund (or passive inflation) but also accumulates "Skill Points" over time. These Skill Points can be used to unlock abilities in a predefined "Skill Tree". Skills can provide various benefits, such as boosting yield multipliers, increasing governance power, unlocking access to special features (like submitting proposals or specific types of withdrawals), or even modifying interactions within the contract. The contract will also include a basic on-chain governance mechanism to manage fund parameters or execute certain actions, potentially weighted by skill unlocks.

This concept is not a standard ERC-20, ERC-721, simple staking, or basic DAO. It combines elements of staking, progression systems (like in games), yield farming, and skill-based governance/utility, all within a single contract.

---

## Smart Contract Outline & Function Summary

**Contract Name:** SkillYieldFund

**Purpose:** A decentralized fund where users stake tokens to earn yield and accumulate Skill Points. Skill Points can be used to unlock abilities in a Skill Tree, granting various in-contract benefits like boosted yield or enhanced governance power. Includes a basic on-chain governance system.

**Key Concepts:**
1.  **Staking:** Lock tokens to participate.
2.  **Yield:** Earn passively based on stake and skill multipliers.
3.  **Skill Points:** Accumulate based on stake and time; spent to unlock skills.
4.  **Skill Tree:** A predefined structure of unlockable abilities with costs and dependencies.
5.  **Skills:** Abilities providing in-contract benefits.
6.  **Governance:** Proposal submission and voting (potentially skill-weighted) for contract parameters or actions.
7.  **Treasury:** Holds staked tokens and potentially generated yield/fees.

**State Variables:**
*   `stakingToken`: Address of the ERC20 token users stake.
*   `totalStaked`: Total amount of `stakingToken` staked in the contract.
*   `treasuryBalance`: Balance of `stakingToken` available for distribution or use (distinct from totalStaked if fees or external yield are collected).
*   `userStates`: Mapping of user address to their `UserState` struct.
*   `skillTree`: Mapping of skill ID to `Skill` struct.
*   `proposals`: Mapping of proposal ID to `Proposal` struct.
*   `nextProposalId`: Counter for proposal IDs.
*   `paused`: Boolean to pause critical operations.
*   Various parameters: `yieldRatePerSecond`, `skillPointRatePerSecond`, `baseYieldMultiplier`, `baseGovernanceWeight`, `proposalThreshold`, `votingPeriodBlocks`, etc.

**Structs:**
*   `UserState`: `stakedAmount`, `skillPoints`, `lastYieldClaimTimestamp`, `lastSkillPointClaimTimestamp`, `unlockedSkills[]`.
*   `Skill`: `skillId`, `name`, `description`, `pointCost`, `dependencies[]`, `effectType` (enum), `effectValue` (uint).
*   `Proposal`: `proposalId`, `proposer`, `description`, `targetContract`, `calldata`, `startBlock`, `endBlock`, `yayVotes`, `nayVotes`, `totalVotingWeight`, `state` (enum).

**Enums:**
*   `SkillEffectType`: `None`, `YieldBoost`, `GovernanceWeightBoost`, `ProposalSubmission`, `SpecialWithdrawal`.
*   `ProposalState`: `Pending`, `Active`, `Succeeded`, `Failed`, `Executed`, `Canceled`.

**Function Summary (26 Functions):**

1.  `constructor`: Initializes the contract with the staking token address and basic parameters.
2.  `initializeSkillTree`: Owner/Deployer function to set up the initial skill tree structure and parameters. Can only be called once.
3.  `stake`: Users stake `stakingToken`. Transfers tokens in, updates user and total stake, records last claim timestamps.
4.  `unstake`: Users withdraw staked `stakingToken`. Transfers tokens out, updates user and total stake. (May require specific skills or have cooldowns in a real system).
5.  `claimYield`: Users claim accumulated yield. Calculates yield based on stake, time, and yield multipliers (influenced by unlocked skills), transfers yield tokens (from treasury or calculated inflation), updates user state.
6.  `claimSkillPoints`: Users claim accumulated Skill Points. Calculates points based on stake and time, updates user state.
7.  `unlockSkill`: Users spend Skill Points to unlock a skill. Checks point balance, skill dependencies, and skill tree status. Deducts points, adds skill to unlocked list.
8.  `getSkillDetails`: Pure function to retrieve details of a specific skill ID from the `skillTree` mapping.
9.  `getSkillDependencies`: Pure function to retrieve dependencies for a specific skill ID.
10. `getSkillsUnlocked`: View function to get the list of skill IDs unlocked by a specific user.
11. `getUserState`: View function to get the full `UserState` for a user.
12. `getTotalStaked`: View function to get the total `stakingToken` staked in the contract.
13. `getPendingYield`: View function to calculate and return the yield currently available for a user to claim.
14. `getPendingSkillPoints`: View function to calculate and return the Skill Points currently available for a user to claim.
15. `getAdjustedYieldRate`: View function to calculate a user's effective yield multiplier based on their unlocked skills.
16. `getUserGovernanceWeight`: View function to calculate a user's governance voting weight based on their stake and unlocked skills.
17. `submitProposal`: Allows users (potentially restricted by skill) to submit a governance proposal. Requires depositing a bond.
18. `vote`: Users vote on an active proposal (Yay or Nay) using their calculated governance weight.
19. `getProposalDetails`: View function to get details of a specific proposal.
20. `getProposalState`: View function to get the current state of a specific proposal.
21. `executeProposal`: Allows anyone (after voting period ends and proposal succeeded) to execute a proposal, triggering the `targetContract` call.
22. `cancelProposal`: Allows the proposer (or potentially others based on skill/governance) to cancel a pending or active proposal.
23. `getTreasuryBalance`: View function to get the current balance of the internal treasury.
24. `distributeTreasuryFunds`: Governance-executable function to distribute funds from the treasury (e.g., pay yield, fund initiatives).
25. `pause`: Emergency function (owner/admin) to pause critical user interactions (stake, unstake, claim, unlock, vote).
26. `unpause`: Owner/admin function to unpause the contract.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

contract SkillYieldFund is Ownable, ReentrancyGuard, Pausable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.UintSet;

    // --- State Variables ---

    IERC20 public immutable stakingToken; // The token users stake

    uint256 public totalStaked; // Total amount of stakingToken staked
    uint256 public treasuryBalance; // Balance of stakingToken available in treasury (for distribution/use)

    // User state mapping: address -> UserState
    mapping(address => UserState) public userStates;

    // Skill Tree mapping: skillId -> Skill
    mapping(uint256 => Skill) public skillTree;
    uint256 private nextSkillId; // Counter for skill IDs
    bool public skillTreeInitialized = false; // Flag to prevent re-initialization

    // Governance Proposals mapping: proposalId -> Proposal
    mapping(uint256 => Proposal) public proposals;
    uint256 public nextProposalId; // Counter for proposal IDs

    // Parameters (Owner/Governance controllable)
    uint256 public yieldRatePerSecond = 100; // Example: yield units per staked token per second (scaled)
    uint256 public skillPointRatePerSecond = 50; // Example: skill points per staked token per second (scaled)
    uint256 public baseYieldMultiplier = 1e18; // Base multiplier (1.0)
    uint256 public baseGovernanceWeight = 1; // Base weight per staked token
    uint256 public proposalThreshold = 1e18; // Minimum stake required to submit a proposal (scaled stake)
    uint256 public votingPeriodBlocks = 100; // Number of blocks a proposal is active
    uint256 public proposalBond = 1e18; // Stake required to submit a proposal (scaled stake)

    // --- Structs ---

    struct UserState {
        uint256 stakedAmount;
        uint256 skillPoints;
        uint256 lastYieldClaimTimestamp;
        uint256 lastSkillPointClaimTimestamp;
        EnumerableSet.UintSet unlockedSkills; // Set of skill IDs unlocked by the user
    }

    enum SkillEffectType {
        None,
        YieldBoost,
        GovernanceWeightBoost,
        ProposalSubmission, // Unlocks the ability to submit proposals
        SpecialWithdrawal // Unlocks ability for limited withdrawal type
        // Add more effect types as needed
    }

    struct Skill {
        uint256 skillId;
        string name;
        string description;
        uint256 pointCost;
        uint256[] dependencies; // Skill IDs that must be unlocked first
        SkillEffectType effectType;
        uint256 effectValue; // Value associated with the effect (e.g., percentage boost, flat value)
    }

    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Failed,
        Executed,
        Canceled
    }

    struct Proposal {
        uint256 proposalId;
        address proposer;
        string description;
        address targetContract; // Contract address to call
        bytes calldata; // Encoded function call data
        uint256 startBlock;
        uint256 endBlock;
        uint256 yayVotes;
        uint256 nayVotes;
        uint256 totalVotingWeight; // Sum of weights of all voters (not just yes/no)
        ProposalState state;
        mapping(address => bool) hasVoted; // Record addresses that have voted
    }

    // --- Events ---

    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount);
    event YieldClaimed(address indexed user, uint256 amount);
    event SkillPointsClaimed(address indexed user, uint256 points);
    event SkillUnlocked(address indexed user, uint256 indexed skillId);
    event ProposalSubmitted(uint256 indexed proposalId, address indexed proposer, string description);
    event Voted(address indexed voter, uint256 indexed proposalId, bool support, uint256 weight);
    event ProposalExecuted(uint256 indexed proposalId);
    event ProposalCanceled(uint256 indexed proposalId);
    event SkillTreeInitialized(uint256 totalSkills);
    event TreasuryFundsDistributed(address indexed recipient, uint256 amount);
    event ParametersUpdated(string paramName, uint256 newValue);

    // --- Modifiers ---

    modifier onlySkillUnlocked(uint256 _skillId) {
        require(userStates[msg.sender].unlockedSkills.contains(_skillId), "Skill not unlocked");
        _;
    }

    // --- Constructor ---

    constructor(address _stakingTokenAddress) Ownable(msg.sender) {
        stakingToken = IERC20(_stakingTokenAddress);
        nextSkillId = 1; // Start skill IDs from 1
        nextProposalId = 1; // Start proposal IDs from 1
    }

    // --- Initialization ---

    /// @notice Initializes the Skill Tree structure. Can only be called once by the owner.
    /// @param _skillIds Array of skill IDs (must be unique, sequential starting from 1).
    /// @param _names Array of skill names.
    /// @param _descriptions Array of skill descriptions.
    /// @param _pointCosts Array of skill point costs.
    /// @param _dependencies Array of skill dependency arrays.
    /// @param _effectTypes Array of skill effect types (enum).
    /// @param _effectValues Array of skill effect values.
    function initializeSkillTree(
        uint256[] memory _skillIds,
        string[] memory _names,
        string[] memory _descriptions,
        uint256[] memory _pointCosts,
        uint256[][] memory _dependencies,
        SkillEffectType[] memory _effectTypes,
        uint256[] memory _effectValues
    ) external onlyOwner {
        require(!skillTreeInitialized, "Skill tree already initialized");
        require(_skillIds.length == _names.length &&
                _skillIds.length == _descriptions.length &&
                _skillIds.length == _pointCosts.length &&
                _skillIds.length == _dependencies.length &&
                _skillIds.length == _effectTypes.length &&
                _skillIds.length == _effectValues.length,
                "Input array lengths mismatch");
        require(_skillIds.length > 0, "Skill tree cannot be empty");
        require(_skillIds[0] == 1, "First skill ID must be 1");

        for (uint i = 0; i < _skillIds.length; i++) {
            uint256 currentId = _skillIds[i];
            require(currentId == nextSkillId, "Skill IDs must be sequential");

            skillTree[currentId] = Skill({
                skillId: currentId,
                name: _names[i],
                description: _descriptions[i],
                pointCost: _pointCosts[i],
                dependencies: _dependencies[i],
                effectType: _effectTypes[i],
                effectValue: _effectValues[i]
            });
            nextSkillId++;
        }
        skillTreeInitialized = true;
        emit SkillTreeInitialized(_skillIds.length);
    }

    // --- Staking & Yield ---

    /// @notice Stakes tokens into the fund.
    /// @param _amount The amount of stakingToken to stake.
    function stake(uint256 _amount) external nonReentrant whenNotPaused {
        require(_amount > 0, "Amount must be greater than 0");

        // Transfer tokens to the contract
        stakingToken.transferFrom(msg.sender, address(this), _amount);

        UserState storage user = userStates[msg.sender];

        // Claim pending points/yield before updating stake
        claimSkillPoints(); // Ensures points are calculated based on previous stake duration
        claimYield();       // Ensures yield is calculated based on previous stake duration

        user.stakedAmount = user.stakedAmount.add(_amount);
        totalStaked = totalStaked.add(_amount);

        // Reset last claim times *after* claiming pending amounts
        user.lastSkillPointClaimTimestamp = block.timestamp;
        user.lastYieldClaimTimestamp = block.timestamp;

        emit Staked(msg.sender, _amount);
    }

    /// @notice Unstakes tokens from the fund.
    /// @param _amount The amount of stakingToken to unstake.
    // NOTE: In a real system, unstaking might have cooldowns, unlockable via skill, or other restrictions.
    function unstake(uint256 _amount) external nonReentrant whenNotPaused {
        UserState storage user = userStates[msg.sender];
        require(_amount > 0, "Amount must be greater than 0");
        require(user.stakedAmount >= _amount, "Insufficient staked amount");

        // Claim pending points/yield before updating stake
        claimSkillPoints();
        claimYield();

        user.stakedAmount = user.stakedAmount.sub(_amount);
        totalStaked = totalStaked.sub(_amount);

        // Transfer tokens back to the user
        stakingToken.transfer(msg.sender, _amount);

        // Reset last claim times *after* claiming pending amounts
        user.lastSkillPointClaimTimestamp = block.timestamp;
        user.lastYieldClaimTimestamp = block.timestamp;

        emit Unstaked(msg.sender, _amount);
    }

    /// @notice Claims accumulated yield for the user.
    function claimYield() public nonReentrant whenNotPaused {
        UserState storage user = userStates[msg.sender];
        uint256 pendingYield = getPendingYield(msg.sender);

        if (pendingYield > 0) {
            // This is a simplified model. In a real fund, yield might come from:
            // 1. Contract inflation (minting new tokens if token is minitable)
            // 2. External DeFi interactions (contract invests staked funds)
            // 3. Protocol fees collected in stakingToken or other tokens
            // For this example, we assume yield is somehow available, potentially from treasury or "magic".
            // A more realistic approach would involve treasury accounting or explicit minting.
            // We'll simulate yield payment by transferring from treasury or assuming availability.
            // In a real system, you'd need logic for how the treasury is funded with yield.

            // Example: Transferring from treasury (requires treasury to be funded)
            require(treasuryBalance >= pendingYield, "Insufficient treasury balance for yield");
            treasuryBalance = treasuryBalance.sub(pendingYield);
            stakingToken.transfer(msg.sender, pendingYield); // Or a separate yield token

            user.lastYieldClaimTimestamp = block.timestamp;
            emit YieldClaimed(msg.sender, pendingYield);
        }
    }

    /// @notice Claims accumulated Skill Points for the user.
    function claimSkillPoints() public nonReentrant whenNotPaused {
        UserState storage user = userStates[msg.sender];
        uint256 pendingPoints = getPendingSkillPoints(msg.sender);

        if (pendingPoints > 0) {
            user.skillPoints = user.skillPoints.add(pendingPoints);
            user.lastSkillPointClaimTimestamp = block.timestamp;
            emit SkillPointsClaimed(msg.sender, pendingPoints);
        }
    }

    /// @notice Calculates the yield currently available for a user to claim.
    /// @param _user The address of the user.
    /// @return The amount of yield available.
    function getPendingYield(address _user) public view returns (uint256) {
        UserState storage user = userStates[_user];
        if (user.stakedAmount == 0) {
            return 0;
        }
        uint256 timeSinceLastClaim = block.timestamp.sub(user.lastYieldClaimTimestamp);
        uint256 yieldPerSecond = user.stakedAmount.mul(yieldRatePerSecond).div(1e18); // Scale down yield rate
        uint256 baseYield = yieldPerSecond.mul(timeSinceLastClaim);
        uint256 adjustedMultiplier = getAdjustedYieldRate(_user);
        // Apply skill-based multiplier
        return baseYield.mul(adjustedMultiplier).div(baseYieldMultiplier); // Apply multiplier
    }

    /// @notice Calculates the Skill Points currently available for a user to claim.
    /// @param _user The address of the user.
    /// @return The amount of Skill Points available.
    function getPendingSkillPoints(address _user) public view returns (uint256) {
        UserState storage user = userStates[_user];
        if (user.stakedAmount == 0) {
            return 0;
        }
        uint256 timeSinceLastClaim = block.timestamp.sub(user.lastSkillPointClaimTimestamp);
        // Points are proportional to stake amount and time
        return user.stakedAmount.mul(skillPointRatePerSecond).mul(timeSinceLastClaim).div(1e18); // Scale based on points rate
    }

    /// @notice Calculates a user's effective yield multiplier based on unlocked skills.
    /// @param _user The address of the user.
    /// @return The combined yield multiplier.
    function getAdjustedYieldRate(address _user) public view returns (uint256) {
        UserState storage user = userStates[_user];
        uint256 currentMultiplier = baseYieldMultiplier; // Start with base

        // Iterate through unlocked skills and apply yield boost effects
        uint256[] memory unlockedSkillIds = user.unlockedSkills.values();
        for (uint i = 0; i < unlockedSkillIds.length; i++) {
            uint256 skillId = unlockedSkillIds[i];
            Skill storage skill = skillTree[skillId];
            if (skill.effectType == SkillEffectType.YieldBoost) {
                // Assuming effectValue is a percentage multiplier (e.g., 105 for 5% boost)
                currentMultiplier = currentMultiplier.mul(10000 + skill.effectValue).div(10000); // Example: 10500/10000 for 5% boost
            }
        }
        return currentMultiplier;
    }

    // --- Skill Tree & Points ---

    /// @notice Unlocks a skill for the user by spending Skill Points.
    /// @param _skillId The ID of the skill to unlock.
    function unlockSkill(uint256 _skillId) external whenNotPaused {
        require(skillTree[_skillId].skillId != 0, "Skill does not exist"); // Check if skillId is valid
        UserState storage user = userStates[msg.sender];

        // Claim pending points first so the current balance is accurate
        claimSkillPoints();

        Skill storage skill = skillTree[_skillId];
        require(!user.unlockedSkills.contains(_skillId), "Skill already unlocked");
        require(user.skillPoints >= skill.pointCost, "Insufficient skill points");

        // Check dependencies
        for (uint i = 0; i < skill.dependencies.length; i++) {
            require(user.unlockedSkills.contains(skill.dependencies[i]), "Dependency skill not unlocked");
        }

        // Deduct points and unlock skill
        user.skillPoints = user.skillPoints.sub(skill.pointCost);
        user.unlockedSkills.add(_skillId);

        emit SkillUnlocked(msg.sender, _skillId);
    }

    /// @notice Gets the list of skill IDs unlocked by a specific user.
    /// @param _user The address of the user.
    /// @return An array of skill IDs.
    function getSkillsUnlocked(address _user) external view returns (uint256[] memory) {
        return userStates[_user].unlockedSkills.values();
    }

    /// @notice Gets the point cost of a specific skill.
    /// @param _skillId The ID of the skill.
    /// @return The skill point cost.
    function getSkillCost(uint256 _skillId) external view returns (uint256) {
        require(skillTree[_skillId].skillId != 0, "Skill does not exist");
        return skillTree[_skillId].pointCost;
    }

    /// @notice Gets the dependency skill IDs for a specific skill.
    /// @param _skillId The ID of the skill.
    /// @return An array of dependency skill IDs.
    function getSkillDependencies(uint256 _skillId) external view returns (uint256[] memory) {
        require(skillTree[_skillId].skillId != 0, "Skill does not exist");
        return skillTree[_skillId].dependencies;
    }

    /// @notice Gets the full state of a user.
    /// @param _user The address of the user.
    /// @return The user's state struct.
    function getUserState(address _user) external view returns (UserState memory) {
        // Note: EnumerableSet.UintSet cannot be returned directly in memory from a view function.
        // Returning a simplified struct or needing a separate getter for unlocked skills is common.
        // For simplicity in this example, we'll return the struct directly (may not work in all tools).
        // A more robust way is to return fields individually or return a custom struct.
        // Let's just return a simplified view for demonstration.
         UserState storage user = userStates[_user];
         return UserState({
             stakedAmount: user.stakedAmount,
             skillPoints: user.skillPoints,
             lastYieldClaimTimestamp: user.lastYieldClaimTimestamp,
             lastSkillPointClaimTimestamp: user.lastSkillPointClaimTimestamp,
             unlockedSkills: new EnumerableSet.UintSet() // Placeholder, actual set data is not easily returned this way
         });
    }

     // Helper to get UserState data reliably
    function getUserStakedAmount(address _user) external view returns (uint256) { return userStates[_user].stakedAmount; }
    function getUserSkillPoints(address _user) external view returns (uint256) { return userStates[_user].skillPoints; }
    // getSkillsUnlocked is already provided above

    // --- Governance ---

    /// @notice Calculates a user's governance voting weight based on stake and skills.
    /// @param _user The address of the user.
    /// @return The calculated voting weight.
    function getUserGovernanceWeight(address _user) public view returns (uint256) {
        UserState storage user = userStates[_user];
        uint256 baseWeight = user.stakedAmount.mul(baseGovernanceWeight); // Simple: weight = stake amount
        uint256 currentWeight = baseWeight;

        // Apply skill-based multipliers
        uint256[] memory unlockedSkillIds = user.unlockedSkills.values();
        for (uint i = 0; i < unlockedSkillIds.length; i++) {
            uint256 skillId = unlockedSkillIds[i];
            Skill storage skill = skillTree[skillId];
            if (skill.effectType == SkillEffectType.GovernanceWeightBoost) {
                // Assuming effectValue is a percentage boost (e.g., 110 for 10% boost)
                currentWeight = currentWeight.mul(10000 + skill.effectValue).div(10000); // Example: 11000/10000 for 10% boost
            }
        }
        return currentWeight;
    }

    /// @notice Allows users (potentially restricted by skill) to submit a governance proposal.
    /// @param _description A description of the proposal.
    /// @param _targetContract The address of the contract the proposal will interact with (often this contract itself).
    /// @param _calldata The encoded function call to execute if the proposal passes.
    function submitProposal(
        string memory _description,
        address _targetContract,
        bytes memory _calldata
    ) external payable whenNotPaused {
        UserState storage user = userStates[msg.sender];

        // Requirement: User must have the ProposalSubmission skill OR meet stake threshold
        bool canSubmit = user.unlockedSkills.contains(getSkillIdByEffect(SkillEffectType.ProposalSubmission));
        if (!canSubmit) {
           require(user.stakedAmount >= proposalThreshold, "Insufficient stake or skill to submit proposal");
        }
        // Note: For a real system, require msg.value == proposalBond might be needed if bond is in ETH.
        // If bond is in stakingToken, need allowance/transferFrom and treasury management.
        // For simplicity, we'll just require stake threshold and omit the bond mechanism here.

        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            proposalId: proposalId,
            proposer: msg.sender,
            description: _description,
            targetContract: _targetContract,
            calldata: _calldata,
            startBlock: block.number,
            endBlock: block.number.add(votingPeriodBlocks),
            yayVotes: 0,
            nayVotes: 0,
            totalVotingWeight: 0,
            state: ProposalState.Active,
            hasVoted: new mapping(address => bool) // Initialize the mapping
        });

        emit ProposalSubmitted(proposalId, msg.sender, _description);
    }

    /// @notice Allows users to vote on an active proposal.
    /// @param _proposalId The ID of the proposal to vote on.
    /// @param _support True for Yay (Yes), False for Nay (No).
    function vote(uint256 _proposalId, bool _support) external whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.state == ProposalState.Active, "Proposal not active");
        require(block.number <= proposal.endBlock, "Voting period has ended");
        require(!proposal.hasVoted[msg.sender], "Already voted on this proposal");

        uint256 weight = getUserGovernanceWeight(msg.sender);
        require(weight > 0, "Insufficient voting weight"); // Must have some stake/skill to vote

        if (_support) {
            proposal.yayVotes = proposal.yayVotes.add(weight);
        } else {
            proposal.nayVotes = proposal.nayVotes.add(weight);
        }
        proposal.totalVotingWeight = proposal.totalVotingWeight.add(weight);
        proposal.hasVoted[msg.sender] = true;

        emit Voted(msg.sender, _proposalId, _support, weight);
    }

    /// @notice Gets the details of a specific proposal.
    /// @param _proposalId The ID of the proposal.
    /// @return The proposal struct details.
    function getProposalDetails(uint256 _proposalId) public view returns (
        uint256 proposalId,
        address proposer,
        string memory description,
        address targetContract,
        bytes memory calldata,
        uint256 startBlock,
        uint256 endBlock,
        uint256 yayVotes,
        uint256 nayVotes,
        uint256 totalVotingWeight,
        ProposalState state
    ) {
        Proposal storage proposal = proposals[_proposalId];
        return (
            proposal.proposalId,
            proposal.proposer,
            proposal.description,
            proposal.targetContract,
            proposal.calldata,
            proposal.startBlock,
            proposal.endBlock,
            proposal.yayVotes,
            proposal.nayVotes,
            proposal.totalVotingWeight,
            getProposalState(_proposalId) // Get current state
        );
    }

    /// @notice Gets the current state of a specific proposal.
    /// @param _proposalId The ID of the proposal.
    /// @return The current proposal state.
    function getProposalState(uint256 _proposalId) public view returns (ProposalState) {
        Proposal storage proposal = proposals[_proposalId];
        if (proposal.state != ProposalState.Pending &&
            proposal.state != ProposalState.Active) {
            return proposal.state; // State is final (Executed, Canceled, Succeeded, Failed)
        }

        if (block.number <= proposal.endBlock) {
            return ProposalState.Active; // Voting is still open
        } else {
            // Voting period ended, determine outcome
            // Simple majority rule for this example
            if (proposal.yayVotes > proposal.nayVotes && proposal.totalVotingWeight > 0) {
                return ProposalState.Succeeded;
            } else {
                return ProposalState.Failed;
            }
        }
    }

    /// @notice Executes a successful proposal. Can be called by anyone.
    /// @param _proposalId The ID of the proposal to execute.
    function executeProposal(uint256 _proposalId) external nonReentrant whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        require(getProposalState(_proposalId) == ProposalState.Succeeded, "Proposal is not in Succeeded state");
        require(proposal.state != ProposalState.Executed, "Proposal already executed");

        // Execute the proposal's action
        (bool success, ) = proposal.targetContract.call(proposal.calldata);
        require(success, "Proposal execution failed");

        proposal.state = ProposalState.Executed;
        // In a real system, if a proposal bond was required, return it to the proposer here.
        emit ProposalExecuted(_proposalId);
    }

    /// @notice Allows the proposer or others (with skill/governance) to cancel a proposal.
    /// @param _proposalId The ID of the proposal to cancel.
    function cancelProposal(uint256 _proposalId) external whenNotPaused {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.state == ProposalState.Pending || proposal.state == ProposalState.Active, "Proposal cannot be canceled in its current state");

        // Requirement: Only proposer OR user with ProposalSubmission skill OR owner can cancel
        bool canCancel = (msg.sender == proposal.proposer) ||
                         userStates[msg.sender].unlockedSkills.contains(getSkillIdByEffect(SkillEffectType.ProposalSubmission)) ||
                         msg.sender == owner();

        require(canCancel, "Not authorized to cancel this proposal");

        proposal.state = ProposalState.Canceled;
        // In a real system, if a proposal bond was required, decide what happens to it on cancellation.
        emit ProposalCanceled(_proposalId);
    }

    // --- Treasury Management ---

    /// @notice Adds funds to the internal treasury. Can be called externally (e.g., from yield source).
    /// @param _amount The amount of stakingToken to add to the treasury.
    function addTreasuryFunds(uint256 _amount) external {
         require(msg.sender != address(0), "Cannot add from zero address");
         require(_amount > 0, "Amount must be greater than 0");
         // In a real system, you might restrict who can call this (e.g., trusted yield adapter contracts)
         // For simplicity, allowing anyone to send to a specific deposit function for treasury.
         // Best practice: Require transferFrom sender or receive() ETH into a separate balance.
         // Let's assume an external source calls this after generating yield.
         // Alternatively, receive() or fallback could accept tokens/ETH and update treasury.
         // Let's make this callable only by owner for simplicity in this example.
         // A better design would involve a dedicated yield adapter.
         require(msg.sender == owner(), "Only owner can manually add treasury funds (for simulation)");
         // Assuming tokens are already in the contract from an external source/transfer.
         // Or, if caller transfers: stakingToken.transferFrom(msg.sender, address(this), _amount);
         treasuryBalance = treasuryBalance.add(_amount);
         // emit event TreasuryFundsAdded(msg.sender, _amount); // Add this event
    }

    /// @notice Distributes funds from the treasury to a recipient. Executable via governance.
    /// @param _recipient The address to send the funds to.
    /// @param _amount The amount of stakingToken to distribute.
    function distributeTreasuryFunds(address _recipient, uint256 _amount) external onlyOwner nonReentrant {
        // This function is designed to be called by a successful governance proposal execution,
        // where the targetContract is THIS contract and calldata encodes this function call.
        // The `onlyOwner` modifier here acts as a proxy for "called by authorized governance execution".
        // In a production system, you'd replace `onlyOwner` with a check like `require(msg.sender == address(this))`
        // combined with logic within `executeProposal` to ensure the internal call is authorized.
        // For simplicity, the deployer is the "authorized executor" in this example.

        require(_recipient != address(0), "Cannot distribute to zero address");
        require(_amount > 0, "Amount must be greater than 0");
        require(treasuryBalance >= _amount, "Insufficient treasury balance");

        treasuryBalance = treasuryBalance.sub(_amount);
        stakingToken.transfer(_recipient, _amount);
        emit TreasuryFundsDistributed(_recipient, _amount);
    }

    /// @notice Gets the current balance of the internal treasury.
    /// @return The treasury balance in stakingToken.
    function getTreasuryBalance() external view returns (uint256) {
        return treasuryBalance;
    }

    // --- Emergency & Utilities ---

    /// @notice Pauses the contract (Staking, Unstaking, Claims, Unlocking, Voting, Proposal Submission).
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpauses the contract.
    function unpause() external onlyOwner {
        _unpause();
    }

    /// @notice Internal helper to find a skill ID by its effect type. Useful for checks.
    /// @param _effectType The effect type to search for.
    /// @return The ID of the first skill found with that effect type, or 0 if none exists.
    function getSkillIdByEffect(SkillEffectType _effectType) internal view returns (uint256) {
        // Note: This is inefficient for large skill trees. A mapping (EffectType -> SkillId) would be better.
        // Assuming a small number of unique effect types for simplicity.
        for(uint256 i = 1; i < nextSkillId; i++) {
            if (skillTree[i].effectType == _effectType) {
                return i;
            }
        }
        return 0; // Not found
    }

    /// @notice Allows a user with the SpecialWithdrawal skill to withdraw a limited amount (example).
    /// @param _amount The amount to withdraw.
    // NOTE: This is a simple example demonstrating a skill-gated function.
    // Real implementation would need clear rules on amount limits, frequency, etc.
    function specialWithdrawal(uint256 _amount) external nonReentrant whenNotPaused onlySkillUnlocked(getSkillIdByEffect(SkillEffectType.SpecialWithdrawal)) {
         require(_amount > 0, "Amount must be greater than 0");
         UserState storage user = userStates[msg.sender];
         // Example limit: Cannot withdraw more than 10% of stake using this skill
         require(_amount <= user.stakedAmount.div(10), "Withdrawal exceeds skill limit");

         // Claim pending points/yield before updating stake
         claimSkillPoints();
         claimYield();

         user.stakedAmount = user.stakedAmount.sub(_amount);
         totalStaked = totalStaked.sub(_amount);

         stakingToken.transfer(msg.sender, _amount);

         user.lastSkillPointClaimTimestamp = block.timestamp;
         user.lastYieldClaimTimestamp = block.timestamp;

         // emit event SpecialWithdrawal(msg.sender, _amount); // Add this event
    }

     /// @notice Sets the staking and yield rates. Callable only by owner (or via governance).
     /// @param _yieldRate The new yield rate per second (scaled).
     /// @param _skillPointRate The new skill point rate per second (scaled).
    function setRates(uint256 _yieldRate, uint256 _skillPointRate) external onlyOwner {
        // In a production system, this would likely be a governance action
        yieldRatePerSecond = _yieldRate;
        skillPointRatePerSecond = _skillPointRate;
        emit ParametersUpdated("yieldRatePerSecond", _yieldRate);
        emit ParametersUpdated("skillPointRatePerSecond", _skillPointRate);
    }

    /// @notice Sets governance parameters. Callable only by owner (or via governance).
    /// @param _proposalThreshold The new minimum stake to submit a proposal.
    /// @param _votingPeriodBlocks The new number of blocks for the voting period.
    /// @param _proposalBond The new bond amount required to submit a proposal.
    function setGovernanceParameters(uint256 _proposalThreshold, uint256 _votingPeriodBlocks, uint256 _proposalBond) external onlyOwner {
        // In a production system, this would likely be a governance action
        proposalThreshold = _proposalThreshold;
        votingPeriodBlocks = _votingPeriodBlocks;
        proposalBond = _proposalBond;
        emit ParametersUpdated("proposalThreshold", _proposalThreshold);
        emit ParametersUpdated("votingPeriodBlocks", _votingPeriodBlocks);
        emit ParametersUpdated("proposalBond", _proposalBond);
    }
}
```

---

**Explanation of Advanced/Creative/Trendy Concepts:**

1.  **Skill Tree Mechanics:** Implementing a structured progression system directly on-chain, where users spend points earned through participation to unlock tiered abilities. This goes beyond simple staking benefits.
2.  **Dynamic Yield/Governance Weight:** User benefits (yield rate, voting power) are not static per token but are dynamically adjusted based on the skills they've unlocked, creating a direct utility for the skill tree.
3.  **Skill-Gated Features:** Certain functions (like `submitProposal` or `specialWithdrawal`) can be restricted, requiring a specific skill unlock, adding a layer of earned access control on top of traditional ownership or simple token balance checks.
4.  **Combined Utility Token:** The staking token acts as both the capital staked for yield *and* the basis for earning skill points, linking financial participation directly to progression and utility.
5.  **On-Chain Governance Integration:** Includes a basic system for proposals, voting (weighted by the skill-adjusted `getUserGovernanceWeight`), and execution of arbitrary calls, allowing the community (influenced by their skill level) to steer the protocol.
6.  **Time-Based Accumulation:** Yield and Skill Points accrue over time based on the staked amount, using timestamps (or block numbers) to calculate pending amounts.
7.  **EnumerableSet for Unlocked Skills:** Using OpenZeppelin's `EnumerableSet` to efficiently manage the list of unlocked skills for each user, allowing for easy checking (`contains`) and iteration (`values()`).
8.  **ReentrancyGuard and Pausable:** Standard but essential security patterns from OpenZeppelin to protect against common vulnerabilities and provide emergency stop functionality.
9.  **Internal Treasury Logic:** Basic structure for managing funds intended for distribution or protocol actions, separate from the total staked balance.
10. **Parameterized and Upgradable Design (Conceptual):** While this example is a single contract, a real-world application would likely use upgradeable proxies and make more parameters configurable via governance to allow the protocol to evolve. The `initializeSkillTree` and `setRates`/`setGovernanceParameters` functions hint at this configurability.

This contract provides a foundation for a community-driven protocol centered around progressive benefits earned through staking and skill development, offering more depth than a simple staking pool or a basic DAO.