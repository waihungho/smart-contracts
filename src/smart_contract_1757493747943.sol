This smart contract, "SynthMind," presents a decentralized platform for AI-generated content. It allows users to register AI Agents (represented as NFTs), submit requests for content generation, and then license the resulting AI-generated content (also represented as dynamic NFTs). The platform incorporates a commit-reveal scheme for requests, a reputation system for AI Agents, and dynamic pricing for content licenses, all governed by a set of platform parameters.

The design aims to be advanced, creative, and unique by:
*   **Decentralized AI Agents as NFTs:** AI models are tokenized, allowing ownership, reputation, and monetization.
*   **Dynamic Content NFTs (dNFTs):** Generated content is an NFT whose license price and metadata can change based on demand, agent reputation, and oracle verification.
*   **Commit-Reveal for Requests:** Enhances fairness and prevents front-running for prompt submissions.
*   **Oracle Integration (Conceptual):** Trusted oracles are crucial for verifying AI output quality and influencing agent reputation.
*   **Dynamic Pricing & Royalty Distribution:** Content license prices adapt, and revenue is split between the requestor, agent owner, and platform.
*   **On-chain Reputation:** AI agents earn or lose reputation based on the quality of their generated content.

The contract uses OpenZeppelin libraries for standard functionalities like ERC721, Ownable, and Pausable, but the core application logic and the unique combination of these features are custom-built.

---

### **Outline**

**I. Contract Setup and Configuration**
    A. Initialization
    B. Oracle Management
    C. Fee Management
    D. Emergency Controls
    E. Fund Withdrawal

**II. AI Agent Management (NFTs)**
    A. Registration
    B. Details Update
    C. Activation/Deactivation
    D. Pricing
    E. Information Retrieval

**III. Generative Content Requests & Fulfillment**
    A. Request Commitment
    B. Request Revelation
    C. Content Fulfillment
    D. Content Verification

**IV. Generated Content Licensing & Monetization (Dynamic NFTs)**
    A. License Purchase
    B. Dynamic Pricing Calculation
    C. Royalty Withdrawal (Agent)
    D. Royalty Withdrawal (Requestor)

**V. Reputation and Analytics**
    A. AI Agent Reputation
    B. Content Popularity

---

### **Function Summary**

**I. Contract Setup and Configuration**

1.  `constructor()`: Initializes the contract with an owner, platform fee recipient, and initial parameters.
2.  `registerTrustedOracle(address _oracle)`: Allows the owner to add a new address to the list of trusted oracles responsible for content verification.
3.  `deregisterTrustedOracle(address _oracle)`: Allows the owner to remove an address from the trusted oracles list.
4.  `setPlatformFeePercentage(uint256 _feePercentage)`: Sets the percentage of content license revenue that goes to the platform.
5.  `setAgentRegistrationFee(uint256 _fee)`: Sets the fee required for users to register a new AI Agent.
6.  `pause()`: Initiates an emergency pause of core contract functionalities, callable only by the owner.
7.  `unpause()`: Resumes contract operations after a pause, callable by the owner.
8.  `withdrawPlatformFunds()`: Allows the platform owner to withdraw accumulated platform fees to the designated fee recipient.

**II. AI Agent Management (NFTs)**

9.  `registerAIAgent(string memory _name, string memory _description, string memory _modelIPFSLink)`: Mints a unique `AIAgentNFT` for the caller, registering their AI model with a name, description, and link to off-chain model details (IPFS). Requires the `agentRegistrationFee`.
10. `updateAIAgentDetails(uint256 _agentId, string memory _newName, string memory _newDescription, string memory _newModelIPFSLink)`: Allows an AI Agent owner to update the descriptive metadata of their registered agent.
11. `deactivateAIAgent(uint256 _agentId)`: Temporarily deactivates an AI Agent, preventing it from fulfilling new requests or earning royalties until reactivated.
12. `reactivateAIAgent(uint256 _agentId)`: Reactivates a previously deactivated AI Agent, allowing it to resume operations.
13. `setAIAgentBasePrice(uint256 _agentId, uint256 _basePrice)`: Allows an AI Agent owner to set the base price used in the dynamic calculation for licensing content generated by their agent.
14. `getAIAgentDetails(uint256 _agentId)`: Retrieves comprehensive data and current status for a specific AI Agent.

**III. Generative Content Requests & Fulfillment**

15. `submitGenerationRequestCommitment(bytes32 _promptHash)`: Initiates a generation request by committing to a hashed prompt, paying a nominal request fee. This is the first step of a commit-reveal scheme.
16. `revealGenerationRequest(uint256 _requestId, string memory _prompt, string memory _params)`: Reveals the actual prompt and parameters for a committed request, validating against the stored hash. This completes the request initiation.
17. `fulfillGenerationRequest(uint256 _requestId, uint256 _agentId, string memory _contentIPFSLink, string memory _generatedMetadataIPFSLink)`: Called by an `AIAgent` (or an authorized relay) to submit the IPFS link of the generated content and its metadata in response to a request. Mints a `GeneratedContentNFT`.
18. `verifyGeneratedContent(uint256 _contentId, bool _isApproved)`: Callable by a `TrustedOracle` to approve or reject generated content. Approval makes the content licensable and impacts the fulfilling AI Agent's reputation.

**IV. Generated Content Licensing & Monetization**

19. `purchaseContentLicense(uint256 _contentId)`: Allows users to purchase a license for approved generated content. The price is dynamically calculated at the time of purchase.
20. `getCurrentContentLicensePrice(uint256 _contentId)`: A view function to calculate and display the current dynamic license price for a given `GeneratedContentNFT`, factoring in agent reputation and content popularity.
21. `withdrawAgentRoyalties(uint256 _agentId)`: Enables the owner of an AI Agent to withdraw their accumulated royalty share from licensed content generated by their agent.
22. `withdrawRequestorEarnings(uint256 _requestId)`: Allows the original requestor of a piece of content to withdraw their share of royalties from its licenses.

**V. Reputation and Analytics**

23. `getAIAgentReputation(uint256 _agentId)`: Returns the current reputation score of an AI Agent, influencing its dynamic pricing and trustworthiness.
24. `getContentPopularityScore(uint256 _contentId)`: Provides a metric of content popularity based on the number of times it has been licensed, contributing to dynamic pricing.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title SynthMind - Decentralized AI Generative Content Nexus
 * @dev This contract facilitates a decentralized platform for AI-generated content.
 *      It manages AI Agents (NFTs), content generation requests, AI-generated content (dynamic NFTs),
 *      licensing, royalty distribution, and a reputation system.
 *      Uses ERC721URIStorage to represent both AI Agents and Generated Content as NFTs,
 *      distinguished by their token URI and internal metadata.
 */
contract SynthMind is ERC721URIStorage, Ownable, Pausable, ReentrancyGuard {
    using Counters for Counters.Counter;

    // --- I. Contract Setup and Configuration ---

    // Events
    event OracleRegistered(address indexed oracle);
    event OracleDeregistered(address indexed oracle);
    event PlatformFeeUpdated(uint256 newFeePercentage);
    event AgentRegistrationFeeUpdated(uint256 newFee);
    event PlatformFundsWithdrawn(address indexed to, uint256 amount);

    // Platform Parameters
    uint256 public platformFeePercentage; // Percentage of license fees taken by the platform (e.g., 500 for 5%)
    uint256 public agentRegistrationFee;  // Fee to register a new AI Agent
    address public platformFeeRecipient;  // Address to receive platform fees

    mapping(address => bool) public trustedOracles; // Oracles authorized to verify content

    // --- II. AI Agent Management (NFTs) ---

    // AI Agent Struct
    struct AIAgent {
        uint256 agentId;          // Unique ID for the agent (also its ERC721 tokenId)
        address owner;            // Owner of the AI Agent NFT
        string name;              // Name of the AI Agent
        string description;       // Description of the AI Agent
        string modelIPFSLink;     // IPFS CID or link to off-chain model details
        int256 reputation;        // Reputation score of the agent
        bool isActive;            // Whether the agent is active and can fulfill requests
        uint256 basePrice;        // Base price for content generated by this agent
        uint256 accumulatedRoyalties; // Royalties accumulated by this agent
    }

    Counters.Counter private _aiAgentIdCounter;
    mapping(uint256 => AIAgent) public aiAgents;
    mapping(address => uint256[]) public ownerToAgentIds; // Track agents owned by an address

    event AIAgentRegistered(uint256 indexed agentId, address indexed owner, string name);
    event AIAgentUpdated(uint256 indexed agentId, string newName);
    event AIAgentStatusChanged(uint256 indexed agentId, bool newStatus);
    event AIAgentBasePriceSet(uint256 indexed agentId, uint256 newBasePrice);
    event AIAgentRoyaltiesWithdrawn(uint256 indexed agentId, address indexed owner, uint256 amount);

    // --- III. Generative Content Requests & Fulfillment ---

    // Generation Request Struct (Commit-Reveal)
    struct GenerationRequest {
        uint256 requestId;       // Unique ID for the request
        address requestor;       // Address that submitted the request
        bytes32 promptHash;      // Keccak256 hash of the prompt for commit-reveal
        string prompt;           // Actual prompt, revealed later
        string params;           // Generation parameters, revealed later
        bool isRevealed;         // True if the prompt has been revealed
        bool isFulfilled;        // True if content has been generated for this request
        uint256 fulfillmentContentId; // The ID of the GeneratedContentNFT that fulfilled this request
        uint256 accumulatedRoyalties; // Royalties accumulated by this request
        uint256 timestamp;       // Timestamp of request commitment
    }

    Counters.Counter private _generationRequestIdCounter;
    mapping(uint256 => GenerationRequest) public generationRequests;

    // Generated Content Struct (Dynamic NFT)
    struct GeneratedContent {
        uint256 contentId;            // Unique ID for the content (also its ERC721 tokenId)
        uint256 requestId;            // ID of the request this content fulfilled
        uint256 agentId;              // ID of the AI Agent that generated this content
        address owner;                // Owner of the Generated Content NFT (always the agent owner for simplicity)
        address requestor;            // Original requestor of the content
        string contentIPFSLink;       // IPFS CID or link to the actual generated content
        string generatedMetadataIPFSLink; // IPFS CID or link to content-specific metadata
        bool isApproved;              // True if content has been approved by an oracle
        uint256 licenseCount;         // Number of times this content has been licensed (popularity)
        uint256 accumulatedRoyalties; // Royalties accumulated by this content
        uint256 timestamp;            // Timestamp of content fulfillment
    }

    Counters.Counter private _generatedContentIdCounter;
    mapping(uint256 => GeneratedContent) public generatedContent;

    event GenerationRequestCommitted(uint256 indexed requestId, address indexed requestor, bytes32 promptHash);
    event GenerationRequestRevealed(uint256 indexed requestId, string prompt, string params);
    event ContentGenerated(uint256 indexed contentId, uint256 indexed requestId, uint256 indexed agentId, string contentIPFSLink);
    event ContentVerified(uint256 indexed contentId, bool isApproved);

    // --- IV. Generated Content Licensing & Monetization ---

    uint256 public constant MAX_REPUTATION_SCORE = 1000; // Max reputation for scaling
    uint256 public constant MAX_POPULARITY_SCORE = 1000; // Max popularity for scaling
    uint256 public constant REQUESTOR_ROYALTY_SHARE_BPS = 2000; // 20% in basis points (10000 BPS = 100%)
    uint256 public constant AGENT_ROYALTY_SHARE_BPS = 7000;     // 70%
    uint256 public constant BASIS_POINTS_DENOMINATOR = 10000;

    event ContentLicensed(uint256 indexed contentId, address indexed purchaser, uint256 price);
    event RequestorEarningsWithdrawn(uint256 indexed requestId, address indexed requestor, uint256 amount);

    // --- V. Reputation and Analytics ---

    // Reputation impact values
    int256 public constant REPUTATION_APPROVAL_BOOST = 10;
    int256 public constant REPUTATION_REJECTION_PENALTY = 50;
    int256 public constant INITIAL_AGENT_REPUTATION = 100;

    // Global NFT token ID counter (for both agents and content)
    Counters.Counter private _nextTokenId;

    // Mappings to track if a token ID refers to an agent or content
    mapping(uint256 => bool) public isAIAgentToken;
    mapping(uint256 => bool) public isGeneratedContentToken;

    constructor(address _platformFeeRecipient) ERC721("SynthMindNFT", "SMNFT") Ownable(msg.sender) {
        require(_platformFeeRecipient != address(0), "Invalid fee recipient");
        platformFeeRecipient = _platformFeeRecipient;
        platformFeePercentage = 500; // 5%
        agentRegistrationFee = 0.01 ether; // Example: 0.01 ETH

        // Initialize counters to prevent ID 0
        _aiAgentIdCounter.increment();
        _generationRequestIdCounter.increment();
        _generatedContentIdCounter.increment();
        _nextTokenId.increment();
    }

    // --- I. Contract Setup and Configuration ---

    /**
     * @dev Registers a trusted oracle address. Only owner can call.
     * @param _oracle The address to register as a trusted oracle.
     */
    function registerTrustedOracle(address _oracle) external onlyOwner {
        require(_oracle != address(0), "Invalid oracle address");
        trustedOracles[_oracle] = true;
        emit OracleRegistered(_oracle);
    }

    /**
     * @dev Deregisters a trusted oracle address. Only owner can call.
     * @param _oracle The address to deregister.
     */
    function deregisterTrustedOracle(address _oracle) external onlyOwner {
        require(_oracle != address(0), "Invalid oracle address");
        trustedOracles[_oracle] = false;
        emit OracleDeregistered(_oracle);
    }

    /**
     * @dev Sets the platform fee percentage. Only owner can call.
     * @param _feePercentage The new fee percentage (e.g., 500 for 5%). Max 10000 (100%).
     */
    function setPlatformFeePercentage(uint256 _feePercentage) external onlyOwner {
        require(_feePercentage <= 10000, "Fee percentage cannot exceed 100%");
        platformFeePercentage = _feePercentage;
        emit PlatformFeeUpdated(_feePercentage);
    }

    /**
     * @dev Sets the fee required to register an AI Agent. Only owner can call.
     * @param _fee The new registration fee in wei.
     */
    function setAgentRegistrationFee(uint256 _fee) external onlyOwner {
        agentRegistrationFee = _fee;
        emit AgentRegistrationFeeUpdated(_fee);
    }

    /**
     * @dev Pauses the contract. Prevents core functionalities like requests, fulfillment, and licensing.
     * Only owner can call.
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the contract. Resumes all functionalities. Only owner can call.
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Allows the platform owner to withdraw accumulated platform fees.
     * Transfers funds to the designated `platformFeeRecipient`.
     */
    function withdrawPlatformFunds() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance - _getTotalLockedFunds();
        require(balance > 0, "No platform funds to withdraw");

        (bool success, ) = payable(platformFeeRecipient).call{value: balance}("");
        require(success, "Failed to withdraw platform funds");

        emit PlatformFundsWithdrawn(platformFeeRecipient, balance);
    }

    /**
     * @dev Internal helper to calculate funds that are not platform fees
     * (e.g., locked for requests, or agent/requestor royalties not yet withdrawn)
     * This is a simplified estimation. A real system would track this more precisely.
     */
    function _getTotalLockedFunds() internal view returns (uint256) {
        uint256 locked = 0;
        // Sum up all request fees that haven't been fulfilled/refunded
        // Sum up all accumulated royalties for agents and requestors
        for (uint256 i = 1; i < _generationRequestIdCounter.current(); i++) {
            GenerationRequest storage req = generationRequests[i];
            // If a request is revealed but not yet fulfilled, its fee might still be "locked"
            // For simplicity, just count royalties that are yet to be withdrawn
            locked += req.accumulatedRoyalties;
        }
        for (uint256 i = 1; i < _aiAgentIdCounter.current(); i++) {
            AIAgent storage agent = aiAgents[i];
            locked += agent.accumulatedRoyalties;
        }
        // This is a simplified approach. A robust system would track available balances more granularly.
        return locked;
    }


    // --- II. AI Agent Management (NFTs) ---

    /**
     * @dev Registers a new AI Agent, minting an AIAgentNFT to the caller.
     * Requires the `agentRegistrationFee`.
     * @param _name The name of the AI Agent.
     * @param _description A description of the AI Agent.
     * @param _modelIPFSLink IPFS CID or link to off-chain model details.
     */
    function registerAIAgent(
        string memory _name,
        string memory _description,
        string memory _modelIPFSLink
    ) external payable whenNotPaused nonReentrant returns (uint256) {
        require(msg.value >= agentRegistrationFee, "Insufficient registration fee");

        _aiAgentIdCounter.increment();
        uint256 agentId = _aiAgentIdCounter.current();
        uint256 tokenId = _nextTokenId.current();
        _nextTokenId.increment();

        aiAgents[agentId] = AIAgent({
            agentId: agentId,
            owner: msg.sender,
            name: _name,
            description: _description,
            modelIPFSLink: _modelIPFSLink,
            reputation: INITIAL_AGENT_REPUTATION,
            isActive: true,
            basePrice: 0, // Agent owner sets this later
            accumulatedRoyalties: 0
        });

        _mint(msg.sender, tokenId);
        _setTokenURI(tokenId, string(abi.encodePacked("ipfs://", _modelIPFSLink, "/agent_metadata")));
        isAIAgentToken[tokenId] = true;
        ownerToAgentIds[msg.sender].push(agentId);

        emit AIAgentRegistered(agentId, msg.sender, _name);
        return agentId;
    }

    /**
     * @dev Allows an AI Agent owner to update their agent's metadata.
     * @param _agentId The ID of the AI Agent to update.
     * @param _newName The new name for the agent.
     * @param _newDescription The new description for the agent.
     * @param _newModelIPFSLink The new IPFS CID for model details.
     */
    function updateAIAgentDetails(
        uint256 _agentId,
        string memory _newName,
        string memory _newDescription,
        string memory _newModelIPFSLink
    ) external whenNotPaused {
        AIAgent storage agent = aiAgents[_agentId];
        require(agent.owner == msg.sender, "Not AI Agent owner");
        require(agent.agentId != 0, "AI Agent does not exist");

        agent.name = _newName;
        agent.description = _newDescription;
        agent.modelIPFSLink = _newModelIPFSLink;
        // Token URI for agents can be dynamic based on the model IPFS link
        _setTokenURI(_getAIAgentTokenId(_agentId), string(abi.encodePacked("ipfs://", _newModelIPFSLink, "/agent_metadata")));

        emit AIAgentUpdated(_agentId, _newName);
    }

    /**
     * @dev Deactivates an AI Agent, preventing it from fulfilling new requests.
     * Only callable by the agent owner.
     * @param _agentId The ID of the AI Agent to deactivate.
     */
    function deactivateAIAgent(uint256 _agentId) external whenNotPaused {
        AIAgent storage agent = aiAgents[_agentId];
        require(agent.owner == msg.sender, "Not AI Agent owner");
        require(agent.agentId != 0, "AI Agent does not exist");
        require(agent.isActive, "AI Agent is already inactive");

        agent.isActive = false;
        emit AIAgentStatusChanged(_agentId, false);
    }

    /**
     * @dev Reactivates a previously deactivated AI Agent. Only callable by the agent owner.
     * @param _agentId The ID of the AI Agent to reactivate.
     */
    function reactivateAIAgent(uint256 _agentId) external whenNotPaused {
        AIAgent storage agent = aiAgents[_agentId];
        require(agent.owner == msg.sender, "Not AI Agent owner");
        require(agent.agentId != 0, "AI Agent does not exist");
        require(!agent.isActive, "AI Agent is already active");

        agent.isActive = true;
        emit AIAgentStatusChanged(_agentId, true);
    }

    /**
     * @dev Allows an AI Agent owner to set the base price for content generated by their agent.
     * This base price is a factor in dynamic license pricing.
     * @param _agentId The ID of the AI Agent.
     * @param _basePrice The new base price in wei.
     */
    function setAIAgentBasePrice(uint256 _agentId, uint256 _basePrice) external whenNotPaused {
        AIAgent storage agent = aiAgents[_agentId];
        require(agent.owner == msg.sender, "Not AI Agent owner");
        require(agent.agentId != 0, "AI Agent does not exist");
        require(_basePrice > 0, "Base price must be greater than zero");

        agent.basePrice = _basePrice;
        emit AIAgentBasePriceSet(_agentId, _basePrice);
    }

    /**
     * @dev Retrieves comprehensive details about a registered AI Agent.
     * @param _agentId The ID of the AI Agent.
     * @return AIAgent struct containing all details.
     */
    function getAIAgentDetails(uint256 _agentId) public view returns (AIAgent memory) {
        require(aiAgents[_agentId].agentId != 0, "AI Agent does not exist");
        return aiAgents[_agentId];
    }

    // --- III. Generative Content Requests & Fulfillment ---

    /**
     * @dev Initiates a generation request by committing to a hashed prompt.
     * This is the first step of a commit-reveal scheme to prevent front-running prompts.
     * Requires a nominal request fee (e.g., to cover gas for future interactions or discourage spam).
     * @param _promptHash Keccak256 hash of the prompt and parameters.
     * @return The ID of the newly created generation request.
     */
    function submitGenerationRequestCommitment(bytes32 _promptHash) external payable whenNotPaused returns (uint256) {
        // Example: require a small fee for commitment, potentially refundable on reveal or fulfilment.
        // For simplicity, let's say the fee is kept by the platform or used for incentives.
        require(msg.value >= 0.001 ether, "Insufficient request commitment fee"); // Example fee

        _generationRequestIdCounter.increment();
        uint256 requestId = _generationRequestIdCounter.current();

        generationRequests[requestId] = GenerationRequest({
            requestId: requestId,
            requestor: msg.sender,
            promptHash: _promptHash,
            prompt: "", // Will be revealed later
            params: "", // Will be revealed later
            isRevealed: false,
            isFulfilled: false,
            fulfillmentContentId: 0,
            accumulatedRoyalties: 0,
            timestamp: block.timestamp
        });

        emit GenerationRequestCommitted(requestId, msg.sender, _promptHash);
        return requestId;
    }

    /**
     * @dev Reveals the actual prompt and parameters for a committed request.
     * Verifies the prompt against the stored hash. Only callable by the original requestor.
     * @param _requestId The ID of the generation request.
     * @param _prompt The actual text prompt.
     * @param _params Additional generation parameters (e.g., "style: photorealistic, size: 1024x1024").
     */
    function revealGenerationRequest(
        uint256 _requestId,
        string memory _prompt,
        string memory _params
    ) external whenNotPaused {
        GenerationRequest storage req = generationRequests[_requestId];
        require(req.requestor == msg.sender, "Not the requestor of this ID");
        require(req.requestId != 0, "Request does not exist");
        require(!req.isRevealed, "Prompt already revealed");
        require(
            req.promptHash == keccak256(abi.encodePacked(_prompt, _params)),
            "Prompt hash mismatch"
        );

        req.prompt = _prompt;
        req.params = _params;
        req.isRevealed = true;

        emit GenerationRequestRevealed(_requestId, _prompt, _params);
    }

    /**
     * @dev Fulfills a generation request by submitting the generated content.
     * Only callable by an active AI Agent that owns the agentId, or a trusted oracle relaying on its behalf.
     * Mints a `GeneratedContentNFT`.
     * @param _requestId The ID of the generation request.
     * @param _agentId The ID of the AI Agent that generated the content.
     * @param _contentIPFSLink IPFS CID or link to the actual generated content (e.g., image, text file).
     * @param _generatedMetadataIPFSLink IPFS CID or link to content-specific metadata.
     * @return The ID of the newly minted GeneratedContentNFT.
     */
    function fulfillGenerationRequest(
        uint256 _requestId,
        uint256 _agentId,
        string memory _contentIPFSLink,
        string memory _generatedMetadataIPFSLink
    ) external whenNotPaused nonReentrant returns (uint256) {
        GenerationRequest storage req = generationRequests[_requestId];
        require(req.requestId != 0, "Request does not exist");
        require(req.isRevealed, "Prompt not yet revealed");
        require(!req.isFulfilled, "Request already fulfilled");

        AIAgent storage agent = aiAgents[_agentId];
        require(agent.agentId != 0, "AI Agent does not exist");
        require(agent.isActive, "AI Agent is inactive");

        // Ensure the caller is either the agent owner or a trusted oracle that is relaying for an agent
        require(msg.sender == agent.owner || trustedOracles[msg.sender], "Unauthorized caller for fulfillment");


        _generatedContentIdCounter.increment();
        uint256 contentId = _generatedContentIdCounter.current();
        uint256 tokenId = _nextTokenId.current();
        _nextTokenId.increment();

        generatedContent[contentId] = GeneratedContent({
            contentId: contentId,
            requestId: _requestId,
            agentId: _agentId,
            owner: agent.owner, // Owner of content NFT is the agent's owner
            requestor: req.requestor,
            contentIPFSLink: _contentIPFSLink,
            generatedMetadataIPFSLink: _generatedMetadataIPFSLink,
            isApproved: false, // Must be approved by oracle to be licensable
            licenseCount: 0,
            accumulatedRoyalties: 0,
            timestamp: block.timestamp
        });

        req.isFulfilled = true;
        req.fulfillmentContentId = contentId;

        _mint(agent.owner, tokenId); // Mint NFT to the AI Agent owner
        _setTokenURI(tokenId, string(abi.encodePacked("ipfs://", _generatedMetadataIPFSLink, "/content_metadata")));
        isGeneratedContentToken[tokenId] = true;

        emit ContentGenerated(contentId, _requestId, _agentId, _contentIPFSLink);
        return contentId;
    }

    /**
     * @dev Verifies generated content. Only callable by a `TrustedOracle`.
     * Approval makes the content licensable and impacts the fulfilling AI Agent's reputation.
     * @param _contentId The ID of the generated content.
     * @param _isApproved True to approve, false to reject.
     */
    function verifyGeneratedContent(uint256 _contentId, bool _isApproved) external whenNotPaused {
        require(trustedOracles[msg.sender], "Only trusted oracles can verify content");

        GeneratedContent storage content = generatedContent[_contentId];
        require(content.contentId != 0, "Content does not exist");
        require(!content.isApproved, "Content already approved or rejected"); // Can only verify once

        AIAgent storage agent = aiAgents[content.agentId];

        content.isApproved = _isApproved;

        if (_isApproved) {
            agent.reputation += REPUTATION_APPROVAL_BOOST;
            if (agent.reputation > MAX_REPUTATION_SCORE) agent.reputation = MAX_REPUTATION_SCORE;
        } else {
            agent.reputation -= REPUTATION_REJECTION_PENALTY;
            if (agent.reputation < 0) agent.reputation = 0; // Reputation can't go negative
        }

        emit ContentVerified(_contentId, _isApproved);
    }

    // --- IV. Generated Content Licensing & Monetization ---

    /**
     * @dev Allows users to purchase a license for approved generated content.
     * The price is dynamically calculated at the time of purchase.
     * @param _contentId The ID of the generated content to license.
     */
    function purchaseContentLicense(uint256 _contentId) external payable whenNotPaused nonReentrant {
        GeneratedContent storage content = generatedContent[_contentId];
        require(content.contentId != 0, "Content does not exist");
        require(content.isApproved, "Content is not yet approved for licensing");

        uint256 currentPrice = getCurrentContentLicensePrice(_contentId);
        require(msg.value >= currentPrice, "Insufficient funds to purchase license");

        content.licenseCount++; // Increase popularity
        content.accumulatedRoyalties += currentPrice;

        // Distribute royalties immediately
        uint256 platformShare = (currentPrice * platformFeePercentage) / BASIS_POINTS_DENOMINATOR;
        uint256 remainingFunds = currentPrice - platformShare;

        uint256 requestorShare = (remainingFunds * REQUESTOR_ROYALTY_SHARE_BPS) / BASIS_POINTS_DENOMINATOR;
        uint256 agentShare = remainingFunds - requestorShare;

        // Update accumulated royalties for direct withdrawal by agent/requestor
        aiAgents[content.agentId].accumulatedRoyalties += agentShare;
        generationRequests[content.requestId].accumulatedRoyalties += requestorShare;

        // Any excess payment is considered a tip to the platform (or could be refunded)
        if (msg.value > currentPrice) {
            platformShare += (msg.value - currentPrice);
        }

        (bool success, ) = payable(platformFeeRecipient).call{value: platformShare}("");
        require(success, "Failed to send platform fees");

        emit ContentLicensed(_contentId, msg.sender, currentPrice);
    }

    /**
     * @dev Calculates and returns the current dynamic price for licensing a specific content.
     * Factors in agent base price, agent reputation, and content popularity.
     * @param _contentId The ID of the generated content.
     * @return The dynamic license price in wei.
     */
    function getCurrentContentLicensePrice(uint256 _contentId) public view returns (uint256) {
        GeneratedContent storage content = generatedContent[_contentId];
        require(content.contentId != 0, "Content does not exist");
        require(content.isApproved, "Content is not approved for licensing");

        AIAgent storage agent = aiAgents[content.agentId];
        require(agent.agentId != 0, "Associated AI Agent does not exist");
        require(agent.basePrice > 0, "AI Agent has no base price set");

        uint256 basePrice = agent.basePrice;

        // Reputation factor: (reputation / MAX_REPUTATION_SCORE) + 1 (e.g., 0-1 multiplier)
        uint256 reputationMultiplier = (uint256(agent.reputation) * 10000) / MAX_REPUTATION_SCORE; // Scale to BPS
        reputationMultiplier = reputationMultiplier + BASIS_POINTS_DENOMINATOR; // Add 1x base

        // Popularity factor: (licenseCount / MAX_POPULARITY_SCORE) + 1
        uint256 popularityMultiplier = (content.licenseCount * 10000) / MAX_POPULARITY_SCORE;
        popularityMultiplier = popularityMultiplier + BASIS_POINTS_DENOMINATOR;

        // Price = BasePrice * (1 + Reputation_Adjust) * (1 + Popularity_Adjust)
        // Simplified: price = basePrice * (reputationMultiplier / BPS) * (popularityMultiplier / BPS)
        // To avoid floating point, calculate as: (basePrice * reputationMultiplier * popularityMultiplier) / (BPS * BPS)
        uint256 dynamicPrice = (basePrice * reputationMultiplier * popularityMultiplier) / (BASIS_POINTS_DENOMINATOR * BASIS_POINTS_DENOMINATOR);

        if (dynamicPrice == 0) return basePrice; // Fallback to base price if calculation yields 0

        return dynamicPrice;
    }

    /**
     * @dev Allows the owner of an AI Agent to withdraw their accumulated royalty share.
     * @param _agentId The ID of the AI Agent.
     */
    function withdrawAgentRoyalties(uint256 _agentId) external nonReentrant {
        AIAgent storage agent = aiAgents[_agentId];
        require(agent.owner == msg.sender, "Not the agent owner");
        require(agent.agentId != 0, "AI Agent does not exist");
        require(agent.accumulatedRoyalties > 0, "No royalties to withdraw");

        uint256 amount = agent.accumulatedRoyalties;
        agent.accumulatedRoyalties = 0; // Reset accumulated royalties

        (bool success, ) = payable(agent.owner).call{value: amount}("");
        require(success, "Failed to withdraw agent royalties");

        emit AIAgentRoyaltiesWithdrawn(_agentId, agent.owner, amount);
    }

    /**
     * @dev Allows the original requestor of a piece of content to withdraw their share of royalties.
     * @param _requestId The ID of the generation request.
     */
    function withdrawRequestorEarnings(uint256 _requestId) external nonReentrant {
        GenerationRequest storage req = generationRequests[_requestId];
        require(req.requestor == msg.sender, "Not the requestor");
        require(req.requestId != 0, "Request does not exist");
        require(req.accumulatedRoyalties > 0, "No earnings to withdraw");

        uint256 amount = req.accumulatedRoyalties;
        req.accumulatedRoyalties = 0; // Reset accumulated royalties

        (bool success, ) = payable(req.requestor).call{value: amount}("");
        require(success, "Failed to withdraw requestor earnings");

        emit RequestorEarningsWithdrawn(_requestId, req.requestor, amount);
    }

    // --- V. Reputation and Analytics ---

    /**
     * @dev Returns the current reputation score of an AI Agent.
     * @param _agentId The ID of the AI Agent.
     * @return The current reputation score.
     */
    function getAIAgentReputation(uint256 _agentId) public view returns (int256) {
        require(aiAgents[_agentId].agentId != 0, "AI Agent does not exist");
        return aiAgents[_agentId].reputation;
    }

    /**
     * @dev Provides a metric of content popularity based on the number of times it has been licensed.
     * @param _contentId The ID of the generated content.
     * @return The number of licenses purchased for this content.
     */
    function getContentPopularityScore(uint256 _contentId) public view returns (uint256) {
        require(generatedContent[_contentId].contentId != 0, "Content does not exist");
        return generatedContent[_contentId].licenseCount;
    }

    // --- Internal / Helper Functions for ERC721 Token Management ---

    /**
     * @dev Override for ERC721's _beforeTokenTransfer to handle pausing.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal override(ERC721) {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        // Only allow transfer of agent NFTs, not content NFTs, as content NFTs are tied to specific logic
        // For simplicity, let's assume content NFTs are not transferable after minting.
        // A more complex system might allow secondary markets for content licenses, but it's out of scope here.
        require(!isGeneratedContentToken[tokenId] || from == address(0), "Generated Content NFTs are non-transferable");
        // Pause also impacts basic NFT transfers
        if (from != address(0) && to != address(0)) { // Not minting/burning
            _requireNotPaused();
        }
    }

    /**
     * @dev Internal helper to get the tokenId for a given AIAgent ID.
     * In this conceptual setup, agentId and contentId are the internal logical IDs.
     * The actual ERC721 tokenId could be a global counter. This method helps map.
     * A more robust system would map logical IDs to ERC721 token IDs.
     * For simplicity here, _aiAgentIdCounter.current() and _generatedContentIdCounter.current() are the tokenIDs.
     * For a single ERC721 contract managing two types, we need a consistent way to assign and retrieve token IDs.
     * This implementation assumes the `agentId` and `contentId` directly correspond to the ERC721 `tokenId`s.
     * This is a simplification; a production environment would manage token IDs more explicitly (e.g., separate ID ranges).
     */
    function _getAIAgentTokenId(uint256 _agentId) internal view returns (uint256) {
        // This is a placeholder. In a real system with mixed NFTs in one contract,
        // you'd have a mapping like `agentIdToTokenId` and `contentIdToTokenId`.
        // For the purpose of this example, we assume agentId == tokenId for agents for simplicity of lookup.
        // The ERC721 `ownerOf` function would be the authoritative source.
        return _agentId; // Simplistic direct mapping
    }

    function _getGeneratedContentTokenId(uint256 _contentId) internal view returns (uint256) {
        // Same as above, for simplicity.
        return _contentId; // Simplistic direct mapping
    }

    // The ERC721 token IDs here are assigned sequentially by `_nextTokenId`.
    // The `_aiAgentIdCounter` and `_generatedContentIdCounter` are for logical IDs.
    // Need a way to map logical IDs (agentId, contentId) to their assigned ERC721 tokenId.

    // A more proper way to manage mixed types of NFTs in one ERC721 contract:
    // mapping(uint256 => uint256) private _logicalAgentIdToTokenId;
    // mapping(uint256 => uint256) private _logicalContentIdToTokenId;
    // mapping(uint256 => uint256) private _tokenIdToLogicalAgentId;
    // mapping(uint256 => uint256) private _tokenIdToLogicalContentId;

    // For the current implementation, I will assume the `agentId` and `contentId` are the actual `tokenId`s.
    // This simplifies the example but is a deviation from a perfect ERC721 implementation of two *distinct* collections
    // within a single contract. It treats the contract as a single ERC721 collection that *contains* agents and content.
    // The `isAIAgentToken` and `isGeneratedContentToken` mappings serve to distinguish the types.
}
```