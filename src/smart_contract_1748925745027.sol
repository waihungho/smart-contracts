Okay, here is a Solidity smart contract incorporating several interesting, advanced, creative, and trendy concepts centered around *evolving NFTs within a managed ecosystem*. It goes beyond standard ERC721 by giving NFTs dynamic states and enabling complex interactions that affect their properties on-chain.

It includes features like:
*   **Dynamic NFT State:** NFTs have properties that change over time or based on actions.
*   **On-Chain Evolution:** NFTs can evolve through defined stages based on criteria like time and interaction.
*   **Ecosystem Interaction:** A global contract state ("Ecosystem") influences NFTs and can be influenced by privileged roles.
*   **User Nurturing:** Owners can perform actions to boost their NFT's state.
*   **Structured Interactions:**
    *   **Pairing:** Two NFTs can be formally paired (requiring owner consent) to potentially trigger combined effects.
    *   **Trait Exchange Proposals:** Owners can propose swapping specific *numerical* trait/stat values with another NFT owner, requiring acceptance.
*   **Role-Based Access Control:** Different levels of administrative control over ecosystem parameters.
*   **Pausable State:** Ability to pause certain dynamic processes.
*   **On-Chain History/Simulation Hooks:** Functions to view state history summary or potentially simulate future states (though simulation is complex for a simple example).

This design aims to be a foundation for a complex digital ecosystem or game where assets are not static collectibles but living entities with programmable behaviors.

---

## Smart Contract: ChronicleEcosystem (Evolving NFTs & Interactions)

**Outline:**

1.  **Contract Overview:** ERC721 extension with dynamic NFT state, ecosystem interaction, and structured inter-NFT actions (Pairing, Trait Exchange).
2.  **State Variables:**
    *   ERC721 core mappings (`_owners`, `_balances`, `_tokenApprovals`, `_operatorApprovals`).
    *   NFT Data Mapping (`_nftData`): Stores dynamic state for each token ID.
    *   Ecosystem State Variables (`_ecosystemEnergy`, `_lastEcosystemUpdateTime`, `_evolutionParameters`, `_stimulusParameters`).
    *   Role Management (`_roles`).
    *   Pausable State (`_paused`).
    *   Minting Counter (`_nextTokenId`).
    *   Pairing Proposal Mapping (`_pairingProposals`).
    *   Pairing Proposal Counter (`_nextPairingProposalId`).
    *   Trait Exchange Proposal Mapping (`_traitExchangeProposals`).
    *   Trait Exchange Proposal Counter (`_nextTraitExchangeProposalId`).
    *   Base URI (`_baseURI`, `_tokenURIPrefix`).
3.  **Structs:**
    *   `NFTData`: Defines dynamic properties of an NFT (evolution stage, stats, last update, etc.).
    *   `PairingProposal`: Defines a proposal for pairing two NFTs.
    *   `TraitExchangeProposal`: Defines a proposal for exchanging stat values between two NFTs.
4.  **Events:** Announce key actions (Mint, Evolution, Nurture, Stimulus, Pairing/Exchange Proposals, Acceptance, Resolution, Role Changes, Pausing).
5.  **Errors:** Custom errors for clearer failure reasons.
6.  **Modifiers:** Access control (`onlyOwner`, `whenNotPaused`, `whenPaused`, `onlyEcosystemModifier`).
7.  **ERC721 Implementations:** Standard functions (`balanceOf`, `ownerOf`, `safeTransferFrom`, `transferFrom`, `approve`, `setApprovalForAll`, `getApproved`, `isApprovedForAll`, `tokenURI`, `supportsInterface`).
8.  **NFT Dynamic State & Evolution:**
    *   `_getNFTData`: Internal helper to retrieve NFT data.
    *   `getNFTState`: Public view function to retrieve NFT data.
    *   `getNFTGeneration`: View function for generation.
    *   `userNurtureNFT`: Owner action to improve NFT stats (consumes resource/fee).
    *   `triggerEvolutionCheck`: Check if NFT is eligible for evolution (read-only).
    *   `evolveNFT`: Execute NFT evolution if criteria met.
    *   `lockNFTState`: Owner locks NFT state changes.
    *   `unlockNFTState`: Owner unlocks NFT state changes.
    *   `getNFTHistorySummary`: View historical state changes (placeholder/conceptual).
9.  **Ecosystem Interaction:**
    *   `getGlobalEcosystemState`: View global state variables.
    *   `applyExternalStimulusToNFT`: Apply influence from external factors (requires roles).
    *   `collectResourceFromNFT`: Owner claims resources generated by NFT (placeholder).
10. **Ecosystem Management (Roles):**
    *   `updateEcosystemParameters`: Modify global influence parameters (requires roles).
    *   `addEcosystemModifierRole`: Grant role.
    *   `removeEcosystemModifierRole`: Revoke role.
    *   `hasEcosystemModifierRole`: Check role status.
11. **Structured Interactions (Pairing):**
    *   `proposePairing`: Initiate pairing proposal between two tokens.
    *   `acceptPairing`: Second owner accepts pairing proposal.
    *   `cancelPairingProposal`: Proposer cancels proposal.
    *   `rejectPairingProposal`: Target owner rejects proposal.
    *   `resolvePairingInteraction`: Execute effects of an accepted pairing.
    *   `getPendingPairingProposal`: View a specific proposal's details.
    *   `getActivePairings`: View currently accepted pairings (placeholder for tracking).
12. **Structured Interactions (Trait Exchange):**
    *   `proposeTraitExchange`: Propose swapping specific stat values between two tokens.
    *   `acceptTraitExchange`: Second owner accepts trait exchange proposal.
    *   `cancelTraitExchangeProposal`: Proposer cancels trait exchange proposal.
    *   `rejectTraitExchange`: Target owner rejects trait exchange proposal.
    *   `getTraitExchangeProposal`: View a specific trait exchange proposal's details.
    *   `resolveTraitExchange`: Execute the stat value swap for an accepted proposal.
13. **Admin & Utility:**
    *   `mint`: Create new NFTs (only owner).
    *   `pauseEvolution`: Pause dynamic changes (requires roles).
    *   `unpauseEvolution`: Unpause dynamic changes (requires roles).
    *   `setBaseURI`: Set base URI for metadata (only owner).
    *   `setTokenURIPrefix`: Set prefix for metadata (only owner).
    *   `transferOwnership`: Standard Ownable.
    *   `renounceOwnership`: Standard Ownable.

**Function Summary:**

*   `constructor(string memory name, string memory symbol)`: Initializes the contract, ERC721, Ownable, Pausable, and AccessControl. Grants deployer the `DEFAULT_ADMIN_ROLE` and `ECOSYSTEM_MODIFIER_ROLE`.
*   `balanceOf(address owner) view returns (uint256)`: Returns the number of tokens owned by an address (ERC721 standard).
*   `ownerOf(uint256 tokenId) view returns (address)`: Returns the owner of a token ID (ERC721 standard).
*   `safeTransferFrom(address from, address to, uint256 tokenId)`: Safely transfers token ownership (ERC721 standard).
*   `safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)`: Safely transfers token ownership with data (ERC721 standard).
*   `transferFrom(address from, address to, uint256 tokenId)`: Transfers token ownership (ERC721 standard).
*   `approve(address to, uint256 tokenId)`: Approves an address to transfer a token (ERC721 standard).
*   `setApprovalForAll(address operator, bool approved)`: Approves/unapproves an operator for all owner's tokens (ERC721 standard).
*   `getApproved(uint256 tokenId) view returns (address)`: Gets the approved address for a token (ERC721 standard).
*   `isApprovedForAll(address owner, address operator) view returns (bool)`: Checks if an operator is approved for an owner (ERC721 standard).
*   `tokenURI(uint256 tokenId) view returns (string memory)`: Returns the metadata URI for a token (ERC721 standard).
*   `supportsInterface(bytes4 interfaceId) view returns (bool)`: Standard interface detection (ERC165 standard).
*   `mint(address to)`: Mints a new NFT to an address (only owner).
*   `getNFTState(uint256 tokenId) view returns (NFTData memory)`: Retrieves the dynamic state of an NFT.
*   `getNFTGeneration(uint256 tokenId) view returns (uint256)`: Retrieves the generation of an NFT.
*   `userNurtureNFT(uint256 tokenId)`: Allows the owner to nurture their NFT, potentially boosting stats (requires `whenNotPaused`).
*   `triggerEvolutionCheck(uint256 tokenId) view returns (bool canEvolve)`: Checks if an NFT meets the criteria to evolve (read-only, requires `whenNotPaused`).
*   `evolveNFT(uint256 tokenId)`: Executes the evolution process for an eligible NFT (requires `whenNotPaused`).
*   `lockNFTState(uint256 tokenId)`: Allows the owner to prevent their NFT's state from changing dynamically (requires `whenNotPaused`).
*   `unlockNFTState(uint256 tokenId)`: Allows the owner to re-enable dynamic state changes for their NFT.
*   `getNFTHistorySummary(uint256 tokenId) view returns (string memory)`: Placeholder for retrieving a summary of past state changes.
*   `getGlobalEcosystemState() view returns (uint256 ecosystemEnergy, uint256 lastUpdateTime)`: Retrieves the current state of the contract's global ecosystem parameters.
*   `applyExternalStimulusToNFT(uint256 tokenId, bytes memory stimulusData)`: Applies an external influence to an NFT, affecting its state (requires `onlyEcosystemModifier`, `whenNotPaused`). `stimulusData` allows for variable external effects.
*   `collectResourceFromNFT(uint256 tokenId)`: Placeholder for allowing owners to claim resources generated by their NFT.
*   `updateEcosystemParameters(uint256 newEnergy, uint256 newEvolutionThreshold, uint256 newStimulusMultiplier)`: Updates global parameters influencing evolution and stimulus effects (requires `onlyEcosystemModifier`).
*   `addEcosystemModifierRole(address account)`: Grants the Ecosystem Modifier role to an address (requires `DEFAULT_ADMIN_ROLE`).
*   `removeEcosystemModifierRole(address account)`: Revokes the Ecosystem Modifier role from an address (requires `DEFAULT_ADMIN_ROLE`).
*   `hasEcosystemModifierRole(address account) view returns (bool)`: Checks if an address has the Ecosystem Modifier role.
*   `proposePairing(uint256 tokenAId, uint256 tokenBId)`: Initiates a pairing proposal between two NFTs (requires `whenNotPaused`).
*   `acceptPairing(uint256 proposalId)`: The owner of the target NFT (token B) accepts a pairing proposal (requires `whenNotPaused`).
*   `cancelPairingProposal(uint256 proposalId)`: The initiator (owner of token A) cancels their pairing proposal.
*   `rejectPairingProposal(uint256 proposalId)`: The target owner (owner of token B) rejects a pairing proposal.
*   `resolvePairingInteraction(uint256 proposalId)`: Executes the effects of an accepted pairing proposal (requires `whenNotPaused`).
*   `getPendingPairingProposal(uint256 proposalId) view returns (PairingProposal memory)`: Retrieves details of a specific pairing proposal.
*   `getActivePairings() view returns (uint256[] memory)`: Placeholder for retrieving a list of currently active/resolved pairings (conceptual).
*   `proposeTraitExchange(uint256 tokenAId, uint256 tokenBId, StatType statTypeA, uint256 valueA, StatType statTypeB, uint256 valueB)`: Initiates a proposal to swap specific stat values between two NFTs (requires `whenNotPaused`).
*   `acceptTraitExchange(uint256 proposalId)`: The owner of the target NFT (token B) accepts a trait exchange proposal (requires `whenNotPaused`).
*   `cancelTraitExchangeProposal(uint256 proposalId)`: The initiator (owner of token A) cancels their trait exchange proposal.
*   `rejectTraitExchange(uint256 proposalId)`: The target owner (owner of token B) rejects a trait exchange proposal.
*   `getTraitExchangeProposal(uint256 proposalId) view returns (TraitExchangeProposal memory)`: Retrieves details of a specific trait exchange proposal.
*   `resolveTraitExchange(uint256 proposalId)`: Executes the stat value swap for an accepted trait exchange proposal (requires `whenNotPaused`).
*   `pauseEvolution()`: Pauses dynamic NFT processes (evolution, nurturing, interactions) (requires `onlyEcosystemModifier`).
*   `unpauseEvolution()`: Unpauses dynamic NFT processes (requires `onlyEcosystemModifier`).
*   `setBaseURI(string memory baseURI)`: Sets the base URI for all token metadata (only owner).
*   `setTokenURIPrefix(string memory prefix)`: Sets a prefix to be added before the token ID in the URI (only owner).
*   `transferOwnership(address newOwner)`: Transfers contract ownership (Ownable standard).
*   `renounceOwnership()`: Renounces contract ownership (Ownable standard).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

// --- Smart Contract: ChronicleEcosystem (Evolving NFTs & Interactions) ---

// Outline:
// 1. Contract Overview: ERC721 extension with dynamic NFT state, ecosystem interaction, and structured inter-NFT actions (Pairing, Trait Exchange).
// 2. State Variables: ERC721 core, NFT Dynamic Data (_nftData), Ecosystem State, Roles, Pausable, Counters, Proposals, URIs.
// 3. Structs: NFTData, PairingProposal, TraitExchangeProposal.
// 4. Events: Announce state changes and interactions.
// 5. Errors: Custom errors for clarity.
// 6. Modifiers: Access control and pausable state checks.
// 7. ERC721 Implementations: Standard ERC721 functions.
// 8. NFT Dynamic State & Evolution: Functions to read, update, and trigger evolution of NFT properties.
// 9. Ecosystem Interaction: Functions for global state influence and resource collection.
// 10. Ecosystem Management (Roles): Functions to manage addresses with special ecosystem modification privileges.
// 11. Structured Interactions (Pairing): Functions for proposing, accepting, rejecting, canceling, and resolving NFT pairings.
// 12. Structured Interactions (Trait Exchange): Functions for proposing, accepting, rejecting, canceling, and resolving swapping stat values between NFTs.
// 13. Admin & Utility: Minting, Pausing, URI management, Ownership.

// Function Summary:
// - constructor(string memory name, string memory symbol): Initializes contract, roles.
// - balanceOf(address owner) view: ERC721 standard.
// - ownerOf(uint256 tokenId) view: ERC721 standard.
// - safeTransferFrom(address from, address to, uint256 tokenId) / (..., bytes memory data): ERC721 standard.
// - transferFrom(address from, address to, uint256 tokenId): ERC721 standard.
// - approve(address to, uint256 tokenId): ERC721 standard.
// - setApprovalForAll(address operator, bool approved): ERC721 standard.
// - getApproved(uint256 tokenId) view: ERC721 standard.
// - isApprovedForAll(address owner, address operator) view: ERC721 standard.
// - tokenURI(uint256 tokenId) view: ERC721 standard with dynamic prefix/base.
// - supportsInterface(bytes4 interfaceId) view: ERC165 standard.
// - mint(address to): Mints a new NFT (only owner).
// - getNFTState(uint256 tokenId) view: Retrieves dynamic NFT data.
// - getNFTGeneration(uint256 tokenId) view: Retrieves NFT generation.
// - userNurtureNFT(uint256 tokenId): Owner action to boost NFT stats (whenNotPaused).
// - triggerEvolutionCheck(uint256 tokenId) view: Checks evolution eligibility (whenNotPaused).
// - evolveNFT(uint256 tokenId): Executes evolution if eligible (whenNotPaused).
// - lockNFTState(uint256 tokenId): Owner locks NFT dynamic state (whenNotPaused).
// - unlockNFTState(uint256 tokenId): Owner unlocks NFT dynamic state.
// - getNFTHistorySummary(uint256 tokenId) view: Placeholder for historical state summary.
// - getGlobalEcosystemState() view: Retrieves global ecosystem parameters.
// - applyExternalStimulusToNFT(uint256 tokenId, bytes memory stimulusData): Applies external influence (onlyEcosystemModifier, whenNotPaused).
// - collectResourceFromNFT(uint256 tokenId): Placeholder for resource claim.
// - updateEcosystemParameters(uint256 newEnergy, uint256 newEvolutionThreshold, uint256 newStimulusMultiplier): Updates ecosystem parameters (onlyEcosystemModifier).
// - addEcosystemModifierRole(address account): Grants Ecosystem Modifier role (DEFAULT_ADMIN_ROLE).
// - removeEcosystemModifierRole(address account): Revokes Ecosystem Modifier role (DEFAULT_ADMIN_ROLE).
// - hasEcosystemModifierRole(address account) view: Checks Ecosystem Modifier role.
// - proposePairing(uint256 tokenAId, uint256 tokenBId): Initiates pairing proposal (whenNotPaused).
// - acceptPairing(uint256 proposalId): Target owner accepts pairing (whenNotPaused).
// - cancelPairingProposal(uint256 proposalId): Proposer cancels pairing.
// - rejectPairingProposal(uint256 proposalId): Target owner rejects pairing.
// - resolvePairingInteraction(uint256 proposalId): Executes accepted pairing effects (whenNotPaused).
// - getPendingPairingProposal(uint256 proposalId) view: Retrieves pairing proposal details.
// - getActivePairings() view: Placeholder for active/resolved pairings list.
// - proposeTraitExchange(uint256 tokenAId, uint256 tokenBId, StatType statTypeA, uint256 valueA, StatType statTypeB, uint256 valueB): Initiates trait exchange proposal (whenNotPaused).
// - acceptTraitExchange(uint256 proposalId): Target owner accepts trait exchange (whenNotPaused).
// - cancelTraitExchangeProposal(uint256 proposalId): Proposer cancels trait exchange.
// - rejectTraitExchange(uint256 proposalId): Target owner rejects trait exchange.
// - getTraitExchangeProposal(uint256 proposalId) view: Retrieves trait exchange proposal details.
// - resolveTraitExchange(uint256 proposalId): Executes accepted trait exchange (whenNotPaused).
// - pauseEvolution(): Pauses dynamic processes (onlyEcosystemModifier).
// - unpauseEvolution(): Unpauses dynamic processes (onlyEcosystemModifier).
// - setBaseURI(string memory baseURI): Sets metadata base URI (only owner).
// - setTokenURIPrefix(string memory prefix): Sets metadata URI prefix (only owner).
// - transferOwnership(address newOwner): Ownable standard.
// - renounceOwnership(): Ownable standard.

contract ChronicleEcosystem is ERC721, Ownable, Pausable, AccessControl {
    using Counters for Counters.Counter;
    using Strings for uint256;

    // --- State Variables ---

    // ERC721 Core (Handled by inherited ERC721)
    // mapping(uint256 => address) private _owners;
    // mapping(address => uint256) private _balances;
    // mapping(uint256 => address) private _tokenApprovals;
    // mapping(address => mapping(address => bool)) private _operatorApprovals;

    // NFT Dynamic Data
    struct NFTData {
        uint256 creationTime;
        uint256 lastUpdateTime;
        uint256 evolutionStage; // e.g., 0=Seed, 1=Sprout, 2=Bloom, etc.
        uint256 generation;     // e.g., Gen 1, Gen 2 (for breeding concepts, though not fully implemented here)
        uint256 energy;         // Resource/stat influencing evolution/actions
        uint256 vitality;       // Another stat
        uint256 resilience;     // Another stat
        bool lockedState;       // If true, dynamic changes (evolution, stimulus) are paused for this specific NFT
        // Add more dynamic traits here
    }

    mapping(uint256 => NFTData) private _nftData;
    Counters.Counter private _nextTokenId;

    // Ecosystem State Parameters
    uint256 public _ecosystemEnergy; // Global resource/state influencing NFTs
    uint256 public _lastEcosystemUpdateTime;
    uint256 public _evolutionThresholdEnergy = 100; // Energy needed for evolution
    uint256 public _evolutionTimeThreshold = 7 days; // Time needed between evolutions
    uint256 public _nurtureEnergyCost = 10;
    uint256 public _nurtureVitalityGain = 15;
    uint256 public _stimulusMultiplier = 1; // Factor for stimulus effects

    // Role Management (Using AccessControl)
    bytes32 public constant ECOSYSTEM_MODIFIER_ROLE = keccak256("ECOSYSTEM_MODIFIER_ROLE");

    // Pausable State (Handled by inherited Pausable)
    // bool private _paused;

    // Structured Interactions: Pairing
    struct PairingProposal {
        uint256 proposalId;
        uint256 tokenAId; // Initiator's token
        address tokenAOwnder;
        uint256 tokenBId; // Target token
        address tokenBOwner;
        uint64 proposalTime;
        bool acceptedByB; // True if token B owner has accepted
        bool resolved;    // True if effects have been applied
        // Maybe add an expiry time?
    }
    mapping(uint256 => PairingProposal) private _pairingProposals;
    Counters.Counter private _nextPairingProposalId;

    // Structured Interactions: Trait Exchange
    enum StatType { Energy, Vitality, Resilience } // Define which stats can be exchanged

    struct TraitExchangeProposal {
        uint256 proposalId;
        uint256 tokenAId;
        address tokenAOwnder;
        uint256 tokenBId;
        address tokenBOwner;
        StatType statTypeA; // Stat type on Token A to potentially swap
        uint256 valueA;     // Proposed value *from* Token A (what A wants to give)
        StatType statTypeB; // Stat type on Token B to potentially swap
        uint256 valueB;     // Proposed value *from* Token B (what B wants to give)
        uint64 proposalTime;
        bool acceptedByB; // True if token B owner has accepted
        bool resolved;    // True if effects have been applied
        // Add expiry time?
    }
    mapping(uint256 => TraitExchangeProposal) private _traitExchangeProposals;
    Counters.Counter private _nextTraitExchangeProposalId;


    // Metadata
    string private _baseURI;
    string private _tokenURIPrefix = "ipfs://"; // Common prefix, adjustable

    // --- Events ---
    event NFTMinted(uint256 indexed tokenId, address indexed owner);
    event NFTNurtured(uint256 indexed tokenId, address indexed owner, uint256 energySpent, uint256 vitalityGained);
    event NFTEvolutionTriggered(uint256 indexed tokenId, uint256 oldStage, uint256 newStage);
    event ExternalStimulusApplied(uint256 indexed tokenId, bytes stimulusData, uint256 effectMagnitude);
    event EcosystemParametersUpdated(uint256 newEnergy, uint256 newEvolutionThreshold, uint256 newStimulusMultiplier);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    event PairingProposed(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address proposer, address targetOwner);
    event PairingAccepted(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address accepter);
    event PairingRejected(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address rejecter);
    event PairingCanceled(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address canceller);
    event PairingResolved(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId);

    event TraitExchangeProposed(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address proposer, address targetOwner, StatType statA, uint256 valueA, StatType statB, uint256 valueB);
    event TraitExchangeAccepted(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address accepter);
    event TraitExchangeRejected(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address rejecter);
    event TraitExchangeCanceled(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId, address canceller);
    event TraitExchangeResolved(uint256 indexed proposalId, uint256 indexed tokenAId, uint256 indexed tokenBId);

    event NFTStateLocked(uint256 indexed tokenId, address indexed owner);
    event NFTStateUnlocked(uint256 indexed tokenId, address indexed owner);


    // --- Errors ---
    error TokenDoesNotExist(uint256 tokenId);
    error NotTokenOwner(uint256 tokenId);
    error EvolutionNotReady(uint256 tokenId);
    error NFTStateIsLocked(uint256 tokenId);
    error NFTStateIsNotLocked(uint256 tokenId);
    error InvalidProposalId(uint256 proposalId);
    error ProposalAlreadyAccepted(uint256 proposalId);
    error ProposalAlreadyResolved(uint256 proposalId);
    error ProposalNotAccepted(uint256 proposalId);
    error NotProposalParticipant(uint256 proposalId);
    error NotPairingProposer(uint256 proposalId);
    error NotPairingTargetOwner(uint256 proposalId);
    error NotTraitExchangeProposer(uint256 proposalId);
    error NotTraitExchangeTargetOwner(uint256 proposalId);
    error SameTokenInProposal(uint256 tokenId);
    error ProposalExpired(uint256 proposalId); // Conceptual, would need time limits
    error InvalidStatType();


    // --- Modifiers ---
    modifier onlyEcosystemModifier() {
        _checkRole(ECOSYSTEM_MODIFIER_ROLE);
        _;
    }

    // --- Constructor ---
    constructor(string memory name, string memory symbol)
        ERC721(name, symbol)
        Ownable(msg.sender)
        Pausable() // Pausable initialized by default state
    {
        // Grant roles to the deployer
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(ECOSYSTEM_MODIFIER_ROLE, msg.sender);

        // Initial ecosystem state
        _ecosystemEnergy = 1000;
        _lastEcosystemUpdateTime = block.timestamp;

        // Emit role events for initial setup
        emit RoleGranted(DEFAULT_ADMIN_ROLE, msg.sender, msg.sender);
        emit RoleGranted(ECOSYSTEM_MODIFIER_ROLE, msg.sender, msg.sender);
    }

    // --- ERC721 Standard Functions (Overrides) ---

    // Override is necessary to add Pausable checks to transfers
    function safeTransferFrom(address from, address to, uint256 tokenId) public override whenNotPaused {
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public override whenNotPaused {
        super.safeTransferFrom(from, to, tokenId, data);
    }

    function transferFrom(address from, address to, uint256 tokenId) public override whenNotPaused {
        super.transferFrom(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) public override whenNotPaused {
        super.approve(to, tokenId);
    }

    function setApprovalForAll(address operator, bool approved) public override whenNotPaused {
        super.setApprovalForAll(operator, approved);
    }

    // tokenURI override to use baseURI and prefix
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (!_exists(tokenId)) {
             revert ERC721NonexistentToken(tokenId);
        }
        // Assuming metadata follows standard pattern: baseURI + tokenId + .json or similar
        // This implementation uses a prefix + tokenId as a simple example
        return string(abi.encodePacked(_tokenURIPrefix, tokenId.toString()));
    }

    // ERC165 interface support (Adds AccessControl, Ownable, Pausable)
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, AccessControl) returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId ||
               interfaceId == type(IOwnable).interfaceId ||
               interfaceId == type(IPausable).interfaceId ||
               super.supportsInterface(interfaceId);
    }

    // --- Internal Helper ---
    function _getNFTData(uint256 tokenId) internal view returns (NFTData storage) {
        if (!_exists(tokenId)) {
            revert TokenDoesNotExist(tokenId);
        }
        return _nftData[tokenId];
    }

    // --- Admin & Utility Functions ---

    /// @notice Mints a new NFT. Only callable by the contract owner.
    /// @param to The address to mint the new token to.
    function mint(address to) public onlyOwner {
        _nextTokenId.increment();
        uint256 newItemId = _nextTokenId.current();

        // Initialize dynamic NFT data
        _nftData[newItemId] = NFTData({
            creationTime: block.timestamp,
            lastUpdateTime: block.timestamp,
            evolutionStage: 0, // Start at stage 0
            generation: 1,     // Start at generation 1
            energy: 50,
            vitality: 50,
            resilience: 50,
            lockedState: false
        });

        _safeMint(to, newItemId); // Safe mint handles existence check and transfer
        emit NFTMinted(newItemId, to);
    }

    /// @notice Sets the base URI for token metadata. Only callable by the contract owner.
    /// @param baseURI The new base URI.
    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseURI = baseURI;
    }

    /// @notice Sets the prefix for token metadata URIs (e.g., IPFS gateway). Only callable by the contract owner.
    /// @param prefix The new URI prefix.
    function setTokenURIPrefix(string memory prefix) public onlyOwner {
        _tokenURIPrefix = prefix;
    }

    /// @notice Pauses dynamic processes like evolution, nurturing, and interactions. Requires the ECOSYSTEM_MODIFIER_ROLE.
    function pauseEvolution() public onlyEcosystemModifier whenNotPaused {
        _pause();
    }

    /// @notice Unpauses dynamic processes. Requires the ECOSYSTEM_MODIFIER_ROLE.
    function unpauseEvolution() public onlyEcosystemModifier whenPaused {
        _unpause();
    }

    // Inherits transferOwnership and renounceOwnership from Ownable

    // AccessControl overrides for events (optional but good practice)
    function _setupRole(bytes32 role, address account) internal override {
        super._setupRole(role, account);
        emit RoleGranted(role, account, msg.sender);
    }

    function _revokeRole(bytes32 role, address account) internal override {
        super._revokeRole(role, account);
        emit RoleRevoked(role, account, msg.sender);
    }


    // --- NFT Dynamic State & Evolution Functions ---

    /// @notice Retrieves the dynamic state of a specific NFT.
    /// @param tokenId The ID of the NFT.
    /// @return NFTData The current dynamic state of the NFT.
    function getNFTState(uint256 tokenId) public view returns (NFTData memory) {
        return _getNFTData(tokenId);
    }

    /// @notice Retrieves the generation of a specific NFT.
    /// @param tokenId The ID of the NFT.
    /// @return uint256 The generation number of the NFT.
    function getNFTGeneration(uint256 tokenId) public view returns (uint256) {
        return _getNFTData(tokenId).generation;
    }


    /// @notice Allows the owner of an NFT to nurture it, increasing stats at a cost (e.g., requires sending native token or burning an external token, simplified here).
    /// Requires the contract not to be paused and the NFT not to be state-locked.
    /// @param tokenId The ID of the NFT to nurture.
    function userNurtureNFT(uint256 tokenId) public payable whenNotPaused {
        NFTData storage nft = _getNFTData(tokenId);

        if (ownerOf(tokenId) != msg.sender) {
            revert NotTokenOwner(tokenId);
        }
        if (nft.lockedState) {
            revert NFTStateIsLocked(tokenId);
        }

        // Simulate cost - e.g., require(msg.value >= 0.01 ether, "Requires 0.01 ETH");
        // Or interaction with an ERC20 token:
        // IERC20 externalToken = IERC20(externalTokenAddress);
        // require(externalToken.transferFrom(msg.sender, address(this), cost), "Token transfer failed");

        // Apply effects
        // Prevent overflow (basic example, would need robust checks)
        nft.energy = nft.energy + _nurtureVitalityGain > type(uint256).max ? type(uint256).max : nft.energy + _nurtureVitalityGain;
        nft.vitality = nft.vitality + _nurtureVitalityGain > type(uint256).max ? type(uint256).max : nft.vitality + _nurtureVitalityGain;
        // Decay energy? nft.energy = nft.energy < _nurtureEnergyCost ? 0 : nft.energy - _nurtureEnergyCost;

        nft.lastUpdateTime = block.timestamp;

        emit NFTNurtured(tokenId, msg.sender, _nurtureEnergyCost, _nurtureVitalityGain);
    }

    /// @notice Checks if a specific NFT meets the criteria to evolve to the next stage. Read-only function.
    /// Requires the contract not to be paused and the NFT not to be state-locked.
    /// @param tokenId The ID of the NFT to check.
    /// @return bool True if the NFT is ready to evolve, false otherwise.
    function triggerEvolutionCheck(uint256 tokenId) public view whenNotPaused returns (bool canEvolve) {
        NFTData memory nft = _getNFTData(tokenId); // Use memory for view function

        if (nft.lockedState) {
            return false; // Cannot evolve if locked
        }

        // Evolution criteria: sufficient energy AND enough time passed since last update
        // Add more complex criteria as needed (e.g., vitality, resilience, ecosystem state)
        canEvolve = (nft.energy >= _evolutionThresholdEnergy) &&
                    (block.timestamp >= nft.lastUpdateTime + _evolutionTimeThreshold);

        return canEvolve;
    }

    /// @notice Executes the evolution process for an NFT if it meets the criteria.
    /// This function updates the NFT's evolution stage and modifies its stats.
    /// Requires the contract not to be paused and the NFT not to be state-locked.
    /// @param tokenId The ID of the NFT to evolve.
    function evolveNFT(uint256 tokenId) public whenNotPaused {
        NFTData storage nft = _getNFTData(tokenId);

        if (nft.lockedState) {
            revert NFTStateIsLocked(tokenId);
        }
        if (!triggerEvolutionCheck(tokenId)) {
            revert EvolutionNotReady(tokenId);
        }

        uint256 oldStage = nft.evolutionStage;
        nft.evolutionStage++; // Increment evolution stage
        nft.lastUpdateTime = block.timestamp;

        // Apply evolution effects (example logic)
        nft.energy = nft.energy < _evolutionThresholdEnergy ? 0 : nft.energy - _evolutionThresholdEnergy; // Consume energy
        nft.vitality += 20; // Boost vitality
        nft.resilience += 5; // Boost resilience

        emit NFTEvolutionTriggered(tokenId, oldStage, nft.evolutionStage);
    }

    /// @notice Allows the owner to lock their NFT's state, preventing dynamic changes like evolution or external stimuli.
    /// Requires the contract not to be paused.
    /// @param tokenId The ID of the NFT to lock.
    function lockNFTState(uint256 tokenId) public whenNotPaused {
         if (ownerOf(tokenId) != msg.sender) {
            revert NotTokenOwner(tokenId);
        }
        NFTData storage nft = _getNFTData(tokenId);
        if (nft.lockedState) {
            revert NFTStateIsLocked(tokenId);
        }
        nft.lockedState = true;
        emit NFTStateLocked(tokenId, msg.sender);
    }

    /// @notice Allows the owner to unlock their NFT's state, re-enabling dynamic changes.
    /// @param tokenId The ID of the NFT to unlock.
    function unlockNFTState(uint256 tokenId) public {
        // This does not require whenNotPaused, as unlocking is always allowed
         if (ownerOf(tokenId) != msg.sender) {
            revert NotTokenOwner(tokenId);
        }
        NFTData storage nft = _getNFTData(tokenId);
        if (!nft.lockedState) {
            revert NFTStateIsNotLocked(tokenId);
        }
        nft.lockedState = false;
        emit NFTStateUnlocked(tokenId, msg.sender);
    }

    /// @notice Placeholder function to retrieve a summary of historical state changes for an NFT.
    /// Actual implementation would require storing historical data (e.g., in events or a separate mapping), which is complex and gas-intensive on-chain.
    /// This function demonstrates the concept but returns a simple string.
    /// @param tokenId The ID of the NFT.
    /// @return string A summary string.
    function getNFTHistorySummary(uint256 tokenId) public view returns (string memory) {
        // In a real application, this would query events or a history data structure.
        // Example: return "Evolution Stage Changes: [0->1 at T1, 1->2 at T2], Stimuli Applied: [TypeA at T3]";
        if (!_exists(tokenId)) {
             revert TokenDoesNotExist(tokenId);
        }
        return string(abi.encodePacked("History summary for token ", tokenId.toString(), " (Conceptual - Data not stored fully on-chain)"));
    }


    // --- Ecosystem Interaction Functions ---

    /// @notice Retrieves the current global ecosystem state parameters.
    /// @return uint256 ecosystemEnergy The current global ecosystem energy level.
    /// @return uint256 lastUpdateTime The timestamp of the last ecosystem parameter update.
    function getGlobalEcosystemState() public view returns (uint256 ecosystemEnergy, uint256 lastUpdateTime) {
        return (_ecosystemEnergy, _lastEcosystemUpdateTime);
    }

    /// @notice Applies an external stimulus (e.g., weather event, market shift) to a specific NFT, affecting its stats.
    /// Requires the ECOSYSTEM_MODIFIER_ROLE and the contract not to be paused, and the NFT not to be state-locked.
    /// `stimulusData` can be used to pass parameters defining the type and magnitude of the stimulus.
    /// @param tokenId The ID of the NFT to stimulate.
    /// @param stimulusData Arbitrary data describing the stimulus effect.
    function applyExternalStimulusToNFT(uint256 tokenId, bytes memory stimulusData) public onlyEcosystemModifier whenNotPaused {
        NFTData storage nft = _getNFTData(tokenId);
        if (nft.lockedState) {
            revert NFTStateIsLocked(tokenId);
        }

        uint256 effectMagnitude = 1; // Placeholder, derive magnitude from stimulusData in a real implementation

        // Example stimulus effect: reduce energy based on stimulus data and multiplier
        // In a real system, stimulusData would be parsed to determine effects on different stats
        if (stimulusData.length > 0) {
            // Simple example: Use the first byte of stimulusData to influence magnitude
            effectMagnitude = uint8(stimulusData[0]) * _stimulusMultiplier;
        }

        if (nft.energy >= effectMagnitude) {
             nft.energy -= effectMagnitude;
        } else {
             nft.energy = 0;
        }

        nft.lastUpdateTime = block.timestamp;

        emit ExternalStimulusApplied(tokenId, stimulusData, effectMagnitude);
    }

    /// @notice Placeholder function for an owner to collect resources potentially generated by their NFT or the ecosystem.
    /// Actual implementation would involve sending native tokens or interacting with an ERC20 contract.
    /// @param tokenId The ID of the NFT.
    function collectResourceFromNFT(uint256 tokenId) public {
        if (ownerOf(tokenId) != msg.sender) {
            revert NotTokenOwner(tokenId);
        }
        // Example: Calculate resource amount based on NFT state (e.g., vitality, evolution stage)
        // uint256 resourcesCollected = _nftData[tokenId].vitality / 10;
        // Transfer resources (e.g., send Ether or call ERC20.transfer)
        // require(msg.sender.sendValue(resourcesCollected), "Resource transfer failed");
        // Update NFT state, e.g., reduce vitality or energy used for resource generation
        // _nftData[tokenId].vitality = _nftData[tokenId].vitality < resourcesCollected ? 0 : _nftData[tokenId].vitality - resourcesCollected;

        // This is a conceptual function and needs a concrete resource mechanism to implement fully.
        // For now, it just checks ownership.
    }


    // --- Ecosystem Management (Roles) Functions ---

    /// @notice Updates global parameters that influence NFT evolution and stimulus effects.
    /// Requires the ECOSYSTEM_MODIFIER_ROLE.
    /// @param newEnergy New global ecosystem energy level.
    /// @param newEvolutionThreshold New energy threshold for evolution.
    /// @param newStimulusMultiplier New multiplier for external stimulus effects.
    function updateEcosystemParameters(uint256 newEnergy, uint256 newEvolutionThreshold, uint256 newStimulusMultiplier) public onlyEcosystemModifier {
        _ecosystemEnergy = newEnergy;
        _evolutionThresholdEnergy = newEvolutionThreshold;
        _stimulusMultiplier = newStimulusMultiplier;
        _lastEcosystemUpdateTime = block.timestamp;

        emit EcosystemParametersUpdated(newEnergy, newEvolutionThreshold, newStimulusMultiplier);
    }

    /// @notice Grants the ECOSYSTEM_MODIFIER_ROLE to an address. Requires the DEFAULT_ADMIN_ROLE.
    /// @param account The address to grant the role to.
    function addEcosystemModifierRole(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(ECOSYSTEM_MODIFIER_ROLE, account);
    }

    /// @notice Revokes the ECOSYSTEM_MODIFIER_ROLE from an address. Requires the DEFAULT_ADMIN_ROLE.
    /// @param account The address to revoke the role from.
    function removeEcosystemModifierRole(address account) public onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(ECOSYSTEM_MODIFIER_ROLE, account);
    }

    /// @notice Checks if an address has the ECOSYSTEM_MODIFIER_ROLE.
    /// @param account The address to check.
    /// @return bool True if the account has the role, false otherwise.
    function hasEcosystemModifierRole(address account) public view returns (bool) {
        return hasRole(ECOSYSTEM_MODIFIER_ROLE, account);
    }


    // --- Structured Interactions (Pairing) Functions ---

    /// @notice Proposes a pairing interaction between two NFTs.
    /// The proposer must own tokenAId. The owner of tokenBId must accept the proposal.
    /// Requires the contract not to be paused.
    /// @param tokenAId The ID of the proposing NFT.
    /// @param tokenBId The ID of the target NFT.
    function proposePairing(uint256 tokenAId, uint256 tokenBId) public whenNotPaused {
        if (ownerOf(tokenAId) != msg.sender) {
            revert NotTokenOwner(tokenAId);
        }
        if (!_exists(tokenBId)) {
            revert TokenDoesNotExist(tokenBId);
        }
        if (tokenAId == tokenBId) {
            revert SameTokenInProposal(tokenAId);
        }

        _nextPairingProposalId.increment();
        uint256 proposalId = _nextPairingProposalId.current();

        _pairingProposals[proposalId] = PairingProposal({
            proposalId: proposalId,
            tokenAId: tokenAId,
            tokenAOwnder: msg.sender,
            tokenBId: tokenBId,
            tokenBOwner: ownerOf(tokenBId), // Store current owner of B
            proposalTime: uint64(block.timestamp),
            acceptedByB: false,
            resolved: false
        });

        emit PairingProposed(proposalId, tokenAId, tokenBId, msg.sender, ownerOf(tokenBId));
    }

    /// @notice The owner of the target NFT (token B) accepts a pairing proposal.
    /// Requires the contract not to be paused.
    /// @param proposalId The ID of the pairing proposal.
    function acceptPairing(uint256 proposalId) public whenNotPaused {
        PairingProposal storage proposal = _pairingProposals[proposalId];
        if (proposal.proposalId == 0) { // Check if proposal exists
            revert InvalidProposalId(proposalId);
        }
        if (proposal.acceptedByB) {
            revert ProposalAlreadyAccepted(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }

        // Check if caller is the current owner of Token B
        if (ownerOf(proposal.tokenBId) != msg.sender) {
            revert NotPairingTargetOwner(proposalId);
        }

        proposal.acceptedByB = true;

        emit PairingAccepted(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);

        // Optionally auto-resolve upon acceptance, or require a separate resolve call
        // resolvePairingInteraction(proposalId); // Option 1: Auto-resolve
    }

    /// @notice The initiator (owner of token A) cancels their pairing proposal.
    /// @param proposalId The ID of the pairing proposal.
    function cancelPairingProposal(uint256 proposalId) public {
        PairingProposal storage proposal = _pairingProposals[proposalId];
         if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }
         if (proposal.tokenAOwnder != msg.sender) { // Check if caller is the original proposer
            revert NotPairingProposer(proposalId);
        }
        if (ownerOf(proposal.tokenAId) != msg.sender) {
             // If ownership changed, the original proposer can still cancel their *proposal*
             // but resolving would fail if ownership isn't correct later.
             // For simplicity, let's allow original proposer to cancel, even if they no longer own the token.
             // A more complex system might require ownership checks here too.
         }

        // Mark as resolved/invalidated without effects
        proposal.resolved = true; // Prevents further actions on this proposal ID
        // Consider adding an explicit 'cancelled' flag vs just 'resolved'

        emit PairingCanceled(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);
        // Consider deleting proposal data to save gas, if not needed for history
        // delete _pairingProposals[proposalId];
    }

    /// @notice The target owner (owner of token B) rejects a pairing proposal.
    /// @param proposalId The ID of the pairing proposal.
    function rejectPairingProposal(uint256 proposalId) public {
        PairingProposal storage proposal = _pairingProposals[proposalId];
         if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }
         // Check if caller is the current owner of Token B
        if (ownerOf(proposal.tokenBId) != msg.sender) {
            revert NotPairingTargetOwner(proposalId);
        }

        // Mark as resolved/invalidated without effects
        proposal.resolved = true;

        emit PairingRejected(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);
        // delete _pairingProposals[proposalId];
    }


    /// @notice Executes the effects of an accepted pairing proposal.
    /// Can be called by either participant after acceptance, or by a trusted third party.
    /// Requires the proposal to be accepted, not resolved, and the contract not to be paused.
    /// Requires both original owners to still own their respective tokens at the time of resolution.
    /// @param proposalId The ID of the pairing proposal.
    function resolvePairingInteraction(uint256 proposalId) public whenNotPaused {
        PairingProposal storage proposal = _pairingProposals[proposalId];
        if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (!proposal.acceptedByB) {
            revert ProposalNotAccepted(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }

        // Verify both participants still own their tokens
        if (ownerOf(proposal.tokenAId) != proposal.tokenAOwnder) {
             // Owner of A changed since proposal
             revert NotPairingProposer(proposalId); // Using this error loosely
        }
         if (ownerOf(proposal.tokenBId) != proposal.tokenBOwner) {
             // Owner of B changed since proposal/acceptance
             revert NotPairingTargetOwner(proposalId); // Using this error loosely
        }

        // --- Implement Pairing Effects ---
        // This is the core creative part. Effects could include:
        // - Boosting stats of both NFTs based on combined stats.
        // - Creating a new "child" NFT (generation +1).
        // - Adding unique "paired" traits/metadata.
        // - Transferring a portion of stats/energy between them.
        // - Consuming global ecosystem energy.

        NFTData storage nftA = _getNFTData(proposal.tokenAId);
        NFTData storage nftB = _getNFTData(proposal.tokenBId);

        // Example effect: Each NFT gains vitality proportional to the other's resilience
        uint256 vitalityBoostA = nftB.resilience / 5;
        uint256 vitalityBoostB = nftA.resilience / 5;

        nftA.vitality = nftA.vitality + vitalityBoostA > type(uint256).max ? type(uint256).max : nftA.vitality + vitalityBoostA;
        nftB.vitality = nftB.vitality + vitalityBoostB > type(uint256).max ? type(uint256).max : nftB.vitality + vitalityBoostB;

        // Example effect: Consume some energy from both
        uint256 energyCost = 20;
        nftA.energy = nftA.energy < energyCost ? 0 : nftA.energy - energyCost;
        nftB.energy = nftB.energy < energyCost ? 0 : nftB.energy - energyCost;

        // Example effect: Consume global ecosystem energy
        if (_ecosystemEnergy >= energyCost) {
             _ecosystemEnergy -= energyCost;
        } else {
             _ecosystemEnergy = 0;
        }


        // Update last update times
        nftA.lastUpdateTime = block.timestamp;
        nftB.lastUpdateTime = block.timestamp;


        // Mark proposal as resolved
        proposal.resolved = true;

        emit PairingResolved(proposalId, proposal.tokenAId, proposal.tokenBId);
    }

    /// @notice Retrieves the details of a specific pairing proposal.
    /// @param proposalId The ID of the pairing proposal.
    /// @return PairingProposal The proposal details.
    function getPendingPairingProposal(uint256 proposalId) public view returns (PairingProposal memory) {
         if (_pairingProposals[proposalId].proposalId == 0 && proposalId != 0) { // proposalId 0 is default state for non-existent
            revert InvalidProposalId(proposalId);
        }
        return _pairingProposals[proposalId];
    }

    /// @notice Placeholder function to retrieve a list of currently active or recently resolved pairing IDs.
    /// Storing and retrieving a dynamic list on-chain is gas-intensive. This function is conceptual.
    /// @return uint256[] An array of pairing proposal IDs.
    function getActivePairings() public view returns (uint256[] memory) {
        // In a real application, this might query events or a separate indexed list structure
        // Return an empty array as placeholder
        return new uint256[](0);
    }


    // --- Structured Interactions (Trait Exchange) Functions ---

    /// @notice Proposes exchanging specific numerical stat values between two NFTs.
    /// The proposer must own tokenAId. The owner of tokenBId must accept the proposal.
    /// Requires the contract not to be paused.
    /// @param tokenAId The ID of the proposing NFT.
    /// @param tokenBId The ID of the target NFT.
    /// @param statTypeA The type of stat on Token A to exchange.
    /// @param valueA The value of statTypeA that Token A is offering.
    /// @param statTypeB The type of stat on Token B to exchange.
    /// @param valueB The value of statTypeB that Token B is offering.
    function proposeTraitExchange(uint256 tokenAId, uint256 tokenBId, StatType statTypeA, uint256 valueA, StatType statTypeB, uint256 valueB) public whenNotPaused {
        if (ownerOf(tokenAId) != msg.sender) {
            revert NotTokenOwner(tokenAId);
        }
        if (!_exists(tokenBId)) {
            revert TokenDoesNotExist(tokenBId);
        }
        if (tokenAId == tokenBId) {
            revert SameTokenInProposal(tokenAId);
        }
        // Add checks that stat types are valid (within enum range)

        _nextTraitExchangeProposalId.increment();
        uint256 proposalId = _nextTraitExchangeProposalId.current();

        _traitExchangeProposals[proposalId] = TraitExchangeProposal({
            proposalId: proposalId,
            tokenAId: tokenAId,
            tokenAOwnder: msg.sender,
            tokenBId: tokenBId,
            tokenBOwner: ownerOf(tokenBId), // Store current owner of B
            statTypeA: statTypeA,
            valueA: valueA,
            statTypeB: statTypeB,
            valueB: valueB,
            proposalTime: uint64(block.timestamp),
            acceptedByB: false,
            resolved: false
        });

        emit TraitExchangeProposed(proposalId, tokenAId, tokenBId, msg.sender, ownerOf(tokenBId), statTypeA, valueA, statTypeB, valueB);
    }

     /// @notice The owner of the target NFT (token B) accepts a trait exchange proposal.
    /// Requires the contract not to be paused.
    /// @param proposalId The ID of the trait exchange proposal.
    function acceptTraitExchange(uint256 proposalId) public whenNotPaused {
        TraitExchangeProposal storage proposal = _traitExchangeProposals[proposalId];
         if (proposal.proposalId == 0) { // Check if proposal exists
            revert InvalidProposalId(proposalId);
        }
        if (proposal.acceptedByB) {
            revert ProposalAlreadyAccepted(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }

        // Check if caller is the current owner of Token B
        if (ownerOf(proposal.tokenBId) != msg.sender) {
            revert NotTraitExchangeTargetOwner(proposalId);
        }

        proposal.acceptedByB = true;

        emit TraitExchangeAccepted(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);

        // Optionally auto-resolve upon acceptance
        // resolveTraitExchange(proposalId); // Option 1: Auto-resolve
    }

    /// @notice The initiator (owner of token A) cancels their trait exchange proposal.
    /// @param proposalId The ID of the trait exchange proposal.
    function cancelTraitExchangeProposal(uint256 proposalId) public {
        TraitExchangeProposal storage proposal = _traitExchangeProposals[proposalId];
         if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }
         if (proposal.tokenAOwnder != msg.sender) { // Check if caller is the original proposer
            revert NotTraitExchangeProposer(proposalId);
        }
         // Ownership check omitted for simplicity as with pairing cancel

        // Mark as resolved/invalidated
        proposal.resolved = true;

        emit TraitExchangeCanceled(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);
        // Consider deleting
        // delete _traitExchangeProposals[proposalId];
    }

     /// @notice The target owner (owner of token B) rejects a trait exchange proposal.
    /// @param proposalId The ID of the trait exchange proposal.
    function rejectTraitExchange(uint256 proposalId) public {
        TraitExchangeProposal storage proposal = _traitExchangeProposals[proposalId];
         if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }
         // Check if caller is the current owner of Token B
        if (ownerOf(proposal.tokenBId) != msg.sender) {
            revert NotTraitExchangeTargetOwner(proposalId);
        }

        // Mark as resolved/invalidated
        proposal.resolved = true;

        emit TraitExchangeRejected(proposalId, proposal.tokenAId, proposal.tokenBId, msg.sender);
        // delete _traitExchangeProposals[proposalId];
    }

     /// @notice Retrieves the details of a specific trait exchange proposal.
    /// @param proposalId The ID of the trait exchange proposal.
    /// @return TraitExchangeProposal The proposal details.
    function getTraitExchangeProposal(uint256 proposalId) public view returns (TraitExchangeProposal memory) {
        if (_traitExchangeProposals[proposalId].proposalId == 0 && proposalId != 0) { // proposalId 0 is default state for non-existent
            revert InvalidProposalId(proposalId);
        }
        return _traitExchangeProposals[proposalId];
    }


    /// @notice Executes the stat value swap for an accepted trait exchange proposal.
    /// Can be called by either participant after acceptance, or by a trusted third party.
    /// Requires the proposal to be accepted, not resolved, and the contract not to be paused.
    /// Requires both original owners to still own their respective tokens at the time of resolution.
    /// @param proposalId The ID of the trait exchange proposal.
    function resolveTraitExchange(uint256 proposalId) public whenNotPaused {
        TraitExchangeProposal storage proposal = _traitExchangeProposals[proposalId];
        if (proposal.proposalId == 0) {
            revert InvalidProposalId(proposalId);
        }
        if (!proposal.acceptedByB) {
            revert ProposalNotAccepted(proposalId);
        }
        if (proposal.resolved) {
            revert ProposalAlreadyResolved(proposalId);
        }

        // Verify both participants still own their tokens
        if (ownerOf(proposal.tokenAId) != proposal.tokenAOwnder) {
             revert NotTraitExchangeProposer(proposalId); // Owner of A changed
        }
         if (ownerOf(proposal.tokenBId) != proposal.tokenBOwner) {
             revert NotTraitExchangeTargetOwner(proposalId); // Owner of B changed
        }

        NFTData storage nftA = _getNFTData(proposal.tokenAId);
        NFTData storage nftB = _getNFTData(proposal.tokenBId);

        // --- Perform the Trait/Stat Swap ---
        // Requires careful handling to ensure values are transferred correctly
        // and stats exist. Use a helper function for stat manipulation.

        _setStat(nftA, proposal.statTypeA, proposal.valueB); // A receives B's value for stat type A
        _setStat(nftB, proposal.statTypeB, proposal.valueA); // B receives A's value for stat type B

        // Optional: update last update times
        nftA.lastUpdateTime = block.timestamp;
        nftB.lastUpdateTime = block.timestamp;

        // Mark proposal as resolved
        proposal.resolved = true;

        emit TraitExchangeResolved(proposalId, proposal.tokenAId, proposal.tokenBId);
    }

    /// @dev Internal helper to set a specific stat value on an NFT based on StatType enum.
    function _setStat(NFTData storage nft, StatType statType, uint256 value) internal {
        if (statType == StatType.Energy) {
            nft.energy = value;
        } else if (statType == StatType.Vitality) {
            nft.vitality = value;
        } else if (statType == StatType.Resilience) {
            nft.resilience = value;
        } else {
            // This should theoretically not happen if enum is used correctly
            // but good for robustness if StatType is ever input directly via bytes
            revert InvalidStatType();
        }
    }


    // The contract now has well over 20 functions covering various advanced concepts.
    // Total non-ERC721 standard functions:
    // Admin/Utility: mint, setBaseURI, setTokenURIPrefix, pauseEvolution, unpauseEvolution (5)
    // NFT State/Evolution: _getNFTData (internal), getNFTState, getNFTGeneration, userNurtureNFT, triggerEvolutionCheck, evolveNFT, lockNFTState, unlockNFTState, getNFTHistorySummary (8, incl internal, or 7 public)
    // Ecosystem: getGlobalEcosystemState, applyExternalStimulusToNFT, collectResourceFromNFT (3)
    // Ecosystem Management: updateEcosystemParameters, addEcosystemModifierRole, removeEcosystemModifierRole, hasEcosystemModifierRole (4)
    // Pairing: proposePairing, acceptPairing, cancelPairingProposal, rejectPairingProposal, resolvePairingInteraction, getPendingPairingProposal, getActivePairings (7)
    // Trait Exchange: proposeTraitExchange, acceptTraitExchange, cancelTraitExchangeProposal, rejectTraitExchange, getTraitExchangeProposal, resolveTraitExchange, _setStat (internal) (7, incl internal, or 6 public)
    // Total Public/External: 5 + 7 + 3 + 4 + 7 + 6 = 32 functions (+ standard 9 ERC721) = 41 total. Exceeds the minimum 20 significantly with custom logic.

}
```