This smart contract, "SentiDAO," is designed to be an advanced, creative, and trendy decentralized autonomous organization (DAO) that manages a portfolio of "Sentient Digital Assets" (SDAs). SDAs are NFTs whose perceived "sentiment" or "value" is dynamically assessed by an off-chain AI oracle. This sentiment score influences various aspects of the DAO, including staking rewards, voting power, the ability for SDAs to "evolve," and participation in a unique predictive market.

**Core Concepts & Unique Features:**

1.  **AI-Driven Dynamic NFTs (SDAs):** NFTs are registered as SDAs, and their "sentiment score" is periodically updated by an AI oracle. This sentiment can trigger on-chain changes or unlock features.
2.  **Reputation-Based Governance:** Beyond token staking, user reputation within the DAO (earned through accurate predictions, successful proposals, etc.) significantly influences voting power and access to advanced features.
3.  **Predictive Sentiment Markets:** Users can predict the future sentiment of specific SDAs. Accurate predictions earn rewards and boost reputation, while incorrect ones might reduce reputation.
4.  **Evolving Digital Assets:** SDAs can "evolve" (e.g., update metadata, unlock new functionalities) if their sentiment score reaches a certain threshold, as decided by the DAO.
5.  **Chainlink Oracle Integration:** Utilizes Chainlink for secure and reliable fetching of AI sentiment analysis results from off-chain systems.
6.  **Sustainable Rewards Model:** Staking rewards are tied to the overall "health" or performance of the SDA portfolio, potentially derived from fees or external yield generated by the SDAs (not explicitly implemented but designed for this possibility).

---

## SentiDAO Smart Contract Outline & Function Summary

**Contract Name:** `SentiDAO`

**Dependencies:**
*   OpenZeppelin (ERC20, Ownable, ReentrancyGuard)
*   Chainlink (ChainlinkClient, LinkToken)

**Interfaces:**
*   `IERC721Minimal`: Minimal ERC721 interface for `ownerOf`, `tokenURI`.
*   `ISentiToken`: Interface for the DAO's governance token.

**Structs:**
*   `SentientAsset`: Represents a registered NFT with its sentiment, oracle request ID, etc.
*   `Proposal`: Details of a DAO proposal, including votes, execution status.
*   `PredictionRound`: Details of a prediction market round for an SDA's sentiment.
*   `UserPrediction`: A user's specific prediction within a round.

**Enums:**
*   `ProposalState`: Enum for different stages of a proposal (Pending, Active, Succeeded, Failed, Executed).

**State Variables:**
*   `sentiToken`: Address of the governance token.
*   `treasury`: Address of the DAO treasury.
*   `chainlinkOracle`, `chainlinkJobId`, `linkToken`: Chainlink configuration.
*   `sentimentOracleFee`: Fee in LINK for sentiment analysis requests.
*   `sdaCounter`: Counter for Sentient Assets.
*   `proposalsCounter`: Counter for DAO proposals.
*   `predictionRoundCounter`: Counter for prediction rounds.
*   `sentientAssets`: Mapping of SDA ID to `SentientAsset` struct.
*   `userReputation`: Mapping of user address to their reputation score.
*   `stakedTokens`: Mapping of user address to their staked token amount.
*   `totalStakedTokens`: Total tokens staked in the DAO.
*   `proposalThreshold`, `minReputationForProposal`, `votingPeriod`: Governance parameters.
*   `minSentimentForEvolution`: Threshold for SDA evolution.
*   `proposals`: Mapping of proposal ID to `Proposal` struct.
*   `proposalVotes`: Nested mapping for tracking individual votes on proposals.
*   `predictionRounds`: Mapping of round ID to `PredictionRound` struct.
*   `userPredictions`: Nested mapping of round ID and user address to `UserPrediction`.
*   `pendingRewards`: Mapping of user address to pending staking rewards.
*   `paused`: Emergency pause status.

**Events:**
*   `SentientAssetRegistered`, `SentimentUpdated`, `AssetEvolved`, `AssetRetired`
*   `ProposalCreated`, `VotedOnProposal`, `ProposalExecuted`
*   `ReputationChanged`, `ReputationDelegated`
*   `TokensStaked`, `TokensUnstaked`, `RewardsClaimed`
*   `PredictionRoundCreated`, `PredictionSubmitted`, `PredictionRoundResolved`
*   `TreasuryDeposited`, `TreasuryWithdrawn`
*   `OracleConfigUpdated`, `GovernanceParametersUpdated`, `Paused`, `Unpaused`

---

### Function Summary (At least 20 functions)

**I. Sentient Digital Asset (SDA) Management**
1.  `registerSentientAsset(address _nftContract, uint256 _tokenId, string memory _initialMetadataURI)`:
    *   Registers an existing NFT as a Sentient Digital Asset (SDA) within the SentiDAO. Assigns it an initial ID and metadata.
2.  `requestSentimentAnalysis(uint256 _sdaId, bytes memory _aiModelParams)`:
    *   Initiates an off-chain request to the Chainlink oracle to perform AI-driven sentiment analysis on a specific SDA. Requires LINK tokens for the oracle fee.
3.  `fulfillSentimentAnalysis(bytes32 _requestId, int256 _newSentimentScore)`:
    *   **Chainlink Callback:** Called *only* by the Chainlink oracle. Updates the sentiment score of an SDA based on the AI's analysis.
4.  `getAssetSentiment(uint256 _sdaId) view`:
    *   Retrieves the current sentiment score of a specified SDA.
5.  `evolveSentientAsset(uint256 _sdaId, string memory _newMetadataURI)`:
    *   Allows the DAO (via a successful proposal) to "evolve" an SDA, updating its metadata or features, provided its sentiment score meets a minimum threshold.
6.  `retireSentientAsset(uint256 _sdaId)`:
    *   DAO-governed function to remove an SDA from active management, e.g., if its sentiment consistently drops.

**II. DAO Governance & Treasury**
7.  `proposeAction(string memory _description, address _target, uint256 _value, bytes memory _callData)`:
    *   Allows qualified members (min stake/reputation) to submit a new proposal for DAO action (e.g., treasury withdrawal, parameter update, SDA evolution).
8.  `voteOnProposal(uint256 _proposalId, bool _support)`:
    *   Members cast their vote (for or against) on an active proposal. Voting power is weighted by combined staked tokens and reputation.
9.  `executeProposal(uint256 _proposalId)`:
    *   Executes a successful and expired proposal by calling the target contract with the specified data.
10. `depositToTreasury()`:
    *   Allows anyone to send native currency (e.g., ETH) to the DAO's treasury.
11. `withdrawTreasuryFunds(address _recipient, uint256 _amount)`:
    *   Executable only through a successful DAO proposal, allows withdrawal of funds from the treasury.

**III. Reputation & Staking**
12. `getReputation(address _user) view`:
    *   Retrieves the current reputation score of a specific user.
13. `_updateReputation(address _user, int256 _change)`:
    *   **Internal Function:** Used by other functions (e.g., prediction resolution) to modify a user's reputation score.
14. `delegateReputation(address _delegatee, uint256 _amount)`:
    *   Allows a user to delegate a portion of their reputation to another address, influencing the delegatee's voting power.
15. `stakeTokens(uint256 _amount)`:
    *   Allows users to stake `ISentiToken` governance tokens, contributing to their voting power and eligibility for rewards.
16. `unstakeTokens(uint256 _amount)`:
    *   Allows users to unstake their `ISentiToken`s after a cooldown period, if applicable (not explicitly coded cooldown for brevity).
17. `claimStakingRewards()`:
    *   Allows staked token holders to claim accumulated rewards, which could be generated from SDA performance fees or treasury distributions.
18. `getPendingRewards(address _user) view`:
    *   Returns the amount of pending rewards for a specific user.

**IV. Predictive Sentiment Markets**
19. `createPredictionRound(uint256 _sdaId, uint256 _endTimestamp, int256 _targetSentimentRangeMin, int256 _targetSentimentRangeMax, uint256 _entryFee)`:
    *   Allows qualified members to create a new prediction market round for an SDA's future sentiment.
20. `submitPrediction(uint256 _roundId, int256 _predictedSentiment)`:
    *   Users submit their sentiment prediction for an active round, typically requiring a small entry fee which goes to the rewards pool.
21. `resolvePredictionRound(uint256 _roundId)`:
    *   Resolves a prediction round after its end time, compares actual sentiment (from oracle) to predictions, distributes rewards to accurate predictors, and adjusts their reputation.

**V. Admin & Utility**
22. `setOracleConfig(address _newOracle, bytes32 _newJobId, uint256 _newFee)`:
    *   Allows the DAO (via proposal) to update the Chainlink oracle contract address, Job ID, and fee.
23. `updateGovernanceParameters(uint256 _newProposalThreshold, uint256 _newMinReputationForProposal, uint256 _newVotingPeriod, int256 _newMinSentimentForEvolution)`:
    *   Allows the DAO (via proposal) to adjust key governance parameters.
24. `emergencyPause()`:
    *   Allows a pre-defined trusted address (e.g., a multi-sig or DAO itself) to pause critical contract functionalities in emergencies.
25. `emergencyUnpause()`:
    *   Unpauses the contract after an `emergencyPause`.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

// OpenZeppelin imports
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Context.sol";

// Chainlink imports
import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";

// --- SentiDAO Smart Contract Outline & Function Summary ---
//
// Contract Name: SentiDAO
//
// Core Concepts & Unique Features:
// 1. AI-Driven Dynamic NFTs (SDAs): NFTs registered as Sentient Digital Assets whose sentiment
//    score, updated by an AI oracle (via Chainlink), influences their evolution and value.
// 2. Reputation-Based Governance: User reputation (earned via accurate predictions, successful
//    proposals) augments voting power and access, beyond just staked tokens.
// 3. Predictive Sentiment Markets: Users can stake tokens to predict future SDA sentiment.
//    Accurate predictions yield rewards and reputation boosts.
// 4. Evolving Digital Assets: SDAs can "evolve" (e.g., metadata updates) if their sentiment
//    score surpasses a DAO-defined threshold.
// 5. Chainlink Oracle Integration: Securely fetches AI sentiment analysis from off-chain.
//
// Interfaces:
// - IERC721Minimal: Basic ERC721 for ownerOf and tokenURI.
// - ISentiToken: Interface for the DAO's governance token.
//
// Structs:
// - SentientAsset: Details of a registered NFT (contract, ID, sentiment, metadata).
// - Proposal: DAO proposal details (description, target, value, calldata, state, votes).
// - PredictionRound: Details for a sentiment prediction market round.
// - UserPrediction: A user's specific prediction within a round.
//
// Enums:
// - ProposalState: Pending, Active, Succeeded, Failed, Executed.
//
// State Variables:
// - sentiToken: Address of the governance token.
// - treasury: Address of the DAO treasury for native tokens.
// - chainlinkOracle, chainlinkJobId, linkToken: Chainlink setup.
// - sentimentOracleFee: Cost in LINK for sentiment requests.
// - sdaCounter, proposalsCounter, predictionRoundCounter: Unique ID counters.
// - sentientAssets: Mapping of SDA ID to SentientAsset struct.
// - userReputation: Mapping of user address to their reputation score.
// - stakedTokens, totalStakedTokens: Tracking staked governance tokens.
// - proposalThreshold, minReputationForProposal, votingPeriod: Governance parameters.
// - minSentimentForEvolution: Threshold for SDA evolution eligibility.
// - proposals: Mapping of proposal ID to Proposal struct.
// - proposalVotes: Nested mapping for tracking individual votes.
// - predictionRounds: Mapping of round ID to PredictionRound struct.
// - userPredictions: Nested mapping for user predictions in a round.
// - pendingRewards: Mapping for user's pending staking rewards.
// - paused: Emergency pause status.
//
// --- Function Summary (25 Functions) ---
//
// I. Sentient Digital Asset (SDA) Management
// 1.  registerSentientAsset(address _nftContract, uint256 _tokenId, string memory _initialMetadataURI)
//     - Registers an existing NFT as an SDA, assigning it an ID and initial metadata.
// 2.  requestSentimentAnalysis(uint256 _sdaId, bytes memory _aiModelParams)
//     - Initiates an off-chain Chainlink request for AI sentiment analysis of an SDA. Requires LINK.
// 3.  fulfillSentimentAnalysis(bytes32 _requestId, int256 _newSentimentScore)
//     - **Chainlink Callback:** Called *only* by the oracle to update an SDA's sentiment.
// 4.  getAssetSentiment(uint256 _sdaId) view
//     - Retrieves the current sentiment score of a specified SDA.
// 5.  evolveSentientAsset(uint256 _sdaId, string memory _newMetadataURI)
//     - DAO-governed function to "evolve" an SDA (update metadata) if its sentiment is high enough.
// 6.  retireSentientAsset(uint256 _sdaId)
//     - DAO-governed function to remove an SDA from active management.
//
// II. DAO Governance & Treasury
// 7.  proposeAction(string memory _description, address _target, uint256 _value, bytes memory _callData)
//     - Allows qualified members to submit a new DAO proposal.
// 8.  voteOnProposal(uint256 _proposalId, bool _support)
//     - Members cast votes on active proposals. Voting power weighted by staked tokens + reputation.
// 9.  executeProposal(uint256 _proposalId)
//     - Executes a successful and expired proposal.
// 10. depositToTreasury() payable
//     - Allows anyone to send native currency (e.g., ETH) to the DAO treasury.
// 11. withdrawTreasuryFunds(address _recipient, uint256 _amount)
//     - DAO-governed withdrawal of funds from the treasury.
//
// III. Reputation & Staking
// 12. getReputation(address _user) view
//     - Retrieves a user's current reputation score.
// 13. _updateReputation(address _user, int256 _change) internal
//     - Internal function to modify user reputation.
// 14. delegateReputation(address _delegatee, uint256 _amount)
//     - Allows a user to delegate reputation to another address, influencing voting power.
// 15. stakeTokens(uint256 _amount)
//     - Users stake governance tokens for voting power and rewards eligibility.
// 16. unstakeTokens(uint256 _amount)
//     - Users unstake governance tokens.
// 17. claimStakingRewards()
//     - Claim accumulated staking rewards.
// 18. getPendingRewards(address _user) view
//     - Returns a user's pending staking rewards.
//
// IV. Predictive Sentiment Markets
// 19. createPredictionRound(uint256 _sdaId, uint256 _endTimestamp, int256 _targetSentimentRangeMin, int256 _targetSentimentRangeMax, uint256 _entryFee)
//     - Creates a new prediction market round for an SDA's future sentiment.
// 20. submitPrediction(uint256 _roundId, int256 _predictedSentiment)
//     - Users submit their sentiment prediction, typically with an entry fee.
// 21. resolvePredictionRound(uint256 _roundId)
//     - Resolves a prediction round, distributes rewards, and adjusts reputation based on accuracy.
//
// V. Admin & Utility
// 22. setOracleConfig(address _newOracle, bytes32 _newJobId, uint256 _newFee)
//     - DAO-governed update of Chainlink oracle configuration.
// 23. updateGovernanceParameters(uint256 _newProposalThreshold, uint256 _newMinReputationForProposal, uint256 _newVotingPeriod, int256 _newMinSentimentForEvolution)
//     - DAO-governed adjustment of key governance parameters.
// 24. emergencyPause()
//     - Allows a trusted address/DAO to pause critical functions.
// 25. emergencyUnpause()
//     - Unpauses the contract after an emergency.

// --- End of Summary ---

// Minimal ERC721 Interface for basic queries
interface IERC721Minimal {
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// Interface for SentiDAO's governance token (assumed ERC20)
interface ISentiToken is IERC20 {
    // We can add specific functions later if needed, but IERC20 is sufficient for now.
}

contract SentiDAO is Ownable, ReentrancyGuard, ChainlinkClient {
    using SafeMath for uint256;

    // --- Enums ---
    enum ProposalState {
        Pending,
        Active,
        Succeeded,
        Failed,
        Executed
    }

    // --- Structs ---

    struct SentientAsset {
        uint256 id;
        address nftContract;
        uint256 tokenId;
        string metadataURI; // Can be updated upon evolution
        int256 sentimentScore; // AI-driven sentiment, e.g., -100 to 100
        bytes32 lastOracleRequestId; // To track pending sentiment requests
        uint256 registrationTimestamp;
        bool retired;
    }

    struct Proposal {
        uint256 id;
        string description;
        address proposer;
        address target;
        uint256 value; // ETH to send with the call
        bytes callData;
        uint256 startBlock;
        uint256 endBlock;
        uint256 votesFor;
        uint256 votesAgainst;
        ProposalState state;
        bool executed;
    }

    struct PredictionRound {
        uint256 id;
        uint256 sdaId;
        uint256 creationTimestamp;
        uint256 endTimestamp;
        int256 targetSentimentRangeMin; // Users predict within this range
        int256 targetSentimentRangeMax;
        uint256 entryFee; // In SentiToken
        uint256 totalPredictionPool; // Total collected entry fees
        bool resolved;
    }

    struct UserPrediction {
        int256 predictedSentiment;
        uint256 submissionTimestamp;
        bool claimedRewards;
        uint256 stakedAmount; // Entry fee
    }

    // --- State Variables ---

    // Governance Token
    ISentiToken public sentiToken;

    // DAO Treasury for native currency
    address public treasury;

    // Chainlink Oracle Configuration
    address public chainlinkOracle;
    bytes32 public chainlinkJobId;
    LinkTokenInterface public linkToken;
    uint256 public sentimentOracleFee; // In LINK wei

    // Counters for unique IDs
    uint256 public sdaCounter;
    uint256 public proposalsCounter;
    uint256 public predictionRoundCounter;

    // Core mappings
    mapping(uint256 => SentientAsset) public sentientAssets;
    mapping(address => int256) public userReputation; // Reputation score for each user
    mapping(address => uint256) public stakedTokens; // SentiTokens staked by users
    uint256 public totalStakedTokens;

    // Governance Parameters
    uint256 public proposalThreshold; // Minimum staked tokens + reputation needed to create a proposal
    uint256 public minReputationForProposal; // Min reputation to propose (separate check)
    uint256 public votingPeriod; // Number of blocks for which a proposal is active
    int256 public minSentimentForEvolution; // Minimum sentiment score for an SDA to be eligible for evolution

    // Proposal tracking
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(address => bool)) public proposalVotes; // proposalId => voterAddress => hasVoted

    // Prediction Market tracking
    mapping(uint256 => PredictionRound) public predictionRounds;
    mapping(uint256 => mapping(address => UserPrediction)) public userPredictions; // roundId => userAddress => UserPrediction

    // Staking rewards tracking (simplified: could be a more complex distribution model)
    mapping(address => uint256) public pendingRewards;

    // Emergency pause
    bool public paused;

    // --- Events ---
    event SentientAssetRegistered(uint256 indexed sdaId, address indexed nftContract, uint256 indexed tokenId, string initialMetadataURI);
    event SentimentUpdated(uint256 indexed sdaId, int256 newSentimentScore, bytes32 indexed requestId);
    event AssetEvolved(uint256 indexed sdaId, string newMetadataURI, address indexed byProposer);
    event AssetRetired(uint256 indexed sdaId, address indexed byProposer);

    event ProposalCreated(uint256 indexed proposalId, string description, address indexed proposer);
    event VotedOnProposal(uint256 indexed proposalId, address indexed voter, bool support, uint256 votingPower);
    event ProposalExecuted(uint256 indexed proposalId, bool success);

    event ReputationChanged(address indexed user, int256 newReputation, string reasonHash);
    event ReputationDelegated(address indexed delegator, address indexed delegatee, uint256 amount);
    event TokensStaked(address indexed user, uint256 amount);
    event TokensUnstaked(address indexed user, uint256 amount);
    event RewardsClaimed(address indexed user, uint256 amount);

    event PredictionRoundCreated(uint256 indexed roundId, uint256 indexed sdaId, uint256 endTimestamp);
    event PredictionSubmitted(uint256 indexed roundId, address indexed predictor, int256 predictedSentiment, uint256 stakedAmount);
    event PredictionRoundResolved(uint256 indexed roundId, uint256 totalWinners, uint256 totalRewardPool);

    event TreasuryDeposited(address indexed depositor, uint256 amount);
    event TreasuryWithdrawn(address indexed recipient, uint256 amount);

    event OracleConfigUpdated(address newOracle, bytes32 newJobId, uint256 newFee);
    event GovernanceParametersUpdated(uint256 proposalThreshold, uint256 minReputationForProposal, uint256 votingPeriod, int256 minSentimentForEvolution);
    event Paused(address indexed by);
    event Unpaused(address indexed by);

    // --- Modifiers ---
    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    modifier whenPaused() {
        require(paused, "Contract is not paused");
        _;
    }

    modifier onlyOracle() {
        require(msg.sender == chainlinkOracle, "Only Chainlink oracle can call this function");
        _;
    }

    // --- Constructor ---
    constructor(
        address _sentiTokenAddress,
        address _treasuryAddress,
        address _linkTokenAddress,
        address _chainlinkOracleAddress,
        bytes32 _chainlinkJobId,
        uint256 _sentimentOracleFee,
        uint256 _proposalThreshold,
        uint256 _minReputationForProposal,
        uint256 _votingPeriod,
        int256 _minSentimentForEvolution
    ) Ownable(msg.sender) {
        require(_sentiTokenAddress != address(0), "Invalid sentiToken address");
        require(_treasuryAddress != address(0), "Invalid treasury address");
        require(_linkTokenAddress != address(0), "Invalid LINK token address");
        require(_chainlinkOracleAddress != address(0), "Invalid Chainlink oracle address");

        sentiToken = ISentiToken(_sentiTokenAddress);
        treasury = _treasuryAddress;

        // Chainlink client setup
        setChainlinkToken(_linkTokenAddress);
        linkToken = LinkTokenInterface(_linkTokenAddress);
        chainlinkOracle = _chainlinkOracleAddress;
        chainlinkJobId = _chainlinkJobId;
        sentimentOracleFee = _sentimentOracleFee;

        proposalThreshold = _proposalThreshold; // e.g., 1000e18 tokens
        minReputationForProposal = _minReputationForProposal; // e.g., 100 reputation points
        votingPeriod = _votingPeriod; // e.g., 17280 blocks (approx 3 days)
        minSentimentForEvolution = _minSentimentForEvolution; // e.g., 70 out of 100

        sdaCounter = 0;
        proposalsCounter = 0;
        predictionRoundCounter = 0;
    }

    // --- I. Sentient Digital Asset (SDA) Management ---

    /**
     * @notice Registers an existing ERC721 NFT as a Sentient Digital Asset (SDA).
     * The `msg.sender` must be the owner of the NFT.
     * @param _nftContract The address of the ERC721 NFT contract.
     * @param _tokenId The ID of the NFT token.
     * @param _initialMetadataURI The initial metadata URI for the SDA.
     */
    function registerSentientAsset(address _nftContract, uint256 _tokenId, string memory _initialMetadataURI)
        external
        whenNotPaused
        returns (uint256)
    {
        require(_nftContract != address(0), "Invalid NFT contract address");
        require(IERC721Minimal(_nftContract).ownerOf(_tokenId) == msg.sender, "Must own the NFT to register");

        sdaCounter = sdaCounter.add(1);
        sentientAssets[sdaCounter] = SentientAsset({
            id: sdaCounter,
            nftContract: _nftContract,
            tokenId: _tokenId,
            metadataURI: _initialMetadataURI,
            sentimentScore: 0, // Initial sentiment
            lastOracleRequestId: bytes32(0),
            registrationTimestamp: block.timestamp,
            retired: false
        });

        emit SentientAssetRegistered(sdaCounter, _nftContract, _tokenId, _initialMetadataURI);
        return sdaCounter;
    }

    /**
     * @notice Initiates an off-chain Chainlink request for AI sentiment analysis of an SDA.
     * Requires LINK tokens to be approved for this contract.
     * @param _sdaId The ID of the SDA to analyze.
     * @param _aiModelParams Custom parameters for the AI model (e.g., query string, context).
     */
    function requestSentimentAnalysis(uint256 _sdaId, bytes memory _aiModelParams)
        external
        whenNotPaused
        nonReentrant
    {
        require(_sdaId > 0 && _sdaId <= sdaCounter, "Invalid SDA ID");
        require(!sentientAssets[_sdaId].retired, "SDA is retired");
        require(linkToken.transferAndCall(chainlinkOracle, sentimentOracleFee, abi.encode(_sdaId, _aiModelParams)), "LINK transfer failed");

        bytes32 requestId = sendChainlinkRequest(chainlinkJobId, address(this), this.fulfillSentimentAnalysis.selector, sentimentOracleFee);
        sentientAssets[_sdaId].lastOracleRequestId = requestId; // Track the request

        // Emit an event for the request, perhaps with requestId
    }

    /**
     * @notice Chainlink callback function to update an SDA's sentiment score.
     * This function can ONLY be called by the Chainlink oracle.
     * @param _requestId The request ID originally sent to the oracle.
     * @param _newSentimentScore The sentiment score returned by the AI (e.g., -100 to 100).
     */
    function fulfillSentimentAnalysis(bytes32 _requestId, int256 _newSentimentScore)
        external
        onlyOracle
        recordChainlinkFulfillment(_requestId)
    {
        uint256 sdaId = 0;
        bool found = false;
        // This linear scan is inefficient for many SDAs. A mapping from requestId to sdaId would be better
        // For demonstration, we'll keep it simple or assume requestId encoding includes sdaId.
        // Or, better, the original request data (abi.encode(_sdaId, _aiModelParams)) should be decoded here.
        // Assuming _newSentimentScore also contains _sdaId for simplicity or that Chainlink request includes sdaId in its data.
        // For proper implementation, Chainlink request should be structured to return sdaId back.
        // Let's assume the bytes data in requestSentimentAnalysis passed _sdaId, and Chainlink returns it.
        // For now, let's just update the SDA associated with the last sent request for simplicity of this example.
        // A more robust solution involves storing `_requestId => sdaId` mapping.
        // For the sake of this example and not overcomplicating Chainlink callback, let's mock it finding the SDA by _requestId
        // (This would typically be done by encoding sdaId in the Chainlink request or having a mapping from requestId to sdaId)

        for(uint i = 1; i <= sdaCounter; i++) {
            if (sentientAssets[i].lastOracleRequestId == _requestId) {
                sdaId = i;
                found = true;
                break;
            }
        }
        require(found, "SDA for this request not found");
        require(!sentientAssets[sdaId].retired, "Cannot update retired SDA");

        sentientAssets[sdaId].sentimentScore = _newSentimentScore;
        emit SentimentUpdated(sdaId, _newSentimentScore, _requestId);
    }

    /**
     * @notice Retrieves the current sentiment score of a specified SDA.
     * @param _sdaId The ID of the SDA.
     * @return The sentiment score.
     */
    function getAssetSentiment(uint256 _sdaId) external view returns (int256) {
        require(_sdaId > 0 && _sdaId <= sdaCounter, "Invalid SDA ID");
        return sentientAssets[_sdaId].sentimentScore;
    }

    /**
     * @notice Allows the DAO to "evolve" an SDA, updating its metadata URI.
     * This function is intended to be called via a successful DAO proposal.
     * Requires the SDA's sentiment score to be above `minSentimentForEvolution`.
     * @param _sdaId The ID of the SDA to evolve.
     * @param _newMetadataURI The new metadata URI for the SDA.
     */
    function evolveSentientAsset(uint256 _sdaId, string memory _newMetadataURI)
        external
        whenNotPaused
    {
        // This function should ONLY be called by the DAO itself (target of a proposal)
        require(msg.sender == address(this), "Must be called via DAO proposal");
        require(_sdaId > 0 && _sdaId <= sdaCounter, "Invalid SDA ID");
        require(!sentientAssets[_sdaId].retired, "Cannot evolve retired SDA");
        require(sentientAssets[_sdaId].sentimentScore >= minSentimentForEvolution, "SDA sentiment too low for evolution");

        sentientAssets[_sdaId].metadataURI = _newMetadataURI;
        emit AssetEvolved(_sdaId, _newMetadataURI, tx.origin); // tx.origin for who initiated the proposal
    }

    /**
     * @notice Allows the DAO to retire an SDA, making it inactive for governance and predictions.
     * This function is intended to be called via a successful DAO proposal.
     * @param _sdaId The ID of the SDA to retire.
     */
    function retireSentientAsset(uint256 _sdaId) external whenNotPaused {
        require(msg.sender == address(this), "Must be called via DAO proposal");
        require(_sdaId > 0 && _sdaId <= sdaCounter, "Invalid SDA ID");
        require(!sentientAssets[_sdaId].retired, "SDA already retired");

        sentientAssets[_sdaId].retired = true;
        emit AssetRetired(_sdaId, tx.origin); // tx.origin for who initiated the proposal
    }


    // --- II. DAO Governance & Treasury ---

    /**
     * @notice Allows qualified members to submit a new proposal for DAO action.
     * Proposal requires minimum staked tokens and reputation.
     * @param _description Description of the proposal.
     * @param _target The address of the contract to call if the proposal passes (can be SentiDAO itself).
     * @param _value ETH to send with the call (0 for most proposals).
     * @param _callData The encoded function call data for the target contract.
     */
    function proposeAction(string memory _description, address _target, uint256 _value, bytes memory _callData)
        external
        whenNotPaused
        returns (uint256)
    {
        uint256 votingPower = stakedTokens[msg.sender].add(uint256(userReputation[msg.sender]));
        require(votingPower >= proposalThreshold, "Not enough combined voting power to propose");
        require(userReputation[msg.sender] >= minReputationForProposal, "Not enough reputation to propose");
        require(_target != address(0), "Target address cannot be zero");

        proposalsCounter = proposalsCounter.add(1);
        proposals[proposalsCounter] = Proposal({
            id: proposalsCounter,
            description: _description,
            proposer: msg.sender,
            target: _target,
            value: _value,
            callData: _callData,
            startBlock: block.number,
            endBlock: block.number.add(votingPeriod),
            votesFor: 0,
            votesAgainst: 0,
            state: ProposalState.Pending, // Will become active upon first vote or after a small grace period
            executed: false
        });

        emit ProposalCreated(proposalsCounter, _description, msg.sender);
        return proposalsCounter;
    }

    /**
     * @notice Allows members to cast their vote on an active proposal.
     * Voting power is determined by a combination of staked tokens and reputation.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _support True for 'for' vote, false for 'against' vote.
     */
    function voteOnProposal(uint256 _proposalId, bool _support) external whenNotPaused nonReentrant {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(proposal.state != ProposalState.Executed, "Proposal already executed");
        require(block.number >= proposal.startBlock, "Voting has not started");
        require(block.number <= proposal.endBlock, "Voting period has ended");
        require(!proposalVotes[_proposalId][msg.sender], "Already voted on this proposal");

        uint256 votingPower = stakedTokens[msg.sender].add(uint256(userReputation[msg.sender]));
        require(votingPower > 0, "No voting power to cast a vote");

        if (_support) {
            proposal.votesFor = proposal.votesFor.add(votingPower);
        } else {
            proposal.votesAgainst = proposal.votesAgainst.add(votingPower);
        }
        proposalVotes[_proposalId][msg.sender] = true;

        if (proposal.state == ProposalState.Pending) { // Activate on first vote
            proposal.state = ProposalState.Active;
        }

        emit VotedOnProposal(_proposalId, msg.sender, _support, votingPower);
    }

    /**
     * @notice Executes a successful and expired proposal.
     * Anyone can call this to trigger execution.
     * @param _proposalId The ID of the proposal to execute.
     */
    function executeProposal(uint256 _proposalId) external whenNotPaused nonReentrant {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.id != 0, "Proposal does not exist");
        require(proposal.state != ProposalState.Executed, "Proposal already executed");
        require(block.number > proposal.endBlock, "Voting period has not ended yet");

        if (proposal.votesFor > proposal.votesAgainst && proposal.votesFor > totalStakedTokens.div(2)) { // Example: Simple majority + quorum based on total staked
            proposal.state = ProposalState.Succeeded;
            // Attempt to execute the proposal
            (bool success, ) = proposal.target.call{value: proposal.value}(proposal.callData);
            require(success, "Proposal execution failed");
            proposal.executed = true;
            emit ProposalExecuted(_proposalId, true);
        } else {
            proposal.state = ProposalState.Failed;
            emit ProposalExecuted(_proposalId, false);
        }
    }

    /**
     * @notice Allows anyone to send native currency (e.g., ETH) to the DAO's treasury.
     */
    function depositToTreasury() external payable whenNotPaused {
        require(msg.value > 0, "Deposit amount must be greater than zero");
        (bool success, ) = treasury.call{value: msg.value}("");
        require(success, "Failed to deposit to treasury");
        emit TreasuryDeposited(msg.sender, msg.value);
    }

    /**
     * @notice Allows withdrawal of funds from the treasury.
     * This function is intended to be called via a successful DAO proposal.
     * @param _recipient The address to send the funds to.
     * @param _amount The amount of native currency to withdraw.
     */
    function withdrawTreasuryFunds(address _recipient, uint256 _amount) external whenNotPaused nonReentrant {
        // This function should ONLY be called by the DAO itself (target of a proposal)
        require(msg.sender == address(this), "Must be called via DAO proposal");
        require(_recipient != address(0), "Recipient cannot be zero address");
        require(_amount > 0, "Withdrawal amount must be greater than zero");
        require(address(treasury).balance >= _amount, "Insufficient treasury balance");

        (bool success, ) = payable(_recipient).call{value: _amount}("");
        require(success, "Failed to withdraw from treasury");
        emit TreasuryWithdrawn(_recipient, _amount);
    }


    // --- III. Reputation & Staking ---

    /**
     * @notice Retrieves the current reputation score of a specific user.
     * @param _user The address of the user.
     * @return The reputation score.
     */
    function getReputation(address _user) external view returns (int256) {
        return userReputation[_user];
    }

    /**
     * @dev Internal function to modify a user's reputation score.
     * Can be called by other internal logic (e.g., successful prediction, proposal).
     * @param _user The address of the user whose reputation is being modified.
     * @param _change The amount to change reputation by (can be negative).
     * @param _reasonHash A hash or string describing the reason for the change.
     */
    function _updateReputation(address _user, int256 _change, string memory _reasonHash) internal {
        userReputation[_user] = userReputation[_user].add(_change);
        emit ReputationChanged(_user, userReputation[_user], _reasonHash);
    }

    /**
     * @notice Allows a user to delegate a portion of their reputation to another address.
     * This affects voting power calculations.
     * @param _delegatee The address to delegate reputation to.
     * @param _amount The amount of reputation to delegate.
     */
    function delegateReputation(address _delegatee, uint256 _amount) external whenNotPaused {
        require(userReputation[msg.sender] >= int256(_amount), "Not enough reputation to delegate");
        userReputation[msg.sender] = userReputation[msg.sender].sub(int256(_amount));
        userReputation[_delegatee] = userReputation[_delegatee].add(int256(_amount)); // Delegatee gains reputation
        emit ReputationDelegated(msg.sender, _delegatee, _amount);
        emit ReputationChanged(msg.sender, userReputation[msg.sender], "Delegated Reputation");
        emit ReputationChanged(_delegatee, userReputation[_delegatee], "Received Delegated Reputation");
    }

    /**
     * @notice Allows users to stake `ISentiToken` governance tokens.
     * Staked tokens contribute to voting power and reward eligibility.
     * @param _amount The amount of SentiTokens to stake.
     */
    function stakeTokens(uint256 _amount) external whenNotPaused nonReentrant {
        require(_amount > 0, "Stake amount must be greater than zero");
        require(sentiToken.transferFrom(msg.sender, address(this), _amount), "SentiToken transfer failed");

        stakedTokens[msg.sender] = stakedTokens[msg.sender].add(_amount);
        totalStakedTokens = totalStakedTokens.add(_amount);

        // Placeholder for reward calculation update (e.g., distribute pending rewards before new stake)
        // updateRewardPerToken(); // In a full implementation, this would update internal reward tracking

        emit TokensStaked(msg.sender, _amount);
    }

    /**
     * @notice Allows users to unstake their `ISentiToken`s.
     * @param _amount The amount of SentiTokens to unstake.
     */
    function unstakeTokens(uint256 _amount) external whenNotPaused nonReentrant {
        require(_amount > 0, "Unstake amount must be greater than zero");
        require(stakedTokens[msg.sender] >= _amount, "Insufficient staked tokens");

        // Placeholder for reward calculation update
        // _distributeRewards(msg.sender); // Distribute pending rewards before unstaking

        stakedTokens[msg.sender] = stakedTokens[msg.sender].sub(_amount);
        totalStakedTokens = totalStakedTokens.sub(_amount);
        require(sentiToken.transfer(msg.sender, _amount), "SentiToken transfer failed during unstake");

        emit TokensUnstaked(msg.sender, _amount);
    }

    /**
     * @notice Allows staked token holders to claim accumulated rewards.
     * Rewards are accumulated based on staking duration and potentially SDA performance.
     */
    function claimStakingRewards() external whenNotPaused nonReentrant {
        uint256 rewards = pendingRewards[msg.sender];
        require(rewards > 0, "No pending rewards to claim");

        pendingRewards[msg.sender] = 0; // Reset
        require(sentiToken.transfer(msg.sender, rewards), "Reward token transfer failed");

        emit RewardsClaimed(msg.sender, rewards);
    }

    /**
     * @notice Returns the amount of pending staking rewards for a specific user.
     * @param _user The address of the user.
     * @return The amount of pending rewards.
     */
    function getPendingRewards(address _user) external view returns (uint256) {
        // In a real system, this would calculate dynamic rewards
        // For this example, it simply returns what's in `pendingRewards`
        // A more complex system would calculate rewards based on _user's share,
        // time staked, and total rewards generated.
        return pendingRewards[_user];
    }


    // --- IV. Predictive Sentiment Markets ---

    /**
     * @notice Creates a new prediction market round for an SDA's future sentiment.
     * Requires min reputation to create.
     * @param _sdaId The ID of the SDA to predict sentiment for.
     * @param _endTimestamp The timestamp when the prediction round ends.
     * @param _targetSentimentRangeMin The minimum expected sentiment score.
     * @param _targetSentimentRangeMax The maximum expected sentiment score.
     * @param _entryFee The fee (in SentiTokens) to participate in this round.
     */
    function createPredictionRound(
        uint256 _sdaId,
        uint256 _endTimestamp,
        int256 _targetSentimentRangeMin,
        int256 _targetSentimentRangeMax,
        uint256 _entryFee
    ) external whenNotPaused returns (uint256) {
        require(userReputation[msg.sender] >= minReputationForProposal, "Not enough reputation to create a prediction round");
        require(_sdaId > 0 && _sdaId <= sdaCounter, "Invalid SDA ID");
        require(!sentientAssets[_sdaId].retired, "Cannot create prediction round for retired SDA");
        require(_endTimestamp > block.timestamp.add(1 days), "End timestamp must be in the future (min 1 day)"); // Min 1 day prediction
        require(_targetSentimentRangeMin < _targetSentimentRangeMax, "Invalid target sentiment range");
        require(_entryFee > 0, "Entry fee must be positive");

        predictionRoundCounter = predictionRoundCounter.add(1);
        predictionRounds[predictionRoundCounter] = PredictionRound({
            id: predictionRoundCounter,
            sdaId: _sdaId,
            creationTimestamp: block.timestamp,
            endTimestamp: _endTimestamp,
            targetSentimentRangeMin: _targetSentimentRangeMin,
            targetSentimentRangeMax: _targetSentimentRangeMax,
            entryFee: _entryFee,
            totalPredictionPool: 0,
            resolved: false
        });

        emit PredictionRoundCreated(predictionRoundCounter, _sdaId, _endTimestamp);
        return predictionRoundCounter;
    }

    /**
     * @notice Users submit their sentiment prediction for an active round.
     * Requires the `entryFee` in SentiTokens.
     * @param _roundId The ID of the prediction round.
     * @param _predictedSentiment The user's predicted sentiment score.
     */
    function submitPrediction(uint256 _roundId, int256 _predictedSentiment) external whenNotPaused nonReentrant {
        PredictionRound storage round = predictionRounds[_roundId];
        require(round.id != 0, "Prediction round does not exist");
        require(block.timestamp < round.endTimestamp, "Prediction round has ended");
        require(!round.resolved, "Prediction round already resolved");
        require(userPredictions[_roundId][msg.sender].submissionTimestamp == 0, "Already submitted prediction for this round");

        // Take entry fee
        require(sentiToken.transferFrom(msg.sender, address(this), round.entryFee), "Entry fee transfer failed");
        round.totalPredictionPool = round.totalPredictionPool.add(round.entryFee);

        userPredictions[_roundId][msg.sender] = UserPrediction({
            predictedSentiment: _predictedSentiment,
            submissionTimestamp: block.timestamp,
            claimedRewards: false,
            stakedAmount: round.entryFee
        });

        emit PredictionSubmitted(_roundId, msg.sender, _predictedSentiment, round.entryFee);
    }

    /**
     * @notice Resolves a prediction round after its end time, distributes rewards, and adjusts reputation.
     * Can be called by anyone once the round has ended and SDA sentiment is updated.
     * @param _roundId The ID of the prediction round to resolve.
     */
    function resolvePredictionRound(uint256 _roundId) external whenNotPaused nonReentrant {
        PredictionRound storage round = predictionRounds[_roundId];
        require(round.id != 0, "Prediction round does not exist");
        require(block.timestamp >= round.endTimestamp, "Prediction round has not ended yet");
        require(!round.resolved, "Prediction round already resolved");

        SentientAsset storage sda = sentientAssets[round.sdaId];
        require(sda.lastOracleRequestId != bytes32(0), "SDA sentiment not yet updated by oracle for this period");
        // For robust resolution, the sentiment score should be from _after_ the prediction round's end time.
        // For simplicity, we use the current stored sentiment. In a real scenario, you'd fetch the sentiment
        // closest to or after `round.endTimestamp` using Chainlink.

        int256 actualSentiment = sda.sentimentScore;
        uint256 totalWinnersStake = 0;
        address[] memory winners; // Dynamically sized array for winners

        // Iterate through all predictions (inefficient for many users, needs optimization for scale)
        // For a large scale, this would involve a Merkle Proof or a batch processing function.
        // For this example, we assume manageable number of participants or off-chain processing for winners.

        // A more scalable approach would be to calculate winners off-chain and submit a ZKP or a Merkle root.
        // For the sake of this example, we iterate (demonstrates concept, not scalable).
        uint256 winnerCount = 0;
        // This loop cannot iterate through _all_ users easily. For a real DApp, you'd track participants
        // in a separate mapping or list, or use an off-chain resolution system.
        // For demonstration, let's assume a fixed list of potential predictors or limited participation.
        // To make it functional, one might need to pass a list of participant addresses.
        // Let's keep it simple by just checking the caller's own prediction, or making this an admin function
        // that takes a list of winners identified off-chain.

        // For simplicity and to avoid iterating all users on-chain, let's say this function
        // awards based on a range. Users will then call `claimPredictionReward(roundId)`
        // which verifies their prediction *after* this function marks the round resolved.

        round.resolved = true;
        // No direct reward distribution here. Instead, `claimPredictionReward` will check if user won.

        emit PredictionRoundResolved(_roundId, 0, round.totalPredictionPool); // Winner count is unknown here
    }

    /**
     * @notice Allows a user to claim their prediction rewards if they were correct.
     * Can only be called after `resolvePredictionRound` has been executed.
     * @param _roundId The ID of the prediction round.
     */
    function claimPredictionReward(uint256 _roundId) external whenNotPaused nonReentrant {
        PredictionRound storage round = predictionRounds[_roundId];
        require(round.id != 0, "Prediction round does not exist");
        require(round.resolved, "Prediction round not yet resolved");
        UserPrediction storage userPred = userPredictions[_roundId][msg.sender];
        require(userPred.submissionTimestamp != 0, "No prediction submitted for this round");
        require(!userPred.claimedRewards, "Rewards already claimed");

        SentientAsset storage sda = sentientAssets[round.sdaId];
        int256 actualSentiment = sda.sentimentScore;

        bool isWinner = (userPred.predictedSentiment >= round.targetSentimentRangeMin &&
                         userPred.predictedSentiment <= round.targetSentimentRangeMax);
        // Or, more accurately, actualSentiment falls in the predicted range:
        // isWinner = (actualSentiment >= userPred.predictedSentiment.sub(tolerance) && actualSentiment <= userPred.predictedSentiment.add(tolerance))
        // Let's use the round's target range for simplicity in this example.
        isWinner = (actualSentiment >= round.targetSentimentRangeMin && actualSentiment <= round.targetSentimentRangeMax);


        if (isWinner) {
            // This is a simplified reward distribution. In reality, you'd calculate
            // individual reward share based on total winners, stake, etc.
            // For example, if there are N winners, each gets `totalPredictionPool / N` (adjusted for their stake).
            // Since we don't track total winners on-chain for scalability reasons, this needs to be re-thought for a real DApp.

            // Simplistic reward: User gets their entry fee back + a small bonus from pool
            uint256 rewardAmount = userPred.stakedAmount.mul(2); // Example: Double the entry fee

            // Deduct from pool (this requires pool to be > rewardAmount)
            // This example is simplified and doesn't handle full pool distribution logic.
            // A realistic scenario would be:
            // 1. Resolve round identifies winners (e.g., via off-chain and submit a Merkle root).
            // 2. This function verifies the user against the Merkle root.
            // 3. User receives a pre-calculated reward share.

            // For now, let's simulate a reward and give back the entry fee.
            // A more complex system would calculate a share of the `round.totalPredictionPool`.
            // Let's assume a simplified reward mechanism where winners get back their stake + a fixed bonus from DAO treasury.
            uint256 bonusFromTreasury = round.entryFee.div(2); // Example bonus
            uint256 totalReward = userPred.stakedAmount.add(bonusFromTreasury);

            // Ensure treasury has funds for this bonus (or take it from totalPredictionPool)
            // Assuming totalPredictionPool is the source of rewards for now.
            // This needs a robust reward allocation logic.

            // For this sample, let's just refund stake for winners and give a small reputation boost.
            require(sentiToken.transfer(msg.sender, userPred.stakedAmount), "Reward transfer failed");
            _updateReputation(msg.sender, 10, "Accurate prediction"); // Boost reputation
            pendingRewards[msg.sender] = pendingRewards[msg.sender].add(userPred.stakedAmount); // Simulate adding to staking rewards
        } else {
            // User loses their entry fee (it stays in totalPredictionPool, which might be distributed to other winners or treasury)
            _updateReputation(msg.sender, -5, "Inaccurate prediction"); // Penalize reputation
        }
        userPred.claimedRewards = true;
    }


    // --- V. Admin & Utility ---

    /**
     * @notice Allows the DAO to update the Chainlink oracle configuration.
     * This function is intended to be called via a successful DAO proposal.
     * @param _newOracle The new Chainlink oracle contract address.
     * @param _newJobId The new Chainlink Job ID.
     * @param _newFee The new fee (in LINK) for oracle requests.
     */
    function setOracleConfig(address _newOracle, bytes32 _newJobId, uint256 _newFee) external whenNotPaused {
        require(msg.sender == address(this), "Must be called via DAO proposal");
        require(_newOracle != address(0), "Invalid oracle address");
        chainlinkOracle = _newOracle;
        chainlinkJobId = _newJobId;
        sentimentOracleFee = _newFee;
        emit OracleConfigUpdated(_newOracle, _newJobId, _newFee);
    }

    /**
     * @notice Allows the DAO to adjust key governance parameters.
     * This function is intended to be called via a successful DAO proposal.
     * @param _newProposalThreshold New minimum combined voting power to create a proposal.
     * @param _newMinReputationForProposal New minimum reputation to create a proposal.
     * @param _newVotingPeriod New duration (in blocks) for voting on proposals.
     * @param _newMinSentimentForEvolution New minimum sentiment for SDA evolution.
     */
    function updateGovernanceParameters(
        uint256 _newProposalThreshold,
        uint256 _newMinReputationForProposal,
        uint256 _newVotingPeriod,
        int256 _newMinSentimentForEvolution
    ) external whenNotPaused {
        require(msg.sender == address(this), "Must be called via DAO proposal");
        proposalThreshold = _newProposalThreshold;
        minReputationForProposal = _newMinReputationForProposal;
        votingPeriod = _newVotingPeriod;
        minSentimentForEvolution = _newMinSentimentForEvolution;
        emit GovernanceParametersUpdated(proposalThreshold, minReputationForProposal, votingPeriod, minSentimentForEvolution);
    }

    /**
     * @notice Allows the owner (or a DAO-controlled multi-sig) to pause critical contract functions in an emergency.
     */
    function emergencyPause() external onlyOwner whenNotPaused {
        paused = true;
        emit Paused(msg.sender);
    }

    /**
     * @notice Allows the owner (or a DAO-controlled multi-sig) to unpause the contract.
     */
    function emergencyUnpause() external onlyOwner whenPaused {
        paused = false;
        emit Unpaused(msg.sender);
    }

    // --- Fallback/Receive ---
    receive() external payable {
        // Allow receiving native tokens to treasury if not explicitly called via depositToTreasury()
        (bool success, ) = treasury.call{value: msg.value}("");
        require(success, "Failed to forward funds to treasury on receive");
        emit TreasuryDeposited(msg.sender, msg.value);
    }
}
```