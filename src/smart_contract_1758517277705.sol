This smart contract, "Neural Genesis," envisions a future where digital entities (Adaptive Digital Entities - ADEs) are not static JPEGs but dynamic, evolving NFTs whose attributes are initially seeded by AI models and continuously shaped by their owner's interactions, ecosystem events, and a unique on-chain reputation system.

The core idea is to merge advanced concepts like AI-driven content generation (via oracles), dynamic NFTs, user-centric evolution mechanics, and a reputation system ("Cognition Points") into a cohesive experience. It also introduces ERC-1155 "Adept Cores" for powerful attribute enhancements and "Genesis Fragments" as soul-bound tokens for on-chain signaling.

---

## Neural Genesis Contract Outline & Function Summary

**Contract Name:** `NeuralGenesis`

**Core Concepts:**
*   **Adaptive Digital Entities (ADEs):** ERC721 tokens whose attributes are dynamic and evolve.
*   **AI-Driven Genesis & Recalibration:** Initial ADE attributes are determined by an AI model (via an oracle) based on a user-provided "seed phrase." Attributes can be recalibrated later.
*   **User-Centric Evolution:** Owners can "train" ADEs to boost specific attributes.
*   **Cognition Points:** A non-transferable, on-chain reputation score earned by staking ADEs and participating positively. Used for governance and unlocking features.
*   **Decentralized Provenance:** Records the AI model versions and prompts influencing each ADE's evolution.
*   **Adept Cores (ERC1155):** Powerful, craftable tokens made by burning multiple ADEs, used to significantly enhance a target ADE.
*   **Genesis Fragments (Soul-bound ERC721):** Non-transferable tokens representing a snapshot of an ADE's traits, used for reputation or specific ecosystem interactions without transferring the main ADE.
*   **Temporal Locks:** Owners can lock their ADEs for benefits, enhancing engagement.
*   **On-chain Governance:** Allows Cognition Point holders to propose and vote on key system parameters.

---

### Function Summary:

**I. Core ADE Management & AI Integration:**
1.  `requestAIDrivenGenesis(string calldata _seedPhrase, address _recipient)`: Initiates the minting of a new ADE, sending a request to the oracle for AI-driven attribute generation based on the seed phrase.
2.  `fulfillAIDrivenGenesis(bytes32 _requestId, uint256 _tokenId, uint256[] calldata _initialAttributes, string calldata _ipfsHash, bytes32 _aiModelHash)`: Oracle callback to finalize ADE minting with AI-generated attributes and IPFS metadata.
3.  `trainADE(uint256 _tokenId, uint8 _attributeIndex, uint256 _boostAmount)`: Allows an ADE owner to directly influence and boost a specific attribute. Requires Cognition Points.
4.  `requestAttributeRecalibration(uint256 _tokenId, string calldata _contextualPrompt)`: Requests the oracle to re-evaluate an ADE's attributes based on a new AI prompt, potentially changing its traits.
5.  `fulfillAttributeRecalibration(bytes32 _requestId, uint256 _tokenId, uint256[] calldata _newAttributes, string calldata _newIpfsHash, bytes32 _aiModelHash)`: Oracle callback to update an ADE's attributes after recalibration.

**II. Cognition Points & Reputation System:**
6.  `stakeADEForCognition(uint256 _tokenId)`: Stakes an ADE to start accruing Cognition Points for its owner.
7.  `unstakeADEFromCognition(uint256 _tokenId)`: Unstakes an ADE, stopping Cognition Point accrual.
8.  `claimCognitionPoints(address _owner)`: Allows an address to claim their accrued Cognition Points.
9.  `delegateCognition(uint256 _tokenId, address _delegatee, uint64 _duration)`: Delegates the ability to claim Cognition Points generated by a specific ADE to another address for a duration.
10. `revokeCognitionDelegation(uint256 _tokenId)`: Revokes an active Cognition Point delegation.

**III. Advanced ADE Interactions & Crafting:**
11. `synthesizeAdeptCore(uint256[] calldata _sourceADETokenIds, string calldata _coreDescription)`: Burns multiple source ADEs to create a new "Adept Core" (ERC1155 token) with aggregated attribute boosts.
12. `applyAdeptCore(uint256 _tokenId, uint256 _coreId, uint256 _amount)`: Applies an Adept Core to a target ADE, permanently enhancing its attributes. Consumes the Adept Core.
13. `mintGenesisFragment(uint256 _tokenId, address _recipient)`: Mints a non-transferable "Genesis Fragment" (Soul-bound ERC721) representing a snapshot of the parent ADE, for reputation or specific ecosystem uses.
14. `redeemGenesisFragment(uint256 _fragmentTokenId)`: Burns a Genesis Fragment, potentially triggering a small benefit or recording a completed task.
15. `activateTemporalLock(uint256 _tokenId, uint64 _lockDuration)`: Temporarily locks an ADE from transfers and major modifications, granting enhanced Cognition Point generation or other benefits.
16. `claimIncentiveFromLock(uint256 _tokenId)`: Allows claiming benefits (e.g., bonus Cognition Points) from an ADE that has been under a temporal lock.

**IV. On-Chain Governance:**
17. `proposeEvolutionParameter(bytes32 _paramKey, bytes calldata _newValue, string calldata _description)`: Allows Cognition Point holders to propose changes to system parameters.
18. `voteOnEvolutionProposal(uint256 _proposalId, bool _support)`: Casts a vote on an active proposal using accrued Cognition Points.
19. `executeEvolutionProposal(uint256 _proposalId)`: Executes a proposal that has met the voting quorum and threshold.

**V. Administrative & View Functions:**
20. `setOracleAddress(address _newOracle)`: Admin function to update the trusted oracle address.
21. `registerAIModel(bytes32 _modelHash, string calldata _description, address _oracleAffiliate)`: Admin function to officially register AI models used by oracles, enhancing provenance.
22. `getADEProvenance(uint256 _tokenId)`: Retrieves the history of AI models and prompts that have influenced an ADE's creation and evolution.
23. `configureAttributeCurve(uint8 _attributeIndex, uint256 _maxVal, uint256 _decayRate)`: Admin function to define how attributes behave (e.g., max value, natural decay).
24. `calculateCurrentADEValue(uint256 _tokenId)`: A view function that estimates an ADE's "intrinsic" value based on its attributes, age, and provenance.
25. `setBaseURI(string calldata _newBaseURI)`: Admin function to update the base URI for ADE metadata.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

// Dummy Chainlink-like Oracle Interface for demonstration
interface IOracle {
    function request(bytes32 _jobId, string calldata _url, bytes4 _callbackFunctionId, bytes32 _callbackRequestId) external returns (bytes32);
    function fulfill(bytes32 _requestId, bytes calldata _data) external;
}

contract NeuralGenesis is ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;
    using Strings for uint256;

    // --- Configuration & Constants ---
    uint256 public constant MAX_ATTRIBUTES = 10; // Max number of attributes per ADE
    uint256 public constant MAX_ATTRIBUTE_VALUE = 1000;
    uint256 public constant MIN_COGNITION_POINTS_FOR_TRAINING = 100;
    uint256 public cognitionPointRatePerStakedADE = 10; // CP per day
    uint256 public cognitionClaimInterval = 1 days;

    // --- Counters for Tokens & Proposals ---
    Counters.Counter private _adeTokenIds;
    Counters.Counter private _adeptCoreTokenIds;
    Counters.Counter private _fragmentTokenIds;
    Counters.Counter private _proposalIds;

    // --- State Variables ---
    address public oracleAddress;
    string public contractBaseURI; // Base URI for ERC721 ADE metadata

    // --- ERC1155 for Adept Cores ---
    ERC1155 public adeptCores;

    // --- Structs ---

    // ADE (Adaptive Digital Entity) Attributes
    struct ADEAttributes {
        uint256[] values; // Dynamic attributes like Harmony, Innovation, Resilience
        string ipfsHash;  // IPFS hash for visual/detailed metadata
    }

    // Provenance record for an ADE's evolution
    struct ProvenanceEntry {
        bytes32 aiModelHash;
        string prompt;
        uint64 timestamp;
        string updateReason; // e.g., "genesis", "recalibration", "adept_core_applied"
    }

    // Governance Proposal
    struct Proposal {
        uint256 id;
        bytes32 paramKey;      // Identifier for the parameter to change
        bytes newValue;        // New value for the parameter
        string description;
        uint256 creationTime;
        uint256 totalVotesFor; // Total Cognition Points voted 'for'
        uint256 totalVotesAgainst; // Total Cognition Points voted 'against'
        mapping(address => bool) hasVoted; // Tracks if an address has voted
        bool executed;
        bool active;
    }

    // AI Model Registry
    struct AIModel {
        string description;
        address oracleAffiliate; // The oracle that certifies this model
        uint64 registrationTime;
    }

    // --- Mappings ---
    mapping(uint256 => ADEAttributes) public adeAttributes;
    mapping(uint256 => ProvenanceEntry[]) public adeProvenance; // ADE ID => list of provenance entries

    // Oracle Request Tracking
    mapping(bytes32 => uint256) public oracleRequestIdToTokenId; // Request ID => ADE Token ID
    mapping(bytes32 => address) public oracleRequestIdToRequester; // Request ID => Original requester
    mapping(uint256 => address) public pendingMintRequests; // TokenId (temp) => Requester address

    // Cognition Points
    mapping(address => uint256) public cognitionPoints;
    mapping(uint256 => uint64) public adeStakedTime; // ADE ID => Timestamp when staked for cognition
    mapping(uint256 => address) public cognitionDelegation; // ADE ID => delegated address
    mapping(uint256 => uint64) public cognitionDelegationEndTime; // ADE ID => delegation end time

    // Adept Cores (ERC1155 specific)
    mapping(uint256 => uint256[]) public adeptCoreAttributeBoosts; // Adept Core ID => array of attribute boosts

    // Temporal Locks
    mapping(uint256 => uint64) public adeLockEndTime; // ADE ID => Lock end timestamp

    // Governance Proposals
    mapping(uint256 => Proposal) public proposals;
    mapping(bytes32 => AIModel) public registeredAIModels; // AI Model Hash => AIModel data

    // Soul-bound Fragments (simplified non-transferable ERC721)
    mapping(uint256 => uint256) public fragmentToParentADE; // Fragment Token ID => Parent ADE Token ID
    mapping(uint256 => address) public fragmentOwner; // Fragment Token ID => Owner address
    mapping(uint256 => bool) public isFragmentBurned; // Fragment Token ID => True if burned

    // --- Events ---
    event AIDrivenGenesisRequested(bytes32 indexed requestId, address indexed requester, string seedPhrase);
    event ADEGenesisFulfilled(uint256 indexed tokenId, address indexed owner, string ipfsHash, bytes32 aiModelHash);
    event ADETrained(uint256 indexed tokenId, uint8 indexed attributeIndex, uint256 boostAmount);
    event AttributeRecalibrationRequested(bytes32 indexed requestId, uint256 indexed tokenId, string contextualPrompt);
    event AttributeRecalibrationFulfilled(uint256 indexed tokenId, string newIpfsHash, bytes32 aiModelHash);
    event ADEStakedForCognition(uint256 indexed tokenId, address indexed owner);
    event ADEUnstakedFromCognition(uint256 indexed tokenId, address indexed owner);
    event CognitionPointsClaimed(address indexed owner, uint256 amount);
    event CognitionDelegated(uint256 indexed tokenId, address indexed delegatee, uint64 duration);
    event CognitionDelegationRevoked(uint256 indexed tokenId);
    event AdeptCoreSynthesized(uint256 indexed coreId, address indexed creator, uint256[] boosts);
    event AdeptCoreApplied(uint256 indexed tokenId, uint256 indexed coreId, uint256 amount);
    event GenesisFragmentMinted(uint256 indexed fragmentTokenId, uint256 indexed parentADEId, address indexed recipient);
    event GenesisFragmentRedeemed(uint256 indexed fragmentTokenId, address indexed redeemer);
    event TemporalLockActivated(uint256 indexed tokenId, uint64 lockDuration, uint64 unlockTime);
    event IncentiveClaimedFromLock(uint256 indexed tokenId, uint256 amount);
    event ProposalCreated(uint256 indexed proposalId, bytes32 paramKey, bytes newValue, string description);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 votes);
    event ProposalExecuted(uint256 indexed proposalId);
    event AIModelRegistered(bytes32 indexed modelHash, string description, address oracleAffiliate);
    event AttributeCurveConfigured(uint8 indexed attributeIndex, uint256 maxVal, uint256 decayRate);
    event OracleAddressSet(address newOracle);
    event BaseURISet(string newURI);

    // --- Modifiers ---
    modifier onlyOracle() {
        require(msg.sender == oracleAddress, "NeuralGenesis: Only callable by the trusted oracle");
        _;
    }

    modifier onlyADEOwner(uint256 _tokenId) {
        require(_exists(_tokenId), "NeuralGenesis: Token does not exist");
        require(_ownerOf(_tokenId) == msg.sender, "NeuralGenesis: Not the owner of this ADE");
        _;
    }

    modifier onlyActiveADE(uint256 _tokenId) {
        require(adeLockEndTime[_tokenId] < block.timestamp, "NeuralGenesis: ADE is temporally locked");
        _;
    }

    constructor(address _oracleAddress, string memory _baseURI) ERC721("NeuralGenesis", "ADE") {
        oracleAddress = _oracleAddress;
        contractBaseURI = _baseURI;
        adeptCores = new ERC1155("https://neuralgenesis.xyz/adeptcores/{id}.json"); // Adept Cores will have their own metadata
    }

    // --- ERC721 Overrides (for ERC721Enumerable) ---
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        // Ensure ADE is not locked before transfer
        if (from != address(0) && to != address(0)) { // Only for actual transfers, not mint/burn
            require(adeLockEndTime[tokenId] < block.timestamp, "NeuralGenesis: Cannot transfer locked ADE");
            // If ADE is staked for cognition, unstake it automatically
            if (adeStakedTime[tokenId] > 0) {
                _unstakeADE(tokenId, from);
            }
            // Clear any delegations
            if (cognitionDelegation[tokenId] != address(0)) {
                delete cognitionDelegation[tokenId];
                delete cognitionDelegationEndTime[tokenId];
                emit CognitionDelegationRevoked(tokenId);
            }
        }
    }

    // --- Admin Functions (Ownable) ---

    /// @notice Sets the address of the trusted oracle.
    /// @param _newOracle The new address for the oracle.
    function setOracleAddress(address _newOracle) external onlyOwner {
        require(_newOracle != address(0), "NeuralGenesis: Oracle address cannot be zero");
        oracleAddress = _newOracle;
        emit OracleAddressSet(_newOracle);
    }

    /// @notice Registers a new AI model used by oracles, enhancing provenance.
    /// @param _modelHash A unique hash identifying the AI model (e.g., IPFS CID of its weights/config).
    /// @param _description A human-readable description of the AI model.
    /// @param _oracleAffiliate The address of the oracle that certifies this model.
    function registerAIModel(bytes32 _modelHash, string calldata _description, address _oracleAffiliate) external onlyOwner {
        require(registeredAIModels[_modelHash].registrationTime == 0, "NeuralGenesis: AI Model already registered");
        require(_oracleAffiliate != address(0), "NeuralGenesis: Oracle affiliate cannot be zero");
        registeredAIModels[_modelHash] = AIModel(_description, _oracleAffiliate, uint64(block.timestamp));
        emit AIModelRegistered(_modelHash, _description, _oracleAffiliate);
    }

    /// @notice Configures the behavior of a specific ADE attribute (e.g., max value, decay).
    /// @param _attributeIndex The index of the attribute to configure.
    /// @param _maxVal The maximum value this attribute can reach.
    /// @param _decayRate The rate at which the attribute naturally decays over time (placeholder for complex logic).
    function configureAttributeCurve(uint8 _attributeIndex, uint256 _maxVal, uint256 _decayRate) external onlyOwner {
        require(_attributeIndex < MAX_ATTRIBUTES, "NeuralGenesis: Invalid attribute index");
        // For demonstration, we just emit an event. Real logic would store these curves.
        emit AttributeCurveConfigured(_attributeIndex, _maxVal, _decayRate);
    }

    /// @notice Sets the base URI for ADE metadata.
    /// @param _newBaseURI The new base URI for ADE token URIs.
    function setBaseURI(string calldata _newBaseURI) external onlyOwner {
        contractBaseURI = _newBaseURI;
        emit BaseURISet(_newBaseURI);
    }

    // --- Core ADE Management & AI Integration ---

    /// @notice Initiates the minting of a new ADE, requesting AI-driven attribute generation.
    /// @param _seedPhrase A user-provided phrase to influence the AI's generation.
    /// @param _recipient The address that will receive the minted ADE.
    /// @return requestId The unique ID for the oracle request.
    function requestAIDrivenGenesis(string calldata _seedPhrase, address _recipient) external returns (bytes32 requestId) {
        require(_recipient != address(0), "NeuralGenesis: Recipient cannot be zero address");
        // Mocking an oracle request. In a real scenario, this would interact with Chainlink or similar.
        // For now, we simulate a request ID and map it.
        requestId = keccak256(abi.encodePacked(block.timestamp, msg.sender, _seedPhrase));
        oracleRequestIdToRequester[requestId] = _recipient;
        emit AIDrivenGenesisRequested(requestId, _recipient, _seedPhrase);
        // In a real integration, you'd call IOracle(oracleAddress).request(...) here.
    }

    /// @notice Oracle callback function to fulfill an ADE genesis request.
    /// @param _requestId The ID of the original oracle request.
    /// @param _tokenId The new unique token ID for the ADE.
    /// @param _initialAttributes An array of initial attribute values generated by AI.
    /// @param _ipfsHash The IPFS hash pointing to the ADE's metadata (image, detailed traits).
    /// @param _aiModelHash The hash of the AI model used for generation.
    function fulfillAIDrivenGenesis(
        bytes32 _requestId,
        uint256 _tokenId,
        uint256[] calldata _initialAttributes,
        string calldata _ipfsHash,
        bytes32 _aiModelHash
    ) external onlyOracle {
        address recipient = oracleRequestIdToRequester[_requestId];
        require(recipient != address(0), "NeuralGenesis: Unknown request ID or recipient");
        require(_initialAttributes.length <= MAX_ATTRIBUTES, "NeuralGenesis: Too many attributes");
        require(registeredAIModels[_aiModelHash].registrationTime > 0, "NeuralGenesis: Unregistered AI model hash");

        // Mint the ERC721 token
        _safeMint(recipient, _tokenId);
        _adeTokenIds.increment();

        // Store ADE attributes
        adeAttributes[_tokenId] = ADEAttributes({
            values: _initialAttributes,
            ipfsHash: _ipfsHash
        });

        // Record provenance
        adeProvenance[_tokenId].push(ProvenanceEntry({
            aiModelHash: _aiModelHash,
            prompt: "genesis_seed", // Can be the actual seed phrase or a hash of it
            timestamp: uint64(block.timestamp),
            updateReason: "genesis"
        }));

        delete oracleRequestIdToRequester[_requestId]; // Clean up request
        emit ADEGenesisFulfilled(_tokenId, recipient, _ipfsHash, _aiModelHash);
    }

    /// @notice Allows an ADE owner to directly influence and boost a specific attribute.
    /// Requires spending Cognition Points.
    /// @param _tokenId The ID of the ADE to train.
    /// @param _attributeIndex The index of the attribute to boost.
    /// @param _boostAmount The amount to increase the attribute by.
    function trainADE(uint256 _tokenId, uint8 _attributeIndex, uint256 _boostAmount) external onlyADEOwner(_tokenId) onlyActiveADE(_tokenId) {
        require(_attributeIndex < adeAttributes[_tokenId].values.length, "NeuralGenesis: Invalid attribute index");
        require(_boostAmount > 0, "NeuralGenesis: Boost amount must be positive");
        require(cognitionPoints[msg.sender] >= MIN_COGNITION_POINTS_FOR_TRAINING, "NeuralGenesis: Not enough Cognition Points to train");

        // Simple spend model: fixed amount per training session
        cognitionPoints[msg.sender] -= MIN_COGNITION_POINTS_FOR_TRAINING;

        uint256 currentVal = adeAttributes[_tokenId].values[_attributeIndex];
        uint256 newVal = currentVal + _boostAmount;
        adeAttributes[_tokenId].values[_attributeIndex] = newVal > MAX_ATTRIBUTE_VALUE ? MAX_ATTRIBUTE_VALUE : newVal;

        // Record training as provenance
        adeProvenance[_tokenId].push(ProvenanceEntry({
            aiModelHash: 0, // No AI model directly involved in this user action
            prompt: "user_training_action",
            timestamp: uint64(block.timestamp),
            updateReason: "training"
        }));

        emit ADETrained(_tokenId, _attributeIndex, _boostAmount);
    }

    /// @notice Requests the oracle to re-evaluate an ADE's attributes based on a new AI prompt.
    /// @param _tokenId The ID of the ADE to recalibrate.
    /// @param _contextualPrompt A new prompt to guide the AI for recalibration.
    /// @return requestId The unique ID for the oracle request.
    function requestAttributeRecalibration(uint256 _tokenId, string calldata _contextualPrompt) external onlyADEOwner(_tokenId) onlyActiveADE(_tokenId) returns (bytes32 requestId) {
        // Mocking an oracle request.
        requestId = keccak256(abi.encodePacked(block.timestamp, msg.sender, _tokenId, _contextualPrompt));
        oracleRequestIdToTokenId[requestId] = _tokenId;
        oracleRequestIdToRequester[requestId] = msg.sender; // Store requester for potential refund/notification
        emit AttributeRecalibrationRequested(requestId, _tokenId, _contextualPrompt);
        // IOracle(oracleAddress).request(...)
    }

    /// @notice Oracle callback function to update an ADE's attributes after recalibration.
    /// @param _requestId The ID of the original oracle request.
    /// @param _tokenId The ID of the ADE being recalibrated.
    /// @param _newAttributes An array of new attribute values generated by AI.
    /// @param _newIpfsHash The new IPFS hash for updated metadata.
    /// @param _aiModelHash The hash of the AI model used for recalibration.
    function fulfillAttributeRecalibration(
        bytes32 _requestId,
        uint256 _tokenId,
        uint256[] calldata _newAttributes,
        string calldata _newIpfsHash,
        bytes32 _aiModelHash
    ) external onlyOracle {
        require(oracleRequestIdToTokenId[_requestId] == _tokenId, "NeuralGenesis: Request ID does not match Token ID");
        require(_exists(_tokenId), "NeuralGenesis: ADE does not exist");
        require(_newAttributes.length == adeAttributes[_tokenId].values.length, "NeuralGenesis: Attribute count mismatch");
        require(registeredAIModels[_aiModelHash].registrationTime > 0, "NeuralGenesis: Unregistered AI model hash");

        adeAttributes[_tokenId].values = _newAttributes;
        adeAttributes[_tokenId].ipfsHash = _newIpfsHash;

        // Record provenance
        adeProvenance[_tokenId].push(ProvenanceEntry({
            aiModelHash: _aiModelHash,
            prompt: "recalibration_prompt", // Can be the actual prompt or a hash
            timestamp: uint64(block.timestamp),
            updateReason: "recalibration"
        }));

        delete oracleRequestIdToTokenId[_requestId];
        delete oracleRequestIdToRequester[_requestId];
        emit AttributeRecalibrationFulfilled(_tokenId, _newIpfsHash, _aiModelHash);
    }

    // --- Cognition Points & Reputation System ---

    /// @dev Internal function to calculate and claim pending Cognition Points.
    function _claimPendingCognitionPoints(address _owner) internal {
        uint256 numStakedADEs = 0;
        uint256 totalClaimable = 0;

        for (uint256 i = 0; i < totalSupply(); i++) {
            uint256 tokenId = tokenByIndex(i);
            if (_ownerOf(tokenId) == _owner && adeStakedTime[tokenId] > 0) {
                numStakedADEs++;
                uint64 lastClaimTime = adeStakedTime[tokenId]; // Use stake time as last claim for simplicity
                if (block.timestamp > lastClaimTime) {
                    uint256 elapsed = block.timestamp - lastClaimTime;
                    totalClaimable += (elapsed / cognitionClaimInterval) * cognitionPointRatePerStakedADE;
                    adeStakedTime[tokenId] = uint64(block.timestamp - (elapsed % cognitionClaimInterval)); // Update last claim time
                }
            }
        }
        if (totalClaimable > 0) {
            cognitionPoints[_owner] += totalClaimable;
            emit CognitionPointsClaimed(_owner, totalClaimable);
        }
    }


    /// @notice Stakes an ADE to start accruing Cognition Points for its owner.
    /// @param _tokenId The ID of the ADE to stake.
    function stakeADEForCognition(uint256 _tokenId) external onlyADEOwner(_tokenId) {
        require(adeStakedTime[_tokenId] == 0, "NeuralGenesis: ADE is already staked");
        _claimPendingCognitionPoints(msg.sender); // Claim any existing points before staking new one

        adeStakedTime[_tokenId] = uint64(block.timestamp);
        emit ADEStakedForCognition(_tokenId, msg.sender);
    }

    /// @notice Unstakes an ADE, stopping Cognition Point accrual.
    /// @param _tokenId The ID of the ADE to unstake.
    function unstakeADEFromCognition(uint256 _tokenId) external onlyADEOwner(_tokenId) {
        _unstakeADE(_tokenId, msg.sender);
    }

    /// @dev Internal helper for unstaking logic.
    function _unstakeADE(uint256 _tokenId, address _owner) internal {
        require(adeStakedTime[_tokenId] > 0, "NeuralGenesis: ADE is not staked");

        _claimPendingCognitionPoints(_owner); // Claim points before unstaking
        delete adeStakedTime[_tokenId];
        emit ADEUnstakedFromCognition(_tokenId, _owner);
    }

    /// @notice Allows an address to claim their accrued Cognition Points.
    /// @param _owner The address to claim points for. Can be `msg.sender` or a delegated address.
    function claimCognitionPoints(address _owner) external {
        if (msg.sender != _owner) {
            bool foundDelegation = false;
            for (uint256 i = 0; i < totalSupply(); i++) {
                uint256 tokenId = tokenByIndex(i);
                if (_ownerOf(tokenId) == _owner && cognitionDelegation[tokenId] == msg.sender && cognitionDelegationEndTime[tokenId] > block.timestamp) {
                    foundDelegation = true;
                    break;
                }
            }
            require(foundDelegation, "NeuralGenesis: Not authorized to claim for this address");
        }
        _claimPendingCognitionPoints(_owner);
    }

    /// @notice Delegates the ability to claim Cognition Points generated by a specific ADE to another address for a duration.
    /// @param _tokenId The ID of the ADE whose points are being delegated.
    /// @param _delegatee The address to delegate claim rights to.
    /// @param _duration The duration in seconds for which the delegation is active.
    function delegateCognition(uint256 _tokenId, address _delegatee, uint64 _duration) external onlyADEOwner(_tokenId) {
        require(_delegatee != address(0), "NeuralGenesis: Delegatee cannot be zero address");
        require(_duration > 0, "NeuralGenesis: Delegation duration must be positive");
        
        cognitionDelegation[_tokenId] = _delegatee;
        cognitionDelegationEndTime[_tokenId] = uint64(block.timestamp) + _duration;
        emit CognitionDelegated(_tokenId, _delegatee, _duration);
    }

    /// @notice Revokes an active Cognition Point delegation for a specific ADE.
    /// @param _tokenId The ID of the ADE whose delegation is being revoked.
    function revokeCognitionDelegation(uint256 _tokenId) external onlyADEOwner(_tokenId) {
        require(cognitionDelegation[_tokenId] != address(0), "NeuralGenesis: No active delegation for this ADE");
        
        delete cognitionDelegation[_tokenId];
        delete cognitionDelegationEndTime[_tokenId];
        emit CognitionDelegationRevoked(_tokenId);
    }

    // --- Advanced ADE Interactions & Crafting ---

    /// @notice Burns multiple source ADEs to create a new "Adept Core" (ERC1155 token) with aggregated attribute boosts.
    /// @param _sourceADETokenIds An array of ADE token IDs to burn.
    /// @param _coreDescription A description for the new Adept Core.
    /// @return coreId The ID of the newly minted Adept Core.
    function synthesizeAdeptCore(uint256[] calldata _sourceADETokenIds, string calldata _coreDescription) external returns (uint256 coreId) {
        require(_sourceADETokenIds.length >= 2, "NeuralGenesis: At least two ADEs are required to synthesize an Adept Core");
        
        uint256[] memory boosts = new uint256[](MAX_ATTRIBUTES);

        for (uint256 i = 0; i < _sourceADETokenIds.length; i++) {
            uint256 tokenId = _sourceADETokenIds[i];
            require(_ownerOf(tokenId) == msg.sender, "NeuralGenesis: Not owner of source ADE");
            require(adeLockEndTime[tokenId] < block.timestamp, "NeuralGenesis: Source ADE is locked");

            // Aggregate attributes for the boost
            for (uint8 j = 0; j < adeAttributes[tokenId].values.length; j++) {
                boosts[j] += adeAttributes[tokenId].values[j] / 5; // Example: 20% of attribute value becomes boost
            }

            // Burn the source ADE
            _burn(tokenId);
        }

        coreId = _adeptCoreTokenIds.current();
        _adeptCoreTokenIds.increment();

        // Mint 1 Adept Core ERC1155 token
        adeptCores.mint(msg.sender, coreId, 1, "");
        adeptCoreAttributeBoosts[coreId] = boosts; // Store boosts for the core

        emit AdeptCoreSynthesized(coreId, msg.sender, boosts);
    }

    /// @notice Applies an Adept Core to a target ADE, permanently enhancing its attributes. Consumes the Adept Core.
    /// @param _tokenId The ID of the ADE to enhance.
    /// @param _coreId The ID of the Adept Core to apply.
    /// @param _amount The amount of Adept Core to apply (usually 1).
    function applyAdeptCore(uint256 _tokenId, uint256 _coreId, uint256 _amount) external onlyADEOwner(_tokenId) onlyActiveADE(_tokenId) {
        require(_amount == 1, "NeuralGenesis: Only one Adept Core can be applied at a time");
        require(adeptCores.balanceOf(msg.sender, _coreId) >= _amount, "NeuralGenesis: Not enough Adept Cores");
        
        uint256[] memory boosts = adeptCoreAttributeBoosts[_coreId];
        require(boosts.length > 0, "NeuralGenesis: Invalid Adept Core or no boosts defined");

        // Apply boosts to the target ADE
        for (uint8 i = 0; i < boosts.length; i++) {
            if (i < adeAttributes[_tokenId].values.length) {
                uint256 currentVal = adeAttributes[_tokenId].values[i];
                uint256 newVal = currentVal + boosts[i];
                adeAttributes[_tokenId].values[i] = newVal > MAX_ATTRIBUTE_VALUE ? MAX_ATTRIBUTE_VALUE : newVal;
            }
        }

        // Burn the Adept Core
        adeptCores.burn(msg.sender, _coreId, _amount);
        delete adeptCoreAttributeBoosts[_coreId]; // Core is consumed

        // Record provenance
        adeProvenance[_tokenId].push(ProvenanceEntry({
            aiModelHash: 0, // No AI model directly involved
            prompt: string(abi.encodePacked("adept_core_applied_", Strings.toString(_coreId))),
            timestamp: uint64(block.timestamp),
            updateReason: "adept_core_applied"
        }));

        emit AdeptCoreApplied(_tokenId, _coreId, _amount);
    }

    /// @notice Mints a non-transferable "Genesis Fragment" (Soul-bound ERC721) representing a snapshot of the parent ADE.
    /// @param _tokenId The ID of the parent ADE.
    /// @param _recipient The address to mint the fragment to.
    /// @return fragmentTokenId The ID of the newly minted fragment.
    function mintGenesisFragment(uint256 _tokenId, address _recipient) external onlyADEOwner(_tokenId) returns (uint256 fragmentTokenId) {
        require(_recipient != address(0), "NeuralGenesis: Recipient cannot be zero");

        fragmentTokenId = _fragmentTokenIds.current();
        _fragmentTokenIds.increment();

        fragmentToParentADE[fragmentTokenId] = _tokenId;
        fragmentOwner[fragmentTokenId] = _recipient;

        // Note: For a true SBT, you'd ensure transfer functions revert, or use a custom ERC721 with that logic.
        // For this exercise, we're simplifying by just setting ownership and preventing transfers via mapping.
        emit GenesisFragmentMinted(fragmentTokenId, _tokenId, _recipient);
    }

    /// @notice Burns a Genesis Fragment, potentially triggering a small benefit or recording a completed task.
    /// @param _fragmentTokenId The ID of the fragment to redeem.
    function redeemGenesisFragment(uint256 _fragmentTokenId) external {
        require(fragmentOwner[_fragmentTokenId] == msg.sender, "NeuralGenesis: Not the owner of this fragment");
        require(!isFragmentBurned[_fragmentTokenId], "NeuralGenesis: Fragment already redeemed");

        isFragmentBurned[_fragmentTokenId] = true;
        // Logic for benefits upon redemption (e.g., small CP boost, unlock a feature)
        cognitionPoints[msg.sender] += 50; // Example benefit

        delete fragmentOwner[_fragmentTokenId]; // No longer owned
        // Do not delete fragmentToParentADE to keep the provenance link
        emit GenesisFragmentRedeemed(_fragmentTokenId, msg.sender);
    }
    
    /// @notice Temporarily locks an ADE from transfers and major modifications, granting enhanced benefits.
    /// @param _tokenId The ID of the ADE to lock.
    /// @param _lockDuration The duration in seconds for which the ADE will be locked.
    function activateTemporalLock(uint256 _tokenId, uint64 _lockDuration) external onlyADEOwner(_tokenId) {
        require(_lockDuration > 0, "NeuralGenesis: Lock duration must be positive");
        require(adeLockEndTime[_tokenId] < block.timestamp, "NeuralGenesis: ADE is already locked");
        
        adeLockEndTime[_tokenId] = uint64(block.timestamp) + _lockDuration;
        // Optionally, reset staked time to start boosted CP generation
        if (adeStakedTime[_tokenId] > 0) {
            _claimPendingCognitionPoints(msg.sender); // Claim points before boosting period starts
            adeStakedTime[_tokenId] = uint64(block.timestamp); // Reset stake time to apply boosted rate
        }

        emit TemporalLockActivated(_tokenId, _lockDuration, adeLockEndTime[_tokenId]);
    }

    /// @notice Allows claiming benefits (e.g., bonus Cognition Points) from an ADE that has been under a temporal lock.
    /// Benefits accrue during the lock period.
    /// @param _tokenId The ID of the ADE to claim incentives from.
    function claimIncentiveFromLock(uint256 _tokenId) external onlyADEOwner(_tokenId) {
        require(adeLockEndTime[_tokenId] < block.timestamp, "NeuralGenesis: ADE is still locked");
        
        // This is a simplified example. A real implementation would track accrued incentives.
        // For demonstration, let's say a locked ADE generates 2x CP.
        // We'd need to adjust _claimPendingCognitionPoints or have separate logic.
        // For simplicity, let's grant a one-time bonus upon unlock.
        
        uint64 lockStart = 0; // Need to track when lock started, not just end
        // For this demo, let's assume `adeStakedTime` could be repurposed or a new mapping added.
        // If we adjust cognitionPointRatePerStakedADE internally, this function might be redundant.
        // For this demo, we'll give a fixed bonus.
        
        // Example: If an ADE was locked, give a bonus upon unlock after the first claim of regular CPs.
        // More robust would be to track "boosted" CP generation during the lock period.
        uint256 bonus = 0;
        // Assuming a simple bonus if the ADE was successfully locked and unlocked.
        // This part needs more detailed state tracking for robust rewards.
        // For now, let's use a placeholder.
        if (adeStakedTime[_tokenId] > 0) { // If it was staked before or during lock
            bonus = (block.timestamp - adeStakedTime[_tokenId]) / (1 days) * (cognitionPointRatePerStakedADE / 2); // 50% bonus over locked period
        }
        
        if (bonus > 0) {
            cognitionPoints[msg.sender] += bonus;
            emit IncentiveClaimedFromLock(_tokenId, bonus);
        } else {
            revert("NeuralGenesis: No incentives to claim from this lock.");
        }
        
        // Reset adeStakedTime if the bonus was tied to locked duration
        adeStakedTime[_tokenId] = uint64(block.timestamp);
    }

    // --- On-Chain Governance ---

    /// @notice Allows Cognition Point holders to propose changes to system parameters.
    /// @param _paramKey A unique identifier for the parameter (e.g., keccak256("cognitionPointRate")).
    /// @param _newValue The new value for the parameter, encoded as bytes.
    /// @param _description A human-readable description of the proposed change.
    /// @return proposalId The ID of the newly created proposal.
    function proposeEvolutionParameter(bytes32 _paramKey, bytes calldata _newValue, string calldata _description) external returns (uint256 proposalId) {
        require(cognitionPoints[msg.sender] > 0, "NeuralGenesis: Must have Cognition Points to propose"); // Or a minimum threshold
        
        proposalId = _proposalIds.current();
        _proposalIds.increment();

        proposals[proposalId] = Proposal({
            id: proposalId,
            paramKey: _paramKey,
            newValue: _newValue,
            description: _description,
            creationTime: block.timestamp,
            totalVotesFor: 0,
            totalVotesAgainst: 0,
            executed: false,
            active: true
        });

        emit ProposalCreated(proposalId, _paramKey, _newValue, _description);
    }

    /// @notice Casts a vote on an active proposal using accrued Cognition Points.
    /// @param _proposalId The ID of the proposal to vote on.
    /// @param _support True for 'for', false for 'against'.
    function voteOnEvolutionProposal(uint256 _proposalId, bool _support) external {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.active, "NeuralGenesis: Proposal is not active");
        require(!proposal.hasVoted[msg.sender], "NeuralGenesis: Already voted on this proposal");
        require(cognitionPoints[msg.sender] > 0, "NeuralGenesis: Must have Cognition Points to vote");

        if (_support) {
            proposal.totalVotesFor += cognitionPoints[msg.sender];
        } else {
            proposal.totalVotesAgainst += cognitionPoints[msg.sender];
        }
        proposal.hasVoted[msg.sender] = true;

        emit VoteCast(_proposalId, msg.sender, _support, cognitionPoints[msg.sender]);
    }

    /// @notice Executes a proposal that has met the voting quorum and threshold.
    /// @param _proposalId The ID of the proposal to execute.
    function executeEvolutionProposal(uint256 _proposalId) external onlyOwner { // Only owner can execute for simplicity. A DAO would have complex execution logic.
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.active, "NeuralGenesis: Proposal not active");
        require(!proposal.executed, "NeuralGenesis: Proposal already executed");

        // Example quorum/threshold (simplified: >50% of positive votes)
        require(proposal.totalVotesFor > proposal.totalVotesAgainst, "NeuralGenesis: Proposal did not pass");

        // Apply the proposed parameter change
        bytes32 paramKey = proposal.paramKey;
        if (paramKey == keccak256("cognitionPointRate")) {
            cognitionPointRatePerStakedADE = abi.decode(proposal.newValue, (uint256));
        }
        // Add more `if` conditions for other parameters

        proposal.executed = true;
        proposal.active = false; // Deactivate after execution

        emit ProposalExecuted(_proposalId);
    }

    // --- View Functions ---

    /// @dev See {ERC721-tokenURI}.
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory base = contractBaseURI;
        string memory ipfsHash = adeAttributes[tokenId].ipfsHash;
        
        if (bytes(ipfsHash).length > 0) {
            return string(abi.encodePacked("ipfs://", ipfsHash));
        } else if (bytes(base).length > 0) {
            return string(abi.encodePacked(base, tokenId.toString()));
        }
        return "";
    }

    /// @notice Retrieves the current attributes of a specific ADE.
    /// @param _tokenId The ID of the ADE.
    /// @return values An array of attribute values.
    /// @return ipfsHash The IPFS hash for the ADE's metadata.
    function getADEAttributes(uint256 _tokenId) public view returns (uint256[] memory values, string memory ipfsHash) {
        require(_exists(_tokenId), "NeuralGenesis: ADE does not exist");
        return (adeAttributes[_tokenId].values, adeAttributes[_tokenId].ipfsHash);
    }

    /// @notice Retrieves the full provenance history of an ADE.
    /// @param _tokenId The ID of the ADE.
    /// @return history An array of ProvenanceEntry structs.
    function getADEProvenance(uint256 _tokenId) public view returns (ProvenanceEntry[] memory history) {
        require(_exists(_tokenId), "NeuralGenesis: ADE does not exist");
        return adeProvenance[_tokenId];
    }

    /// @notice Estimates an ADE's "intrinsic" value based on its attributes, age, and provenance.
    /// This is a simplified on-chain calculation. A real system might involve external oracle for more complex valuation.
    /// @param _tokenId The ID of the ADE.
    /// @return estimatedValue The estimated value in a generic unit.
    function calculateCurrentADEValue(uint256 _tokenId) public view returns (uint256 estimatedValue) {
        require(_exists(_tokenId), "NeuralGenesis: ADE does not exist");

        uint256 totalAttributeScore = 0;
        for (uint256 i = 0; i < adeAttributes[_tokenId].values.length; i++) {
            totalAttributeScore += adeAttributes[_tokenId].values[i];
        }

        uint256 ageInDays = (block.timestamp - block.timestamp) / 1 days; // Placeholder: ADE creation time needed
        if (adeProvenance[_tokenId].length > 0) {
             ageInDays = (block.timestamp - adeProvenance[_tokenId][0].timestamp) / 1 days;
        }

        uint256 provenanceBonus = adeProvenance[_tokenId].length * 10; // More history = more value
        
        estimatedValue = (totalAttributeScore * 10) + (ageInDays * 5) + provenanceBonus;
        return estimatedValue;
    }

    /// @notice Returns the amount of Cognition Points held by an address.
    /// @param _addr The address to query.
    /// @return points The current Cognition Points balance.
    function getCognitionPoints(address _addr) public view returns (uint256 points) {
        return cognitionPoints[_addr];
    }

    /// @notice Returns information about a specific governance proposal.
    /// @param _proposalId The ID of the proposal.
    /// @return id The proposal ID.
    /// @return paramKey The key of the parameter.
    /// @return newValue The proposed new value.
    /// @return description The proposal description.
    /// @return creationTime The creation timestamp.
    /// @return totalVotesFor Total 'for' votes.
    /// @return totalVotesAgainst Total 'against' votes.
    /// @return executed Whether the proposal has been executed.
    /// @return active Whether the proposal is still active.
    function getProposal(uint256 _proposalId)
        public
        view
        returns (
            uint256 id,
            bytes32 paramKey,
            bytes memory newValue,
            string memory description,
            uint256 creationTime,
            uint256 totalVotesFor,
            uint256 totalVotesAgainst,
            bool executed,
            bool active
        )
    {
        Proposal storage p = proposals[_proposalId];
        return (
            p.id,
            p.paramKey,
            p.newValue,
            p.description,
            p.creationTime,
            p.totalVotesFor,
            p.totalVotesAgainst,
            p.executed,
            p.active
        );
    }

    /// @notice Check if an address has voted on a proposal.
    /// @param _proposalId The ID of the proposal.
    /// @param _voter The address to check.
    /// @return hasVoted True if the address has voted, false otherwise.
    function hasVotedOnProposal(uint256 _proposalId, address _voter) public view returns (bool) {
        return proposals[_proposalId].hasVoted[_voter];
    }

    /// @notice Returns information about a registered AI model.
    /// @param _modelHash The hash of the AI model.
    /// @return description The model's description.
    /// @return oracleAffiliate The oracle address that registered the model.
    /// @return registrationTime The timestamp of registration.
    function getAIModelInfo(bytes32 _modelHash) public view returns (string memory description, address oracleAffiliate, uint64 registrationTime) {
        AIModel storage model = registeredAIModels[_modelHash];
        return (model.description, model.oracleAffiliate, model.registrationTime);
    }
    
    // --- Soul-bound Fragment specific views ---

    /// @notice Returns the parent ADE token ID for a given fragment.
    /// @param _fragmentTokenId The ID of the fragment.
    /// @return parentADEId The ID of the parent ADE.
    function getFragmentParentADE(uint256 _fragmentTokenId) public view returns (uint256 parentADEId) {
        return fragmentToParentADE[_fragmentTokenId];
    }

    /// @notice Returns the owner of a fragment (if not burned).
    /// @param _fragmentTokenId The ID of the fragment.
    /// @return owner The owner's address.
    function getFragmentOwner(uint256 _fragmentTokenId) public view returns (address owner) {
        require(!isFragmentBurned[_fragmentTokenId], "NeuralGenesis: Fragment has been redeemed/burned");
        return fragmentOwner[_fragmentTokenId];
    }

    /// @notice Checks if a fragment has been burned.
    /// @param _fragmentTokenId The ID of the fragment.
    /// @return burned True if burned, false otherwise.
    function isFragmentBurned(uint256 _fragmentTokenId) public view returns (bool burned) {
        return isFragmentBurned[_fragmentTokenId];
    }

    /// @notice Returns the current lock end time for an ADE.
    /// @param _tokenId The ID of the ADE.
    /// @return unlockTime The timestamp when the lock expires.
    function getADETemporalLockEndTime(uint256 _tokenId) public view returns (uint64 unlockTime) {
        return adeLockEndTime[_tokenId];
    }
}
```