Okay, here is a Solidity smart contract incorporating various advanced, creative, and trendy concepts like dynamic assets, time-based interactions, resource management, delegation, and a simplified on-chain governance mechanism for parameter tuning.

It's designed as a kind of "digital ecosystem" where users manage unique "Nodes" and "Modules," interact with them over time, and potentially influence the system's parameters.

**Disclaimer:** This is a complex example for illustrative purposes. Deploying a contract of this complexity requires extensive security audits, testing, and careful consideration of gas costs and potential attack vectors. The governance mechanism is very simplified.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title CryptoNexus
 * @dev A smart contract managing dynamic digital assets (Nodes & Modules),
 *      time-based interactions, resource generation, delegation, and simple governance.
 *      Nodes are dynamic assets with properties like level, power, and attached modules.
 *      Modules are enhancements that can be attached to Nodes.
 *      Users manage 'EnergyUnits' (internal resource) generated by 'energizing' Nodes.
 *      Parameters of the system can be adjusted via a simple owner-led proposal/voting system.
 *      Includes delegation of Node actions and internal fee collection.
 *
 * Outline:
 * 1. Errors
 * 2. Events
 * 3. Enums
 * 4. Structs (Node, Module, Proposal)
 * 5. State Variables (Counters, Mappings, Parameters, Owner, Paused State)
 * 6. Modifiers (onlyOwner, whenNotPaused, whenPaused, onlyNodeOwnerOrDelegated)
 * 7. Constructor
 * 8. Admin/Control Functions (transferOwnership, pause, unpause, withdrawFees, setParameters)
 * 9. Node Management Functions (mintNode, upgradeNode, transferNode, burnNode, getNodeDetails, getUserNodes)
 * 10. Module Management Functions (mintModule, transferModule, getModuleDetails, getUserModules)
 * 11. Node-Module Interaction Functions (attachModuleToNode, detachModuleFromNode, getNodeAttachedModules)
 * 12. Dynamic Interaction Functions (energizeNode, combineNodes, stakeNode, unstakeNode)
 * 13. Resource/Utility Functions (getUserEnergyUnits, convertEtherToEnergy)
 * 14. Delegation Functions (delegateNodeAction, revokeNodeDelegation, getNodeDelegate)
 * 15. Governance Functions (createParameterProposal, voteOnProposal, executeProposal)
 * 16. View/Pure Helper Functions
 */

// 1. Errors
error CryptoNexus__NotOwner();
error CryptoNexus__Paused();
error CryptoNexus__NotPaused();
error CryptoNexus__NodeNotFound(uint256 nodeId);
error CryptoNexus__ModuleNotFound(uint256 moduleId);
error CryptoNexus__NotNodeOwner(uint256 nodeId, address caller);
error CryptoNexus__NotModuleOwner(uint256 moduleId, address caller);
error CryptoNexus__InsufficientEnergy(address caller, uint256 required, uint256 available);
error CryptoNexus__EnergizeCooldownNotPassed(uint256 nodeId, uint256 timeRemaining);
error CryptoNexus__ModuleAlreadyAttached(uint256 moduleId, uint256 existingNodeId);
error CryptoNexus__ModuleNotAttached(uint256 moduleId);
error CryptoNexus__NodeCapacityReached(uint256 nodeId);
error CryptoNexus__ModuleNotAttachedToNode(uint256 moduleId, uint256 nodeId);
error CryptoNexus__InvalidModuleType();
error CryptoNexus__NodeAlreadyStaked(uint256 nodeId);
error CryptoNexus__NodeNotStaked(uint256 nodeId);
error CryptoNexus__CannotCombineInsufficientNodes(uint256 required, uint256 provided);
error CryptoNexus__CannotCombineMismatchedOwnership();
error CryptoNexus__CombineNodesBurned(uint256 nodeId);
error CryptoNexus__CombineFailedToMintNewNode(); // Should not happen if internal mintNode works
error CryptoNexus__SelfDelegation();
error CryptoNexus__NodeAlreadyDelegatedToAddress(uint256 nodeId, address delegatee);
error CryptoNexus__NodeNotDelegatedToAddress(uint256 nodeId, address delegatee);
error CryptoNexus__ProposalNotFound(uint256 proposalId);
error CryptoNexus__ProposalNotActive(uint256 proposalId);
error CryptoNexus__AlreadyVoted(uint256 proposalId, address voter);
error CryptoNexus__ProposalNotEnded(uint256 proposalId);
error CryptoNexus__ProposalAlreadyExecuted(uint256 proposalId);
error CryptoNexus__ProposalDidNotPass(uint256 proposalId);
error CryptoNexus__InsufficientVotes(uint256 yesVotes, uint256 threshold);
error CryptoNexus__InvalidParameterIndex(uint8 paramIndex);

// 2. Events
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
event ContractPaused(address account);
event ContractUnpaused(address account);
event FeesWithdrawn(address indexed recipient, uint256 amount);

event NodeMinted(uint256 indexed nodeId, address indexed owner, uint256 level, uint256 powerScore);
event NodeUpgraded(uint256 indexed nodeId, uint256 newLevel, uint256 newPowerScore, uint256 energyCost);
event NodeTransferred(uint256 indexed nodeId, address indexed from, address indexed to);
event NodeBurned(uint256 indexed nodeId, address indexed owner);
event NodeEnergized(uint256 indexed nodeId, address indexed energizer, uint256 energyGenerated);
event NodesCombined(uint256[] indexed burnedNodeIds, uint256 indexed newNodeId, address indexed owner);
event NodeStaked(uint256 indexed nodeId, address indexed owner);
event NodeUnstaked(uint256 indexed nodeId, address indexed owner);

event ModuleMinted(uint256 indexed moduleId, address indexed owner, uint256 moduleType, uint256 powerBonus);
event ModuleTransferred(uint256 indexed moduleId, address indexed from, address indexed to);
event ModuleAttached(uint256 indexed moduleId, uint256 indexed nodeId);
event ModuleDetached(uint256 indexed moduleId, uint256 indexed nodeId);

event EnergyUnitsGranted(address indexed user, uint256 amount);
event EnergyUnitsSpent(address indexed user, uint256 amount);
event EtherConvertedToEnergy(address indexed user, uint256 etherAmount, uint256 energyAmount);

event NodeActionDelegated(uint256 indexed nodeId, address indexed delegator, address indexed delegatee);
event NodeActionRevoked(uint256 indexed nodeId, address indexed delegator, address indexed delegatee);

event ParameterProposalCreated(uint256 indexed proposalId, address indexed creator, string description, uint8 parameterIndex, uint256 newValue, uint256 endTime);
event VoteCast(uint256 indexed proposalId, address indexed voter, bool vote); // true for yes, false for no
event ProposalExecuted(uint256 indexed proposalId);
event ParameterChangedByProposal(uint8 indexed parameterIndex, uint256 indexed oldValue, uint256 indexed newValue);


// 3. Enums
enum ModuleType { POWER, EFFICIENCY, FORTUNE } // Example module types

// 4. Structs
struct Node {
    uint256 id;
    address owner;
    uint256 level;
    uint256 powerScore;
    uint256 creationTime;
    uint256 lastEnergizedTime;
    uint256[] attachedModules; // List of attached module IDs
    bool isStaked;
    bool isBurned; // Nodes are marked burned instead of deleted
    address delegatee; // Address allowed to perform actions like energize
}

struct Module {
    uint256 id;
    address owner;
    ModuleType moduleType;
    uint256 powerBonus; // Bonus power it grants to a node
    uint256 attachedToNode; // Node ID it's attached to (0 if not attached)
    bool isBurned; // Modules can be marked burned
}

struct Proposal {
    uint256 id;
    string description;
    uint8 parameterIndex; // Index of the parameter to change (corresponds to PARAMETER_NAMES)
    uint256 newValue;     // The proposed new value
    uint256 endTime;
    uint256 yesVotes;
    uint256 noVotes;
    bool executed;
    bool active; // To prevent voting after execution or cancellation

    // Mapping to track who has voted. Consider a more gas-efficient structure for large scale.
    mapping(address => bool) voted;
}

// 5. State Variables
address private _owner;
bool private _paused;

uint256 private _nextNodeId = 1;
uint256 private _nextModuleId = 1;
uint256 private _nextProposalId = 1;

// Core data storage
mapping(uint255 => Node) private s_nodes; // Use uint255 to potentially save a tiny bit on storage slots if 2^256 is never reached
mapping(uint255 => Module) private s_modules;
mapping(address => uint256) private s_userEnergyUnits;
mapping(address => uint256[]) private s_userNodes; // Store array of Node IDs for each user
mapping(address => uint256[]) private s_userModules; // Store array of Module IDs for each user
mapping(uint256 => Proposal) private s_proposals;

// System Parameters (adjustable via governance)
uint256[] public s_systemParameters;
// Index mapping for parameters:
uint8 private constant PARAM_NODE_MINT_ENERGY_COST = 0;
uint8 private constant PARAM_NODE_UPGRADE_ENERGY_COST_PER_LEVEL = 1;
uint8 private constant PARAM_ENERGIZED_ENERGY_PER_LEVEL_PER_HOUR = 2;
uint8 private constant PARAM_ENERGIZED_COOLDOWN_SECONDS = 3;
uint8 private constant PARAM_COMBINE_NODE_COUNT_REQUIRED = 4;
uint8 private constant PARAM_COMBINE_ENERGY_COST = 5;
uint8 private constant PARAM_MIN_PROPOSAL_VOTES_FOR_EXECUTION = 6; // Minimum 'yes' votes required
uint8 private constant PARAM_PROPOSAL_VOTING_PERIOD_SECONDS = 7;
uint8 private constant PARAM_ETHER_TO_ENERGY_RATIO = 8; // How much energy per wei of ether
uint8 private constant PARAM_NODE_MODULE_CAPACITY = 9; // How many modules a node can hold

// For clearer parameter identification in proposals/events
string[] public PARAMETER_NAMES = [
    "NodeMintEnergyCost",
    "NodeUpgradeEnergyCostPerLevel",
    "EnergizedEnergyPerLevelPerHour",
    "EnergizedCooldownSeconds",
    "CombineNodeCountRequired",
    "CombineEnergyCost",
    "MinProposalVotesForExecution",
    "ProposalVotingPeriodSeconds",
    "EtherToEnergyRatio",
    "NodeModuleCapacity"
];

// 6. Modifiers
modifier onlyOwner() {
    if (msg.sender != _owner) revert CryptoNexus__NotOwner();
    _;
}

modifier whenNotPaused() {
    if (_paused) revert CryptoNexus__Paused();
    _;
}

modifier whenPaused() {
    if (!_paused) revert CryptoNexus__NotPaused();
    _;
}

modifier onlyNodeOwnerOrDelegated(uint256 _nodeId) {
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender && node.delegatee != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender); // Revert if not owner OR delegatee
    if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId); // Cannot interact with burned nodes
    _;
}

// 7. Constructor
constructor() {
    _owner = msg.sender;
    _paused = false;

    // Initialize system parameters (example values)
    s_systemParameters.push(500);   // PARAM_NODE_MINT_ENERGY_COST
    s_systemParameters.push(100);  // PARAM_NODE_UPGRADE_ENERGY_COST_PER_LEVEL
    s_systemParameters.push(1);    // PARAM_ENERGIZED_ENERGY_PER_LEVEL_PER_HOUR (1 Energy per level per hour)
    s_systemParameters.push(1 days); // PARAM_ENERGIZED_COOLDOWN_SECONDS (1 day cooldown)
    s_systemParameters.push(2);    // PARAM_COMBINE_NODE_COUNT_REQUIRED
    s_systemParameters.push(1000); // PARAM_COMBINE_ENERGY_COST
    s_systemParameters.push(5);    // PARAM_MIN_PROPOSAL_VOTES_FOR_EXECUTION
    s_systemParameters.push(7 days); // PARAM_PROPOSAL_VOTING_PERIOD_SECONDS
    s_systemParameters.push(1000); // PARAM_ETHER_TO_ENERGY_RATIO (1 wei Ether -> 1000 Energy)
    s_systemParameters.push(2);    // PARAM_NODE_MODULE_CAPACITY
}

// 8. Admin/Control Functions
/**
 * @dev Transfers ownership of the contract to a new address.
 * @param newOwner The address to transfer ownership to.
 */
function transferOwnership(address newOwner) external onlyOwner {
    require(newOwner != address(0), "New owner is the zero address");
    address oldOwner = _owner;
    _owner = newOwner;
    emit OwnershipTransferred(oldOwner, newOwner);
}

/**
 * @dev Pauses the contract, preventing most state-changing operations.
 *      Only owner functions and view functions remain accessible.
 */
function pauseContract() external onlyOwner whenNotPaused {
    _paused = true;
    emit ContractPaused(msg.sender);
}

/**
 * @dev Unpauses the contract, allowing normal operations.
 */
function unpauseContract() external onlyOwner whenPaused {
    _paused = false;
    emit ContractUnpaused(msg.sender);
}

/**
 * @dev Allows the owner to withdraw accumulated Ether (from convertEtherToEnergy).
 * @param recipient The address to send the Ether to.
 */
function withdrawFees(address payable recipient) external onlyOwner {
    uint256 amount = address(this).balance;
    require(amount > 0, "No Ether to withdraw");
    (bool success, ) = recipient.call{value: amount}("");
    require(success, "Ether withdrawal failed");
    emit FeesWithdrawn(recipient, amount);
}

/**
 * @dev Owner-only function to set a system parameter directly (bypassing governance).
 *      Intended for initial setup or emergency changes. Use governance for normal updates.
 * @param parameterIndex Index of the parameter to change.
 * @param newValue The new value for the parameter.
 */
function setSystemParameter(uint8 parameterIndex, uint256 newValue) external onlyOwner {
    if (parameterIndex >= s_systemParameters.length) revert CryptoNexus__InvalidParameterIndex(parameterIndex);
    uint256 oldValue = s_systemParameters[parameterIndex];
    s_systemParameters[parameterIndex] = newValue;
    emit ParameterChangedByProposal(parameterIndex, oldValue, newValue); // Re-use event for logging
}

// 9. Node Management Functions
/**
 * @dev Mints a new Node for the caller. Requires EnergyUnits.
 */
function mintNode() external whenNotPaused {
    uint256 mintCost = s_systemParameters[PARAM_NODE_MINT_ENERGY_COST];
    if (s_userEnergyUnits[msg.sender] < mintCost) {
        revert CryptoNexus__InsufficientEnergy(msg.sender, mintCost, s_userEnergyUnits[msg.sender]);
    }

    s_userEnergyUnits[msg.sender] -= mintCost;
    emit EnergyUnitsSpent(msg.sender, mintCost);

    uint256 nodeId = _nextNodeId++;
    s_nodes[nodeId] = Node({
        id: nodeId,
        owner: msg.sender,
        level: 1,
        powerScore: 100, // Initial power
        creationTime: block.timestamp,
        lastEnergizedTime: block.timestamp, // Can energize immediately after mint
        attachedModules: new uint256[](0),
        isStaked: false,
        isBurned: false,
        delegatee: address(0)
    });

    s_userNodes[msg.sender].push(nodeId);

    emit NodeMinted(nodeId, msg.sender, s_nodes[nodeId].level, s_nodes[nodeId].powerScore);
}

/**
 * @dev Upgrades a Node, increasing its level and power. Requires EnergyUnits.
 * @param _nodeId The ID of the Node to upgrade.
 */
function upgradeNode(uint256 _nodeId) external whenNotPaused onlyNodeOwnerOrDelegated(_nodeId) {
    Node storage node = s_nodes[_nodeId];
    uint256 upgradeCost = s_systemParameters[PARAM_NODE_UPGRADE_ENERGY_COST_PER_LEVEL] * node.level; // Cost increases with level

    if (s_userEnergyUnits[msg.sender] < upgradeCost) {
         revert CryptoNexus__InsufficientEnergy(msg.sender, upgradeCost, s_userEnergyUnits[msg.sender]);
    }

    s_userEnergyUnits[msg.sender] -= upgradeCost;
    emit EnergyUnitsSpent(msg.sender, upgradeCost);

    node.level++;
    node.powerScore = node.powerScore + (node.powerScore / 10) + (node.level * 5); // Example power increase formula

    emit NodeUpgraded(_nodeId, node.level, node.powerScore, upgradeCost);
}

/**
 * @dev Transfers ownership of a Node to another address.
 * @param _nodeId The ID of the Node to transfer.
 * @param _to The recipient address.
 */
function transferNode(uint255 _nodeId, address _to) external whenNotPaused {
     // Use uint255 mapping key directly
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
    if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);
    require(_to != address(0), "Cannot transfer to zero address");

    // Remove node from old owner's list (inefficient for large arrays, but simple)
    uint256[] storage oldOwnerNodes = s_userNodes[msg.sender];
    for (uint i = 0; i < oldOwnerNodes.length; i++) {
        if (oldOwnerNodes[i] == _nodeId) {
            oldOwnerNodes[i] = oldOwnerNodes[oldOwnerNodes.length - 1];
            oldOwnerNodes.pop();
            break;
        }
    }

    node.owner = _to;
    s_userNodes[_to].push(_nodeId);

    // Clear delegation on transfer for security
    node.delegatee = address(0);

    emit NodeTransferred(_nodeId, msg.sender, _to);
}

/**
 * @dev Burns (destroys) a Node. Node and any attached modules become unusable.
 * @param _nodeId The ID of the Node to burn.
 */
function burnNode(uint255 _nodeId) external whenNotPaused {
    // Use uint255 mapping key directly
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
    if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);

    // Mark as burned
    node.isBurned = true;
    // Transfer to zero address or update owner to address(0) to signify burning (mapping key is uint255, value is struct)
    // We keep the struct but mark it burned. Setting owner to 0 could also work.
    // Keeping the struct allows retrieving details even after burning.

    // Detach and burn any attached modules
    uint256[] memory attached = node.attachedModules; // Copy to memory before modifying storage array
    delete node.attachedModules; // Clear attached modules on the node

    for (uint i = 0; i < attached.length; i++) {
        uint256 moduleId = attached[i];
        Module storage module = s_modules[moduleId];
        if (module.attachedToNode == _nodeId) { // Double check connection
            module.attachedToNode = 0;
            module.isBurned = true; // Mark module as burned too
            // Removing from user's module list is complex and gas intensive,
            // relies on isBurned check in getUserModules view function.
        }
    }

     // Remove node from owner's list (inefficient for large arrays, but simple)
    uint256[] storage ownerNodes = s_userNodes[msg.sender];
    for (uint i = 0; i < ownerNodes.length; i++) {
        if (ownerNodes[i] == _nodeId) {
            ownerNodes[i] = ownerNodes[ownerNodes.length - 1];
            ownerNodes.pop();
            break;
        }
    }

    // Cannot unstake or interact if burned, set staked to false just in case
    node.isStaked = false;
    node.delegatee = address(0); // Clear delegation

    emit NodeBurned(_nodeId, msg.sender);
}


/**
 * @dev Gets the details of a specific Node.
 * @param _nodeId The ID of the Node.
 * @return Node struct details.
 */
function getNodeDetails(uint255 _nodeId) external view returns (Node memory) {
    // Use uint255 mapping key directly
    Node memory node = s_nodes[_nodeId];
    if (node.id == 0 || node.isBurned) revert CryptoNexus__NodeNotFound(_nodeId); // Check if initialized or burned
    return node;
}

/**
 * @dev Gets the list of Node IDs owned by a user.
 * @param _user The address of the user.
 * @return An array of Node IDs.
 */
function getUserNodes(address _user) external view returns (uint256[] memory) {
    // This returns the raw list. User should call getNodeDetails and check isBurned if needed.
    return s_userNodes[_user];
}


// 10. Module Management Functions
/**
 * @dev Mints a new Module for the caller. Requires EnergyUnits.
 * @param _moduleType The type of module to mint.
 */
function mintModule(ModuleType _moduleType) external whenNotPaused {
    // Example: Mint cost varies by type
    uint256 mintCost;
    if (_moduleType == ModuleType.POWER) {
        mintCost = 200;
    } else if (_moduleType == ModuleType.EFFICIENCY) {
        mintCost = 300;
    } else if (_moduleType == ModuleType.FORTUNE) {
        mintCost = 500;
    } else {
        revert CryptoNexus__InvalidModuleType();
    }

    if (s_userEnergyUnits[msg.sender] < mintCost) {
         revert CryptoNexus__InsufficientEnergy(msg.sender, mintCost, s_userEnergyUnits[msg.sender]);
    }

    s_userEnergyUnits[msg.sender] -= mintCost;
    emit EnergyUnitsSpent(msg.sender, mintCost);

    uint256 moduleId = _nextModuleId++;
    s_modules[moduleId] = Module({
        id: moduleId,
        owner: msg.sender,
        moduleType: _moduleType,
        powerBonus: (_moduleType == ModuleType.POWER ? 50 : (_moduleType == ModuleType.EFFICIENCY ? 20 : 30)), // Example bonus
        attachedToNode: 0,
        isBurned: false
    });

    s_userModules[msg.sender].push(moduleId);

    emit ModuleMinted(moduleId, msg.sender, _moduleType, s_modules[moduleId].powerBonus);
}

/**
 * @dev Transfers ownership of a Module to another address.
 * @param _moduleId The ID of the Module to transfer.
 * @param _to The recipient address.
 */
function transferModule(uint255 _moduleId, address _to) external whenNotPaused {
     // Use uint255 mapping key directly
    Module storage module = s_modules[_moduleId];
    if (module.owner != msg.sender) revert CryptoNexus__NotModuleOwner(_moduleId, msg.sender);
     if (module.isBurned) revert CryptoNexus__ModuleBurned(_moduleId); // Need ModuleBurned error
    require(_to != address(0), "Cannot transfer to zero address");

    // Cannot transfer if attached to a node
    require(module.attachedToNode == 0, "Cannot transfer an attached module");

     // Remove module from old owner's list (inefficient for large arrays, but simple)
    uint256[] storage oldOwnerModules = s_userModules[msg.sender];
    for (uint i = 0; i < oldOwnerModules.length; i++) {
        if (oldOwnerModules[i] == _moduleId) {
            oldOwnerModules[i] = oldOwnerModules[oldOwnerModules.length - 1];
            oldOwnerModules.pop();
            break;
        }
    }

    module.owner = _to;
    s_userModules[_to].push(_moduleId);

    emit ModuleTransferred(_moduleId, msg.sender, _to);
}

/**
 * @dev Gets the details of a specific Module.
 * @param _moduleId The ID of the Module.
 * @return Module struct details.
 */
function getModuleDetails(uint255 _moduleId) external view returns (Module memory) {
     // Use uint255 mapping key directly
    Module memory module = s_modules[_moduleId];
    if (module.id == 0 || module.isBurned) revert CryptoNexus__ModuleNotFound(_moduleId); // Check if initialized or burned
    return module;
}

/**
 * @dev Gets the list of Module IDs owned by a user.
 * @param _user The address of the user.
 * @return An array of Module IDs.
 */
function getUserModules(address _user) external view returns (uint256[] memory) {
     // This returns the raw list. User should call getModuleDetails and check isBurned if needed.
    return s_userModules[_user];
}


// 11. Node-Module Interaction Functions
/**
 * @dev Attaches a Module to a Node. Both must be owned by the caller.
 * @param _nodeId The ID of the Node.
 * @param _moduleId The ID of the Module.
 */
function attachModuleToNode(uint256 _nodeId, uint256 _moduleId) external whenNotPaused {
    Node storage node = s_nodes[_nodeId];
    Module storage module = s_modules[_moduleId];

    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
    if (module.owner != msg.sender) revert CryptoNexus__NotModuleOwner(_moduleId, msg.sender);
    if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);
    if (module.isBurned) revert CryptoNexus__ModuleBurned(_moduleId); // Need ModuleBurned error

    if (module.attachedToNode != 0) revert CryptoNexus__ModuleAlreadyAttached(_moduleId, module.attachedToNode);
    if (node.attachedModules.length >= s_systemParameters[PARAM_NODE_MODULE_CAPACITY]) {
        revert CryptoNexus__NodeCapacityReached(_nodeId);
    }

    // Attach
    node.attachedModules.push(_moduleId);
    module.attachedToNode = _nodeId;

    // Note: Power Score could be dynamically calculated in view or updated here.
    // Let's keep powerScore simple as base + level bonus and calculate effective power in view.

    emit ModuleAttached(_moduleId, _nodeId);
}

/**
 * @dev Detaches a Module from a Node. Both must be owned by the caller.
 * @param _nodeId The ID of the Node the module is attached to.
 * @param _moduleId The ID of the Module.
 */
function detachModuleFromNode(uint256 _nodeId, uint256 _moduleId) external whenNotPaused {
     Node storage node = s_nodes[_nodeId];
    Module storage module = s_modules[_moduleId];

    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
    if (module.owner != msg.sender) revert CryptoNexus__NotModuleOwner(_moduleId, msg.sender);
    if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);
    if (module.isBurned) revert CryptoNexus__ModuleBurned(_moduleId); // Need ModuleBurned error


    if (module.attachedToNode != _nodeId) revert CryptoNexus__ModuleNotAttachedToNode(_moduleId, _nodeId);

    // Detach
    module.attachedToNode = 0;

    // Remove from node's attachedModules array (inefficient, but simple)
    uint256[] storage attached = node.attachedModules;
    for (uint i = 0; i < attached.length; i++) {
        if (attached[i] == _moduleId) {
            attached[i] = attached[attached.length - 1];
            attached.pop();
            break;
        }
    }

    emit ModuleDetached(_moduleId, _nodeId);
}

/**
 * @dev Gets the list of module IDs attached to a Node.
 * @param _nodeId The ID of the Node.
 * @return An array of Module IDs.
 */
function getNodeAttachedModules(uint255 _nodeId) external view returns (uint256[] memory) {
    Node memory node = s_nodes[_nodeId];
     if (node.id == 0 || node.isBurned) revert CryptoNexus__NodeNotFound(_nodeId);
    return node.attachedModules;
}


// 12. Dynamic Interaction Functions
/**
 * @dev "Energizes" a Node, generating EnergyUnits based on time elapsed since last energize, level, and potential bonuses (like staking).
 * @param _nodeId The ID of the Node to energize.
 */
function energizeNode(uint256 _nodeId) external whenNotPaused onlyNodeOwnerOrDelegated(_nodeId) {
    Node storage node = s_nodes[_nodeId];

    uint256 cooldown = s_systemParameters[PARAM_ENERGIZED_COOLDOWN_SECONDS];
    uint256 timeSinceLastEnergized = block.timestamp - node.lastEnergizedTime;

    if (timeSinceLastEnergized < cooldown) {
        revert CryptoNexus__EnergizeCooldownNotPassed(_nodeId, cooldown - timeSinceLastEnergized);
    }

    uint256 energyPerLevelPerHour = s_systemParameters[PARAM_ENERGIZED_ENERGY_PER_LEVEL_PER_HOUR];
    uint256 hoursSinceLastEnergized = timeSinceLastEnergized / 3600; // Integer division

    // Calculate base energy generation
    uint256 energyGenerated = node.level * energyPerLevelPerHour * hoursSinceLastEnergized;

    // Apply staking bonus (example: 2x if staked)
    if (node.isStaked) {
        energyGenerated = energyGenerated * 2;
    }

    // Apply module bonuses (example: Efficiency modules increase energy generated)
    for (uint i = 0; i < node.attachedModules.length; i++) {
        uint256 moduleId = node.attachedModules[i];
        Module storage module = s_modules[moduleId];
        if (!module.isBurned && module.moduleType == ModuleType.EFFICIENCY) {
             // Simple additive bonus for now
            energyGenerated += module.powerBonus * hoursSinceLastEnergized;
        }
    }


    node.lastEnergizedTime = block.timestamp; // Reset cooldown
    s_userEnergyUnits[msg.sender] += energyGenerated; // Grant energy to the caller (owner or delegatee)

    emit NodeEnergized(_nodeId, msg.sender, energyGenerated);
    emit EnergyUnitsGranted(msg.sender, energyGenerated);
}

/**
 * @dev Combines two Nodes into a single, potentially higher-level Node. Burns the input Nodes.
 *      Requires EnergyUnits and a minimum number of nodes (e.g., 2).
 * @param _nodeIdsToCombine An array of Node IDs to combine.
 */
function combineNodes(uint256[] memory _nodeIdsToCombine) external whenNotPaused {
    uint256 requiredNodes = s_systemParameters[PARAM_COMBINE_NODE_COUNT_REQUIRED];
    if (_nodeIdsToCombine.length < requiredNodes) {
        revert CryptoNexus__CannotCombineInsufficientNodes(requiredNodes, _nodeIdsToCombine.length);
    }

    uint256 combineCost = s_systemParameters[PARAM_COMBINE_ENERGY_COST];
     if (s_userEnergyUnits[msg.sender] < combineCost) {
         revert CryptoNexus__InsufficientEnergy(msg.sender, combineCost, s_userEnergyUnits[msg.sender]);
    }

    uint256 totalLevel = 0;
    uint256 totalPower = 0;
    uint256[] memory burnedIds = new uint256[](_nodeIdsToCombine.length);

    // Check ownership, collect stats, mark for burning
    for (uint i = 0; i < _nodeIdsToCombine.length; i++) {
        uint256 nodeId = _nodeIdsToCombine[i];
        Node storage node = s_nodes[nodeId]; // Use storage to modify

        if (node.owner != msg.sender) {
            revert CryptoNexus__CannotCombineMismatchedOwnership();
        }
        if (node.isBurned) {
             revert CryptoNexus__NodeBurned(nodeId); // Cannot combine already burned nodes
        }
         if (node.isStaked) {
            revert CryptoNexus__NodeAlreadyStaked(nodeId); // Cannot combine staked nodes (must unstake first)
        }
         if (node.attachedModules.length > 0) {
            revert("Cannot combine nodes with attached modules"); // Must detach modules first
        }


        totalLevel += node.level;
        totalPower += node.powerScore;
        burnedIds[i] = nodeId;

        // Mark as burned immediately to prevent re-using same node ID
        node.isBurned = true;
         // Also remove from user's list immediately
        uint256[] storage ownerNodes = s_userNodes[msg.sender];
        for (uint j = 0; j < ownerNodes.length; j++) {
            if (ownerNodes[j] == nodeId) {
                ownerNodes[j] = ownerNodes[ownerNodes.length - 1];
                ownerNodes.pop();
                break;
            }
        }
        node.delegatee = address(0); // Clear delegation
        // Attached modules were checked/required detached above
    }

    s_userEnergyUnits[msg.sender] -= combineCost;
    emit EnergyUnitsSpent(msg.sender, combineCost);

    // Calculate new node properties (example logic)
    uint256 newLevel = (totalLevel / requiredNodes) + 1; // Average level + 1
    uint256 newPower = totalPower + (totalPower / 5); // Sum of power + 20% bonus

     // Mint the new combined node
    uint256 newNodeId = _nextNodeId++;
    s_nodes[newNodeId] = Node({
        id: newNodeId,
        owner: msg.sender,
        level: newLevel,
        powerScore: newPower,
        creationTime: block.timestamp,
        lastEnergizedTime: block.timestamp,
        attachedModules: new uint256[](0),
        isStaked: false,
        isBurned: false,
        delegatee: address(0)
    });

    s_userNodes[msg.sender].push(newNodeId);

    emit NodesCombined(burnedIds, newNodeId, msg.sender);
    emit NodeMinted(newNodeId, msg.sender, newLevel, newPower);

    // Emit burn events for the input nodes
    for (uint i = 0; i < burnedIds.length; i++) {
        emit NodeBurned(burnedIds[i], msg.sender);
    }
}

/**
 * @dev Stakes a Node. Staked nodes might receive bonuses (e.g., for energizing).
 * @param _nodeId The ID of the Node to stake.
 */
function stakeNode(uint256 _nodeId) external whenNotPaused {
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
     if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);

    if (node.isStaked) revert CryptoNexus__NodeAlreadyStaked(_nodeId);

    node.isStaked = true;
    emit NodeStaked(_nodeId, msg.sender);
}

/**
 * @dev Unstakes a Node.
 * @param _nodeId The ID of the Node to unstake.
 */
function unstakeNode(uint256 _nodeId) external whenNotPaused {
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
     if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);


    if (!node.isStaked) revert CryptoNexus__NodeNotStaked(_nodeId);

    node.isStaked = false;
    emit NodeUnstaked(_nodeId, msg.sender);
}


// 13. Resource/Utility Functions
/**
 * @dev Gets the current EnergyUnits balance for a user.
 * @param _user The address of the user.
 * @return The amount of EnergyUnits.
 */
function getUserEnergyUnits(address _user) external view returns (uint256) {
    return s_userEnergyUnits[_user];
}

/**
 * @dev Allows users to convert Ether sent with the transaction into EnergyUnits.
 *      This Ether accumulates in the contract and can be withdrawn by the owner.
 */
function convertEtherToEnergy() external payable whenNotPaused {
    uint256 etherAmount = msg.value;
    require(etherAmount > 0, "Must send Ether");

    uint256 energyAmount = etherAmount * s_systemParameters[PARAM_ETHER_TO_ENERGY_RATIO];
    s_userEnergyUnits[msg.sender] += energyAmount;

    emit EtherConvertedToEnergy(msg.sender, etherAmount, energyAmount);
    emit EnergyUnitsGranted(msg.sender, energyAmount);
}

// 14. Delegation Functions
/**
 * @dev Delegates the ability to perform actions like `energizeNode` on a specific Node
 *      to another address. Only the Node owner can delegate.
 * @param _nodeId The ID of the Node to delegate.
 * @param _delegatee The address to delegate actions to (address(0) to clear delegation).
 */
function delegateNodeAction(uint256 _nodeId, address _delegatee) external whenNotPaused {
    Node storage node = s_nodes[_nodeId];
    if (node.owner != msg.sender) revert CryptoNexus__NotNodeOwner(_nodeId, msg.sender);
     if (node.isBurned) revert CryptoNexus__NodeBurned(_nodeId);

    if (_delegatee != address(0) && _delegatee == msg.sender) revert CryptoNexus__SelfDelegation();
    if (_delegatee != address(0) && node.delegatee == _delegatee) revert CryptoNexus__NodeAlreadyDelegatedToAddress(_nodeId, _delegatee);
     if (_delegatee == address(0) && node.delegatee == address(0)) return; // No delegation to revoke

    address oldDelegatee = node.delegatee;
    node.delegatee = _delegatee;

    if (_delegatee != address(0)) {
        emit NodeActionDelegated(_nodeId, msg.sender, _delegatee);
    } else {
         emit NodeActionRevoked(_nodeId, msg.sender, oldDelegatee);
    }
}

/**
 * @dev Revokes the delegation for a specific Node. Only the Node owner can revoke.
 *      This is a helper function that just calls `delegateNodeAction` with address(0).
 * @param _nodeId The ID of the Node to revoke delegation for.
 */
function revokeNodeDelegation(uint256 _nodeId) external whenNotPaused {
    delegateNodeAction(_nodeId, address(0));
}

/**
 * @dev Gets the current delegatee address for a specific Node.
 * @param _nodeId The ID of the Node.
 * @return The delegatee address, or address(0) if no delegation.
 */
function getNodeDelegate(uint255 _nodeId) external view returns (address) {
     Node memory node = s_nodes[_nodeId];
     if (node.id == 0 || node.isBurned) revert CryptoNexus__NodeNotFound(_nodeId);
    return node.delegatee;
}


// 15. Governance Functions (Simple Parameter Tuning)
/**
 * @dev Allows the owner to propose changing a system parameter.
 *      Anyone can vote 'yes' or 'no' during the voting period.
 *      Requires reaching a minimum number of 'yes' votes to be executable.
 * @param _description A description of the proposal.
 * @param _parameterIndex The index of the parameter to change.
 * @param _newValue The proposed new value for the parameter.
 */
function createParameterProposal(string calldata _description, uint8 _parameterIndex, uint256 _newValue) external onlyOwner whenNotPaused {
    if (_parameterIndex >= s_systemParameters.length) revert CryptoNexus__InvalidParameterIndex(_parameterIndex);

    uint256 proposalId = _nextProposalId++;
    uint256 votingEndTime = block.timestamp + s_systemParameters[PARAM_PROPOSAL_VOTING_PERIOD_SECONDS];

    s_proposals[proposalId] = Proposal({
        id: proposalId,
        description: _description,
        parameterIndex: _parameterIndex,
        newValue: _newValue,
        endTime: votingEndTime,
        yesVotes: 0,
        noVotes: 0,
        executed: false,
        active: true // Mark as active initially
    });

    emit ParameterProposalCreated(proposalId, msg.sender, _description, _parameterIndex, _newValue, votingEndTime);
}

/**
 * @dev Allows a user to vote on an active proposal.
 * @param _proposalId The ID of the proposal to vote on.
 * @param _vote True for 'yes', False for 'no'.
 */
function voteOnProposal(uint256 _proposalId, bool _vote) external whenNotPaused {
    Proposal storage proposal = s_proposals[_proposalId];
    if (proposal.id == 0 || !proposal.active) revert CryptoNexus__ProposalNotFound(_proposalId); // Check if exists and active

    if (block.timestamp > proposal.endTime) revert CryptoNexus__ProposalNotActive(_proposalId);
    if (proposal.voted[msg.sender]) revert CryptoNexus__AlreadyVoted(_proposalId, msg.sender);

    proposal.voted[msg.sender] = true;
    if (_vote) {
        proposal.yesVotes++;
    } else {
        proposal.noVotes++;
    }

    emit VoteCast(_proposalId, msg.sender, _vote);
}

/**
 * @dev Allows anyone to execute a proposal that has ended and passed the required vote threshold.
 * @param _proposalId The ID of the proposal to execute.
 */
function executeProposal(uint256 _proposalId) external whenNotPaused {
     Proposal storage proposal = s_proposals[_proposalId];
    if (proposal.id == 0 || !proposal.active) revert CryptoNexus__ProposalNotFound(_proposalId); // Check if exists and active

    if (block.timestamp <= proposal.endTime) revert CryptoNexus__ProposalNotEnded(_proposalId);
    if (proposal.executed) revert CryptoNexus__ProposalAlreadyExecuted(_proposalId);

    uint256 requiredVotes = s_systemParameters[PARAM_MIN_PROPOSAL_VOTES_FOR_EXECUTION];
    if (proposal.yesVotes < requiredVotes) {
         proposal.active = false; // Mark inactive as it failed
         revert CryptoNexus__ProposalDidNotPass(_proposalId);
    }

    // Proposal passed - execute the parameter change
    uint8 paramIndex = proposal.parameterIndex;
    if (paramIndex >= s_systemParameters.length) {
        // This should ideally not happen if createProposal validated correctly
        // but as a safeguard, mark failed and return.
        proposal.active = false;
        revert CryptoNexus__InvalidParameterIndex(paramIndex);
    }

    uint256 oldValue = s_systemParameters[paramIndex];
    s_systemParameters[paramIndex] = proposal.newValue;

    proposal.executed = true;
    proposal.active = false; // Mark as inactive after execution

    emit ParameterChangedByProposal(paramIndex, oldValue, proposal.newValue);
    emit ProposalExecuted(_proposalId);
}

/**
 * @dev Gets the details of a proposal.
 * @param _proposalId The ID of the proposal.
 * @return Proposal struct details.
 */
function getProposalDetails(uint256 _proposalId) external view returns (Proposal memory) {
    Proposal memory proposal = s_proposals[_proposalId];
    if (proposal.id == 0) revert CryptoNexus__ProposalNotFound(_proposalId); // Check if exists
    return proposal;
}

/**
 * @dev Gets the current values of all system parameters.
 * @return An array of parameter values.
 */
function getSystemParameters() external view returns (uint256[] memory) {
    return s_systemParameters;
}

/**
 * @dev Gets the list of all parameter names.
 * @return An array of parameter names.
 */
function getSystemParameterNames() external view returns (string[] memory) {
    return PARAMETER_NAMES;
}


// 16. View/Pure Helper Functions
/**
 * @dev Returns the address of the current owner.
 */
function owner() external view returns (address) {
    return _owner;
}

/**
 * @dev Returns true if the contract is paused, false otherwise.
 */
function paused() external view returns (bool) {
    return _paused;
}

/**
 * @dev Calculates the current effective power of a node, including module bonuses.
 * @param _nodeId The ID of the Node.
 * @return The effective power score.
 */
function getNodeEffectivePower(uint255 _nodeId) external view returns (uint256) {
     Node memory node = s_nodes[_nodeId];
     if (node.id == 0 || node.isBurned) revert CryptoNexus__NodeNotFound(_nodeId);

    uint256 effectivePower = node.powerScore;
    for (uint i = 0; i < node.attachedModules.length; i++) {
        uint256 moduleId = node.attachedModules[i];
        Module memory module = s_modules[moduleId];
        // Only add bonus if module exists, is not burned, and is correctly attached
        if (module.id != 0 && !module.isBurned && module.attachedToNode == _nodeId) {
            effectivePower += module.powerBonus;
        }
    }
    return effectivePower;
}

// Fallback and Receive functions to accept Ether for convertEtherToEnergy
receive() external payable {
    convertEtherToEnergy();
}

fallback() external payable {
    convertEtherToEnergy();
}

// Helper error definitions that use dynamic data
error CryptoNexus__ModuleBurned(uint256 moduleId); // Added during implementation review

// Final check on function count:
// Admin/Control: 5
// Node Management: 6
// Module Management: 4
// Node-Module Interaction: 3
// Dynamic Interaction: 4
// Resource/Utility: 2 + Fallback/Receive (3 if counted)
// Delegation: 3
// Governance: 5
// View/Pure Helpers: 4
// Total: 5 + 6 + 4 + 3 + 4 + 2 + 3 + 5 + 4 = 36 (Exceeds 20)
```