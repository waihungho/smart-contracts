This smart contract, **CognitoNexus**, is designed to be a decentralized AI-driven research and innovation lab. It facilitates the entire lifecycle of research projects, from proposal submission and AI-assisted evaluation to funding, milestone management, and the tokenization of intellectual property (IP) as dynamic NFTs. It also incorporates a reputation-based governance model and an on-chain treasury.

---

## CognitoNexus Smart Contract Outline & Function Summary

**Contract Name:** `CognitoNexus`

**Core Concepts:**
*   **Epoch-based Operations:** Time is structured into epochs for proposal deadlines, voting periods, and system progression.
*   **Reputation System:** A non-transferable, on-chain reputation score that can be delegated for governance, representing a researcher's trustworthiness and contribution.
*   **AI Oracle Integration:** A pattern for integrating external AI evaluation services for objective assessment of research proposals and deliverables.
*   **Dynamic Intellectual Property NFTs (IP-NFTs):** ERC-721 tokens representing research output, with mutable metadata to reflect ongoing development or new insights.
*   **Decentralized Governance:** Reputation-weighted voting for system parameters and treasury management.
*   **Project Lifecycle Management:** Structured handling of proposals, funding, milestones, and deliverables.

---

### Function Summary:

**I. Core Infrastructure & Global State**
1.  **`constructor()`**: Initializes the contract, sets the initial epoch, AI Oracle address, and administrative roles.
2.  **`advanceEpoch()`**: Moves the system to the next epoch, triggering state transitions for proposals and projects.
3.  **`pauseContract()`**: Allows the owner/governance to pause critical contract operations in emergencies.
4.  **`unpauseContract()`**: Allows the owner/governance to unpause the contract.

**II. Researcher & Reputation Management**
5.  **`registerResearcher(string _ipfsProfileHash)`**: Allows an individual to register as a researcher within the CognitoNexus, linking an IPFS hash to their profile.
6.  **`updateResearcherProfile(string _newIpfsProfileHash)`**: Enables a registered researcher to update their public profile's IPFS hash.
7.  **`getResearcherReputation(address _researcher)`**: Retrieves the current reputation score of a specific researcher.
8.  **`delegateReputation(address _delegatee, uint256 _amount)`**: Allows a researcher to delegate a portion of their reputation to another address for voting purposes.
9.  **`revokeReputationDelegation(address _delegatee)`**: Revokes a previously established reputation delegation.

**III. Research Proposal & Project Lifecycle**
10. **`submitResearchProposal(string _ipfsProposalHash, uint256 _requestedFunds, uint256 _milestoneCount, uint256 _evaluationDeadlineEpoch)`**: Allows a researcher to submit a new research proposal, detailing its scope, requested funding, and milestones.
11. **`voteOnProposalEvaluation(uint256 _proposalId, bool _approve)`**: Researchers/delegates vote on the initial human merit assessment of a proposal before potential AI evaluation.
12. **`requestAIEvaluation(uint256 _proposalId)`**: An internal or authorized function to trigger an off-chain AI oracle request for a deeper, objective evaluation of a proposal.
13. **`receiveAIEvaluationCallback(uint256 _proposalId, bool _aiApproved, uint256 _aiScore)`**: A callback function for the designated AI oracle to submit its evaluation results, influencing the proposal's status.
14. **`fundApprovedProposal(uint256 _proposalId)`**: Initiates the funding process for a proposal that has successfully passed all evaluation stages (human and AI).
15. **`submitMilestoneDeliverable(uint256 _projectId, uint256 _milestoneIndex, string _ipfsDeliverableHash)`**: The project lead submits the deliverable for a specific project milestone.
16. **`evaluateMilestoneDeliverable(uint256 _projectId, uint256 _milestoneIndex, bool _approved)`**: A designated evaluator (e.g., internal committee, AI oracle) approves or rejects a submitted milestone deliverable.
17. **`claimMilestonePayment(uint256 _projectId, uint256 _milestoneIndex)`**: Allows the project lead to claim the payment for an approved milestone.

**IV. Intellectual Property (IP) & Dynamic NFTs**
18. **`mintResearchIPNFT(uint256 _projectId, string _ipfsIPHash, address _recipient)`**: Mints a unique, non-fungible token (IP-NFT) representing the intellectual property generated by a completed project, linked to an IPFS hash.
19. **`updateIPNFTMetadata(uint256 _tokenId, string _newIpfsIPHash)`**: Allows the owner of an IP-NFT to update its associated metadata (e.g., when new research builds upon it or the IP evolves).
20. **`licenseResearchIP(uint256 _tokenId, address _licensee, uint256 _royaltyPercentage)`**: Establishes an on-chain license agreement for an IP-NFT, defining royalty terms for its usage.
21. **`collectIPRoyalties(uint256 _tokenId)`**: Enables the IP-NFT owner to collect accumulated royalty payments from licenses.

**V. Governance & Treasury Management**
22. **`createGovernanceProposal(string _ipfsProposalHash, uint256 _votingDeadlineEpoch)`**: Allows eligible researchers to propose changes to the DAO's parameters, contract upgrades, or significant actions.
23. **`voteOnGovernanceProposal(uint256 _proposalId, bool _approve)`**: Casts a reputation-weighted vote on an active governance proposal.
24. **`executeGovernanceProposal(uint256 _proposalId)`**: Executes an approved governance proposal once the voting period ends and quorum/thresholds are met.
25. **`depositToTreasury()`**: Allows external users or researchers to deposit Ether into the CognitoNexus DAO's treasury.
26. **`withdrawFromTreasury(address _recipient, uint256 _amount)`**: Allows funds to be withdrawn from the treasury, typically triggered by an approved governance proposal or project funding.
27. **`setAIEvaluationOracle(address _newOracleAddress)`**: Admin/governance function to set or update the address of the trusted AI evaluation oracle.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @title CognitoNexus
 * @dev A Decentralized AI-Driven Research & Innovation Lab.
 * This contract facilitates the entire lifecycle of research projects, from proposal submission
 * and AI-assisted evaluation to funding, milestone management, and the tokenization of
 * intellectual property (IP) as dynamic NFTs. It also incorporates a reputation-based
 * governance model and an on-chain treasury.
 */
contract CognitoNexus is ERC721, Ownable, Pausable {
    using Counters for Counters.Counter;

    // --- State Variables ---

    // Global counters for unique IDs
    Counters.Counter private _proposalIdCounter;
    Counters.Counter private _projectIdCounter;
    Counters.Counter private _governanceProposalIdCounter;
    
    // Core System Parameters
    uint256 public currentEpoch;
    uint256 public constant EPOCH_DURATION = 1 days; // Example: 1 day per epoch
    uint256 public constant MIN_REP_TO_SUBMIT_PROPOSAL = 100;
    uint256 public constant MIN_REP_TO_CREATE_GOV_PROPOSAL = 500;
    uint256 public constant GOV_PROPOSAL_VOTING_PERIOD_EPOCHS = 7;
    uint256 public constant PROPOSAL_EVALUATION_PERIOD_EPOCHS = 3;

    address public aiEvaluationOracle; // Address of the trusted off-chain AI oracle

    // --- Mappings ---

    // Researcher Data: address => ResearcherProfile
    mapping(address => ResearcherProfile) public researchers;
    // Researcher Reputation: address => reputation score
    mapping(address => uint256) public researcherReputation;
    // Reputation Delegation: delegator => delegatee
    mapping(address => address) public reputationDelegates;
    // Total delegated reputation per delegatee: delegatee => total delegated reputation
    mapping(address => uint256) public delegatedReputationSums;

    // Research Proposals: proposalId => Proposal
    mapping(uint256 => Proposal) public proposals;
    // Research Projects: projectId => Project
    mapping(uint256 => Project) public projects;
    // Milestone Details: projectId => milestoneIndex => Milestone
    mapping(uint256 => mapping(uint256 => Milestone)) public milestones;

    // IP-NFTs: tokenId => IPNFT
    mapping(uint256 => IPNFT) public ipNFTs;
    // IP-NFT Licenses: tokenId => licensee => License
    mapping(uint256 => mapping(address => License)) public ipLicenses;

    // Governance Proposals: govProposalId => GovernanceProposal
    mapping(uint256 => GovernanceProposal) public governanceProposals;
    // Governance Proposal Votes: govProposalId => voter => hasVoted
    mapping(uint256 => mapping(address => bool)) public governanceProposalVotes;

    // --- Enums ---

    enum ProposalStatus {
        Submitted,
        EvaluatingHuman,
        EvaluatingAI,
        Approved,
        Rejected,
        Funded,
        Completed
    }

    enum ProjectStatus {
        InProgress,
        Completed,
        Cancelled
    }

    enum GovernanceProposalStatus {
        Pending,
        Active,
        Passed,
        Failed,
        Executed
    }

    // --- Structs ---

    struct ResearcherProfile {
        address researcherAddress;
        string ipfsProfileHash;
        uint256 reputation; // Redundant with researcherReputation mapping but useful for struct completeness
        uint256 epochRegistered;
        bool isRegistered;
    }

    struct Proposal {
        uint256 id;
        address submitter;
        string ipfsProposalHash;
        uint256 requestedFunds; // In wei
        uint256 milestoneCount;
        ProposalStatus status;
        uint256 votesForEvaluation;
        uint256 votesAgainstEvaluation;
        bool aiApproved;
        uint256 aiScore; // Score from AI evaluation, e.g., 0-100
        uint256 evaluationDeadlineEpoch;
        uint256 projectId; // Will be set after funding, links to project
    }

    struct Project {
        uint256 id;
        uint256 proposalId;
        address leadResearcher;
        uint256 totalMilestones;
        uint256 currentMilestoneIndex; // 0-indexed, represents the next milestone to be submitted
        uint256 fundedAmount; // Total amount allocated to the project
        ProjectStatus status;
        uint256 ipNFTTokenId; // Will be set upon IP-NFT minting
    }

    struct Milestone {
        string ipfsDeliverableHash;
        bool approved;
        bool paymentClaimed;
        uint256 paymentAmount; // Amount for this specific milestone
    }

    struct IPNFT {
        uint256 projectId;
        string ipfsIPHash; // Current IPFS hash for metadata
        uint256 royaltyPercentage; // e.g., 100 for 1% (10000 for 100%)
        uint256 accumulatedRoyalties; // In wei
        address owner; // Owner of the IP-NFT, can be different from project lead
        bool isMinted; // To verify existence
    }

    struct License {
        address licensee;
        uint256 royaltyPercentage; // Percentage of revenue to be paid to IP-NFT owner (e.g., 100 for 1%)
        bool isActive;
    }

    struct GovernanceProposal {
        uint256 id;
        address submitter;
        string ipfsProposalHash;
        uint256 votingDeadlineEpoch;
        uint256 votesFor;
        uint256 votesAgainst;
        GovernanceProposalStatus status;
        bool executed;
    }

    // --- Events ---

    event EpochAdvanced(uint256 newEpoch);
    event ResearcherRegistered(address indexed researcher, string ipfsProfileHash, uint256 reputation);
    event ProfileUpdated(address indexed researcher, string newIpfsProfileHash);
    event ReputationDelegated(address indexed delegator, address indexed delegatee, uint256 amount);
    event ReputationDelegationRevoked(address indexed delegator, address indexed delegatee);

    event ResearchProposalSubmitted(uint256 indexed proposalId, address indexed submitter, uint256 requestedFunds, uint256 milestoneCount);
    event ProposalEvaluationVote(uint256 indexed proposalId, address indexed voter, bool approve, uint256 reputationWeight);
    event AIEvaluationRequested(uint256 indexed proposalId);
    event AIEvaluationReceived(uint256 indexed proposalId, bool aiApproved, uint256 aiScore);
    event ProposalStatusChanged(uint256 indexed proposalId, ProposalStatus oldStatus, ProposalStatus newStatus);
    event ProposalFunded(uint256 indexed proposalId, uint256 indexed projectId, address leadResearcher, uint256 fundedAmount);

    event MilestoneDeliverableSubmitted(uint256 indexed projectId, uint256 indexed milestoneIndex, string ipfsDeliverableHash);
    event MilestoneDeliverableEvaluated(uint256 indexed projectId, uint256 indexed milestoneIndex, bool approved);
    event MilestonePaymentClaimed(uint256 indexed projectId, uint256 indexed milestoneIndex, uint256 amount);
    event ProjectStatusChanged(uint256 indexed projectId, ProjectStatus oldStatus, ProjectStatus newStatus);

    event IPNFTMinted(uint256 indexed tokenId, uint256 indexed projectId, address indexed owner, string ipfsIPHash);
    event IPNFTMetadataUpdated(uint256 indexed tokenId, string newIpfsIPHash);
    event IPLicensed(uint256 indexed tokenId, address indexed licensee, uint256 royaltyPercentage);
    event IPRoyaltiesCollected(uint256 indexed tokenId, address indexed collector, uint256 amount);

    event GovernanceProposalCreated(uint256 indexed proposalId, address indexed submitter, string ipfsProposalHash);
    event GovernanceVoteCast(uint256 indexed proposalId, address indexed voter, bool approve, uint256 reputationWeight);
    event GovernanceProposalExecuted(uint256 indexed proposalId);
    event GovernanceProposalStatusChanged(uint256 indexed proposalId, GovernanceProposalStatus oldStatus, GovernanceProposalStatus newStatus);

    event FundsDeposited(address indexed depositor, uint256 amount);
    event FundsWithdrawn(address indexed recipient, uint256 amount);

    // --- Errors ---

    error NotRegisteredResearcher();
    error AlreadyRegistered();
    error InsufficientReputation(uint256 required, uint256 has);
    error InvalidEpoch();
    error ProposalNotFound();
    error ProposalNotInCorrectStatus();
    error ProjectNotFound();
    error ProjectNotInCorrectStatus();
    error MilestoneNotFound();
    error MilestoneAlreadyApproved();
    error MilestoneNotApproved();
    error MilestonePaymentAlreadyClaimed();
    error OnlyProjectLead();
    error InvalidIPNFT();
    error NotIPNFTOwner();
    error IPNFTAlreadyLicensed();
    error IPNFTNotLicensed();
    error NoRoyaltiesToCollect();
    error GovernanceProposalNotFound();
    error GovernanceProposalNotActive();
    error GovernanceVoteAlreadyCast();
    error NotEnoughVotes();
    error ProposalAlreadyExecuted();
    error OnlyAIOracle();
    error InvalidFunds();
    error CallerNotAllowed();
    error NotYetFunded();
    error InsufficientTreasuryBalance(uint256 required, uint256 has);


    // --- Constructor ---

    constructor(address _aiEvaluationOracle) ERC721("CognitoNexusIP", "CNXIP") Ownable(msg.sender) Pausable() {
        require(_aiEvaluationOracle != address(0), "AI Oracle cannot be zero address");
        aiEvaluationOracle = _aiEvaluationOracle;
        currentEpoch = block.timestamp / EPOCH_DURATION; // Initialize current epoch based on deployment time
    }

    // --- Modifiers ---

    modifier onlyRegisteredResearcher() {
        if (!researchers[msg.sender].isRegistered) revert NotRegisteredResearcher();
        _;
    }

    modifier onlyProjectLead(uint256 _projectId) {
        if (projects[_projectId].leadResearcher != msg.sender) revert OnlyProjectLead();
        _;
    }

    modifier onlyAIOracle() {
        if (msg.sender != aiEvaluationOracle) revert OnlyAIOracle();
        _;
    }

    // --- I. Core Infrastructure & Global State ---

    /**
     * @dev Advances the contract's epoch. This function can be called by anyone,
     * but will only advance if a full EPOCH_DURATION has passed since the last epoch advancement.
     * Triggers state transitions for proposals and projects.
     */
    function advanceEpoch() public whenNotPaused {
        uint256 newEpoch = block.timestamp / EPOCH_DURATION;
        if (newEpoch <= currentEpoch) {
            revert InvalidEpoch(); // Not enough time has passed
        }

        uint256 oldEpoch = currentEpoch;
        currentEpoch = newEpoch;
        emit EpochAdvanced(currentEpoch);

        // Process any time-sensitive transitions (e.g., proposal evaluation deadlines)
        for (uint256 i = 0; i < _proposalIdCounter.current(); i++) {
            Proposal storage prop = proposals[i];
            if (prop.status == ProposalStatus.EvaluatingHuman && currentEpoch >= prop.evaluationDeadlineEpoch) {
                // If AI evaluation is not requested, or human evaluation failed
                if (!prop.aiApproved && prop.votesForEvaluation < prop.votesAgainstEvaluation) { // Simplified check
                    _setProposalStatus(i, ProposalStatus.Rejected);
                } else if (!prop.aiApproved && prop.aiScore == 0 && prop.votesForEvaluation > prop.votesAgainstEvaluation) {
                    // Scenario where human votes pass, but AI not yet evaluated or AI evaluation still pending/not requested
                    // This implies proposals need AI approval after human approval, or fallback to human if AI not setup/responsive
                    // For now, let's assume it *must* pass AI if AI evaluation was requested.
                    // If AI was never requested, and human votes are sufficient, it can move to Approved
                    // This logic needs to be robust. For simplicity here: if AI hasn't approved it, it's still stuck or fails
                    // This might be better handled by forcing `requestAIEvaluation` explicitly after human voting
                }
            }
        }
        // Governance proposals status updates
        for (uint256 i = 0; i < _governanceProposalIdCounter.current(); i++) {
            GovernanceProposal storage govProp = governanceProposals[i];
            if (govProp.status == GovernanceProposalStatus.Active && currentEpoch >= govProp.votingDeadlineEpoch) {
                // Example: simple majority rule
                if (govProp.votesFor > govProp.votesAgainst) {
                    _setGovernanceProposalStatus(i, GovernanceProposalStatus.Passed);
                } else {
                    _setGovernanceProposalStatus(i, GovernanceProposalStatus.Failed);
                }
            }
        }
    }

    /**
     * @dev Pauses the contract. Callable by the owner or by an approved governance proposal.
     */
    function pauseContract() public onlyOwner {
        _pause();
    }

    /**
     * @dev Unpauses the contract. Callable by the owner or by an approved governance proposal.
     */
    function unpauseContract() public onlyOwner {
        _unpause();
    }

    // --- II. Researcher & Reputation Management ---

    /**
     * @dev Allows an individual to register as a researcher in CognitoNexus.
     * @param _ipfsProfileHash IPFS hash pointing to the researcher's profile metadata.
     */
    function registerResearcher(string memory _ipfsProfileHash) public whenNotPaused {
        if (researchers[msg.sender].isRegistered) revert AlreadyRegistered();

        researchers[msg.sender] = ResearcherProfile({
            researcherAddress: msg.sender,
            ipfsProfileHash: _ipfsProfileHash,
            reputation: 0, // Starts with 0 reputation
            epochRegistered: currentEpoch,
            isRegistered: true
        });
        emit ResearcherRegistered(msg.sender, _ipfsProfileHash, 0);
    }

    /**
     * @dev Allows a registered researcher to update their public profile's IPFS hash.
     * @param _newIpfsProfileHash The new IPFS hash for the researcher's profile.
     */
    function updateResearcherProfile(string memory _newIpfsProfileHash) public onlyRegisteredResearcher whenNotPaused {
        researchers[msg.sender].ipfsProfileHash = _newIpfsProfileHash;
        emit ProfileUpdated(msg.sender, _newIpfsProfileHash);
    }

    /**
     * @dev Retrieves the current reputation score of a specific researcher.
     * @param _researcher The address of the researcher.
     * @return The current reputation score.
     */
    function getResearcherReputation(address _researcher) public view returns (uint256) {
        return researcherReputation[_researcher];
    }

    /**
     * @dev Allows a researcher to delegate a portion of their reputation to another address for voting purposes.
     * @param _delegatee The address to whom reputation is delegated.
     * @param _amount The amount of reputation to delegate.
     */
    function delegateReputation(address _delegatee, uint256 _amount) public onlyRegisteredResearcher whenNotPaused {
        if (_amount > researcherReputation[msg.sender]) revert InsufficientReputation(researcherReputation[msg.sender], _amount);
        if (reputationDelegates[msg.sender] != address(0)) {
            delegatedReputationSums[reputationDelegates[msg.sender]] -= researcherReputation[msg.sender]; // Remove old delegation first
        }
        reputationDelegates[msg.sender] = _delegatee;
        delegatedReputationSums[_delegatee] += _amount;
        emit ReputationDelegated(msg.sender, _delegatee, _amount);
    }

    /**
     * @dev Revokes a previously established reputation delegation.
     * The reputation returns to the delegator for their own voting.
     * If the delegator has updated their reputation since delegation, the delegated amount changes.
     */
    function revokeReputationDelegation(address _delegatee) public onlyRegisteredResearcher whenNotPaused {
        if (reputationDelegates[msg.sender] == address(0)) revert CallerNotAllowed(); // No active delegation
        
        uint256 delegatedAmt = researcherReputation[msg.sender]; // Amount delegated is always the current full reputation for simplicity
        delegatedReputationSums[reputationDelegates[msg.sender]] -= delegatedAmt;
        delete reputationDelegates[msg.sender];
        emit ReputationDelegationRevoked(msg.sender, _delegatee);
    }

    // --- III. Research Proposal & Project Lifecycle ---

    /**
     * @dev Allows a researcher to submit a new research proposal.
     * Requires minimum reputation.
     * @param _ipfsProposalHash IPFS hash of the detailed proposal.
     * @param _requestedFunds The total funds requested for the project (in wei).
     * @param _milestoneCount The number of milestones planned for the project.
     * @param _evaluationDeadlineEpoch The epoch by which human evaluation must conclude.
     */
    function submitResearchProposal(
        string memory _ipfsProposalHash,
        uint256 _requestedFunds,
        uint256 _milestoneCount,
        uint256 _evaluationDeadlineEpoch
    ) public onlyRegisteredResearcher whenNotPaused {
        if (researcherReputation[msg.sender] < MIN_REP_TO_SUBMIT_PROPOSAL) {
            revert InsufficientReputation(MIN_REP_TO_SUBMIT_PROPOSAL, researcherReputation[msg.sender]);
        }
        if (_milestoneCount == 0) revert InvalidFunds(); // Must have at least one milestone
        if (_evaluationDeadlineEpoch <= currentEpoch) revert InvalidEpoch();

        uint256 newProposalId = _proposalIdCounter.current();
        proposals[newProposalId] = Proposal({
            id: newProposalId,
            submitter: msg.sender,
            ipfsProposalHash: _ipfsProposalHash,
            requestedFunds: _requestedFunds,
            milestoneCount: _milestoneCount,
            status: ProposalStatus.Submitted,
            votesForEvaluation: 0,
            votesAgainstEvaluation: 0,
            aiApproved: false,
            aiScore: 0,
            evaluationDeadlineEpoch: _evaluationDeadlineEpoch,
            projectId: 0 // Will be set upon funding
        });
        _proposalIdCounter.increment();
        _setProposalStatus(newProposalId, ProposalStatus.EvaluatingHuman); // Immediately start human evaluation
        emit ResearchProposalSubmitted(newProposalId, msg.sender, _requestedFunds, _milestoneCount);
    }

    /**
     * @dev Allows researchers or their delegates to vote on the initial human merit assessment of a proposal.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _approve True for approval, false for rejection.
     */
    function voteOnProposalEvaluation(uint256 _proposalId, bool _approve) public onlyRegisteredResearcher whenNotPaused {
        Proposal storage prop = proposals[_proposalId];
        if (prop.id != _proposalId) revert ProposalNotFound();
        if (prop.status != ProposalStatus.EvaluatingHuman) revert ProposalNotInCorrectStatus();
        if (currentEpoch >= prop.evaluationDeadlineEpoch) revert InvalidEpoch();

        address voter = msg.sender;
        if (reputationDelegates[msg.sender] != address(0)) {
            voter = reputationDelegates[msg.sender]; // If msg.sender has delegated, vote with delegatee's power
        }
        
        uint256 votingPower = researcherReputation[voter];
        if (votingPower == 0) revert InsufficientReputation(1, 0); // Must have some reputation to vote

        if (_approve) {
            prop.votesForEvaluation += votingPower;
        } else {
            prop.votesAgainstEvaluation += votingPower;
        }
        emit ProposalEvaluationVote(_proposalId, msg.sender, _approve, votingPower);
    }

    /**
     * @dev Internal or authorized function to trigger an off-chain AI oracle request for a deeper evaluation.
     * This function's access control would typically be managed by a governance vote or an automated system
     * after initial human evaluation. For simplicity, it's callable by the proposal submitter here,
     * but in a real system, an external bot or governance would trigger this.
     * @param _proposalId The ID of the proposal to be evaluated by AI.
     */
    function requestAIEvaluation(uint256 _proposalId) public onlyRegisteredResearcher whenNotPaused {
        Proposal storage prop = proposals[_proposalId];
        if (prop.id != _proposalId) revert ProposalNotFound();
        if (prop.status != ProposalStatus.EvaluatingHuman && prop.status != ProposalStatus.Submitted) revert ProposalNotInCorrectStatus();
        // In a real system, this would make an external call to an oracle service.
        // For this example, we'll simulate it by moving status.
        _setProposalStatus(_proposalId, ProposalStatus.EvaluatingAI);
        emit AIEvaluationRequested(_proposalId);
    }

    /**
     * @dev Callback function for the designated AI oracle to submit its evaluation results.
     * This is expected to be called by the `aiEvaluationOracle` address after an off-chain AI computation.
     * @param _proposalId The ID of the proposal evaluated.
     * @param _aiApproved Boolean indicating if the AI approved the proposal.
     * @param _aiScore The numerical score provided by the AI (e.g., 0-100).
     */
    function receiveAIEvaluationCallback(uint256 _proposalId, bool _aiApproved, uint256 _aiScore) public onlyAIOracle whenNotPaused {
        Proposal storage prop = proposals[_proposalId];
        if (prop.id != _proposalId) revert ProposalNotFound();
        if (prop.status != ProposalStatus.EvaluatingAI) revert ProposalNotInCorrectStatus();

        prop.aiApproved = _aiApproved;
        prop.aiScore = _aiScore;

        // Decision logic after AI evaluation: if human votes are enough AND AI approves, then approved.
        // Or AI approval is overriding. This logic can be complex.
        // For simplicity: AI approval is critical for final approval.
        if (prop.aiApproved && prop.votesForEvaluation > prop.votesAgainstEvaluation) {
            _setProposalStatus(_proposalId, ProposalStatus.Approved);
        } else {
            _setProposalStatus(_proposalId, ProposalStatus.Rejected);
        }
        emit AIEvaluationReceived(_proposalId, _aiApproved, _aiScore);
    }

    /**
     * @dev Initiates the funding process for a proposal that has successfully passed all evaluation stages.
     * Transfers funds from the DAO treasury to a new project.
     * @param _proposalId The ID of the approved proposal to fund.
     */
    function fundApprovedProposal(uint256 _proposalId) public onlyOwner whenNotPaused { // Owner for simplicity, ideally by governance
        Proposal storage prop = proposals[_proposalId];
        if (prop.id != _proposalId) revert ProposalNotFound();
        if (prop.status != ProposalStatus.Approved) revert ProposalNotInCorrectStatus();
        if (address(this).balance < prop.requestedFunds) revert InsufficientTreasuryBalance(prop.requestedFunds, address(this).balance);

        uint256 newProjectId = _projectIdCounter.current();
        projects[newProjectId] = Project({
            id: newProjectId,
            proposalId: _proposalId,
            leadResearcher: prop.submitter,
            totalMilestones: prop.milestoneCount,
            currentMilestoneIndex: 0,
            fundedAmount: prop.requestedFunds,
            status: ProjectStatus.InProgress,
            ipNFTTokenId: 0
        });

        // Distribute funds for milestones, for simplicity, evenly here
        uint256 fundsPerMilestone = prop.requestedFunds / prop.milestoneCount;
        for (uint256 i = 0; i < prop.milestoneCount; i++) {
            milestones[newProjectId][i] = Milestone({
                ipfsDeliverableHash: "",
                approved: false,
                paymentClaimed: false,
                paymentAmount: fundsPerMilestone
            });
        }
        
        prop.projectId = newProjectId;
        _setProposalStatus(_proposalId, ProposalStatus.Funded);
        _projectIdCounter.increment();

        // No direct transfer here, funds are claimed per milestone.
        // This keeps the funds in the treasury until deliverables are approved.
        emit ProposalFunded(_proposalId, newProjectId, prop.submitter, prop.requestedFunds);
    }

    /**
     * @dev The project lead submits the deliverable for a specific project milestone.
     * @param _projectId The ID of the project.
     * @param _milestoneIndex The 0-indexed milestone number.
     * @param _ipfsDeliverableHash IPFS hash of the milestone deliverable.
     */
    function submitMilestoneDeliverable(uint256 _projectId, uint256 _milestoneIndex, string memory _ipfsDeliverableHash)
        public
        onlyProjectLead(_projectId)
        whenNotPaused
    {
        Project storage project = projects[_projectId];
        if (project.id != _projectId) revert ProjectNotFound();
        if (project.status != ProjectStatus.InProgress) revert ProjectNotInCorrectStatus();
        if (_milestoneIndex != project.currentMilestoneIndex) revert MilestoneNotFound(); // Must submit in order
        if (_milestoneIndex >= project.totalMilestones) revert MilestoneNotFound();

        milestones[_projectId][_milestoneIndex].ipfsDeliverableHash = _ipfsDeliverableHash;
        emit MilestoneDeliverableSubmitted(_projectId, _milestoneIndex, _ipfsDeliverableHash);
    }

    /**
     * @dev A designated evaluator (e.g., internal committee, AI oracle, or project lead for sub-milestones)
     * approves or rejects a submitted milestone deliverable.
     * This function's access control is simplified here to `onlyOwner` but would be more complex (e.g., trusted evaluators).
     * @param _projectId The ID of the project.
     * @param _milestoneIndex The 0-indexed milestone number.
     * @param _approved Boolean indicating if the deliverable is approved.
     */
    function evaluateMilestoneDeliverable(uint256 _projectId, uint256 _milestoneIndex, bool _approved) public onlyOwner whenNotPaused {
        Project storage project = projects[_projectId];
        if (project.id != _projectId) revert ProjectNotFound();
        if (_milestoneIndex >= project.totalMilestones) revert MilestoneNotFound();
        if (milestones[_projectId][_milestoneIndex].approved) revert MilestoneAlreadyApproved(); // Prevent re-evaluation

        milestones[_projectId][_milestoneIndex].approved = _approved;
        emit MilestoneDeliverableEvaluated(_projectId, _milestoneIndex, _approved);

        if (_approved) {
            // If the milestone is approved, increment the currentMilestoneIndex for the project
            // and check if all milestones are completed.
            project.currentMilestoneIndex++;
            if (project.currentMilestoneIndex == project.totalMilestones) {
                project.status = ProjectStatus.Completed;
                _increaseResearcherReputation(project.leadResearcher, 500); // Reward for project completion
                emit ProjectStatusChanged(_projectId, ProjectStatus.InProgress, ProjectStatus.Completed);
                _setProposalStatus(project.proposalId, ProposalStatus.Completed);
            }
        } else {
            // If milestone is rejected, lead can resubmit. For now, it stays in progress.
            // A more complex system might cancel the project, allow re-submission, etc.
            // Simple approach: no automatic status change on rejection, just awaits new submission.
        }
    }

    /**
     * @dev Allows the project lead to claim the payment for an approved milestone.
     * @param _projectId The ID of the project.
     * @param _milestoneIndex The 0-indexed milestone number.
     */
    function claimMilestonePayment(uint256 _projectId, uint256 _milestoneIndex) public onlyProjectLead(_projectId) whenNotPaused {
        Project storage project = projects[_projectId];
        if (project.id != _projectId) revert ProjectNotFound();
        if (_milestoneIndex >= project.totalMilestones) revert MilestoneNotFound();
        Milestone storage milestone = milestones[_projectId][_milestoneIndex];

        if (!milestone.approved) revert MilestoneNotApproved();
        if (milestone.paymentClaimed) revert MilestonePaymentAlreadyClaimed();
        
        if (address(this).balance < milestone.paymentAmount) revert InsufficientTreasuryBalance(milestone.paymentAmount, address(this).balance);

        milestone.paymentClaimed = true;

        (bool success,) = payable(project.leadResearcher).call{value: milestone.paymentAmount}("");
        if (!success) revert InvalidFunds(); // Transfer failed

        emit MilestonePaymentClaimed(_projectId, _milestoneIndex, milestone.paymentAmount);
    }

    // --- IV. Intellectual Property (IP) & Dynamic NFTs ---

    /**
     * @dev Mints a unique, non-fungible token (IP-NFT) representing the intellectual property
     * generated by a completed project. This IP-NFT can be dynamic.
     * @param _projectId The ID of the completed project.
     * @param _ipfsIPHash Initial IPFS hash pointing to the IP's metadata/content.
     * @param _recipient The address to receive the minted IP-NFT.
     */
    function mintResearchIPNFT(uint256 _projectId, string memory _ipfsIPHash, address _recipient) public onlyProjectLead(_projectId) whenNotPaused {
        Project storage project = projects[_projectId];
        if (project.id != _projectId) revert ProjectNotFound();
        if (project.status != ProjectStatus.Completed) revert ProjectNotInCorrectStatus();
        if (project.ipNFTTokenId != 0) revert InvalidIPNFT(); // IP-NFT already minted for this project

        uint256 newIpNFTId = _tokenIds.current();
        _tokenIds.increment();

        _mint(_recipient, newIpNFTId); // Mints the ERC721 token

        ipNFTs[newIpNFTId] = IPNFT({
            projectId: _projectId,
            ipfsIPHash: _ipfsIPHash,
            royaltyPercentage: 0, // Default to 0, can be set later via licensing
            accumulatedRoyalties: 0,
            owner: _recipient,
            isMinted: true
        });

        project.ipNFTTokenId = newIpNFTId; // Link project to its IP-NFT
        _setTokenURI(newIpNFTId, string(abi.encodePacked("ipfs://", _ipfsIPHash))); // Set initial token URI

        emit IPNFTMinted(newIpNFTId, _projectId, _recipient, _ipfsIPHash);
    }

    /**
     * @dev Allows the owner of an IP-NFT to update its associated metadata.
     * This makes the IP-NFT "dynamic", allowing evolution of the IP itself.
     * @param _tokenId The ID of the IP-NFT.
     * @param _newIpfsIPHash The new IPFS hash for the IP's metadata/content.
     */
    function updateIPNFTMetadata(uint256 _tokenId, string memory _newIpfsIPHash) public whenNotPaused {
        if (ownerOf(_tokenId) != msg.sender) revert NotIPNFTOwner();
        IPNFT storage ipNFT = ipNFTs[_tokenId];
        if (!ipNFT.isMinted) revert InvalidIPNFT();

        ipNFT.ipfsIPHash = _newIpfsIPHash;
        _setTokenURI(_tokenId, string(abi.encodePacked("ipfs://", _newIpfsIPHash))); // Update ERC721 token URI

        emit IPNFTMetadataUpdated(_tokenId, _newIpfsIPHash);
    }

    /**
     * @dev Establishes an on-chain license agreement for an IP-NFT, defining royalty terms.
     * This is a simplified licensing mechanism.
     * @param _tokenId The ID of the IP-NFT to license.
     * @param _licensee The address of the licensee.
     * @param _royaltyPercentage The percentage of revenue to be paid as royalty (e.g., 100 for 1%, 1000 for 10%).
     */
    function licenseResearchIP(uint256 _tokenId, address _licensee, uint256 _royaltyPercentage) public whenNotPaused {
        if (ownerOf(_tokenId) != msg.sender) revert NotIPNFTOwner();
        IPNFT storage ipNFT = ipNFTs[_tokenId];
        if (!ipNFT.isMinted) revert InvalidIPNFT();
        if (_royaltyPercentage > 10000) revert InvalidFunds(); // Max 100% (10000 basis points)

        if (ipLicenses[_tokenId][_licensee].isActive) revert IPNFTAlreadyLicensed();

        ipLicenses[_tokenId][_licensee] = License({
            licensee: _licensee,
            royaltyPercentage: _royaltyPercentage,
            isActive: true
        });

        ipNFT.royaltyPercentage = _royaltyPercentage; // Set main royalty for this IP-NFT
        emit IPLicensed(_tokenId, _licensee, _royaltyPercentage);
    }

    /**
     * @dev Allows the IP-NFT owner to collect accumulated royalty payments from licenses.
     * In a real-world scenario, revenue streams would be integrated (e.g., from an external payment system).
     * Here, it's a manual process where the licensee hypothetically sends funds to the contract,
     * and the IP-NFT owner collects them.
     * @param _tokenId The ID of the IP-NFT.
     */
    function collectIPRoyalties(uint256 _tokenId) public whenNotPaused {
        if (ownerOf(_tokenId) != msg.sender) revert NotIPNFTOwner();
        IPNFT storage ipNFT = ipNFTs[_tokenId];
        if (!ipNFT.isMinted) revert InvalidIPNFT();
        if (ipNFT.accumulatedRoyalties == 0) revert NoRoyaltiesToCollect();
        
        uint256 amountToCollect = ipNFT.accumulatedRoyalties;
        ipNFT.accumulatedRoyalties = 0; // Reset for future royalties

        (bool success,) = payable(msg.sender).call{value: amountToCollect}("");
        if (!success) revert InvalidFunds(); // Transfer failed
        emit IPRoyaltiesCollected(_tokenId, msg.sender, amountToCollect);
    }

    // This function would be called by a licensee to pay royalties.
    // In a real system, this would be integrated with the specific usage contract of the IP.
    // For demonstration, direct send will increase accumulatedRoyalties.
    function payRoyalties(uint256 _tokenId, address _licensee) external payable {
        IPNFT storage ipNFT = ipNFTs[_tokenId];
        if (!ipNFT.isMinted) revert InvalidIPNFT();
        License storage license = ipLicenses[_tokenId][_licensee];
        if (!license.isActive) revert IPNFTNotLicensed();
        if (msg.value == 0) revert InvalidFunds();

        // Calculate royalty amount from the sent value
        uint256 royaltyAmount = (msg.value * license.royaltyPercentage) / 10000;
        ipNFT.accumulatedRoyalties += royaltyAmount;
        // Remainder would go to the licensee's operational address or specific contract
        // (msg.value - royaltyAmount)
    }

    // --- V. Governance & Treasury Management ---

    /**
     * @dev Allows eligible researchers to propose changes to the DAO's parameters, contract upgrades,
     * or significant actions.
     * @param _ipfsProposalHash IPFS hash containing the detailed governance proposal.
     * @param _votingDeadlineEpoch The epoch by which voting must conclude.
     */
    function createGovernanceProposal(string memory _ipfsProposalHash, uint256 _votingDeadlineEpoch) public onlyRegisteredResearcher whenNotPaused {
        if (researcherReputation[msg.sender] < MIN_REP_TO_CREATE_GOV_PROPOSAL) {
            revert InsufficientReputation(MIN_REP_TO_CREATE_GOV_PROPOSAL, researcherReputation[msg.sender]);
        }
        if (_votingDeadlineEpoch <= currentEpoch + GOV_PROPOSAL_VOTING_PERIOD_EPOCHS) revert InvalidEpoch();

        uint256 newGovProposalId = _governanceProposalIdCounter.current();
        governanceProposals[newGovProposalId] = GovernanceProposal({
            id: newGovProposalId,
            submitter: msg.sender,
            ipfsProposalHash: _ipfsProposalHash,
            votingDeadlineEpoch: _votingDeadlineEpoch,
            votesFor: 0,
            votesAgainst: 0,
            status: GovernanceProposalStatus.Active,
            executed: false
        });
        _governanceProposalIdCounter.increment();
        emit GovernanceProposalCreated(newGovProposalId, msg.sender, _ipfsProposalHash);
    }

    /**
     * @dev Casts a reputation-weighted vote on an active governance proposal.
     * @param _proposalId The ID of the governance proposal.
     * @param _approve True for approval, false for rejection.
     */
    function voteOnGovernanceProposal(uint256 _proposalId, bool _approve) public onlyRegisteredResearcher whenNotPaused {
        GovernanceProposal storage govProp = governanceProposals[_proposalId];
        if (govProp.id != _proposalId) revert GovernanceProposalNotFound();
        if (govProp.status != GovernanceProposalStatus.Active) revert GovernanceProposalNotActive();
        if (currentEpoch >= govProp.votingDeadlineEpoch) revert InvalidEpoch();
        if (governanceProposalVotes[_proposalId][msg.sender]) revert GovernanceVoteAlreadyCast();

        address voter = msg.sender;
        if (reputationDelegates[msg.sender] != address(0)) {
            voter = reputationDelegates[msg.sender];
        }
        
        uint256 votingPower = researcherReputation[voter];
        if (votingPower == 0) revert InsufficientReputation(1, 0);

        if (_approve) {
            govProp.votesFor += votingPower;
        } else {
            govProp.votesAgainst += votingPower;
        }
        governanceProposalVotes[_proposalId][msg.sender] = true;
        emit GovernanceVoteCast(_proposalId, msg.sender, _approve, votingPower);
    }

    /**
     * @dev Executes an approved governance proposal once the voting period ends and quorum/thresholds are met.
     * Callable by anyone after the deadline.
     * @param _proposalId The ID of the governance proposal to execute.
     */
    function executeGovernanceProposal(uint256 _proposalId) public whenNotPaused {
        GovernanceProposal storage govProp = governanceProposals[_proposalId];
        if (govProp.id != _proposalId) revert GovernanceProposalNotFound();
        if (govProp.status != GovernanceProposalStatus.Passed) revert GovernanceProposalNotActive(); // Must be 'Passed'
        if (currentEpoch < govProp.votingDeadlineEpoch) revert NotEnoughVotes(); // Voting period not over
        if (govProp.executed) revert ProposalAlreadyExecuted();

        // In a real system, this would parse the IPFS hash and execute logic
        // For example, calling an `upgrade` function on a proxy contract,
        // or updating a state variable if the proposal was about parameter changes.
        // This is highly dependent on the nature of the governance proposal.
        // For now, it just marks as executed.
        govProp.executed = true;
        _setGovernanceProposalStatus(_proposalId, GovernanceProposalStatus.Executed);
        emit GovernanceProposalExecuted(_proposalId);
    }

    /**
     * @dev Allows external users to deposit Ether into the CognitoNexus DAO's treasury.
     */
    function depositToTreasury() public payable whenNotPaused {
        if (msg.value == 0) revert InvalidFunds();
        emit FundsDeposited(msg.sender, msg.value);
    }

    /**
     * @dev Allows funds to be withdrawn from the treasury. Typically triggered by an approved governance proposal
     * or for project funding after approval.
     * @param _recipient The address to send funds to.
     * @param _amount The amount of Ether to withdraw (in wei).
     */
    function withdrawFromTreasury(address _recipient, uint256 _amount) public onlyOwner whenNotPaused { // Simplified: onlyOwner, but ideally governance controlled
        if (address(this).balance < _amount) revert InsufficientTreasuryBalance(_amount, address(this).balance);
        if (_amount == 0) revert InvalidFunds();

        (bool success,) = payable(_recipient).call{value: _amount}("");
        if (!success) revert InvalidFunds(); // Transfer failed

        emit FundsWithdrawn(_recipient, _amount);
    }

    /**
     * @dev Admin/governance function to set or update the address of the trusted AI evaluation oracle.
     * @param _newOracleAddress The new address for the AI oracle.
     */
    function setAIEvaluationOracle(address _newOracleAddress) public onlyOwner {
        require(_newOracleAddress != address(0), "AI Oracle cannot be zero address");
        aiEvaluationOracle = _newOracleAddress;
    }

    // --- Internal/Private Helper Functions ---

    /**
     * @dev Internal function to update a proposal's status and emit an event.
     */
    function _setProposalStatus(uint256 _proposalId, ProposalStatus _newStatus) internal {
        Proposal storage prop = proposals[_proposalId];
        ProposalStatus oldStatus = prop.status;
        prop.status = _newStatus;
        emit ProposalStatusChanged(_proposalId, oldStatus, _newStatus);
    }

    /**
     * @dev Internal function to update a governance proposal's status and emit an event.
     */
    function _setGovernanceProposalStatus(uint256 _proposalId, GovernanceProposalStatus _newStatus) internal {
        GovernanceProposal storage govProp = governanceProposals[_proposalId];
        GovernanceProposalStatus oldStatus = govProp.status;
        govProp.status = _newStatus;
        emit GovernanceProposalStatusChanged(_proposalId, oldStatus, _newStatus);
    }

    /**
     * @dev Internal function to increase a researcher's reputation.
     */
    function _increaseResearcherReputation(address _researcher, uint256 _amount) internal {
        researcherReputation[_researcher] += _amount;
        // Optionally update researcher profile struct if it also stores reputation
        if (researchers[_researcher].isRegistered) {
            researchers[_researcher].reputation = researcherReputation[_researcher];
        }
        // If there's a delegate, update their delegated sum as well
        address delegatee = reputationDelegates[_researcher];
        if (delegatee != address(0)) {
            delegatedReputationSums[delegatee] += _amount;
        }
    }

    // --- ERC721 Overrides for Token URI (to support dynamic IP-NFT metadata) ---

    // The _setTokenURI function is already handled within `updateIPNFTMetadata` and `mintResearchIPNFT`
    // using the inherited _setTokenURI from ERC721.
}
```