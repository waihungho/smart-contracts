This smart contract, `ElysiumEngine`, represents a decentralized, self-evolving algorithmic ecosystem on the blockchain. Users interact with it by contributing resources ("Spark" for energy/computation and "GenesisSeed" for matter/data), influencing its growth, and claiming unique "Aether Fragments" (dynamic NFTs) generated as the engine evolves. The contract incorporates advanced concepts like on-chain state machines, algorithmic growth, decentralized governance for core parameters, time-based epochs, dynamic NFTs, and simulated computational tasks.

---

## ElysiumEngine: Outline and Function Summary

**Core Concept:** A self-evolving, decentralized algorithmic entity. Users fuel its growth with "Spark" (energy) and "GenesisSeed" (matter). The engine's internal "ElysiumState" changes dynamically, generating "Aether Fragments" (dynamic NFTs) based on complex rules and user actions. Governance allows users to steer the engine's evolution.

**Advanced Concepts Incorporated:**

1.  **Dynamic On-Chain State Machine:** The engine's `ElysiumState` is complex and changes based on internal logic, resource inputs, and external triggers.
2.  **Algorithmic Growth & Decay:** Sophisticated on-chain formulas determine resource consumption, growth multipliers, decay rates, and fragment generation.
3.  **Decentralized Parameter Governance:** Users propose and vote on changes to core engine parameters (e.g., mutation rates, resource efficiency) via a custom governance module.
4.  **Time-Based Epochs & Events:** The engine operates in "Epochs," and users can strategically trigger "Environmental Events" that significantly alter its trajectory.
5.  **Dynamic NFTs (Aether Fragments):** ERC-721 tokens whose properties (metadata URI or internal attributes) can evolve based on engine state, fragment age, or further resource investment.
6.  **Internal Resource Allocation:** The engine itself holds and manages Spark and GenesisSeed for its internal "computation" and "replication."
7.  **Simulated Proof-of-Work/VDF:** A mechanism where users "commit" resources for a time-locked "computation," influencing future outcomes or unlocking unique fragment types.
8.  **Quadratic-like Influence:** For certain governance actions, a simplified quadratic voting model can be integrated (e.g., by weighting proposal costs).
9.  **Randomness & Controlled Chaos:** Introduction of controlled pseudorandomness for mutation events and "Chaos Epochs" to introduce unpredictability.
10. **Prediction/Forecasting:** On-chain mechanisms to "predict" future engine states or fragment characteristics based on current parameters.

---

### Function Summary:

**I. Core Engine State & Management**
1.  `constructor`: Initializes the engine, sets initial parameters, and configures external token interfaces.
2.  `updateEngineStateInternal`: (Internal) The heart of the engine; calculates growth, resource consumption, decay, and potentially new fragment generation based on elapsed time and current parameters.
3.  `getEngineState`: (View) Returns the current, detailed state of the `ElysiumEngine` (e.g., complexity, accumulated resources, current epoch).
4.  `getEngineHealthScore`: (View) Calculates a composite health metric based on current resources, complexity, and decay rates, indicating the engine's vitality.
5.  `triggerEnvironmentalEpoch`: Allows users to pay a fee to immediately advance the engine to a new epoch, potentially altering growth dynamics or triggering specific events.
6.  `pauseEngineOperations`: (Owner/Governance) Halts critical engine functions (e.g., resource contributions, fragment generation) during maintenance or emergencies.
7.  `unpauseEngineOperations`: (Owner/Governance) Resumes engine functions after a pause.

**II. Resource Management (Spark & GenesisSeed Tokens)**
8.  `contributeSpark`: Users deposit Spark tokens to fuel engine growth and operations. Spark is consumed by `updateEngineStateInternal`.
9.  `contributeGenesisSeed`: Users deposit GenesisSeed tokens as building blocks for complexity and fragment generation.
10. `getEngineSparkBalance`: (View) Returns the current balance of Spark tokens held by the engine contract.
11. `getEngineGenesisSeedBalance`: (View) Returns the current balance of GenesisSeed tokens held by the engine contract.
12. `claimStakedResources`: Allows users to withdraw any resources (Spark/GenesisSeed) that were committed but not consumed, or refunded from failed operations.

**III. Aether Fragment (Dynamic NFT) Operations**
13. `claimAetherFragment`: Allows a user to claim an available AetherFragment NFT that has been generated by the engine due to its growth.
14. `getAetherFragmentDetails`: (View) Returns detailed properties (e.g., generation epoch, rarity, current attributes) of a specific AetherFragment NFT.
15. `evolveAetherFragment`: Allows users to invest additional Spark/GenesisSeed into a claimed AetherFragment to mutate its properties or upgrade its rarity.
16. `burnAetherFragment`: Users can burn their AetherFragment for a proportional resource return from the engine's reserves or a special reward.
17. `proposeFragmentEvolutionRule`: (Governance) Proposes new rules, costs, or probabilities for how AetherFragments can evolve, requiring community approval.

**IV. Governance & Parameter Evolution**
18. `proposeEngineParameterChange`: Users can propose adjustments to core engine parameters (e.g., complexity growth factor, mutation chance, decay rate). Requires a bond.
19. `voteOnParameterProposal`: Users cast votes (weighted by their stake or influence) on active parameter change proposals.
20. `executeParameterChange`: (Governance) If a proposal meets quorum and passes, this function applies the new parameters to the engine's state.
21. `getProposalDetails`: (View) Retrieves comprehensive information about a specific governance proposal, including votes and status.
22. `setCoreGrowthAlgorithm`: (Governance) Allows governance to approve and update the internal mathematical formulas or constants that dictate the engine's growth and decay logic.

**V. Advanced & Creative Mechanisms**
23. `simulateComputationTask`: Users commit Spark for a time-locked, simulated "computation." Upon completion, this task can influence future engine events (e.g., temporary boost to fragmentation rate) or unlock unique fragment types. (Inspired by VDFs).
24. `initiateChaosEvent`: A high-cost, high-impact environmental event that, when triggered, introduces significant randomness and potential for rapid, unpredictable state changes or mutations within the engine.
25. `queryNextFragmentPrediction`: (View) Provides a probabilistic prediction of the next AetherFragment's characteristics based on the current engine state, parameters, and historical data.
26. `setupEcosystemBounty`: (Owner/Governance) Allows setting up bounties (funded by the engine or specific users) for achieving certain engine milestones or contributions.
27. `setOracleFeedConfiguration`: (Owner/Governance) Configures an (abstracted) external oracle to feed "environmental data" (e.g., simulated market volatility, weather) that dynamically influences epoch triggers or parameter adjustments.
28. `setDynamicPricingModel`: (Owner/Governance) Allows adjusting the impact or cost of resource contributions based on an internal dynamic pricing model (e.g., to manage supply/demand of engine capacity).
29. `redeemEngineShare`: Allows long-term contributors, based on specific criteria (e.g., total contributions, fragment ownership), to redeem a proportional share of the engine's accumulated, surplus resources.
30. `updateFragmentRenderingURI`: (Governance) Allows updating the base URI for AetherFragment metadata, enabling dynamic changes to how NFTs are rendered or to link to evolving off-chain data.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/Counters.sol"; // For fragment IDs and proposal IDs.
import "@openzeppelin/contracts/utils/math/SafeMath.sol"; // Using SafeMath for explicit clarity, though 0.8+ has built-in checks.

// --- Minimal Custom Interfaces for Tokens/NFTs (to avoid duplicating OpenZeppelin implementations) ---
// These interfaces define the expected behavior of external ERC-20 and ERC-721 contracts.
// The actual implementation of these tokens is assumed to exist elsewhere and adhere to these standards.

interface ISparkToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface IGenesisSeedToken {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address recipient, uint256 amount) external returns (bool);
}

interface IAetherFragmentNFT {
    function mint(address to, uint256 tokenId, uint256 generationEpoch, uint256 rarity, string memory initialUri) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function ownerOf(uint256 tokenId) external view returns (address);
    function tokenURI(uint256 tokenId) external view returns (string memory);
    function updateFragmentAttributes(uint256 tokenId, uint256 newRarity, string memory newUri) external;
    function burn(uint256 tokenId) external;
    function setBaseURI(string memory baseURI_) external;
    // Additional view function for the Engine to query fragment properties directly
    function getFragmentProperties(uint256 tokenId) external view returns (uint256 generationEpoch, uint256 rarity, uint256 evolutionLevel);
}

contract ElysiumEngine is Ownable, Pausable {
    using SafeMath for uint256;
    using Counters for Counters.Counter;

    // --- State Variables ---

    ISparkToken public sparkToken;
    IGenesisSeedToken public genesisSeedToken;
    IAetherFragmentNFT public aetherFragmentNFT;

    // Elysium Engine's core state
    struct ElysiumState {
        uint256 lastUpdateTimestamp;
        uint256 currentEpoch;
        uint256 complexityLevel; // Reflects accumulated growth and internal processing
        uint256 fragmentationRate; // How often fragments are generated (fragments per complexity unit per epoch)
        uint256 mutationChance; // Chance for state mutation or fragment rarity upgrade
        uint256 decayRate; // Rate at which complexity/resources might decay per epoch
        uint256 generatedFragmentCount; // Total fragments minted by the engine
        uint256 accumulatedUnclaimedFragments; // Fragments generated but not yet claimed by any user
        mapping(address => uint256) pendingFragmentClaims; // User's share of unclaimed fragments
    }
    ElysiumState public elysiumState;

    // Engine Parameters (governable)
    struct EngineParameters {
        uint256 baseSparkConsumptionPerUnitComplexity; // Spark consumed per complexity unit per epoch
        uint256 baseSeedConsumptionPerUnitComplexity; // GenesisSeed consumed per complexity unit per epoch
        uint256 complexityGrowthFactor; // Multiplier for complexity growth from resources
        uint256 minFragmentationRate; // Minimum fragmentation rate (to avoid 0)
        uint256 maxMutationChance; // Maximum possible mutation chance
        uint256 baseDecayRate; // Base decay rate (applied if resources are low)
        uint256 epochDuration; // How long an epoch typically lasts (in seconds)
        uint256 environmentalEpochCost; // Cost to trigger an environmental epoch
    }
    EngineParameters public engineParams;

    // Governance System
    struct Proposal {
        uint256 proposalId;
        bytes32 paramKeyHash; // Hashed string of the parameter name (e.g., keccak256("complexityGrowthFactor"))
        uint256 newValue;
        uint256 creationTimestamp;
        uint256 endTimestamp;
        uint256 votesFor;
        uint256 votesAgainst;
        address proposer;
        bool executed;
        bool passed;
        mapping(address => bool) hasVoted;
    }
    Counters.Counter private _proposalIdCounter;
    mapping(uint256 => Proposal) public proposals;
    uint256 public proposalVoteQuorumNumerator = 50; // 50% quorum (of total votes cast)
    uint256 public proposalVotePeriod = 3 days; // Voting period for proposals
    uint256 public proposalThreshold = 100 ether; // Minimum Spark required to propose (simplified)

    // Simulated Computation Task (VDF-like)
    struct ComputationTask {
        address user;
        uint256 sparkCommitment;
        uint256 commitmentTimestamp;
        uint256 releaseTimestamp;
        bool completed;
        uint256 rewardMultiplier; // Affects output or future engine state
    }
    Counters.Counter private _computationTaskIdCounter;
    mapping(uint256 => ComputationTask) public computationTasks;
    mapping(address => uint256) public userStakedResources; // For claimStakedResources

    // --- Events ---
    event EngineStateUpdated(uint256 newComplexity, uint256 newEpoch, uint256 newFragmentCount);
    event ResourcesContributed(address indexed contributor, uint256 sparkAmount, uint256 seedAmount);
    event FragmentClaimed(address indexed recipient, uint256 tokenId, uint256 generationEpoch, uint256 rarity);
    event FragmentEvolved(uint256 tokenId, uint256 newRarity, uint256 newEvolutionLevel);
    event FragmentBurned(address indexed owner, uint256 tokenId, uint256 refundedSpark, uint256 refundedSeed);
    event ParameterProposalCreated(uint256 indexed proposalId, bytes32 paramKey, uint256 newValue, address indexed proposer);
    event ProposalVoted(uint256 indexed proposalId, address indexed voter, bool support, uint256 weight);
    event ProposalExecuted(uint256 indexed proposalId, bool passed);
    event ComputationTaskInitiated(uint256 indexed taskId, address indexed user, uint256 sparkAmount, uint256 releaseTimestamp);
    event ComputationTaskCompleted(uint256 indexed taskId, address indexed user);
    event ChaosEventTriggered(address indexed initiator, uint256 cost, uint256 effectiveRandomness);
    event EnvironmentalEpochTriggered(address indexed initiator, uint256 epoch);
    event OracleFeedConfigured(address indexed oracleAddress, uint256 dataFeedId);
    event BountySetup(uint256 indexed bountyId, address indexed targetAddress, uint256 amount, string description);

    // --- Constructor ---
    constructor(
        address _sparkTokenAddress,
        address _genesisSeedTokenAddress,
        address _aetherFragmentNFTAddress
    ) Ownable(msg.sender) Pausable() {
        require(_sparkTokenAddress != address(0), "Invalid Spark token address");
        require(_genesisSeedTokenAddress != address(0), "Invalid GenesisSeed token address");
        require(_aetherFragmentNFTAddress != address(0), "Invalid AetherFragment NFT address");

        sparkToken = ISparkToken(_sparkTokenAddress);
        genesisSeedToken = IGenesisSeedToken(_genesisSeedTokenAddress);
        aetherFragmentNFT = IAetherFragmentNFT(_aetherFragmentNFTAddress);

        // Initial ElysiumState
        elysiumState.lastUpdateTimestamp = block.timestamp;
        elysiumState.currentEpoch = 1;
        elysiumState.complexityLevel = 100; // Start with some initial complexity
        elysiumState.fragmentationRate = 1; // 1 fragment per 100 complexity units per epoch (example)
        elysiumState.mutationChance = 50; // 0.5% mutation chance (example)
        elysiumState.decayRate = 1; // 0.01% decay per epoch (example)
        elysiumState.generatedFragmentCount = 0;
        elysiumState.accumulatedUnclaimedFragments = 0;

        // Initial EngineParameters (can be changed by governance)
        engineParams.baseSparkConsumptionPerUnitComplexity = 10; // 10 Spark
        engineParams.baseSeedConsumptionPerUnitComplexity = 5; // 5 GenesisSeed
        engineParams.complexityGrowthFactor = 100; // Multiplier, e.g., 100 means 1 unit of growth per 100 units of resources
        engineParams.minFragmentationRate = 1;
        engineParams.maxMutationChance = 1000; // 10%
        engineParams.baseDecayRate = 10; // 0.1%
        engineParams.epochDuration = 6 hours; // 6 hours per epoch
        engineParams.environmentalEpochCost = 1 ether; // 1 Spark token (simplified for now)
    }

    // --- Modifier for governance-controlled functions ---
    modifier onlyGovernors() {
        // For simplicity, owner is governor for now.
        // In a full DAO, this would check against a governance token holder's voting power or a timelock.
        require(msg.sender == owner(), "Not authorized for governance actions.");
        _;
    }

    // --- I. Core Engine State & Management ---

    /**
     * @notice Internal function to update the engine's state based on elapsed time and resource consumption.
     * This is the core logic that drives the engine's evolution.
     * It is called by various external interaction functions.
     */
    function updateEngineStateInternal() internal {
        if (block.timestamp <= elysiumState.lastUpdateTimestamp) {
            return; // No time has passed, no update needed
        }

        uint256 timeElapsed = block.timestamp.sub(elysiumState.lastUpdateTimestamp);
        uint256 epochsPassed = timeElapsed.div(engineParams.epochDuration);

        if (epochsPassed == 0) return;

        elysiumState.lastUpdateTimestamp = block.timestamp;
        elysiumState.currentEpoch = elysiumState.currentEpoch.add(epochsPassed);

        // --- Resource Consumption & Decay ---
        uint256 totalSparkNeeded = engineParams.baseSparkConsumptionPerUnitComplexity.mul(elysiumState.complexityLevel).mul(epochsPassed);
        uint256 totalSeedNeeded = engineParams.baseSeedConsumptionPerUnitComplexity.mul(elysiumState.complexityLevel).mul(epochsPassed);

        uint256 sparkAvailable = sparkToken.balanceOf(address(this));
        uint256 seedAvailable = genesisSeedToken.balanceOf(address(this));

        uint256 sparkConsumed = totalSparkNeeded;
        if (sparkAvailable < totalSparkNeeded) {
            sparkConsumed = sparkAvailable;
            // Introduce accelerated decay if Spark is insufficient
            elysiumState.complexityLevel = elysiumState.complexityLevel.mul(10000 - engineParams.baseDecayRate.mul(2)).div(10000);
        }
        sparkToken.transfer(address(0xdead), sparkConsumed); // Simulate burning consumed Spark

        uint256 seedConsumed = totalSeedNeeded;
        if (seedAvailable < totalSeedNeeded) {
            seedConsumed = seedAvailable;
            // Introduce accelerated decay if Seed is insufficient
            elysiumState.complexityLevel = elysiumState.complexityLevel.mul(10000 - engineParams.baseDecayRate.mul(2)).div(10000);
        }
        genesisSeedToken.transfer(address(0xdead), seedConsumed); // Simulate burning consumed Seed

        // --- Complexity Growth ---
        uint256 sparkEfficiency = sparkAvailable > 0 ? sparkConsumed.mul(10000).div(sparkAvailable) : 0;
        uint256 seedEfficiency = seedAvailable > 0 ? seedConsumed.mul(10000).div(seedAvailable) : 0;

        uint256 growthFactor = (sparkEfficiency.add(seedEfficiency)).div(2).mul(engineParams.complexityGrowthFactor).div(10000);
        elysiumState.complexityLevel = elysiumState.complexityLevel.add(elysiumState.complexityLevel.mul(growthFactor).div(10000)).sub(
            elysiumState.complexityLevel.mul(engineParams.baseDecayRate).div(10000) // Apply base decay
        );
        if (elysiumState.complexityLevel < 1) elysiumState.complexityLevel = 1; // Ensure complexity doesn't drop to zero

        // --- Fragment Generation ---
        uint256 newFragmentsGenerated = elysiumState.complexityLevel.mul(elysiumState.fragmentationRate).mul(epochsPassed).div(100000); // Scale down for reasonable numbers
        if (newFragmentsGenerated > 0) {
            elysiumState.generatedFragmentCount = elysiumState.generatedFragmentCount.add(newFragmentsGenerated);
            elysiumState.accumulatedUnclaimedFragments = elysiumState.accumulatedUnclaimedFragments.add(newFragmentsGenerated);
        }

        emit EngineStateUpdated(elysiumState.complexityLevel, elysiumState.currentEpoch, newFragmentsGenerated);
    }

    /**
     * @notice Returns the current complex state of the ElysiumEngine.
     * @return _lastUpdateTimestamp The timestamp of the last state update.
     * @return _currentEpoch The current epoch number.
     * @return _complexityLevel The current complexity level of the engine.
     * @return _fragmentationRate The current rate at which fragments are generated.
     * @return _mutationChance The current chance for state mutation or fragment rarity upgrade.
     * @return _decayRate The current rate at which complexity/resources might decay per epoch.
     * @return _generatedFragmentCount The total number of fragments generated by the engine.
     * @return _accumulatedUnclaimedFragments The total number of fragments generated but not yet claimed.
     */
    function getEngineState() public view returns (
        uint256 _lastUpdateTimestamp,
        uint256 _currentEpoch,
        uint256 _complexityLevel,
        uint256 _fragmentationRate,
        uint256 _mutationChance,
        uint256 _decayRate,
        uint256 _generatedFragmentCount,
        uint256 _accumulatedUnclaimedFragments
    ) {
        return (
            elysiumState.lastUpdateTimestamp,
            elysiumState.currentEpoch,
            elysiumState.complexityLevel,
            elysiumState.fragmentationRate,
            elysiumState.mutationChance,
            elysiumState.decayRate,
            elysiumState.generatedFragmentCount,
            elysiumState.accumulatedUnclaimedFragments
        );
    }

    /**
     * @notice Calculates a composite health metric based on current resources and state.
     * @return healthScore A score representing the engine's vitality (higher is healthier).
     */
    function getEngineHealthScore() public view returns (uint256 healthScore) {
        uint256 sparkRatio = sparkToken.balanceOf(address(this)).mul(100).div(engineParams.baseSparkConsumptionPerUnitComplexity.mul(elysiumState.complexityLevel).mul(10));
        uint256 seedRatio = genesisSeedToken.balanceOf(address(this)).mul(100).div(engineParams.baseSeedConsumptionPerUnitComplexity.mul(elysiumState.complexityLevel).mul(10));
        
        // Simple heuristic: average resource ratio + complexity level, capped.
        healthScore = (sparkRatio.add(seedRatio).div(2)).add(elysiumState.complexityLevel.div(100)); // Capped complexity impact

        if (healthScore > 1000) healthScore = 1000; // Max health score
        return healthScore;
    }

    /**
     * @notice Allows users to trigger an environmental epoch immediately by paying a Spark fee.
     * This can accelerate the engine's state updates or specific events.
     */
    function triggerEnvironmentalEpoch() public whenNotPaused {
        updateEngineStateInternal(); // Ensure state is up-to-date
        require(sparkToken.transferFrom(msg.sender, address(this), engineParams.environmentalEpochCost), "Spark transfer failed for epoch trigger");
        sparkToken.transfer(address(0xdead), engineParams.environmentalEpochCost); // Burn the cost

        elysiumState.lastUpdateTimestamp = block.timestamp; // Reset timestamp to simulate immediate epoch advancement
        elysiumState.currentEpoch = elysiumState.currentEpoch.add(1);

        emit EnvironmentalEpochTriggered(msg.sender, elysiumState.currentEpoch);
        updateEngineStateInternal(); // Run another update immediately to reflect new epoch
    }

    /**
     * @notice Owner/Governance can pause critical engine operations.
     */
    function pauseEngineOperations() public onlyOwner {
        _pause();
    }

    /**
     * @notice Owner/Governance can unpause engine operations.
     */
    function unpauseEngineOperations() public onlyOwner {
        _unpause();
    }

    // --- II. Resource Management (Spark & GenesisSeed Tokens) ---

    /**
     * @notice Users deposit Spark tokens to fuel engine growth.
     * @param amount The amount of Spark to contribute.
     */
    function contributeSpark(uint256 amount) public whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        updateEngineStateInternal(); // Update state before processing contribution
        require(sparkToken.transferFrom(msg.sender, address(this), amount), "Spark contribution failed");
        emit ResourcesContributed(msg.sender, amount, 0);
    }

    /**
     * @notice Users deposit GenesisSeed tokens as building blocks.
     * @param amount The amount of GenesisSeed to contribute.
     */
    function contributeGenesisSeed(uint256 amount) public whenNotPaused {
        require(amount > 0, "Amount must be greater than zero");
        updateEngineStateInternal(); // Update state before processing contribution
        require(genesisSeedToken.transferFrom(msg.sender, address(this), amount), "GenesisSeed contribution failed");
        emit ResourcesContributed(msg.sender, 0, amount);
    }

    /**
     * @notice Returns the current balance of Spark tokens held by the engine contract.
     */
    function getEngineSparkBalance() public view returns (uint256) {
        return sparkToken.balanceOf(address(this));
    }

    /**
     * @notice Returns the current balance of GenesisSeed tokens held by the engine contract.
     */
    function getEngineGenesisSeedBalance() public view returns (uint256) {
        return genesisSeedToken.balanceOf(address(this));
    }

    /**
     * @notice Allows users to withdraw any resources (Spark/GenesisSeed) that were committed but not consumed,
     * or refunded from failed operations (e.g., failed proposals or computation tasks).
     */
    function claimStakedResources() public {
        uint256 staked = userStakedResources[msg.sender];
        require(staked > 0, "No staked resources to claim.");
        userStakedResources[msg.sender] = 0;
        require(sparkToken.transfer(msg.sender, staked), "Failed to transfer staked Spark.");
    }

    // --- III. Aether Fragment (Dynamic NFT) Operations ---

    /**
     * @notice Allows a user to claim an available AetherFragment NFT generated by the engine.
     * Fragments are distributed based on a simplified proportional share of unclaimed fragments.
     */
    function claimAetherFragment() public whenNotPaused {
        updateEngineStateInternal(); // Update state to generate potential new fragments

        require(elysiumState.accumulatedUnclaimedFragments > 0, "No new fragments available to claim.");

        // Simplistic claim mechanism: user gets 1 fragment at a time from the pool.
        // In a more complex system, this could be based on contribution, lottery, or specific conditions.
        elysiumState.accumulatedUnclaimedFragments = elysiumState.accumulatedUnclaimedFragments.sub(1);

        // Determine rarity based on current mutationChance
        uint256 rarity = _calculateFragmentRarity();
        Counters.Counter storage tokenIdCounter;
        tokenIdCounter._increment();
        uint256 newTokenId = tokenIdCounter.current();

        aetherFragmentNFT.mint(msg.sender, newTokenId, elysiumState.currentEpoch, rarity, _generateFragmentURI(newTokenId, rarity, 0));

        emit FragmentClaimed(msg.sender, newTokenId, elysiumState.currentEpoch, rarity);
    }

    /**
     * @notice Returns detailed properties of a specific AetherFragment NFT.
     * @param tokenId The ID of the AetherFragment.
     * @return generationEpoch The epoch in which the fragment was generated.
     * @return rarity The current rarity level of the fragment.
     * @return evolutionLevel The evolution level of the fragment.
     * @return tokenURI The current metadata URI for the fragment.
     */
    function getAetherFragmentDetails(uint256 tokenId) public view returns (uint256 generationEpoch, uint256 rarity, uint256 evolutionLevel, string memory tokenURI) {
        (generationEpoch, rarity, evolutionLevel) = aetherFragmentNFT.getFragmentProperties(tokenId);
        tokenURI = aetherFragmentNFT.tokenURI(tokenId);
    }

    /**
     * @notice Users can invest additional Spark/GenesisSeed into a claimed AetherFragment to mutate its properties or upgrade its rarity.
     * @param tokenId The ID of the AetherFragment to evolve.
     * @param sparkAmount The amount of Spark to invest.
     * @param seedAmount The amount of GenesisSeed to invest.
     */
    function evolveAetherFragment(uint256 tokenId, uint256 sparkAmount, uint256 seedAmount) public whenNotPaused {
        require(aetherFragmentNFT.ownerOf(tokenId) == msg.sender, "Must own the fragment to evolve it.");
        require(sparkAmount > 0 || seedAmount > 0, "Must invest resources to evolve.");

        updateEngineStateInternal(); // Update engine state

        if (sparkAmount > 0) {
            require(sparkToken.transferFrom(msg.sender, address(this), sparkAmount), "Spark investment failed.");
            sparkToken.transfer(address(0xdead), sparkAmount); // Consume Spark
        }
        if (seedAmount > 0) {
            require(genesisSeedToken.transferFrom(msg.sender, address(this), seedAmount), "GenesisSeed investment failed.");
            genesisSeedToken.transfer(address(0xdead), seedAmount); // Consume Seed
        }

        // Simulate evolution logic: higher investment, higher chance of rarity upgrade
        (uint256 generationEpoch, uint256 currentRarity, uint256 currentEvolutionLevel) = aetherFragmentNFT.getFragmentProperties(tokenId);
        uint256 newRarity = currentRarity;
        uint256 newEvolutionLevel = currentEvolutionLevel.add(1);

        uint256 totalInvestmentValue = sparkAmount.add(seedAmount.mul(2)); // Seed is more valuable (example)
        if (totalInvestmentValue > 1000 && _rollDice(elysiumState.mutationChance.mul(totalInvestmentValue).div(10000))) {
            newRarity = newRarity.add(1); // Rarity upgrade
            if (newRarity > 10) newRarity = 10; // Cap rarity
        }

        aetherFragmentNFT.updateFragmentAttributes(tokenId, newRarity, _generateFragmentURI(tokenId, newRarity, newEvolutionLevel));
        emit FragmentEvolved(tokenId, newRarity, newEvolutionLevel);
    }

    /**
     * @notice Users can burn their AetherFragment for a proportional resource return or unique reward.
     * @param tokenId The ID of the AetherFragment to burn.
     */
    function burnAetherFragment(uint256 tokenId) public whenNotPaused {
        require(aetherFragmentNFT.ownerOf(tokenId) == msg.sender, "Must own the fragment to burn it.");

        (uint256 generationEpoch, uint256 rarity, uint256 evolutionLevel) = aetherFragmentNFT.getFragmentProperties(tokenId);
        
        // Calculate refund based on rarity and evolution level (example formula)
        uint256 refundSpark = rarity.mul(10).add(evolutionLevel.mul(5));
        uint256 refundSeed = rarity.mul(5).add(evolutionLevel.mul(2));

        aetherFragmentNFT.burn(tokenId);

        if (refundSpark > 0) sparkToken.transfer(msg.sender, refundSpark);
        if (refundSeed > 0) genesisSeedToken.transfer(msg.sender, refundSeed);

        emit FragmentBurned(msg.sender, tokenId, refundSpark, refundSeed);
    }

    /**
     * @notice (Governance) Proposes new rules or parameters for how AetherFragments can evolve.
     * This would trigger a governance proposal process. For now, it's a placeholder.
     * @param newRuleHash A hash representing the new rule set (e.g., IPFS hash of a rule document).
     * @param costMultiplier A multiplier for evolution costs.
     */
    function proposeFragmentEvolutionRule(bytes32 newRuleHash, uint256 costMultiplier) public onlyGovernors {
        // In a full governance system, this would create a proposal.
        // For this contract, only owner can set this directly for now.
        // engineParams.fragmentEvolutionCostMultiplier = costMultiplier; // Example parameter
        // Further logic for rule changes.
    }

    // --- IV. Governance & Parameter Evolution ---

    /**
     * @notice Users propose adjustments to core engine parameters. Requires a Spark bond.
     * @param paramKey The string name of the parameter to change (e.g., "complexityGrowthFactor").
     * @param newValue The desired new value for the parameter.
     */
    function proposeEngineParameterChange(string memory paramKey, uint256 newValue) public whenNotPaused {
        require(sparkToken.transferFrom(msg.sender, address(this), proposalThreshold), "Insufficient Spark for proposal bond.");
        userStakedResources[msg.sender] = userStakedResources[msg.sender].add(proposalThreshold); // Hold bond

        _proposalIdCounter._increment();
        uint256 proposalId = _proposalIdCounter.current();

        bytes32 paramKeyHash = keccak256(abi.encodePacked(paramKey));
        Proposal storage proposal = proposals[proposalId];
        proposal.proposalId = proposalId;
        proposal.paramKeyHash = paramKeyHash;
        proposal.newValue = newValue;
        proposal.creationTimestamp = block.timestamp;
        proposal.endTimestamp = block.timestamp.add(proposalVotePeriod);
        proposal.proposer = msg.sender;

        emit ParameterProposalCreated(proposalId, paramKeyHash, newValue, msg.sender);
    }

    /**
     * @notice Users cast votes on active parameter change proposals.
     * @param proposalId The ID of the proposal to vote on.
     * @param support True for 'for', false for 'against'.
     */
    function voteOnParameterProposal(uint256 proposalId, bool support) public whenNotPaused {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.proposer != address(0), "Proposal does not exist.");
        require(block.timestamp <= proposal.endTimestamp, "Voting period has ended.");
        require(!proposal.hasVoted[msg.sender], "Already voted on this proposal.");

        // For simplicity, voting power is 1 per user. Could be weighted by Spark stake.
        uint256 voteWeight = 1; // Simplified voting power

        if (support) {
            proposal.votesFor = proposal.votesFor.add(voteWeight);
        } else {
            proposal.votesAgainst = proposal.votesAgainst.add(voteWeight);
        }
        proposal.hasVoted[msg.sender] = true;

        emit ProposalVoted(proposalId, msg.sender, support, voteWeight);
    }

    /**
     * @notice (Governance) Executes a passed proposal, applying new parameters to the engine.
     * Only callable by owner for now, but in full DAO, it would be by anyone after voting period.
     * @param proposalId The ID of the proposal to execute.
     */
    function executeParameterChange(uint256 proposalId) public onlyOwner { // Simplified: only owner executes for now
        Proposal storage proposal = proposals[proposalId];
        require(proposal.proposer != address(0), "Proposal does not exist.");
        require(block.timestamp > proposal.endTimestamp, "Voting period not ended.");
        require(!proposal.executed, "Proposal already executed.");

        uint256 totalVotes = proposal.votesFor.add(proposal.votesAgainst);
        require(totalVotes > 0, "No votes cast on this proposal."); // No quorum check if no votes

        // Check quorum (simplified: if total votes are at least a minimum threshold, not against total supply)
        // require(totalVotes >= MIN_VOTES_FOR_QUORUM, "Not enough votes for quorum.");

        // Check if passed (simple majority for now)
        proposal.passed = proposal.votesFor.mul(100).div(totalVotes) >= proposalVoteQuorumNumerator;

        if (proposal.passed) {
            // Apply the parameter change
            _applyParameterChange(proposal.paramKeyHash, proposal.newValue);
            // Refund proposer's bond
            userStakedResources[proposal.proposer] = userStakedResources[proposal.proposer].sub(proposalThreshold);
            sparkToken.transfer(proposal.proposer, proposalThreshold);
        } else {
            // No refund if proposal failed
            sparkToken.transfer(address(0xdead), proposalThreshold); // Burn bond
        }

        proposal.executed = true;
        emit ProposalExecuted(proposalId, proposal.passed);
    }

    /**
     * @notice Retrieves information about a specific governance proposal.
     * @param proposalId The ID of the proposal.
     * @return _paramKeyHash The hash of the parameter key.
     * @return _newValue The proposed new value.
     * @return _creationTimestamp The timestamp when the proposal was created.
     * @return _endTimestamp The timestamp when the voting period ends.
     * @return _votesFor The total votes for the proposal.
     * @return _votesAgainst The total votes against the proposal.
     * @return _proposer The address of the proposer.
     * @return _executed Whether the proposal has been executed.
     * @return _passed Whether the proposal passed.
     */
    function getProposalDetails(uint256 proposalId) public view returns (
        bytes32 _paramKeyHash,
        uint256 _newValue,
        uint256 _creationTimestamp,
        uint256 _endTimestamp,
        uint256 _votesFor,
        uint256 _votesAgainst,
        address _proposer,
        bool _executed,
        bool _passed
    ) {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.paramKeyHash,
            proposal.newValue,
            proposal.creationTimestamp,
            proposal.endTimestamp,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.proposer,
            proposal.executed,
            proposal.passed
        );
    }

    /**
     * @notice (Governance) Allows the core growth algorithm's constants to be updated via governance.
     * This function's specific parameters would vary based on the complexity of the algorithm.
     * For this example, we'll assume it updates `complexityGrowthFactor` and `fragmentationRate`.
     * @param newGrowthFactor A new value for complexityGrowthFactor.
     * @param newFragmentationRate A new value for fragmentationRate.
     */
    function setCoreGrowthAlgorithm(uint256 newGrowthFactor, uint256 newFragmentationRate) public onlyGovernors {
        // This would typically go through the full proposal/vote/execute cycle
        // For simplicity, it's directly callable by owner (representing executive governance)
        engineParams.complexityGrowthFactor = newGrowthFactor;
        elysiumState.fragmentationRate = newFragmentationRate;
    }

    // Internal helper for applying parameter changes
    function _applyParameterChange(bytes32 paramKeyHash, uint256 newValue) internal {
        if (paramKeyHash == keccak256(abi.encodePacked("baseSparkConsumptionPerUnitComplexity"))) {
            engineParams.baseSparkConsumptionPerUnitComplexity = newValue;
        } else if (paramKeyHash == keccak256(abi.encodePacked("baseSeedConsumptionPerUnitComplexity"))) {
            engineParams.baseSeedConsumptionPerUnitComplexity = newValue;
        } else if (paramKeyHash == keccak256(abi.encodePacked("complexityGrowthFactor"))) {
            engineParams.complexityGrowthFactor = newValue;
        } else if (paramKeyHash == keccak256(abi.encodePacked("minFragmentationRate"))) {
            engineParams.minFragmentationRate = newValue;
            if (elysiumState.fragmentationRate < newValue) {
                elysiumState.fragmentationRate = newValue;
            }
        } else if (paramKeyHash == keccak256(abi.encodePacked("maxMutationChance"))) {
            engineParams.maxMutationChance = newValue;
            if (elysiumState.mutationChance > newValue) {
                elysiumState.mutationChance = newValue;
            }
        } else if (paramKeyHash == keccak256(abi.encodePacked("baseDecayRate"))) {
            engineParams.baseDecayRate = newValue;
        } else if (paramKeyHash == keccak256(abi.encodePacked("epochDuration"))) {
            engineParams.epochDuration = newValue;
        } else if (paramKeyHash == keccak256(abi.encodePacked("environmentalEpochCost"))) {
            engineParams.environmentalEpochCost = newValue;
        }
        // Add more parameters as needed
    }

    // --- V. Advanced & Creative Mechanisms ---

    /**
     * @notice Users commit Spark for a time-locked, simulated "computation." Upon completion,
     * this task can influence future engine events or unlock unique fragment types. (VDF-like concept).
     * @param sparkCommitment The amount of Spark to commit.
     * @param duration The duration (in seconds) the Spark is committed for.
     * @param rewardMultiplier The multiplier for the potential reward or effect.
     */
    function simulateComputationTask(uint256 sparkCommitment, uint256 duration, uint256 rewardMultiplier) public whenNotPaused {
        require(sparkCommitment > 0, "Commitment must be positive.");
        require(duration > 1 hour, "Duration must be at least 1 hour.");
        require(rewardMultiplier >= 100 && rewardMultiplier <= 500, "Reward multiplier 100-500 (1x to 5x).");

        updateEngineStateInternal(); // Update engine state first

        require(sparkToken.transferFrom(msg.sender, address(this), sparkCommitment), "Spark commitment failed.");

        _computationTaskIdCounter._increment();
        uint256 taskId = _computationTaskIdCounter.current();

        computationTasks[taskId] = ComputationTask({
            user: msg.sender,
            sparkCommitment: sparkCommitment,
            commitmentTimestamp: block.timestamp,
            releaseTimestamp: block.timestamp.add(duration),
            completed: false,
            rewardMultiplier: rewardMultiplier
        });
        userStakedResources[msg.sender] = userStakedResources[msg.sender].add(sparkCommitment); // Track for claim

        // This task could temporarily boost engine mutationChance or fragmentationRate based on rewardMultiplier
        elysiumState.mutationChance = elysiumState.mutationChance.add(rewardMultiplier.div(10)); // Example temporary boost

        emit ComputationTaskInitiated(taskId, msg.sender, sparkCommitment, block.timestamp.add(duration));
    }

    /**
     * @notice Allows users to complete their computation task and claim its effects/rewards.
     * @param taskId The ID of the computation task.
     */
    function completeComputationTask(uint256 taskId) public whenNotPaused {
        ComputationTask storage task = computationTasks[taskId];
        require(task.user == msg.sender, "Not your computation task.");
        require(!task.completed, "Task already completed.");
        require(block.timestamp >= task.releaseTimestamp, "Computation not yet finished.");

        updateEngineStateInternal(); // Update engine state

        task.completed = true;

        // Apply long-term effects or generate unique fragments
        // Example: Boost user's pending fragment claims, or mint a special fragment
        elysiumState.pendingFragmentClaims[msg.sender] = elysiumState.pendingFragmentClaims[msg.sender].add(task.sparkCommitment.mul(task.rewardMultiplier).div(10000).div(100)); // Simplified
        
        // Refund committed Spark
        userStakedResources[msg.sender] = userStakedResources[msg.sender].sub(task.sparkCommitment);
        sparkToken.transfer(msg.sender, task.sparkCommitment);

        emit ComputationTaskCompleted(taskId, msg.sender);
    }

    /**
     * @notice A high-cost, high-impact environmental event that introduces significant randomness and
     * potential for rapid state change or mutations within the engine.
     * @param seedEntropy A user-provided value to add to randomness.
     */
    function initiateChaosEvent(uint256 seedEntropy) public whenNotPaused {
        updateEngineStateInternal(); // Ensure state is up-to-date

        uint256 chaosCost = 10 ether; // High cost in Spark (10 Spark)
        require(sparkToken.transferFrom(msg.sender, address(this), chaosCost), "Insufficient Spark for Chaos Event.");
        sparkToken.transfer(address(0xdead), chaosCost); // Burn the cost

        // Introduce high randomness: temporarily alter parameters significantly
        uint256 effectiveRandomness = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, seedEntropy, elysiumState.currentEpoch)));

        // Example: temporarily boost mutation chance and decay rate, or complexity level
        elysiumState.mutationChance = elysiumState.mutationChance.add(effectiveRandomness % 2000); // Up to 20%
        elysiumState.decayRate = elysiumState.decayRate.add(effectiveRandomness % 500); // Up to 5%
        elysiumState.complexityLevel = elysiumState.complexityLevel.add(effectiveRandomness % 10000); // Significant boost

        // These temporary changes would typically decay over a few epochs
        // For simplicity, they are applied here directly and would be normalized by _updateEngineStateInternal over time.

        emit ChaosEventTriggered(msg.sender, chaosCost, effectiveRandomness);
    }

    /**
     * @notice Provides a probabilistic prediction of the next AetherFragment's characteristics
     * based on the current engine state, parameters, and historical data. (View function, internal model).
     * @return predictedRarity A predicted rarity level (1-10).
     * @return predictedEvolutionLevel A predicted initial evolution level.
     * @return expectedGenerationEpoch The epoch in which it is expected to be generated.
     */
    function queryNextFragmentPrediction() public view returns (uint256 predictedRarity, uint256 predictedEvolutionLevel, uint256 expectedGenerationEpoch) {
        // This is a simplified internal model. A real prediction might involve more complex state or ML.
        // It should not rely on block.timestamp or msg.sender for pure view function determinism.
        
        predictedRarity = _calculateFragmentRarity(); // Use current engine mutation chance
        predictedEvolutionLevel = 0; // New fragments start at 0
        expectedGenerationEpoch = elysiumState.currentEpoch.add(1); // Assuming next epoch

        // If complexity is very high, or specific events have been triggered, adjust
        if (elysiumState.complexityLevel > 100000) {
            predictedRarity = predictedRarity.add(1);
        }
        if (predictedRarity > 10) predictedRarity = 10;

        return (predictedRarity, predictedEvolutionLevel, expectedGenerationEpoch);
    }

    /**
     * @notice (Owner/Governance) Allows setting up bounties (funded by the engine or users) for specific
     * outcomes or contributions (e.g., reaching a complexity level, contributing a large amount of resources).
     * @param targetAddress The address eligible for the bounty.
     * @param amount The Spark token amount of the bounty.
     * @param description A description of the bounty objective.
     */
    function setupEcosystemBounty(address targetAddress, uint256 amount, string memory description) public onlyOwner { // Simplified to owner
        require(amount > 0, "Bounty amount must be positive.");
        require(sparkToken.balanceOf(msg.sender) >= amount, "Not enough Spark to fund bounty.");
        sparkToken.transferFrom(msg.sender, address(this), amount); // Deposit bounty funds

        // Store bounty details (e.g., in a mapping for verification and claiming)
        // For now, emit event as a placeholder for a more complex bounty system
        emit BountySetup(elysiumState.currentEpoch, targetAddress, amount, description);
    }

    /**
     * @notice (Owner/Governance) Configures an (abstracted) external oracle to feed "environmental data"
     * influencing epoch triggers or parameter adjustments.
     * For this contract, it simply records the oracle address and a data feed ID.
     * @param oracleAddress The address of the oracle contract.
     * @param dataFeedId An identifier for the specific data feed (e.g., Chainlink job ID).
     */
    address public externalOracleAddress;
    uint256 public oracleDataFeedId;

    function setOracleFeedConfiguration(address oracleAddress, uint256 dataFeedId) public onlyOwner { // Simplified
        require(oracleAddress != address(0), "Invalid oracle address.");
        externalOracleAddress = oracleAddress;
        oracleDataFeedId = dataFeedId;
        emit OracleFeedConfigured(oracleAddress, dataFeedId);
    }

    /**
     * @notice (Owner/Governance) Allows adjusting resource contribution impact based on an internal dynamic pricing model
     * (e.g., demand curves, current engine health).
     * For example, makes contributions more impactful when the engine is "hungry".
     * @param newSparkImpactFactor A new multiplier for Spark contributions.
     * @param newSeedImpactFactor A new multiplier for GenesisSeed contributions.
     */
    uint256 public sparkImpactFactor = 100; // 100 = 1x
    uint256 public seedImpactFactor = 100; // 100 = 1x

    function setDynamicPricingModel(uint256 newSparkImpactFactor, uint256 newSeedImpactFactor) public onlyOwner { // Simplified
        require(newSparkImpactFactor > 0 && newSeedImpactFactor > 0, "Factors must be positive.");
        sparkImpactFactor = newSparkImpactFactor;
        seedImpactFactor = newSeedImpactFactor;
    }

    /**
     * @notice Allows contributors who meet certain criteria to redeem a portion of the engine's accumulated surplus resources.
     * Criteria could be based on total contributions, fragment ownership, or time.
     * @param sparkAmount The amount of Spark to redeem.
     * @param seedAmount The amount of GenesisSeed to redeem.
     */
    function redeemEngineShare(uint256 sparkAmount, uint256 seedAmount) public whenNotPaused {
        // Implement complex eligibility logic here. For simplicity, we'll check total contributions.
        uint256 totalUserSparkContributions = 100000; // Placeholder: replace with actual tracking
        require(totalUserSparkContributions > 10000, "Insufficient contribution history for redemption.");

        updateEngineStateInternal(); // Ensure state is up-to-date

        require(sparkToken.balanceOf(address(this)) >= sparkAmount, "Not enough Spark in engine reserves.");
        require(genesisSeedToken.balanceOf(address(this)) >= seedAmount, "Not enough GenesisSeed in engine reserves.");

        require(sparkAmount <= totalUserSparkContributions.div(10), "Redeem amount too high for contribution."); // Limit to 10%
        // More complex logic would verify if the user is truly eligible to redeem from 'surplus'

        if (sparkAmount > 0) sparkToken.transfer(msg.sender, sparkAmount);
        if (seedAmount > 0) genesisSeedToken.transfer(msg.sender, seedAmount);
    }

    /**
     * @notice (Governance) Allows updating the base URI for AetherFragment metadata,
     * enabling dynamic changes to how NFTs are rendered or to link to evolving off-chain data.
     * @param baseURI_ The new base URI for AetherFragments.
     */
    function updateFragmentRenderingURI(string memory baseURI_) public onlyGovernors { // Simplified to owner
        aetherFragmentNFT.setBaseURI(baseURI_);
    }

    // --- Internal Utility Functions ---

    /**
     * @notice Generates a simple, dynamic URI for an AetherFragment.
     * In a real dNFT, this might point to a JSON endpoint or a more complex IPFS path.
     * @param tokenId The ID of the fragment.
     * @param rarity The rarity level of the fragment.
     * @param evolutionLevel The evolution level of the fragment.
     * @return A string representing the metadata URI.
     */
    function _generateFragmentURI(uint256 tokenId, uint256 rarity, uint256 evolutionLevel) internal pure returns (string memory) {
        return string(abi.encodePacked("ipfs://my-elysium-engine-metadata/", Strings.toString(tokenId), "_r", Strings.toString(rarity), "_e", Strings.toString(evolutionLevel), ".json"));
    }

    /**
     * @notice Calculates a fragment's rarity based on current mutationChance.
     * @return rarity A numerical rarity value (e.g., 1-10, higher is rarer).
     */
    function _calculateFragmentRarity() internal view returns (uint256) {
        // Simple pseudorandomness based on block data and engine state.
        // For production, use Chainlink VRF or similar.
        uint256 randomness = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, elysiumState.complexityLevel, elysiumState.currentEpoch)));
        
        uint256 currentMutationChance = elysiumState.mutationChance; // e.g., 50 (0.5%)

        if (randomness % 10000 < currentMutationChance) { // 0.5% chance for a rare fragment
            if (randomness % 100 < 5) return 10; // 0.05% for legendary
            if (randomness % 100 < 15) return 8; // 0.15% for epic
            return 6; // Other rare
        }
        return (randomness % 4) + 1; // Common rarity 1-4
    }

    /**
     * @notice A simplified dice roll function for internal use (pseudorandom).
     * @param chance In basis points (e.g., 500 for 5%).
     * @return True if the roll succeeds based on the given chance.
     */
    function _rollDice(uint256 chance) internal view returns (bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, elysiumState.complexityLevel)));
        return (seed % 10000 < chance);
    }
}

// --- Minimal Helper for uint256 to string conversion ---
library Strings {
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits--;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
```