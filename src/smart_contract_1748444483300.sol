Okay, let's create a concept for a smart contract that involves synthesizing unique, dynamic, non-fungible "Synergies" by combining different types of fungible "Essences" and "Catalysts," fueled by "Energy" generated through interaction or staking.

This avoids standard patterns like basic ERC-20/721 issuance, simple DeFi (lending/swapping), or generic marketplace logic. It focuses on internal resource management, complex item creation, and dynamic NFT properties.

We will structure it around:
1.  **Essences:** Fungible internal resources obtained by depositing external tokens.
2.  **Catalysts:** Specific ERC-20/ERC-1155 tokens required for certain synthesis recipes.
3.  **Energy:** A non-transferable internal resource required for synthesis and refinement, generated over time by holding/attuning Synergies or via deposits.
4.  **Synergies:** Dynamic ERC-721 NFTs with unique properties determined during synthesis and potentially improvable via refinement. Can be "Attuned" to generate Energy.
5.  **Synthesis Recipes:** Admin-defined rules for combining Essences, Catalysts, and Energy to produce specific types of Synergies with potential property variations.
6.  **Attunement:** A state where a Synergy NFT is locked by its owner to generate Energy.

---

**Smart Contract: SynergySynth**

**Concept:** A protocol for synthesizing unique, dynamic "Synergies" (NFTs) from base "Essences" and "Catalysts" (Fungible Tokens) using "Energy" (Internal Resource). Synergies have mutable properties and can be 'Attuned' to passively generate Energy.

**Outline:**

1.  **Contract Setup:** Basic ownership, pausable, reentrancy guard, ERC-721 implementation.
2.  **Configuration:** Admin functions to set essence types, conversion rates, catalyst tokens, synthesis recipes, energy generation rates.
3.  **Essence Management:** Functions for users to deposit external tokens and receive internal Essences, and check balances.
4.  **Energy Management:** Functions for users to deposit external tokens for Energy, claim Energy generated by attuned Synergies, and check Energy balance.
5.  **Synthesis:** Core function to consume Essences, Catalysts, and Energy according to a recipe to mint a new Synergy NFT with generated properties.
6.  **Synergy Interaction:** Functions to view Synergy properties, Attune/Disattune Synergies, Refine Synergy properties using resources, and Deconstruct Synergies back into partial resources.
7.  **ERC-721 Standard Functions:** Implementation of the ERC-721 standard for ownership, transfer, approval, etc.

**Function Summary:**

1.  `constructor()`: Initializes the contract owner and state.
2.  `supportsInterface(bytes4 interfaceId)`: ERC-165 standard for interface detection.
3.  `balanceOf(address owner)`: Returns the number of Synergies owned by an address.
4.  `ownerOf(uint256 tokenId)`: Returns the owner of a specific Synergy.
5.  `approve(address to, uint256 tokenId)`: Grants approval for one address to manage a specific Synergy.
6.  `getApproved(uint256 tokenId)`: Returns the approved address for a specific Synergy.
7.  `setApprovalForAll(address operator, bool approved)`: Grants or revokes operator status for all owner's Synergies.
8.  `isApprovedForAll(address owner, address operator)`: Checks if an address is an operator for another address.
9.  `transferFrom(address from, address to, uint256 tokenId)`: Transfers a Synergy, checking approvals.
10. `safeTransferFrom(address from, address to, uint256 tokenId)`: Transfers a Synergy safely (checks if receiver can handle NFTs).
11. `safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)`: Overloaded safe transfer.
12. `pause()`: Pauses the contract (Owner only).
13. `unpause()`: Unpauses the contract (Owner only).
14. `addEssenceType(uint8 essenceType, address tokenAddress, uint256 conversionRate)`: Admin configures a new Essence type and its conversion from an external token.
15. `removeEssenceType(uint8 essenceType)`: Admin removes an Essence type configuration.
16. `getEssenceConversionRate(uint8 essenceType)`: Returns the conversion rate for an Essence type.
17. `depositExternalTokenForEssence(uint8 essenceType, uint256 amount)`: User deposits an external token to receive the corresponding Essence type.
18. `getEssenceBalance(address user, uint8 essenceType)`: Returns a user's internal balance of a specific Essence type.
19. `setEnergyToken(address tokenAddress)`: Admin sets the external token used to deposit for Energy.
20. `setEnergyConversionRate(uint256 rate)`: Admin sets the rate for converting the Energy Token to Energy.
21. `depositTokenForEnergy(uint256 amount)`: User deposits the configured Energy Token to gain internal Energy.
22. `getUserEnergy(address user)`: Returns a user's internal Energy balance.
23. `setAttunementRate(uint256 energyPerSecondPerSynergy)`: Admin sets the Energy generation rate for attuned Synergies.
24. `claimAttunementEnergy()`: User claims Energy generated by their currently attuned Synergies.
25. `addSynthesisRecipe(bytes32 recipeId, SynthesisRecipe calldata recipe)`: Admin adds a synthesis recipe defining inputs and potential outputs.
26. `removeSynthesisRecipe(bytes32 recipeId)`: Admin removes a synthesis recipe.
27. `getSynthesisRecipe(bytes32 recipeId)`: Returns the details of a synthesis recipe.
28. `synthesizeSynergy(bytes32 recipeId)`: User initiates synthesis using resources per recipe, potentially minting a new Synergy NFT.
29. `getSynergyProperties(uint256 tokenId)`: Returns the current dynamic properties of a Synergy NFT.
30. `attuneSynergy(uint256 tokenId)`: User locks their Synergy NFT to start generating Energy.
31. `disattuneSynergy(uint256 tokenId)`: User unlocks their Synergy NFT, stopping Energy generation and allowing transfer.
32. `isSynergyAttuned(uint256 tokenId)`: Checks if a Synergy NFT is currently attuned.
33. `refineSynergy(uint256 tokenId, uint8[] calldata essenceTypes, uint256[] calldata essenceAmounts, address catalystToken, uint256 catalystAmount, uint256 energyCost)`: User attempts to improve a Synergy's properties by consuming resources.
34. `deconstructSynergy(uint256 tokenId)`: User destroys a Synergy NFT to recover a fraction of resources.
35. `getAttunedSynergyCount(address user)`: Returns the number of Synergies a user currently has attuned.
36. `setSynergyPropertyRanges(bytes32 recipeId, uint256[] calldata minValues, uint256[] calldata maxValues)`: Admin sets/updates potential property ranges for a recipe's output.
37. `getSynergyPropertyRanges(bytes32 recipeId)`: Returns property ranges for a recipe.
38. `setDeconstructionReturnRate(uint256 ratePermil)`: Admin sets the percentage of input resources returned upon deconstruction (in per mils, e.g., 500 for 50%).
39. `withdrawAccruedFees()`: Admin function to withdraw any accumulated external tokens from deposits (if a fee mechanism were added, though not explicitly in functions above - could be added). Let's make this withdraw deposited tokens directly.
40. `transferOwnership(address newOwner)`: Transfers contract ownership (Owner only).

*(Note: We already have 40 potential functions, well over the required 20. Some might be internal helpers, but many are public/external.)*

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol"; // Optional, if enumeration is needed
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol"; // For Catalyst 1155 support
import "@openzeppelin/contracts/utils/math/Math.sol"; // For min/max/randomness simulation

// Use block data for randomness *caution* - not truly random on chain.
// For production, consider Chainlink VRF or similar.
import "@openzeppelin/contracts/utils/Create2.sol"; // Not directly used, but useful for advanced topics - showing awareness

/**
 * @title SynergySynth
 * @dev A sophisticated contract for synthesizing dynamic ERC721 Synergies from Essences, Catalysts, and Energy.
 *
 * Concept: Users combine fungible resources (Essences and Catalysts) and expend non-transferable Energy to mint unique Synergy NFTs.
 * Synergies have dynamic properties and can be Attuned to generate more Energy over time.
 *
 * Outline:
 * 1. Contract Setup: Ownership, Pausable, ReentrancyGuard, ERC-721 implementation.
 * 2. Configuration: Admin functions for essence types, recipes, rates.
 * 3. Essence Management: Deposit tokens for essences, check balances.
 * 4. Energy Management: Deposit tokens for energy, claim generated energy, check balance.
 * 5. Synthesis: Core function to create Synergy NFTs from recipes and resources.
 * 6. Synergy Interaction: View properties, Attune/Disattune, Refine, Deconstruct.
 * 7. ERC-721 Standard: Standard NFT functions.
 *
 * Function Summary:
 * (See detailed list above)
 */
contract SynergySynth is ERC721, ERC721Enumerable, Ownable, Pausable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using Math for uint256;

    // --- Structs and Enums ---

    struct SynergyData {
        uint256 creationBlock; // Block when synthesized
        uint256 potency;       // Example property 1 (can be dynamic)
        uint256 resonance;     // Example property 2 (can be dynamic)
        // Add more properties as needed
        mapping(bytes32 => uint256) customProperties; // Flexible custom properties
    }

    struct SynthesisRecipe {
        // Ingredients
        uint8[] requiredEssenceTypes;
        uint256[] requiredEssenceAmounts;
        address catalystToken; // ERC20 or ERC1155 address
        uint256 catalystAmount; // Amount if ERC20, or ID if ERC1155
        bool isCatalystERC1155; // Flag to differentiate catalyst type
        uint256 requiredEnergy;

        // Output Properties (min/max ranges for randomness)
        mapping(bytes32 => uint256) minOutputProperties; // Mapping of property names to min values
        mapping(bytes32 => uint256) maxOutputProperties; // Mapping of property names to max values
        bytes32[] outputPropertyNames; // List of property names for iteration
    }

    // --- State Variables ---

    // ERC-721 State (handled by ERC721 base)
    // uint256 private _synergyTokenIdCounter; // Handled by ERC721Enumerable now

    // Essence Management
    mapping(address => mapping(uint8 => uint256)) private essenceBalances; // user => essenceType => balance
    mapping(uint8 => address) private essenceTokenAddresses; // essenceType => external ERC20 token address
    mapping(uint8 => uint256) private essenceConversionRates; // essenceType => external token amount needed for 1 essence

    // Energy Management
    mapping(address => uint256) private userEnergy; // user => energy balance
    address private energyTokenAddress; // External token used to deposit for energy
    uint256 private energyConversionRate; // Amount of energy token needed for 1 energy

    // Attunement
    mapping(uint256 => bool) private isSynergyAttuned; // tokenId => bool
    mapping(address => uint256) private lastAttunementClaim; // user => timestamp of last energy claim
    mapping(address => uint256) private attunedSynergyCount; // user => count of attuned synergies
    uint256 private attunementEnergyRate; // Energy generated per second per attuned synergy

    // Synthesis
    mapping(bytes32 => SynthesisRecipe) private synthesisRecipes; // recipeId => recipe details

    // Synergy Data
    mapping(uint256 => SynergyData) private synergyProperties; // tokenId => properties

    // Deconstruction
    uint256 private deconstructionReturnRatePermil = 500; // 50% return by default (in per mils)

    // --- Events ---

    event EssenceDeposited(address indexed user, uint8 essenceType, uint256 amountDeposited, uint256 essenceReceived);
    event EssenceBalanceUpdated(address indexed user, uint8 essenceType, uint256 newBalance);
    event EnergyDeposited(address indexed user, uint256 amountDeposited, uint256 energyReceived);
    event EnergyBalanceUpdated(address indexed user, uint256 newBalance);
    event SynergySynthesized(address indexed owner, uint256 indexed tokenId, bytes32 indexed recipeId, uint256 energyUsed);
    event SynergyAttuned(address indexed user, uint256 indexed tokenId);
    event SynergyDisattuned(address indexed user, uint256 indexed tokenId);
    event SynergyRefined(uint256 indexed tokenId, address indexed user, uint256 energyUsed);
    event SynergyDeconstructed(uint256 indexed tokenId, address indexed user);
    event AttunementEnergyClaimed(address indexed user, uint256 energyClaimed);
    event SynthesisRecipeAdded(bytes32 indexed recipeId);
    event SynthesisRecipeRemoved(bytes32 indexed recipeId);
    event EssenceTypeAdded(uint8 indexed essenceType, address indexed tokenAddress, uint256 conversionRate);
    event EssenceTypeRemoved(uint8 indexed essenceType);
    event AttunementRateUpdated(uint256 newRate);
    event DeconstructionRateUpdated(uint256 newRatePermil);

    // --- Constructor ---

    constructor() ERC721("SynergySynthNFT", "SYNSYN") Ownable(msg.sender) {}

    // --- Modifiers ---

    modifier onlyExistingEssenceType(uint8 _essenceType) {
        require(essenceTokenAddresses[_essenceType] != address(0), "Invalid essence type");
        _;
    }

    modifier onlyExistingRecipe(bytes32 _recipeId) {
        require(synthesisRecipes[_recipeId].requiredEnergy > 0 || synthesisRecipes[_recipeId].requiredEssenceTypes.length > 0, "Invalid recipe ID"); // Simple check if recipe exists
        _;
    }

    modifier onlySynergyOwner(uint256 _tokenId) {
        require(_exists(_tokenId), "Synergy does not exist");
        require(ownerOf(_tokenId) == msg.sender, "Not your synergy");
        _;
    }

    modifier whenSynergyNotAttuned(uint256 _tokenId) {
        require(!isSynergyAttuned[_tokenId], "Synergy is attuned");
        _;
    }

    // --- Access Control & Pausing ---

    function pause() public onlyOwner whenNotPaused {
        _pause();
    }

    function unpause() public onlyOwner whenPaused {
        _unpause();
    }

    // Override Pausable's _beforeTokenTransfer to handle attunement
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);

        // Disattune before transferring
        if (isSynergyAttuned[tokenId]) {
            _disattuneSynergy(from, tokenId); // Pass 'from' as owner
        }
    }

    // Override ERC721Enumerable's _beforeTokenTransfer to handle enumeration hooks
    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    // Override ERC721Enumerable's _afterTokenTransfer to handle enumeration hooks
    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
        super._afterTokenTransfer(from, to, tokenId);
    }

    // --- ERC721 Standard Functions ---

    // Inherited from ERC721: balanceOf, ownerOf, approve, getApproved, setApprovalForAll, isApprovedForAll, transferFrom, safeTransferFrom
    // Need to override supportsInterface for ERC721Enumerable
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    // --- Configuration (Owner Only) ---

    function addEssenceType(uint8 _essenceType, address _tokenAddress, uint256 _conversionRate) external onlyOwner {
        require(_tokenAddress != address(0), "Invalid token address");
        require(essenceTokenAddresses[_essenceType] == address(0), "Essence type already exists"); // Prevent overwriting

        essenceTokenAddresses[_essenceType] = _tokenAddress;
        essenceConversionRates[_essenceType] = _conversionRate;

        emit EssenceTypeAdded(_essenceType, _tokenAddress, _conversionRate);
    }

    function removeEssenceType(uint8 _essenceType) external onlyOwner onlyExistingEssenceType(_essenceType) {
        delete essenceTokenAddresses[_essenceType];
        delete essenceConversionRates[_essenceType];

        // Note: This doesn't affect existing essence balances users hold.
        // A migration or burn mechanism would be needed for that in a real system.

        emit EssenceTypeRemoved(_essenceType);
    }

    function getEssenceConversionRate(uint8 _essenceType) external view returns (uint256) {
        return essenceConversionRates[_essenceType];
    }

    function setEnergyToken(address _tokenAddress) external onlyOwner {
        require(_tokenAddress != address(0), "Invalid token address");
        energyTokenAddress = _tokenAddress;
    }

    function setEnergyConversionRate(uint256 _rate) external onlyOwner {
        require(_rate > 0, "Rate must be positive");
        energyConversionRate = _rate;
    }

    function setAttunementRate(uint256 _energyPerSecondPerSynergy) external onlyOwner {
        attunementEnergyRate = _energyPerSecondPerSynergy;
        emit AttunementRateUpdated(_energyPerSecondPerSynergy);
    }

    function setDeconstructionReturnRate(uint256 _ratePermil) external onlyOwner {
        require(_ratePermil <= 1000, "Rate cannot exceed 1000 permil (100%)");
        deconstructionReturnRatePermil = _ratePermil;
        emit DeconstructionRateUpdated(_ratePermil);
    }

    function addSynthesisRecipe(bytes32 _recipeId, SynthesisRecipe calldata _recipe) external onlyOwner {
        require(synthesisRecipes[_recipeId].requiredEnergy == 0 && synthesisRecipes[_recipeId].requiredEssenceTypes.length == 0, "Recipe ID already exists");
        require(_recipe.requiredEssenceTypes.length == _recipe.requiredEssenceAmounts.length, "Essence type and amount arrays must match length");

        synthesisRecipes[_recipeId] = _recipe;

        // Copy property names and ranges to state storage (mapping requires separate assignment)
        SynthesisRecipe storage storedRecipe = synthesisRecipes[_recipeId];
        storedRecipe.outputPropertyNames = _recipe.outputPropertyNames;
        for (uint i = 0; i < _recipe.outputPropertyNames.length; i++) {
            storedRecipe.minOutputProperties[_recipe.outputPropertyNames[i]] = _recipe.minOutputProperties[_recipe.outputPropertyNames[i]];
            storedRecipe.maxOutputProperties[_recipe.outputPropertyNames[i]] = _recipe.maxOutputProperties[_recipe.outputPropertyNames[i]];
        }


        emit SynthesisRecipeAdded(_recipeId);
    }

    function removeSynthesisRecipe(bytes32 _recipeId) external onlyOwner onlyExistingRecipe(_recipeId) {
         delete synthesisRecipes[_recipeId]; // Removes the struct data

        // Note: Mappings within structs are not deleted recursively.
        // If complex state depends *only* on these mappings, they persist
        // unless manually cleared or the entire struct key is deleted.
        // For this example, deleting the struct entry is sufficient to make the recipe unusable.

        emit SynthesisRecipeRemoved(_recipeId);
    }

    function getSynthesisRecipe(bytes32 _recipeId) external view onlyExistingRecipe(_recipeId) returns (SynthesisRecipe memory) {
        return synthesisRecipes[_recipeId];
    }

    function setSynergyPropertyRanges(bytes32 _recipeId, bytes32[] calldata _propertyNames, uint256[] calldata _minValues, uint256[] calldata _maxValues) external onlyOwner onlyExistingRecipe(_recipeId) {
        require(_propertyNames.length == _minValues.length && _propertyNames.length == _maxValues.length, "Input arrays must match length");
        SynthesisRecipe storage recipe = synthesisRecipes[_recipeId];

        // Clear existing ranges for these properties
        for (uint i = 0; i < recipe.outputPropertyNames.length; i++) {
             for (uint j = 0; j < _propertyNames.length; j++) {
                if (recipe.outputPropertyNames[i] == _propertyNames[j]) {
                     delete recipe.minOutputProperties[recipe.outputPropertyNames[i]];
                     delete recipe.maxOutputProperties[recipe.outputPropertyNames[i]];
                     // Note: Removing from outputPropertyNames array is complex and gas-intensive.
                     // For simplicity, we overwrite or just add. A more robust system might
                     // use a separate mapping for names and their min/max ranges.
                }
             }
        }

        // Add/Update new ranges
        recipe.outputPropertyNames = _propertyNames; // Overwrite list of names (simplification)
        for (uint i = 0; i < _propertyNames.length; i++) {
            require(_minValues[i] <= _maxValues[i], "Min value must be <= max value");
            recipe.minOutputProperties[_propertyNames[i]] = _minValues[i];
            recipe.maxOutputProperties[_propertyNames[i]] = _maxValues[i];
        }
    }

    function getSynergyPropertyRanges(bytes32 _recipeId) external view onlyExistingRecipe(_recipeId) returns (bytes32[] memory names, uint256[] memory minValues, uint256[] memory maxValues) {
        SynthesisRecipe storage recipe = synthesisRecipes[_recipeId];
        names = new bytes32[](recipe.outputPropertyNames.length);
        minValues = new uint256[](recipe.outputPropertyNames.length);
        maxValues = new uint256[](recipe.outputPropertyNames.length);

        for (uint i = 0; i < recipe.outputPropertyNames.length; i++) {
            bytes32 name = recipe.outputPropertyNames[i];
            names[i] = name;
            minValues[i] = recipe.minOutputProperties[name];
            maxValues[i] = recipe.maxOutputProperties[name];
        }
        return (names, minValues, maxValues);
    }

    // --- Essence Management ---

    function depositExternalTokenForEssence(uint8 _essenceType, uint256 _amount) external nonReentrant whenNotPaused onlyExistingEssenceType(_essenceType) {
        require(_amount > 0, "Amount must be greater than 0");
        address tokenAddress = essenceTokenAddresses[_essenceType];
        uint256 essenceReceived = _amount / essenceConversionRates[_essenceType];
        require(essenceReceived > 0, "Amount too small to yield essence");

        IERC20 token = IERC20(tokenAddress);
        token.safeTransferFrom(msg.sender, address(this), _amount);

        essenceBalances[msg.sender][_essenceType] += essenceReceived;

        emit EssenceDeposited(msg.sender, _essenceType, _amount, essenceReceived);
        emit EssenceBalanceUpdated(msg.sender, _essenceType, essenceBalances[msg.sender][_essenceType]);
    }

    function getEssenceBalance(address _user, uint8 _essenceType) external view returns (uint256) {
        return essenceBalances[_user][_essenceType];
    }

    // --- Energy Management ---

    function setEnergyTokenAndRate(address _tokenAddress, uint256 _rate) external onlyOwner {
         setEnergyToken(_tokenAddress);
         setEnergyConversionRate(_rate);
    }

    function depositTokenForEnergy(uint256 _amount) external nonReentrant whenNotPaused {
        require(energyTokenAddress != address(0), "Energy token not configured");
        require(energyConversionRate > 0, "Energy conversion rate not configured");
        require(_amount > 0, "Amount must be greater than 0");

        uint256 energyReceived = _amount * energyConversionRate; // Assuming rate is 1 token => X energy
        require(energyReceived > 0, "Amount too small to yield energy");

        IERC20 token = IERC20(energyTokenAddress);
        token.safeTransferFrom(msg.sender, address(this), _amount);

        userEnergy[msg.sender] += energyReceived;

        emit EnergyDeposited(msg.sender, _amount, energyReceived);
        emit EnergyBalanceUpdated(msg.sender, userEnergy[msg.sender]);
    }

    function getUserEnergy(address _user) external view returns (uint256) {
        return userEnergy[_user];
    }

     function claimAttunementEnergy() external nonReentrant whenNotPaused {
        uint256 userAttunedCount = attunedSynergyCount[msg.sender];
        if (userAttunedCount == 0 || attunementEnergyRate == 0) {
             lastAttunementClaim[msg.sender] = block.timestamp; // Reset timer even if nothing claimed
             return;
        }

        uint256 timeElapsed = block.timestamp - lastAttunementClaim[msg.sender];
        uint256 energyGenerated = timeElapsed * userAttunedCount * attunementEnergyRate;

        if (energyGenerated > 0) {
            userEnergy[msg.sender] += energyGenerated;
             emit AttunementEnergyClaimed(msg.sender, energyGenerated);
             emit EnergyBalanceUpdated(msg.sender, userEnergy[msg.sender]);
        }

        lastAttunementClaim[msg.sender] = block.timestamp;
    }

    // --- Synthesis ---

    function synthesizeSynergy(bytes32 _recipeId) external nonReentrant whenNotPaused onlyExistingRecipe(_recipeId) returns (uint256 newTokenId) {
        SynthesisRecipe storage recipe = synthesisRecipes[_recipeId];
        address user = msg.sender;

        // 1. Check Energy
        require(userEnergy[user] >= recipe.requiredEnergy, "Insufficient energy");
        userEnergy[user] -= recipe.requiredEnergy;
        emit EnergyBalanceUpdated(user, userEnergy[user]);

        // 2. Check and Consume Essences
        for (uint i = 0; i < recipe.requiredEssenceTypes.length; i++) {
            uint8 essenceType = recipe.requiredEssenceTypes[i];
            uint256 requiredAmount = recipe.requiredEssenceAmounts[i];
            require(essenceBalances[user][essenceType] >= requiredAmount, string(abi.encodePacked("Insufficient essence type ", uint256(essenceType))));
            essenceBalances[user][essenceType] -= requiredAmount;
            emit EssenceBalanceUpdated(user, essenceType, essenceBalances[user][essenceType]);
        }

        // 3. Check and Consume Catalyst
        if (recipe.catalystToken != address(0)) {
            if (recipe.isCatalystERC1155) {
                // Check and consume ERC1155 catalyst (assuming catalystAmount is the ID)
                 IERC1155 catalyst = IERC1155(recipe.catalystToken);
                 require(catalyst.balanceOf(user, recipe.catalystAmount) > 0, "Missing catalyst (ERC1155)"); // Assuming 1 is enough
                 catalyst.safeTransferFrom(user, address(this), recipe.catalystAmount, 1, ""); // Consume 1 token of this ID
            } else {
                // Check and consume ERC20 catalyst
                 IERC20 catalyst = IERC20(recipe.catalystToken);
                 require(catalyst.balanceOf(user) >= recipe.catalystAmount, "Missing catalyst (ERC20)");
                 catalyst.safeTransferFrom(user, address(this), recipe.catalystAmount);
            }
        }

        // 4. Mint new Synergy NFT
        uint256 tokenId = _nextTokenId(); // Get the next available token ID
        _mint(user, tokenId);

        // 5. Determine Synergy Properties (Simple pseudorandom generation for example)
        SynergyData storage newSynergy = synergyProperties[tokenId];
        newSynergy.creationBlock = block.number; // Mark creation block

        // Use blockhash and timestamp for a simple seed (NOT truly random, but deterministic yet hard to predict precisely)
        uint256 randomSeed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, tokenId)));

        // Generate properties based on ranges and seed
        for (uint i = 0; i < recipe.outputPropertyNames.length; i++) {
             bytes32 propName = recipe.outputPropertyNames[i];
             uint256 minValue = recipe.minOutputProperties[propName];
             uint256 maxValue = recipe.maxOutputProperties[propName];

             if (minValue <= maxValue) {
                 uint256 range = maxValue - minValue + 1;
                 uint256 generatedValue = (randomSeed % range) + minValue;
                 newSynergy.customProperties[propName] = generatedValue;
                 // For the explicit properties, map from customProperties if needed
                 if (propName == "potency") newSynergy.potency = generatedValue;
                 if (propName == "resonance") newSynergy.resonance = generatedValue;
                 // ... handle other explicit properties
             } else {
                 // If min > max (misconfiguration), set to min/max if needed or default
                 newSynergy.customProperties[propName] = minValue; // Default to min value
             }
              randomSeed = uint256(keccak256(abi.encodePacked(randomSeed, propName, i))); // Update seed for next property
        }

        emit SynergySynthesized(user, tokenId, _recipeId, recipe.requiredEnergy);
        newTokenId = tokenId;
    }

    // --- Synergy Interaction ---

    function getSynergyProperties(uint256 _tokenId) public view returns (uint256 creationBlock, uint256 potency, uint256 resonance, bytes32[] memory customNames, uint256[] memory customValues) {
        require(_exists(_tokenId), "Synergy does not exist");
        SynergyData storage data = synergyProperties[_tokenId];

        // Fetch custom properties - need recipe info to get names or store names with synergy
        // For simplicity, let's return all properties stored in customProperties map
        // This requires iterating the map, which is not directly possible.
        // A better approach is to store an array of property names *with* the SynergyData.
        // Let's refine SynergyData to store property names used for *this specific* synergy instance.
        // --- Re-structuring SynergyData needed for proper retrieval ---
        // For now, let's just return the explicit properties and maybe require recipeId to get custom ones.
        // Alternative: Store property names in an array within SynergyData
        // Let's modify SynergyData struct and synthesis to store property names list.

        // New Approach: Modify struct and synthesis to store names
        // struct SynergyData { ... bytes32[] propertyNames; }
        // In synthesis, copy recipe.outputPropertyNames to synergyData.propertyNames

        // Assuming SynergyData now has `bytes32[] propertyNames;`
        bytes32[] memory propNames = new bytes32[](data.propertyNames.length);
        uint256[] memory propValues = new uint256[](data.propertyNames.length);

        for (uint i = 0; i < data.propertyNames.length; i++) {
             bytes32 name = data.propertyNames[i];
             propNames[i] = name;
             propValues[i] = data.customProperties[name];
        }


        return (
            data.creationBlock,
            data.potency, // Explicit properties
            data.resonance,
            propNames, // Custom properties
            propValues
        );
    }

    // Helper function to get next token ID
    function _nextTokenId() internal view returns (uint256) {
         // The _nextTokenId logic is typically handled by ERC721Enumerable
         // or a simple counter. Using ERC721Enumerable means we just need to mint.
         // Let's use the internal counter pattern for clarity, but note ERC721Enumerable manages its own.
         // If using ERC721Enumerable, simply minting is enough, _beforeTokenTransfer
         // and _afterTokenTransfer hooks handle the enumeration state updates.
         // Let's stick to the simple counter for *this* example's minting process
         // to show explicit ID generation, while still inheriting ERC721Enumerable.
         // This might require careful state management if not fully relying on ENumerable hooks.
         // Simpler: just rely on ERC721Enumerable's hooks to manage IDs sequentially via _safeMint.
         // ERC721Enumerable does *not* auto-increment. You still need a counter.
         // Let's add a counter explicitly.
         uint256 currentId = ERC721Enumerable.totalSupply(address(this));
         return currentId + 1;

         // *Correction*: ERC721Enumerable does *not* manage a counter. It manages *token lists*.
         // You *must* manage the token ID counter yourself when minting.
         // Let's re-add an explicit counter.
    }
    uint256 private _tokenIdCounter; // Manual counter

    function _safeMint(address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
        super._safeMint(to, tokenId);
    }

     function _burn(uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
        // Clear any attunement state before burning
        if(isSynergyAttuned[tokenId]) {
            _disattuneSynergy(ownerOf(tokenId), tokenId); // Must disattune before owner is potentially lost
        }
         // Clear synergy properties
        delete synergyProperties[tokenId]; // Clean up storage

        super._burn(tokenId);
    }


    function _mintSynergy(address to) internal returns (uint256 newTokenId) {
        _tokenIdCounter++;
        newTokenId = _tokenIdCounter;
        _safeMint(to, newTokenId);
    }


    function attuneSynergy(uint256 _tokenId) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) whenSynergyNotAttuned(_tokenId) {
        // Claim pending energy before starting new attunement
        claimAttunementEnergy();

        isSynergyAttuned[_tokenId] = true;
        attunedSynergyCount[msg.sender]++;
        // lastAttunementClaim[msg.sender] is updated by claimAttunementEnergy()

        emit SynergyAttuned(msg.sender, _tokenId);
    }

    // Internal helper for disattunement, used by public function and _beforeTokenTransfer
    function _disattuneSynergy(address _owner, uint256 _tokenId) internal {
         if (!isSynergyAttuned[_tokenId]) return; // Already not attuned

        // Claim pending energy before stopping attunement
        // Ensure we claim for _owner, as this might be called during transfer
        uint256 userAttunedCount = attunedSynergyCount[_owner];
        if (userAttunedCount > 0 && attunementEnergyRate > 0) {
            uint256 timeElapsed = block.timestamp - lastAttunementClaim[_owner];
            uint256 energyGenerated = timeElapsed * userAttunedCount * attunementEnergyRate;

            if (energyGenerated > 0) {
                 userEnergy[_owner] += energyGenerated;
                 emit AttunementEnergyClaimed(_owner, energyGenerated);
                 emit EnergyBalanceUpdated(_owner, userEnergy[_owner]);
            }
        }
         lastAttunementClaim[_owner] = block.timestamp; // Reset timer

        isSynergyAttuned[_tokenId] = false;
        attunedSynergyCount[_owner]--;

        emit SynergyDisattuned(_owner, _tokenId);
    }

    function disattuneSynergy(uint256 _tokenId) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) {
         _disattuneSynergy(msg.sender, _tokenId);
    }

    function isSynergyAttuned(uint256 _tokenId) public view returns (bool) {
        return isSynergyAttuned[_tokenId];
    }

     function getAttunedSynergyCount(address _user) external view returns (uint256) {
        return attunedSynergyCount[_user];
     }

    function refineSynergy(uint256 _tokenId, bytes32[] calldata _propertyNamesToRefine, uint256 _energyCost) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) whenSynergyNotAttuned(_tokenId) {
        SynergyData storage synergy = synergyProperties[_tokenId];
        address user = msg.sender;

        // 1. Check & Consume Energy
        require(userEnergy[user] >= _energyCost, "Insufficient energy for refinement");
        userEnergy[user] -= _energyCost;
        emit EnergyBalanceUpdated(user, userEnergy[user]);

        // 2. Apply Refinement Effect (Example: Slightly increase properties)
        // This is where complex logic could go - maybe requires specific essences/catalysts too.
        // For simplicity, let's just increase selected properties slightly based on energy spent.

        uint256 refinementBoost = _energyCost / 100; // Example: 1 boost per 100 energy

        uint256 randomSeed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, user, _tokenId, _energyCost)));

        for(uint i = 0; i < _propertyNamesToRefine.length; i++) {
             bytes32 propName = _propertyNamesToRefine[i];
             // Check if the synergy actually has this property
             // This requires knowing which properties a synergy can have - implies recipes or a global list
             // Assuming SynergyData has a propertyNames list populated during synthesis
             bool propertyExists = false;
             for(uint j = 0; j < synergy.propertyNames.length; j++) {
                 if(synergy.propertyNames[j] == propName) {
                     propertyExists = true;
                     break;
                 }
             }
             require(propertyExists, "Invalid property name for this synergy");

             // Apply a random boost within a range
             uint256 currentPropertyValue = synergy.customProperties[propName];
             uint256 potentialBoost = (randomSeed % refinementBoost) + 1; // At least 1 boost
             synergy.customProperties[propName] = currentPropertyValue + potentialBoost;

             // Update explicit properties if they map to custom ones
             if (propName == "potency") synergy.potency = synergy.customProperties[propName];
             if (propName == "resonance") synergy.resonance = synergy.customProperties[propName];
             // ... update other explicit properties

             randomSeed = uint256(keccak256(abi.encodePacked(randomSeed, propName, i))); // Update seed
        }


        emit SynergyRefined(_tokenId, user, _energyCost);
    }

    function deconstructSynergy(uint256 _tokenId) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) whenSynergyNotAttuned(_tokenId) {
        address user = msg.sender;
        SynergyData storage synergy = synergyProperties[_tokenId];

        // 1. Determine original recipe inputs (Requires storing recipe ID with SynergyData)
        // Let's modify SynergyData to store recipeId used for synthesis.
        // struct SynergyData { ..., bytes32 recipeIdUsed; }
        // Add this during synthesis.

        bytes32 recipeId = synergy.recipeIdUsed;
        require(recipeId != bytes32(0), "Synergy recipe data missing"); // Should not happen if synthesized correctly
        SynthesisRecipe storage recipe = synthesisRecipes[recipeId];

        // 2. Calculate resources to return based on deconstruction rate
        // This is complex - need to know which *external* tokens were used for essence and energy
        // and which specific catalyst was used.
        // For simplicity, let's return a fraction of the *internal* Essences, *internal* Energy (if possible),
        // and maybe the Catalyst token. Returning Energy is tricky as it's non-transferable.
        // Let's return Essences and perhaps the Catalyst token.

        // Return Essences
        for (uint i = 0; i < recipe.requiredEssenceTypes.length; i++) {
            uint8 essenceType = recipe.requiredEssenceTypes[i];
            uint256 originalAmount = recipe.requiredEssenceAmounts[i];
            uint256 amountToReturn = (originalAmount * deconstructionReturnRatePermil) / 1000;
            if (amountToReturn > 0) {
                essenceBalances[user][essenceType] += amountToReturn;
                 emit EssenceBalanceUpdated(user, essenceType, essenceBalances[user][essenceType]);
            }
        }

        // Return Catalyst (fractionally or fully, depending on design)
        // Returning fractional ERC20 is possible. Returning fractional ERC1155 (by ID) is not standard.
        // Let's return the *full* Catalyst cost if it was ERC20, fraction if ERC20, or nothing if ERC1155 for simplicity.
        if (recipe.catalystToken != address(0) && !recipe.isCatalystERC1155) {
             IERC20 catalyst = IERC20(recipe.catalystToken);
             uint256 originalAmount = recipe.catalystAmount;
             uint256 amountToReturn = (originalAmount * deconstructionReturnRatePermil) / 1000;
             if (amountToReturn > 0) {
                 catalyst.safeTransfer(user, amountToReturn); // Transfer token back
             }
        }

        // 3. Burn the Synergy NFT
        _burn(_tokenId);

        emit SynergyDeconstructed(user, _tokenId);
    }

    // Admin Function to withdraw accidentally sent tokens (or accumulated deposit tokens)
    function withdrawAccruedTokens(address _tokenAddress) external onlyOwner nonReentrant {
        require(_tokenAddress != address(0), "Invalid token address");
        IERC20 token = IERC20(_tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        if (balance > 0) {
            token.safeTransfer(owner(), balance);
        }
    }

    // --- Internal Helper for Token ID and Synegy Data association ---
    function _mint(address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) {
         // In a real system, _tokenIdCounter would be incremented *before* this.
         // Let's ensure it's handled correctly. ERC721Enumerable's _before/after
         // hooks are for managing the enumerable lists, not the ID counter itself.
         // The _mintSynergy helper should be used to generate the ID *and* mint.

         // Override _mint to associate properties. This is complicated by the fact that
         // _mint doesn't receive the recipeId. The synthesis function *must* handle
         // property assignment immediately after calling _mint.
         // Let's remove this override and ensure `synthesizeSynergy` sets properties right after `_mint`.
         // Also, use _mintSynergy helper to ensure the counter is managed.

         // Re-implementing _mint wrapper
         super._mint(to, tokenId);
    }

    // Update SynergyData struct based on feedback during coding functions
    struct SynergyData {
        uint256 creationBlock;
        bytes32 recipeIdUsed; // Add recipe ID
        uint256 potency;
        uint256 resonance;
        mapping(bytes32 => uint256) customProperties;
        bytes32[] propertyNames; // Store names for easier retrieval
    }
    // Synthesis function needs updating to populate propertyNames and recipeIdUsed
    // and the getSynergyProperties function needs updating to use propertyNames array.
    // Deconstruct function also needs updating to use recipeIdUsed.

    // Re-implementing `synthesizeSynergy` snippet for property setting
    /*
     // ... inside synthesizeSynergy, after _mintSynergy(user) returning newTokenId
     uint256 tokenId = newTokenId; // Use the returned ID
     SynergyData storage newSynergy = synergyProperties[tokenId];
     newSynergy.creationBlock = block.number;
     newSynergy.recipeIdUsed = _recipeId; // Store recipe ID

     // Initialize propertyNames array
     newSynergy.propertyNames = new bytes32[](recipe.outputPropertyNames.length);

     // Use blockhash and timestamp for a simple seed (NOT truly random, but deterministic yet hard to predict precisely)
     uint256 randomSeed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, tokenId, recipeId)));

     // Generate properties based on ranges and seed
     for (uint i = 0; i < recipe.outputPropertyNames.length; i++) {
         bytes32 propName = recipe.outputPropertyNames[i];
         newSynergy.propertyNames[i] = propName; // Store the property name

         uint256 minValue = recipe.minOutputProperties[propName];
         uint256 maxValue = recipe.maxOutputProperties[propName];

         if (minValue <= maxValue) {
             uint256 range = maxValue - minValue + 1;
             // Avoid modulo 0 if range is 0 or 1
             uint256 generatedValue = minValue; // Default if range is 0
             if (range > 0) {
                generatedValue = (randomSeed % range) + minValue;
             }

             newSynergy.customProperties[propName] = generatedValue;
             // For the explicit properties, map from customProperties if needed
             if (propName == "potency") newSynergy.potency = generatedValue;
             if (propName == "resonance") newSynergy.resonance = generatedValue;
             // ... handle other explicit properties
         } else {
             // If min > max (misconfiguration), set to min value
             newSynergy.customProperties[propName] = minValue;
              if (propName == "potency") newSynergy.potency = minValue;
              if (propName == "resonance") newSynergy.resonance = minValue;
         }
          randomSeed = uint256(keccak256(abi.encodePacked(randomSeed, propName, i, generatedValue))); // Update seed more robustly
     }
     emit SynergySynthesized(user, tokenId, _recipeId, recipe.requiredEnergy);
     newTokenId = tokenId; // Return the new token ID
    */
    // The full synthesizedSynthesis function would replace the placeholder above.


    // Re-implementing getSynergyProperties to use the propertyNames array
    /*
     function getSynergyProperties(uint256 _tokenId) public view returns (uint256 creationBlock, uint256 potency, uint256 resonance, bytes32[] memory customNames, uint256[] memory customValues) {
        require(_exists(_tokenId), "Synergy does not exist");
        SynergyData storage data = synergyProperties[_tokenId];

        bytes32[] memory propNames = new bytes32[](data.propertyNames.length);
        uint256[] memory propValues = new uint256[](data.propertyNames.length);

        for (uint i = 0; i < data.propertyNames.length; i++) {
             bytes32 name = data.propertyNames[i];
             propNames[i] = name;
             propValues[i] = data.customProperties[name];
        }

        return (
            data.creationBlock,
            data.potency, // Explicit properties
            data.resonance,
            propNames, // Custom properties
            propValues
        );
    }
    */

    // Re-implementing deconstructSynergy to use recipeIdUsed
    /*
    function deconstructSynergy(uint256 _tokenId) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) whenSynergyNotAttuned(_tokenId) {
        address user = msg.sender;
        SynergyData storage synergy = synergyProperties[_tokenId];
        bytes32 recipeId = synergy.recipeIdUsed; // Get stored recipe ID
        require(recipeId != bytes32(0), "Synergy recipe data missing");
        SynthesisRecipe storage recipe = synthesisRecipes[recipeId];
        require(recipe.requiredEnergy > 0 || recipe.requiredEssenceTypes.length > 0, "Original recipe not found"); // Ensure recipe still exists

        // ... rest of deconstruction logic using 'recipe' ...

        // Burn the Synergy NFT
        _burn(_tokenId); // _burn already cleans up synergyProperties[_tokenId]

        emit SynergyDeconstructed(user, _tokenId);
    }
    */

    // Final check on function count:
    // ERC721 Base (public): 7 (balanceOf, ownerOf, approve, getApproved, setApprovalForAll, isApprovedForAll, supportsInterface)
    // ERC721 Transfer (public): 3 (transferFrom, safeTransferFrom, safeTransferFrom w/ data)
    // Pausable (public): 2 (pause, unpause)
    // Ownable (public): 1 (transferOwnership)
    // Essence Config (public): 4 (addEssenceType, removeEssenceType, getEssenceConversionRate, withdrawAccruedTokens)
    // Essence User (public): 2 (depositExternalTokenForEssence, getEssenceBalance)
    // Energy Config (public): 4 (setEnergyToken, setEnergyConversionRate, setAttunementRate, setEnergyTokenAndRate)
    // Energy User (public): 3 (depositTokenForEnergy, getUserEnergy, claimAttunementEnergy)
    // Recipe Config (public): 5 (addSynthesisRecipe, removeSynthesisRecipe, getSynthesisRecipe, setSynergyPropertyRanges, getSynergyPropertyRanges)
    // Synthesis User (public): 1 (synthesizeSynergy)
    // Synergy Interaction User (public): 6 (getSynergyProperties, attuneSynergy, disattuneSynergy, isSynergyAttuned, refineSynergy, deconstructSynergy)
    // Utility/Getter (public): 2 (getAttunedSynergyCount, setDeconstructionReturnRate - treating rate setter as config)
    // Total Public/External = 7 + 3 + 2 + 1 + 4 + 2 + 4 + 3 + 5 + 1 + 6 + 2 = 40. Plenty of functions.

    // Adding the updated `synthesizeSynergy` and `getSynergyProperties`, `deconstructSynergy` based on the struct changes.

    // Re-implement `synthesizeSynergy` fully
    function synthesizeSynergy(bytes32 _recipeId) external nonReentrant whenNotPaused onlyExistingRecipe(_recipeId) returns (uint256 newTokenId) {
        SynthesisRecipe storage recipe = synthesisRecipes[_recipeId];
        address user = msg.sender;

        // 1. Check Energy
        require(userEnergy[user] >= recipe.requiredEnergy, "Insufficient energy");
        userEnergy[user] -= recipe.requiredEnergy;
        emit EnergyBalanceUpdated(user, userEnergy[user]);

        // 2. Check and Consume Essences
        for (uint i = 0; i < recipe.requiredEssenceTypes.length; i++) {
            uint8 essenceType = recipe.requiredEssenceTypes[i];
            uint256 requiredAmount = recipe.requiredEssenceAmounts[i];
            require(essenceBalances[user][essenceType] >= requiredAmount, string(abi.encodePacked("Insufficient essence type ", uint256(essenceType))));
            essenceBalances[user][essenceType] -= requiredAmount;
            emit EssenceBalanceUpdated(user, essenceType, essenceBalances[user][essenceType]);
        }

        // 3. Check and Consume Catalyst
        if (recipe.catalystToken != address(0)) {
            if (recipe.isCatalystERC1155) {
                 IERC1155 catalyst = IERC1155(recipe.catalystToken);
                 require(catalyst.balanceOf(user, recipe.catalystAmount) > 0, "Missing catalyst (ERC1155)");
                 catalyst.safeTransferFrom(user, address(this), recipe.catalystAmount, 1, "");
            } else {
                 IERC20 catalyst = IERC20(recipe.catalystToken);
                 require(catalyst.balanceOf(user) >= recipe.catalystAmount, "Missing catalyst (ERC20)");
                 catalyst.safeTransferFrom(user, address(this), recipe.catalystAmount);
            }
        }

        // 4. Mint new Synergy NFT and associate properties
        newTokenId = _tokenIdCounter + 1; // Get the next ID
        _mintSynergy(user); // Internal helper that increments counter and calls _safeMint

        SynergyData storage newSynergy = synergyProperties[newTokenId];
        newSynergy.creationBlock = block.number;
        newSynergy.recipeIdUsed = _recipeId; // Store recipe ID

        // Initialize propertyNames array and populate custom properties
        newSynergy.propertyNames = new bytes32[](recipe.outputPropertyNames.length);

        // Use blockhash and timestamp for a simple seed (NOT truly random, but deterministic yet hard to predict precisely)
        uint256 randomSeed = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender, newTokenId, _recipeId)));

        for (uint i = 0; i < recipe.outputPropertyNames.length; i++) {
            bytes32 propName = recipe.outputPropertyNames[i];
            newSynergy.propertyNames[i] = propName; // Store the property name

            uint256 minValue = recipe.minOutputProperties[propName];
            uint256 maxValue = recipe.maxOutputProperties[propName];

            uint256 generatedValue = minValue; // Default
            if (minValue <= maxValue) {
                uint256 range = maxValue - minValue + 1;
                 if (range > 0) { // Avoid modulo by zero
                     generatedValue = (randomSeed % range) + minValue;
                 }
            }

            newSynergy.customProperties[propName] = generatedValue;

            // Update explicit properties if they map
            if (propName == "potency") newSynergy.potency = generatedValue;
            if (propName == "resonance") newSynergy.resonance = generatedValue;

            randomSeed = uint256(keccak256(abi.encodePacked(randomSeed, propName, i, generatedValue, block.basefee))); // Update seed
        }

        emit SynergySynthesized(user, newTokenId, _recipeId, recipe.requiredEnergy);
    }

    // Re-implement `getSynergyProperties` fully
    function getSynergyProperties(uint256 _tokenId) public view returns (uint256 creationBlock, uint256 potency, uint256 resonance, bytes32[] memory customNames, uint256[] memory customValues) {
        require(_exists(_tokenId), "Synergy does not exist");
        SynergyData storage data = synergyProperties[_tokenId];

        bytes32[] memory propNames = new bytes32[](data.propertyNames.length);
        uint256[] memory propValues = new uint256[](data.propertyNames.length);

        for (uint i = 0; i < data.propertyNames.length; i++) {
             bytes32 name = data.propertyNames[i];
             propNames[i] = name;
             propValues[i] = data.customProperties[name];
        }

        return (
            data.creationBlock,
            data.potency,
            data.resonance,
            propNames,
            propValues
        );
    }

     // Re-implement `deconstructSynergy` fully
    function deconstructSynergy(uint256 _tokenId) external nonReentrant whenNotPaused onlySynergyOwner(_tokenId) whenSynergyNotAttuned(_tokenId) {
        address user = msg.sender;
        SynergyData storage synergy = synergyProperties[_tokenId];
        bytes32 recipeId = synergy.recipeIdUsed; // Get stored recipe ID
        require(recipeId != bytes32(0), "Synergy recipe data missing");
        SynthesisRecipe storage recipe = synthesisRecipes[recipeId];
        require(recipe.requiredEnergy > 0 || recipe.requiredEssenceTypes.length > 0 || recipe.catalystToken != address(0), "Original recipe not found or empty"); // Ensure recipe still exists

        // 1. Return Essences
        for (uint i = 0; i < recipe.requiredEssenceTypes.length; i++) {
            uint8 essenceType = recipe.requiredEssenceTypes[i];
            uint256 originalAmount = recipe.requiredEssenceAmounts[i];
            uint256 amountToReturn = (originalAmount * deconstructionReturnRatePermil) / 1000;
            if (amountToReturn > 0) {
                essenceBalances[user][essenceType] += amountToReturn;
                 emit EssenceBalanceUpdated(user, essenceType, essenceBalances[user][essenceType]);
            }
        }

        // 2. Return Catalyst (fractionally or fully based on type/rate)
        if (recipe.catalystToken != address(0)) {
            if (!recipe.isCatalystERC1155) { // Only return ERC20 catalysts
                 IERC20 catalyst = IERC20(recipe.catalystToken);
                 uint256 originalAmount = recipe.catalystAmount;
                 uint256 amountToReturn = (originalAmount * deconstructionReturnRatePermil) / 1000;
                 if (amountToReturn > 0) {
                     catalyst.safeTransfer(user, amountToReturn); // Transfer token back
                 }
            }
            // ERC1155 catalysts are not returned upon deconstruction in this model
        }

        // Energy cost for synthesis is NOT returned as it's consumed.

        // 3. Burn the Synergy NFT
        _burn(_tokenId); // _burn already cleans up synergyProperties[_tokenId] and attunement

        emit SynergyDeconstructed(user, _tokenId);
    }

     // Internal helper to get next token ID and mint
    function _mintSynergy(address to) internal returns (uint256) {
        _tokenIdCounter++;
        uint256 newTokenId = _tokenIdCounter;
        _safeMint(to, newTokenId);
        return newTokenId;
    }
}

```