The `CognitiveAssetProtocol` (CAP) is an advanced Solidity smart contract designed to tokenize, manage, and evolve "cognitive assets" on the blockchain. These assets are represented as ERC-721 NFTs and can encapsulate a wide range of intellectual creations, such as trained AI models, complex algorithms, unique datasets, generative art algorithms, or highly structured creative works.

This protocol introduces several cutting-edge concepts:

1.  **Lineage-Based Dynamic Royalties**: A system where value generated by a derivative asset flows proportionally back to its original parent assets in the lineage, ensuring fair compensation for foundational creativity.
2.  **AI-Assisted Asset Evolution**: Assets can accumulate "evolution points" via off-chain AI analysis (facilitated by oracles), which can trigger on-chain state changes, unlock new capabilities, or influence their inherent value.
3.  **Synergy Pools**: A mechanism allowing owners to stake compatible cognitive assets together into "pools" to unlock combinatorial benefits, generate new "synergy assets," or enhance collective value.
4.  **Decentralized Licensing**: On-chain representation of licensing terms that can be dynamically updated.
5.  **Basic Governance & Moderation**: Core functionalities for protocol parameter adjustments and community-driven content flagging.

---

### Contract: `CognitiveAssetProtocol`

**Outline and Function Summary:**

**I. Core Asset Management**
1.  `registerCognitiveAsset(string _uri, uint256 _licenseType, uint256[] _parentAssets)`: Mints a new NFT for a cognitive asset. Sets its metadata URI, initial license type, and links it to existing parent assets to establish its lineage.
2.  `updateAssetURI(uint256 _tokenId, string _newUri)`: Allows the owner of an asset to update its associated metadata URI, reflecting changes or evolution.
3.  `transferAssetOwnership(uint256 _tokenId, address _newOwner)`: Standard ERC-721 function for transferring ownership of a cognitive asset NFT.
4.  `getAssetDetails(uint256 _tokenId)`: Retrieves all detailed on-chain information about a specific cognitive asset, including its lineage, evolution points, and current status.
5.  `setAssetLicense(uint256 _tokenId, uint256 _newLicenseType)`: Allows the asset owner to change the licensing terms associated with their asset.

**II. Value Accrual & Royalties**
6.  `recordValueContribution(uint256 _tokenId, uint256 _amount)`: An external system or user calls this to record a monetary value generated by a specific asset. This triggers the calculation and distribution of royalties to the asset owner and its parents.
7.  `claimRoyalties()`: Allows any registered asset owner to claim their accumulated pending royalty earnings.
8.  `getPendingRoyalties(address _owner)`: Queries the total amount of royalties currently awaiting collection by a specific address.
9.  `setRoyaltyRate(uint256 _newRate)`: Callable by the contract owner (or governance) to adjust the global protocol royalty rate (in basis points).
10. `setParentRoyaltySplit(uint256 _tokenId, uint256[] _parentIds, uint256[] _splits)`: Allows an asset owner to customize how the parent's share of royalties generated by *this* asset is split among its immediate parents.

**III. Evolutionary & Synergistic Mechanics**
11. `recordEvolutionEvent(uint256 _tokenId, uint256 _evolutionPoints, bytes32 _eventHash)`: Callable by the designated AI oracle to record an "evolution event" for an asset, incrementing its `evolutionPoints` and potentially impacting its `qualityScore`.
12. `triggerAssetEvolution(uint256 _tokenId)`: Allows the asset owner to trigger an "evolution" process for their asset, provided it has accumulated sufficient `evolutionPoints`. This might update its `qualityScore` or metadata URI (off-chain).
13. `createSynergyPool(uint256[] _tokenIds, uint256 _poolType)`: Enables multiple asset owners to collaboratively create a "synergy pool" by staking a set of compatible cognitive assets.
14. `stakeToSynergyPool(uint256 _poolId, uint256[] _tokenIds)`: Allows additional assets to be staked into an existing synergy pool.
15. `unstakeFromSynergyPool(uint256 _poolId, uint256[] _tokenIds)`: Allows staked assets to be retrieved from a synergy pool by their owners.
16. `getSynergyPoolDetails(uint256 _poolId)`: Retrieves detailed information about a specific synergy pool, including its staked assets and type.

**IV. Governance & Protocol Parameters**
17. `updateOracleAddress(address _newOracle)`: Allows the contract owner to update the address of the trusted AI Oracle authorized to submit evolution and analysis results.
18. `proposeParameterChange(bytes32 _paramName, uint256 _newValue)`: Initiates a governance proposal to modify a key protocol parameter (e.g., royalty rates, minimum evolution points).
19. `voteOnProposal(uint256 _proposalId, bool _approve)`: Allows eligible voters (e.g., asset owners, protocol token holders if integrated) to cast their vote on an active governance proposal.
20. `executeProposal(uint256 _proposalId)`: Callable by the contract owner to execute a governance proposal once it has met the voting threshold and its deadline has passed.

**V. Dispute Resolution & Moderation**
21. `flagAsset(uint256 _tokenId, string _reason)`: Allows any user to flag a cognitive asset for review (e.g., for inappropriate content, copyright infringement, or malicious function).
22. `resolveFlag(uint256 _tokenId, bool _remove, string _resolutionDetails)`: Callable by the contract owner (or designated moderators) to review and resolve flagged assets, potentially leading to suspension or delisting.

**VI. AI-Interaction Facades (Oracle Interface)**
23. `requestAIAnalysis(uint256 _tokenId, string _prompt)`: Logs a request for off-chain AI analysis on a specific cognitive asset based on a given prompt.
24. `submitAIAnalysisResult(uint256 _requestId, uint256 _tokenId, bytes32 _resultHash, uint256 _aiConfidenceScore, uint256 _suggestedEvolutionPoints)`: Callable *only* by the designated AI Oracle to submit the results of an off-chain AI analysis, impacting the asset's metrics like `qualityScore` and `evolutionPoints`.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title CognitiveAssetProtocol (CAP)
 * @dev A novel framework to tokenize, manage, and evolve "cognitive assets" on the blockchain.
 *      Incorporates lineage-based dynamic royalties, AI-assisted evolution (via oracle),
 *      synergy pools for combinatorial asset creation, and basic governance/moderation.
 *
 * Outline:
 * I.  Core Asset Management
 *     - registerCognitiveAsset: Mints a new NFT for a cognitive asset, establishes lineage.
 *     - updateAssetURI: Allows asset owner to update its metadata URI.
 *     - transferAssetOwnership: Standard NFT transfer.
 *     - getAssetDetails: Retrieves all detailed information about an asset.
 *     - setAssetLicense: Modifies the licensing terms associated with an asset.
 * II. Value Accrual & Royalties
 *     - recordValueContribution: Records value generated by an asset, triggering royalty distribution up the lineage.
 *     - claimRoyalties: Allows asset owners to claim their accumulated royalty earnings.
 *     - getPendingRoyalties: Queries the amount of royalties pending for an owner.
 *     - setRoyaltyRate: Callable by governance to adjust the global royalty rate.
 *     - setParentRoyaltySplit: Allows an asset owner to customize how royalties are split among multiple direct parents.
 * III. Evolutionary & Synergistic Mechanics
 *     - recordEvolutionEvent: An oracle or trusted AI agent records an evolution event, adding points to an asset.
 *     - triggerAssetEvolution: Based on accumulated evolution points, an asset can trigger on-chain state changes or unlock new capabilities.
 *     - createSynergyPool: Enables owners of compatible assets to combine them into a "synergy pool" for shared benefits.
 *     - stakeToSynergyPool: Adds more assets to an existing synergy pool.
 *     - unstakeFromSynergyPool: Removes assets from a synergy pool.
 *     - getSynergyPoolDetails: Provides detailed information about a synergy pool.
 * IV. Governance & Protocol Parameters
 *     - updateOracleAddress: Admin function to set or update the trusted AI oracle address.
 *     - proposeParameterChange: Initiates a governance proposal to modify protocol parameters.
 *     - voteOnProposal: Allows eligible voters to cast their vote on an active proposal.
 *     - executeProposal: Executes a passed governance proposal.
 * V.  Dispute Resolution & Moderation
 *     - flagAsset: Allows users to flag assets deemed inappropriate or malicious.
 *     - resolveFlag: Admin/governance function to resolve flagged assets (e.g., suspend, delist).
 * VI. AI-Interaction Facades (Oracle Interface)
 *     - requestAIAnalysis: Logs a request for off-chain AI analysis on an asset, potentially requiring a fee.
 *     - submitAIAnalysisResult: Callable by the AI Oracle to submit analysis results, impacting asset metrics.
 */
contract CognitiveAssetProtocol is ERC721, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;

    // --- Constants for License Types ---
    uint256 public constant LICENSE_TYPE_PUBLIC_DOMAIN = 0;
    uint256 public constant LICENSE_TYPE_COMMERCIAL_RESTRICTED = 1;
    uint256 public constant LICENSE_TYPE_COMMERCIAL_OPEN = 2;
    uint256 public constant LICENSE_TYPE_NON_COMMERCIAL_ONLY = 3;

    // --- Constants for Synergy Pool Types ---
    uint256 public constant POOL_TYPE_COLLABORATIVE = 0; // Assets contribute to a shared goal
    uint256 public constant POOL_TYPE_GENERATIVE = 1;    // Assets combine to generate new output/asset
    uint256 public constant POOL_TYPE_COMPETITIVE = 2;   // Assets compete, best performer benefits

    // --- State Variables ---
    Counters.Counter private _tokenIdCounter;
    Counters.Counter private _synergyPoolIdCounter;
    Counters.Counter private _proposalIdCounter;
    Counters.Counter private _aiRequestIdCounter;

    // AI Oracle address, authorized to submit AI analysis results
    address public aiOracleAddress;

    // Global Royalty Parameters (in basis points, 10000 = 100%)
    uint256 public globalRoyaltyRate = 1000; // 10% of generated value goes to protocol for royalties
    uint256 public parentContributionRate = 2000; // 20% of globalRoyaltyRate share goes to parents

    // Minimum evolution points required to trigger an asset's evolution
    uint256 public minEvolutionPointsForTrigger = 100;

    // --- Data Structures ---

    // Represents a single Cognitive Asset
    struct CognitiveAsset {
        string uri;                 // Metadata URI (contains details like description, code hash, model hash)
        address creator;            // Original creator of the asset
        uint256 registrationTime;   // Timestamp of asset registration
        uint256[] parentAssets;     // Token IDs of parent assets (for lineage)
        uint256 currentLicenseType; // Current licensing terms (e.g., Public Domain, Commercial Restricted)
        uint256 evolutionPoints;    // Points accumulated from AI analysis or contributions
        uint256 qualityScore;       // Derived from AI analysis, user ratings, etc. (e.g., 0-1000)
        bool isFlagged;             // True if asset has been flagged for review
        bool isSuspended;           // True if asset has been suspended (e.g., due to flag resolution)
    }

    // Represents a Synergy Pool where multiple assets are combined
    struct SynergyPool {
        uint256[] stakedAssets;     // Token IDs of assets staked in this pool
        address creator;            // Creator of the synergy pool
        uint256 poolType;           // Type of synergy (e.g., Collaborative, Generative)
        uint256 synergyScore;       // Calculated score based on compatibility, usage, etc.
        uint256 generatedTokenId;   // If the pool generates a new asset, its tokenId
    }

    // Represents a Governance Proposal for parameter changes
    struct Proposal {
        bytes32 paramName;          // Hashed name of the parameter to change
        uint256 newValue;           // New value for the parameter
        uint256 voteCountYes;       // Number of 'yes' votes
        uint256 voteCountNo;        // Number of 'no' votes
        uint256 totalVoters;        // Total eligible voters (for simple voting, can be total assets/tokens)
        uint256 deadline;           // Timestamp when voting ends
        mapping(address => bool) hasVoted; // Tracks if an address has voted on this proposal
        bool executed;              // True if the proposal has been executed
    }

    // Represents a request for off-chain AI analysis
    struct AIAnalysisRequest {
        uint256 tokenId;
        address requester;
        string prompt;
        uint256 timestamp;
        bool fulfilled;
    }

    // --- Mappings ---
    mapping(uint256 => CognitiveAsset) public cognitiveAssets;
    mapping(uint256 => SynergyPool) public synergyPools;
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => AIAnalysisRequest) public aiAnalysisRequests;

    // Tracks pending royalty amounts for each asset owner
    mapping(address => uint256) public pendingRoyalties;

    // Custom parent royalty splits: assetId -> parentId -> split_percentage (basis points)
    // Sum of split_percentage for all parents for a given asset should be 10000 (100%) if set.
    // Otherwise, it's evenly split.
    mapping(uint256 => mapping(uint256 => uint256)) public customParentRoyaltySplits;

    // --- Events ---
    event CognitiveAssetRegistered(uint256 indexed tokenId, address indexed creator, string uri, uint256[] parentAssets);
    event AssetURIUpdated(uint256 indexed tokenId, string newUri);
    event AssetLicenseUpdated(uint256 indexed tokenId, uint256 newLicenseType);
    event ValueContributionRecorded(uint256 indexed tokenId, address indexed contributor, uint256 amount);
    event RoyaltiesClaimed(address indexed receiver, uint256 amount);
    event GlobalRoyaltyRateUpdated(uint256 newRate);
    event ParentContributionRateUpdated(uint256 newRate);
    event ParentRoyaltySplitSet(uint256 indexed tokenId, uint256[] parentIds, uint256[] splits);

    event EvolutionEventRecorded(uint256 indexed tokenId, uint256 evolutionPointsAdded, uint256 newEvolutionPoints);
    event AssetEvolutionTriggered(uint256 indexed tokenId, uint256 currentEvolutionPoints);
    event SynergyPoolCreated(uint256 indexed poolId, address indexed creator, uint256[] stakedAssets, uint256 poolType);
    event AssetsStakedToPool(uint256 indexed poolId, uint256[] tokenIds);
    event AssetsUnstakedFromPool(uint256 indexed poolId, uint256[] tokenIds);

    event OracleAddressUpdated(address oldAddress, address newAddress);
    event ProposalCreated(uint256 indexed proposalId, bytes32 paramName, uint256 newValue, uint256 deadline);
    event Voted(uint256 indexed proposalId, address indexed voter, bool decision);
    event ProposalExecuted(uint256 indexed proposalId, bool success);

    event AssetFlagged(uint256 indexed tokenId, address indexed flipper, string reason);
    event AssetFlagResolved(uint256 indexed tokenId, bool removed, string resolutionDetails);

    event AIAnalysisRequested(uint256 indexed requestId, uint256 indexed tokenId, address requester, string prompt);
    event AIAnalysisResultSubmitted(uint256 indexed requestId, uint256 indexed tokenId, bytes32 resultHash, uint256 confidenceScore, uint256 suggestedEvolutionPoints);

    constructor() ERC721("CognitiveAsset", "CAP") {
        aiOracleAddress = msg.sender; // Set initial oracle to deployer
    }

    modifier onlyOracle() {
        require(msg.sender == aiOracleAddress, "CAP: Only AI Oracle can call this function");
        _;
    }

    // --- I. Core Asset Management ---

    /**
     * @dev Mints a new NFT for a cognitive asset.
     * @param _uri Metadata URI for the asset.
     * @param _licenseType Initial licensing terms.
     * @param _parentAssets Optional array of parent asset token IDs to establish lineage.
     */
    function registerCognitiveAsset(string calldata _uri, uint256 _licenseType, uint256[] calldata _parentAssets) external nonReentrant {
        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();

        for (uint256 i = 0; i < _parentAssets.length; i++) {
            require(_exists(_parentAssets[i]), "CAP: Parent asset does not exist");
        }

        cognitiveAssets[newTokenId] = CognitiveAsset({
            uri: _uri,
            creator: msg.sender,
            registrationTime: block.timestamp,
            parentAssets: _parentAssets,
            currentLicenseType: _licenseType,
            evolutionPoints: 0,
            qualityScore: 0, // Initial quality score, can be updated by AI analysis
            isFlagged: false,
            isSuspended: false
        });

        _safeMint(msg.sender, newTokenId);
        emit CognitiveAssetRegistered(newTokenId, msg.sender, _uri, _parentAssets);
    }

    /**
     * @dev Allows the owner of an asset to update its associated metadata URI.
     * @param _tokenId The ID of the asset to update.
     * @param _newUri The new metadata URI.
     */
    function updateAssetURI(uint256 _tokenId, string calldata _newUri) external {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "CAP: Not asset owner or approved");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        cognitiveAssets[_tokenId].uri = _newUri;
        emit AssetURIUpdated(_tokenId, _newUri);
    }

    /**
     * @dev Standard ERC-721 function for transferring ownership of a cognitive asset NFT.
     *      Overrides to enforce custom checks like suspension.
     */
    function transferAssetOwnership(uint256 _tokenId, address _newOwner) public {
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        safeTransferFrom(msg.sender, _newOwner, _tokenId);
    }

    /**
     * @dev Retrieves all detailed on-chain information about a specific cognitive asset.
     * @param _tokenId The ID of the asset.
     * @return CognitiveAsset struct containing all details.
     */
    function getAssetDetails(uint256 _tokenId)
        public
        view
        returns (
            string memory uri,
            address creator,
            uint256 registrationTime,
            uint256[] memory parentAssets,
            uint256 currentLicenseType,
            uint256 evolutionPoints,
            uint256 qualityScore,
            bool isFlagged,
            bool isSuspended
        )
    {
        CognitiveAsset storage asset = cognitiveAssets[_tokenId];
        require(_exists(_tokenId), "CAP: Asset does not exist");
        return (
            asset.uri,
            asset.creator,
            asset.registrationTime,
            asset.parentAssets,
            asset.currentLicenseType,
            asset.evolutionPoints,
            asset.qualityScore,
            asset.isFlagged,
            asset.isSuspended
        );
    }

    /**
     * @dev Allows the asset owner to change the licensing terms associated with their asset.
     * @param _tokenId The ID of the asset.
     * @param _newLicenseType The new license type.
     */
    function setAssetLicense(uint256 _tokenId, uint256 _newLicenseType) external {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "CAP: Not asset owner or approved");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        cognitiveAssets[_tokenId].currentLicenseType = _newLicenseType;
        emit AssetLicenseUpdated(_tokenId, _newLicenseType);
    }

    // --- II. Value Accrual & Royalties ---

    /**
     * @dev Records a monetary value generated by a specific asset.
     *      This triggers the calculation and distribution of royalties to the asset owner and its parents.
     *      Assumes _amount is in the smallest unit of the payment token (e.g., wei for ETH).
     * @param _tokenId The ID of the asset that generated value.
     * @param _amount The gross value generated by the asset.
     */
    function recordValueContribution(uint256 _tokenId, uint256 _amount) external nonReentrant {
        require(_exists(_tokenId), "CAP: Asset does not exist");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        require(_amount > 0, "CAP: Amount must be positive");

        uint256 totalGrossValue = _amount;
        uint256 protocolShare = (totalGrossValue * globalRoyaltyRate) / 10000; // e.g., 10% of gross value

        uint256 toParentsShare = (protocolShare * parentContributionRate) / 10000; // e.g., 20% of protocol share
        uint256 toAssetOwnerShare = protocolShare - toParentsShare; // remaining 80% of protocol share

        // Distribute to current asset owner
        address currentAssetOwner = ownerOf(_tokenId);
        pendingRoyalties[currentAssetOwner] += toAssetOwnerShare;

        // Distribute to parent assets
        uint256[] memory parents = cognitiveAssets[_tokenId].parentAssets;
        if (parents.length > 0) {
            uint256 totalCustomSplitPercentage;
            bool hasCustomSplit = false;
            // Check if custom splits are defined and sum them up
            for (uint256 i = 0; i < parents.length; i++) {
                if (customParentRoyaltySplits[_tokenId][parents[i]] > 0) {
                    hasCustomSplit = true;
                    totalCustomSplitPercentage += customParentRoyaltySplits[_tokenId][parents[i]];
                }
            }

            // Distribute based on custom splits or evenly
            for (uint256 i = 0; i < parents.length; i++) {
                uint256 parentId = parents[i];
                if (_exists(parentId)) { // Ensure parent still exists
                    address parentOwner = ownerOf(parentId);
                    uint256 shareToParent;
                    if (hasCustomSplit && totalCustomSplitPercentage > 0) {
                        // Use custom split percentage if available for this parent
                        shareToParent = (toParentsShare * customParentRoyaltySplits[_tokenId][parentId]) / totalCustomSplitPercentage;
                    } else {
                        // Otherwise, distribute evenly
                        shareToParent = toParentsShare / parents.length;
                    }
                    pendingRoyalties[parentOwner] += shareToParent;
                }
            }
        }

        emit ValueContributionRecorded(_tokenId, msg.sender, _amount);
    }

    /**
     * @dev Allows any registered asset owner to claim their accumulated pending royalty earnings.
     */
    function claimRoyalties() external nonReentrant {
        uint256 amount = pendingRoyalties[msg.sender];
        require(amount > 0, "CAP: No pending royalties to claim");

        pendingRoyalties[msg.sender] = 0; // Reset pending amount BEFORE sending to prevent reentrancy

        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success, "CAP: Failed to send royalties");

        emit RoyaltiesClaimed(msg.sender, amount);
    }

    /**
     * @dev Queries the total amount of royalties currently awaiting collection by a specific address.
     * @param _owner The address to query.
     * @return The amount of pending royalties in wei.
     */
    function getPendingRoyalties(address _owner) external view returns (uint256) {
        return pendingRoyalties[_owner];
    }

    /**
     * @dev Callable by the contract owner (or governance) to adjust the global protocol royalty rate.
     * @param _newRate The new royalty rate in basis points (e.g., 1000 for 10%). Max 10000 (100%).
     */
    function setRoyaltyRate(uint256 _newRate) external onlyOwner {
        require(_newRate <= 10000, "CAP: Royalty rate cannot exceed 100%");
        globalRoyaltyRate = _newRate;
        emit GlobalRoyaltyRateUpdated(_newRate);
    }

    /**
     * @dev Callable by the contract owner (or governance) to adjust the percentage of global royalty that goes to parents.
     * @param _newRate The new parent contribution rate in basis points (e.g., 2000 for 20%). Max 10000 (100%).
     */
    function setParentContributionRate(uint256 _newRate) external onlyOwner {
        require(_newRate <= 10000, "CAP: Parent contribution rate cannot exceed 100%");
        parentContributionRate = _newRate;
        emit ParentContributionRateUpdated(_newRate);
    }

    /**
     * @dev Allows an asset owner to customize how the parent's share of royalties generated by *this* asset
     *      is split among its immediate parents.
     *      The sum of _splits must equal 10000 (100%) if provided.
     * @param _tokenId The ID of the asset whose parent splits are being set.
     * @param _parentIds Array of parent token IDs.
     * @param _splits Array of split percentages (in basis points) corresponding to _parentIds.
     */
    function setParentRoyaltySplit(uint256 _tokenId, uint256[] calldata _parentIds, uint256[] calldata _splits) external {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "CAP: Not asset owner or approved");
        require(_parentIds.length == _splits.length, "CAP: Mismatched parentIds and splits array lengths");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");

        uint256 totalSplit = 0;
        for (uint256 i = 0; i < _splits.length; i++) {
            totalSplit += _splits[i];
            require(_exists(_parentIds[i]), "CAP: Invalid parent ID provided");
        }
        require(totalSplit == 10000, "CAP: Total split percentages must sum to 10000 (100%)");

        // Clear existing custom splits for this asset's parents
        for (uint256 i = 0; i < cognitiveAssets[_tokenId].parentAssets.length; i++) {
            customParentRoyaltySplits[_tokenId][cognitiveAssets[_tokenId].parentAssets[i]] = 0;
        }

        // Set new custom splits
        for (uint256 i = 0; i < _parentIds.length; i++) {
            customParentRoyaltySplits[_tokenId][_parentIds[i]] = _splits[i];
        }

        emit ParentRoyaltySplitSet(_tokenId, _parentIds, _splits);
    }

    // --- III. Evolutionary & Synergistic Mechanics ---

    /**
     * @dev Callable by the designated AI oracle to record an "evolution event" for an asset,
     *      incrementing its `evolutionPoints` and potentially impacting its `qualityScore`.
     * @param _tokenId The ID of the asset.
     * @param _evolutionPoints The number of evolution points to add.
     * @param _eventHash A hash representing the specific evolution event (e.g., AI model update, major data contribution).
     */
    function recordEvolutionEvent(uint256 _tokenId, uint256 _evolutionPoints, bytes32 _eventHash) external onlyOracle {
        require(_exists(_tokenId), "CAP: Asset does not exist");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        cognitiveAssets[_tokenId].evolutionPoints += _evolutionPoints;
        // Optionally update qualityScore based on event details / oracle logic
        // cognitiveAssets[_tokenId].qualityScore = calculateNewQualityScore(...)
        emit EvolutionEventRecorded(_tokenId, _evolutionPoints, cognitiveAssets[_tokenId].evolutionPoints);
    }

    /**
     * @dev Allows the asset owner to trigger an "evolution" process for their asset,
     *      provided it has accumulated sufficient `evolutionPoints`. This might update its
     *      `qualityScore` or metadata URI (off-chain logic could be implied for URI change).
     * @param _tokenId The ID of the asset to evolve.
     */
    function triggerAssetEvolution(uint256 _tokenId) external {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "CAP: Not asset owner or approved");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");
        require(cognitiveAssets[_tokenId].evolutionPoints >= minEvolutionPointsForTrigger, "CAP: Not enough evolution points");

        // Here, you would implement the on-chain effects of evolution.
        // For example, resetting evolution points and potentially increasing quality score,
        // or triggering an update to its metadata URI which implies an off-chain change.
        uint256 currentPoints = cognitiveAssets[_tokenId].evolutionPoints;
        cognitiveAssets[_tokenId].evolutionPoints = 0; // Reset points after triggering evolution
        cognitiveAssets[_tokenId].qualityScore = cognitiveAssets[_tokenId].qualityScore + (currentPoints / minEvolutionPointsForTrigger) * 10; // Simple example

        emit AssetEvolutionTriggered(_tokenId, currentPoints);
    }

    /**
     * @dev Enables multiple asset owners to collaboratively create a "synergy pool"
     *      by staking a set of compatible cognitive assets. All assets must be owned by msg.sender.
     * @param _tokenIds Array of token IDs to stake into the new pool.
     * @param _poolType The type of synergy pool (e.g., Collaborative, Generative).
     */
    function createSynergyPool(uint256[] calldata _tokenIds, uint256 _poolType) external nonReentrant {
        require(_tokenIds.length > 1, "CAP: A synergy pool requires at least two assets");
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            require(_isApprovedOrOwner(msg.sender, _tokenIds[i]), "CAP: Not owner of all assets to stake");
            require(!cognitiveAssets[_tokenIds[i]].isSuspended, "CAP: Cannot stake suspended asset");
            // Transfer ownership to contract (or use ERC-721Enumerable for tracking)
            _transfer(msg.sender, address(this), _tokenIds[i]);
        }

        _synergyPoolIdCounter.increment();
        uint256 newPoolId = _synergyPoolIdCounter.current();

        synergyPools[newPoolId] = SynergyPool({
            stakedAssets: _tokenIds,
            creator: msg.sender,
            poolType: _poolType,
            synergyScore: 0, // Initial score, can evolve
            generatedTokenId: 0 // No generated token yet
        });

        emit SynergyPoolCreated(newPoolId, msg.sender, _tokenIds, _poolType);
    }

    /**
     * @dev Allows additional assets to be staked into an existing synergy pool.
     * @param _poolId The ID of the synergy pool.
     * @param _tokenIds Array of token IDs to add to the pool.
     */
    function stakeToSynergyPool(uint256 _poolId, uint256[] calldata _tokenIds) external nonReentrant {
        SynergyPool storage pool = synergyPools[_poolId];
        require(pool.creator != address(0), "CAP: Synergy pool does not exist");

        for (uint256 i = 0; i < _tokenIds.length; i++) {
            require(_isApprovedOrOwner(msg.sender, _tokenIds[i]), "CAP: Not owner of asset to stake");
            require(!cognitiveAssets[_tokenIds[i]].isSuspended, "CAP: Cannot stake suspended asset");
            pool.stakedAssets.push(_tokenIds[i]);
            _transfer(msg.sender, address(this), _tokenIds[i]);
        }
        emit AssetsStakedToPool(_poolId, _tokenIds);
    }

    /**
     * @dev Allows staked assets to be retrieved from a synergy pool by their owners.
     * @param _poolId The ID of the synergy pool.
     * @param _tokenIds Array of token IDs to remove from the pool.
     */
    function unstakeFromSynergyPool(uint256 _poolId, uint256[] calldata _tokenIds) external nonReentrant {
        SynergyPool storage pool = synergyPools[_poolId];
        require(pool.creator != address(0), "CAP: Synergy pool does not exist");

        for (uint256 i = 0; i < _tokenIds.length; i++) {
            uint256 tokenIdToRemove = _tokenIds[i];
            bool foundAndRemoved = false;
            for (uint256 j = 0; j < pool.stakedAssets.length; j++) {
                if (pool.stakedAssets[j] == tokenIdToRemove) {
                    require(ownerOf(tokenIdToRemove) == address(this), "CAP: Asset not in this pool");
                    // Simple removal by overwriting and popping (order doesn't matter for stakedAssets)
                    pool.stakedAssets[j] = pool.stakedAssets[pool.stakedAssets.length - 1];
                    pool.stakedAssets.pop();
                    _transfer(address(this), msg.sender, tokenIdToRemove);
                    foundAndRemoved = true;
                    break;
                }
            }
            require(foundAndRemoved, "CAP: Asset not found in pool or not owned by caller");
        }
        emit AssetsUnstakedFromPool(_poolId, _tokenIds);
    }

    /**
     * @dev Retrieves detailed information about a specific synergy pool.
     * @param _poolId The ID of the synergy pool.
     * @return SynergyPool struct containing all details.
     */
    function getSynergyPoolDetails(uint256 _poolId)
        public
        view
        returns (
            uint256[] memory stakedAssets,
            address creator,
            uint256 poolType,
            uint256 synergyScore,
            uint256 generatedTokenId
        )
    {
        SynergyPool storage pool = synergyPools[_poolId];
        require(pool.creator != address(0), "CAP: Synergy pool does not exist");
        return (pool.stakedAssets, pool.creator, pool.poolType, pool.synergyScore, pool.generatedTokenId);
    }

    // --- IV. Governance & Protocol Parameters ---

    /**
     * @dev Allows the contract owner to update the address of the trusted AI Oracle.
     *      The AI Oracle is authorized to submit AI analysis results and evolution events.
     * @param _newOracle The new address for the AI Oracle.
     */
    function updateOracleAddress(address _newOracle) external onlyOwner {
        require(_newOracle != address(0), "CAP: New oracle address cannot be zero");
        address oldOracle = aiOracleAddress;
        aiOracleAddress = _newOracle;
        emit OracleAddressUpdated(oldOracle, _newOracle);
    }

    /**
     * @dev Initiates a governance proposal to modify a key protocol parameter.
     *      Only the contract owner can execute proposals after voting.
     * @param _paramName Hashed name of the parameter to change (e.g., keccak256("globalRoyaltyRate")).
     * @param _newValue The new value for the parameter.
     */
    function proposeParameterChange(bytes32 _paramName, uint256 _newValue) external {
        _proposalIdCounter.increment();
        uint256 proposalId = _proposalIdCounter.current();
        // For simplicity, voting period is 7 days (604800 seconds)
        proposals[proposalId] = Proposal({
            paramName: _paramName,
            newValue: _newValue,
            voteCountYes: 0,
            voteCountNo: 0,
            totalVoters: 0, // Could be total assets or total CAP token holders
            deadline: block.timestamp + 7 days,
            executed: false
        });
        emit ProposalCreated(proposalId, _paramName, _newValue, proposals[proposalId].deadline);
    }

    /**
     * @dev Allows eligible voters (e.g., asset owners, protocol token holders if integrated)
     *      to cast their vote on an active governance proposal.
     *      For simplicity, any user can vote, and each user gets one vote per proposal.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _approve True for 'yes', false for 'no'.
     */
    function voteOnProposal(uint256 _proposalId, bool _approve) external {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.deadline > block.timestamp, "CAP: Voting period has ended");
        require(!proposal.executed, "CAP: Proposal already executed");
        require(!proposal.hasVoted[msg.sender], "CAP: Already voted on this proposal");

        if (_approve) {
            proposal.voteCountYes++;
        } else {
            proposal.voteCountNo++;
        }
        proposal.hasVoted[msg.sender] = true;
        emit Voted(_proposalId, msg.sender, _approve);
    }

    /**
     * @dev Callable by the contract owner to execute a governance proposal once it has met
     *      the voting threshold and its deadline has passed.
     *      Requires a simple majority for passing (Yes > No).
     * @param _proposalId The ID of the proposal to execute.
     */
    function executeProposal(uint256 _proposalId) external onlyOwner {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.deadline <= block.timestamp, "CAP: Voting period not ended yet");
        require(!proposal.executed, "CAP: Proposal already executed");
        require(proposal.voteCountYes > proposal.voteCountNo, "CAP: Proposal did not pass majority vote");

        proposal.executed = true;
        bool success = true;

        if (proposal.paramName == keccak256("globalRoyaltyRate")) {
            setRoyaltyRate(proposal.newValue);
        } else if (proposal.paramName == keccak256("parentContributionRate")) {
            setParentContributionRate(proposal.newValue);
        } else if (proposal.paramName == keccak256("minEvolutionPointsForTrigger")) {
            minEvolutionPointsForTrigger = proposal.newValue;
        } else {
            success = false; // Parameter not recognized or not implementable via this mechanism
        }
        emit ProposalExecuted(_proposalId, success);
    }

    // --- V. Dispute Resolution & Moderation ---

    /**
     * @dev Allows any user to flag a cognitive asset for review (e.g., for inappropriate content,
     *      copyright infringement, or malicious function).
     * @param _tokenId The ID of the asset to flag.
     * @param _reason A string detailing the reason for flagging.
     */
    function flagAsset(uint256 _tokenId, string calldata _reason) external {
        require(_exists(_tokenId), "CAP: Asset does not exist");
        require(!cognitiveAssets[_tokenId].isFlagged, "CAP: Asset already flagged");
        cognitiveAssets[_tokenId].isFlagged = true;
        emit AssetFlagged(_tokenId, msg.sender, _reason);
    }

    /**
     * @dev Callable by the contract owner (or designated moderators) to review and resolve flagged assets,
     *      potentially leading to suspension or delisting.
     * @param _tokenId The ID of the asset to resolve.
     * @param _remove If true, the asset will be suspended. If false, the flag is simply cleared.
     * @param _resolutionDetails A string detailing the resolution.
     */
    function resolveFlag(uint256 _tokenId, bool _remove, string calldata _resolutionDetails) external onlyOwner {
        require(_exists(_tokenId), "CAP: Asset does not exist");
        require(cognitiveAssets[_tokenId].isFlagged, "CAP: Asset is not flagged");

        cognitiveAssets[_tokenId].isFlagged = false;
        if (_remove) {
            cognitiveAssets[_tokenId].isSuspended = true; // Suspend asset functionality
        }
        emit AssetFlagResolved(_tokenId, _remove, _resolutionDetails);
    }

    // --- VI. AI-Interaction Facades (Oracle Interface) ---

    /**
     * @dev Logs a request for off-chain AI analysis on a specific cognitive asset based on a given prompt.
     *      This function typically initiates an off-chain process.
     * @param _tokenId The ID of the asset to analyze.
     * @param _prompt The specific prompt or query for the AI analysis.
     */
    function requestAIAnalysis(uint256 _tokenId, string calldata _prompt) external nonReentrant {
        require(_exists(_tokenId), "CAP: Asset does not exist");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");

        _aiRequestIdCounter.increment();
        uint256 requestId = _aiRequestIdCounter.current();

        aiAnalysisRequests[requestId] = AIAnalysisRequest({
            tokenId: _tokenId,
            requester: msg.sender,
            prompt: _prompt,
            timestamp: block.timestamp,
            fulfilled: false
        });

        emit AIAnalysisRequested(requestId, _tokenId, msg.sender, _prompt);
    }

    /**
     * @dev Callable *only* by the designated AI Oracle to submit the results of an off-chain AI analysis.
     *      This impacts the asset's metrics like `qualityScore` and `evolutionPoints`.
     * @param _requestId The ID of the original AI analysis request.
     * @param _tokenId The ID of the asset that was analyzed.
     * @param _resultHash A hash of the detailed AI analysis result (stored off-chain).
     * @param _aiConfidenceScore A score from the AI indicating its confidence in the analysis (e.g., 0-1000).
     * @param _suggestedEvolutionPoints Points suggested by AI for asset's evolution.
     */
    function submitAIAnalysisResult(
        uint256 _requestId,
        uint256 _tokenId,
        bytes32 _resultHash,
        uint256 _aiConfidenceScore,
        uint256 _suggestedEvolutionPoints
    ) external onlyOracle {
        AIAnalysisRequest storage request = aiAnalysisRequests[_requestId];
        require(request.tokenId == _tokenId, "CAP: Request ID does not match tokenId");
        require(!request.fulfilled, "CAP: AI analysis request already fulfilled");
        require(_exists(_tokenId), "CAP: Target asset does not exist");
        require(!cognitiveAssets[_tokenId].isSuspended, "CAP: Asset is suspended");

        request.fulfilled = true;

        // Update asset's quality score and evolution points based on AI analysis
        // This is a simplified example; real-world logic could be more complex.
        cognitiveAssets[_tokenId].qualityScore = (_aiConfidenceScore + cognitiveAssets[_tokenId].qualityScore) / 2;
        cognitiveAssets[_tokenId].evolutionPoints += _suggestedEvolutionPoints;

        emit AIAnalysisResultSubmitted(_requestId, _tokenId, _resultHash, _aiConfidenceScore, _suggestedEvolutionPoints);
    }

    // The following functions are standard ERC721 overrides and do not count towards the 20+ functions.
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
        internal
        override(ERC721)
    {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        // Additional checks can be added here if needed before any transfer
    }

    function _approve(address to, uint256 tokenId) internal override(ERC721) {
        require(!cognitiveAssets[tokenId].isSuspended, "CAP: Cannot approve suspended asset");
        super._approve(to, tokenId);
    }

    function _setApprovalForAll(address owner, address operator, bool approved) internal override(ERC721) {
        // No specific suspension check here as it applies to all tokens, individual transfers will check
        super._setApprovalForAll(owner, operator, approved);
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return cognitiveAssets[tokenId].uri;
    }
}
```