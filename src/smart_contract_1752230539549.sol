Okay, let's create a complex, feature-rich smart contract for an "Evolving Digital Companion" (EDC). This contract will combine elements of NFTs, gaming mechanics (XP, Levels, Energy), modular functionality, internal staking/yield simulation, reputation, and challenges. It aims for interactivity and dynamic state changes.

This contract avoids being a simple clone of ERC-20/721/1155 or a standard DeFi protocol by implementing unique state variables per token and custom logic for interaction and progression.

**Outline:**

1.  **Contract Introduction:** SPDX License, Pragma, Imports, Contract Definition.
2.  **State Variables:** Define all necessary mappings, structs, and constants to manage token state (XP, Level, Energy, Modules, Staking, Reputation, Challenges), module types, and admin settings.
3.  **Events:** Define events for key state changes (Mint, LevelUp, ModuleUnlocked, EnergySynced, Staked, Claimed, ChallengeCreated, ChallengeProgress, ChallengeCompleted, ReputationGained).
4.  **Structs:** Define structs for complex data types like `ModuleDetails` and `Challenge`.
5.  **Modifiers:** Define custom modifiers (e.g., `whenModuleAvailable`, `whenModuleUnlocked`, `whenCompanionExists`).
6.  **Internal Helpers:** Private/internal functions for core logic like calculating energy, adding XP, checking level-ups, consuming energy, syncing state.
7.  **Core ERC-721 Functions:** Implement or override necessary ERC-721 functions (`tokenURI`).
8.  **Companion Management:** Functions for minting and potentially burning companions.
9.  **State Retrieval (View Functions):** Functions to check XP, Level, Energy, Modules, Staking, Reputation, Challenge status of a companion.
10. **Module Management (Admin & User):** Functions for admin to define modules and for users to unlock/upgrade modules.
11. **Module Usage:** Specific functions representing actions a user can perform using unlocked modules (e.g., staking, claiming, attempting challenges, social actions).
12. **Challenge System:** Functions for admin to create challenges and for users to participate and complete them.
13. **Admin Functions:** Functions restricted to the owner for configuring parameters, granting boosts, pausing features, etc.

**Function Summary (Approx. 30+ custom & inherited functions):**

*   `constructor`: Initializes the contract, sets base parameters and admin.
*   `mintCompanion(address _to)`: Mints a new Evolving Digital Companion NFT to an address, initializes its state.
*   `burnCompanion(uint256 _tokenId)`: Allows the owner of a token to burn it.
*   `getTokenXP(uint256 _tokenId)`: Returns the current experience points of a companion.
*   `getTokenLevel(uint256 _tokenId)`: Returns the current level of a companion based on XP.
*   `getTokenEnergy(uint256 _tokenId)`: Calculates and returns the current energy of a companion, potentially syncing state.
*   `getTokenModules(uint256 _tokenId)`: Returns the list of module IDs unlocked for a companion.
*   `getTokenReputation(uint256 _tokenId)`: Returns the reputation score of a companion.
*   `getTokenStakedAmount(uint256 _tokenId, address _tokenAddress)`: Returns the amount of a specific ERC20 token staked within the companion.
*   `getAvailableModules()`: Returns the list of all defined module types that can be unlocked.
*   `getModuleDetails(bytes32 _moduleId)`: Returns the configuration details (level req, costs, gains) for a specific module type.
*   `getCurrentChallenge()`: Returns the details of the current active challenge.
*   `getCompanionChallengeProgress(uint256 _tokenId)`: Returns the progress a companion has made on the current challenge.
*   `unlockModule(uint256 _tokenId, bytes32 _moduleId)`: Allows the owner of a companion to unlock a module if requirements (level, energy) are met.
*   `useModule_Staking(uint256 _tokenId, address _tokenAddress, uint256 _amount)`: Uses energy to stake a specified ERC20 token amount *within* the companion's internal state. Requires a specific staking module to be unlocked.
*   `withdrawStaked(uint256 _tokenId, address _tokenAddress, uint256 _amount)`: Allows withdrawing staked tokens from the companion.
*   `useModule_ClaimYield(uint256 _tokenId, address _tokenAddress)`: Uses energy to claim simulated yield generated by tokens staked within the companion. Requires a specific yield module.
*   `useModule_SubmitChallengeProgress(uint256 _tokenId, uint256 _progressAmount)`: Uses energy and submits progress towards the current global challenge for a companion. Requires a specific challenge module.
*   `useModule_ReputationBoost(uint256 _tokenId)`: Uses energy to gain a small amount of reputation for the companion. Requires a specific reputation module.
*   `completeChallenge(uint256 _tokenId)`: Checks if a companion has met the challenge target and, if so, completes the challenge for that token, awarding XP and reputation.
*   `tokenURI(uint256 _tokenId)`: Overrides ERC-721 to provide a dynamic URI based on the companion's current state (XP, Level, Modules, Reputation).
*   `addModuleType(bytes32 _moduleId, uint256 _levelRequired, uint256 _energyCost, uint256 _xpGainOnUse)`: Admin function to define a new type of module with its properties.
*   `setModuleDetails(bytes32 _moduleId, uint256 _levelRequired, uint256 _energyCost, uint256 _xpGainOnUse)`: Admin function to update the properties of an existing module type.
*   `removeModuleType(bytes32 _moduleId)`: Admin function to remove a module type.
*   `setEnergyRecoveryRate(uint256 _rate)`: Admin function to set the energy recovery rate per second.
*   `setXPRequiredForLevel(uint256 _level, uint256 _xpRequired)`: Admin function to set the XP required for a specific level.
*   `createChallenge(bytes32 _challengeId, uint256 _targetProgress, uint256 _xpReward, uint256 _reputationReward)`: Admin function to initiate a new global challenge.
*   `grantXP(uint256 _tokenId, uint256 _amount)`: Admin function to manually grant XP to a companion (e.g., for events).
*   `grantReputation(uint256 _tokenId, uint256 _amount)`: Admin function to manually grant reputation to a companion.
*   `pauseModuleUse(bytes32 _moduleId)`: Admin function to temporarily pause the usage of a specific module type.
*   `unpauseModuleUse(bytes32 _moduleId)`: Admin function to unpause a module type.
*   `getPausedModules()`: View function to list currently paused modules.
*   *Inherited from ERC721Enumerable/Ownable:* `transferFrom`, `safeTransferFrom`, `approve`, `setApprovalForAll`, `getApproved`, `isApprovedForAll`, `balanceOf`, `ownerOf`, `totalSupply`. (Adds ~9+ functions)

This structure provides a robust framework for an interactive NFT with evolving characteristics and gameplay-like loops.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title EvolvingDigitalCompanion
/// @dev A sophisticated NFT contract where tokens evolve through user interaction, gaining XP, leveling up,
///      unlocking modular abilities, managing internal state (like staked tokens), and participating in challenges.
///      Combines aspects of collectibles, gaming mechanics, reputation systems, and micro-DeFi within the NFT.
contract EvolvingDigitalCompanion is ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;

    Counters.Counter private _tokenIdCounter;

    // --- State Variables ---

    // --- Token Specific State ---
    mapping(uint256 => uint256) private _tokenXP; // XP per token
    mapping(uint256 => uint256) private _tokenLastEnergySync; // Timestamp of last energy sync
    mapping(uint256 => uint256) private _tokenReputation; // Reputation score per token
    mapping(uint256 => bytes32[]) private _tokenUnlockedModules; // List of module IDs unlocked for a token
    mapping(uint256 => mapping(address => uint256)) private _tokenStakedAmounts; // ERC20 address => amount staked within the token
    mapping(uint256 => uint256) private _tokenChallengeProgress; // Progress on current challenge

    // --- Global Configuration ---
    uint256 public energyRecoveryRatePerSecond; // How much energy is recovered per second
    uint256 public maxEnergy; // Maximum energy a companion can have
    mapping(uint256 => uint256) public xpRequiredForLevel; // Level => XP needed to reach that level
    string private _baseTokenURI; // Base URI for dynamic metadata

    // --- Module Configuration ---
    struct ModuleDetails {
        uint256 levelRequired;      // Minimum level to unlock this module
        uint256 energyCost;         // Energy consumed when using this module
        uint256 xpGainOnUse;        // XP gained when using this module
        bool exists;                // Flag to check if module ID is defined
    }
    mapping(bytes32 => ModuleDetails) private _moduleDetails; // Module ID => Details
    bytes32[] private _availableModules; // List of module IDs that can be unlocked

    // --- Challenge Configuration ---
    struct Challenge {
        bytes32 challengeId;      // Unique ID for the challenge
        uint256 targetProgress;   // Total progress required to complete
        uint256 xpReward;         // XP awarded upon completion
        uint256 reputationReward; // Reputation awarded upon completion
        bool active;              // Is this challenge currently active
    }
    Challenge public currentChallenge; // The currently active global challenge

    // --- Pause/Security ---
    mapping(bytes32 => bool) private _pausedModules; // Module ID => is paused

    // --- Events ---
    event CompanionMinted(uint256 indexed tokenId, address indexed owner);
    event CompanionBurned(uint256 indexed tokenId);
    event XPAdded(uint256 indexed tokenId, uint256 amount, uint256 newXP, uint256 newLevel);
    event LevelUp(uint256 indexed tokenId, uint256 newLevel, uint256 oldLevel);
    event EnergySynced(uint256 indexed tokenId, uint256 recoveredAmount, uint256 newEnergy);
    event ModuleTypeAdded(bytes32 indexed moduleId, uint256 levelRequired, uint256 energyCost, uint256 xpGainOnUse);
    event ModuleTypeRemoved(bytes32 indexed moduleId);
    event ModuleUnlocked(uint256 indexed tokenId, bytes32 indexed moduleId);
    event ModuleUsed(uint256 indexed tokenId, bytes32 indexed moduleId, uint256 energyConsumed, uint256 xpGained);
    event TokenStaked(uint256 indexed tokenId, address indexed tokenAddress, uint256 amount);
    event TokenWithdrawn(uint256 indexed tokenId, address indexed tokenAddress, uint256 amount);
    event YieldClaimed(uint256 indexed tokenId, address indexed tokenAddress, uint256 amount); // Simplified yield concept
    event ChallengeCreated(bytes32 indexed challengeId, uint256 targetProgress);
    event ChallengeProgressSubmitted(uint256 indexed tokenId, uint256 amount, uint256 newProgress);
    event ChallengeCompleted(uint256 indexed tokenId, bytes32 indexed challengeId, uint256 xpReward, uint256 reputationReward);
    event ReputationGained(uint256 indexed tokenId, uint256 amount, uint256 newReputation);
    event ModulePaused(bytes32 indexed moduleId);
    event ModuleUnpaused(bytes32 indexed moduleId);

    // --- Modifiers ---
    modifier whenCompanionExists(uint256 _tokenId) {
        require(_exists(_tokenId), "EDC: Token does not exist");
        _;
    }

    modifier whenModuleAvailable(bytes32 _moduleId) {
        require(_moduleDetails[_moduleId].exists, "EDC: Module type does not exist");
        _;
    }

    modifier whenModuleUnlocked(uint256 _tokenId, bytes32 _moduleId) {
        require(_isModuleUnlocked(_tokenId, _moduleId), "EDC: Module not unlocked");
        _;
    }

    modifier whenModuleNotPaused(bytes32 _moduleId) {
        require(!_pausedModules[_moduleId], "EDC: Module is paused");
        _;
    }

    // --- Constructor ---
    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) Ownable(msg.sender) {
        // Set initial parameters (example values)
        energyRecoveryRatePerSecond = 1; // 1 energy per second
        maxEnergy = 86400; // Max energy (e.g., 24 hours worth)

        // Example XP requirements for initial levels
        xpRequiredForLevel[1] = 0; // Level 1 starts at 0 XP
        xpRequiredForLevel[2] = 100;
        xpRequiredForLevel[3] = 300;
        xpRequiredForLevel[4] = 600;
        xpRequiredForLevel[5] = 1000;
        // ... Add more levels as needed
    }

    // --- Internal Helpers ---

    /// @dev Calculates and syncs energy for a token based on time elapsed.
    /// @param _tokenId The ID of the companion token.
    function _syncEnergy(uint256 _tokenId) internal {
        uint256 currentEnergy = _getTokenEnergyInternal(_tokenId); // Get current stored energy
        uint256 lastSyncTime = _tokenLastEnergySync[_tokenId];
        uint256 currentTime = block.timestamp;

        if (currentTime > lastSyncTime) {
            uint256 timeElapsed = currentTime - lastSyncTime;
            uint256 energyGained = timeElapsed * energyRecoveryRatePerSecond;
            uint256 newEnergy = currentEnergy + energyGained;
            if (newEnergy > maxEnergy) {
                newEnergy = maxEnergy;
            }
            _setTokenEnergyInternal(_tokenId, newEnergy);
            _tokenLastEnergySync[_tokenId] = currentTime;
            emit EnergySynced(_tokenId, newEnergy - currentEnergy, newEnergy);
        }
    }

    /// @dev Internal function to get energy without syncing time (use _syncEnergy before calling this for real-time value).
    function _getTokenEnergyInternal(uint256 _tokenId) internal view returns (uint256) {
        // Energy is not stored directly, but derived. Let's assume maxEnergy is the base, and actions subtract from it.
        // A simpler model: store current energy and last sync time.
        // Re-evaluating: storing *current* energy and *last sync time* is best. Energy recovers over time.
        // The `_tokenLastEnergySync` timestamp is updated in `_syncEnergy` and whenever energy is consumed.
        // Let's store the *current energy value* and the *last sync time*.
        // To avoid another mapping, let's derive it from the last sync time and current time, assuming maxEnergy initially.
        // Even simpler: Store *energy lost* or *energy spent*. Recovered energy brings it towards 0 (full).
        // Okay, let's store `_tokenCurrentEnergy` mapping and `_tokenLastEnergySync`.

        // Correction: The requested `_getTokenEnergy` is a view function. It *cannot* modify state (_syncEnergy).
        // Need to calculate energy *recoverable* since last sync, but not actually update state here.
        // State-changing functions that depend on energy will need to call _syncEnergy first.

        uint256 lastSyncTime = _tokenLastEnergySync[_tokenId];
        uint256 currentTime = block.timestamp;
        uint256 storedEnergy = _tokenStakedAmounts[_tokenId][address(0)]; // Use a placeholder to store energy state? No, need a separate mapping.

        // Let's add a dedicated energy mapping
        mapping(uint256 => uint256) private _tokenCurrentEnergy;

        uint256 currentEnergy = _tokenCurrentEnergy[_tokenId];
        uint256 timeElapsed = currentTime - lastSyncTime;
        uint256 energyGained = timeElapsed * energyRecoveryRatePerSecond;
        uint256 syncedEnergy = currentEnergy + energyGained;
        return syncedEnergy > maxEnergy ? maxEnergy : syncedEnergy;
    }

    /// @dev Internal function to set the current energy value. Should be called after calculating recovered energy.
    function _setTokenEnergyInternal(uint256 _tokenId, uint256 _amount) internal {
        _tokenCurrentEnergy[_tokenId] = _amount;
        _tokenLastEnergySync[_tokenId] = block.timestamp; // Update sync time whenever energy is set
    }


    /// @dev Deducts energy from a token, syncing first and updating last sync time.
    function _consumeEnergy(uint256 _tokenId, uint256 _amount) internal {
        _syncEnergy(_tokenId); // Sync energy before consuming
        uint256 currentEnergy = _tokenCurrentEnergy[_tokenId];
        require(currentEnergy >= _amount, "EDC: Not enough energy");
        _setTokenEnergyInternal(_tokenId, currentEnergy - _amount); // Update energy and last sync time
    }

    /// @dev Adds XP to a token and checks for level-up.
    function _addXP(uint256 _tokenId, uint256 _amount) internal {
        uint256 oldXP = _tokenXP[_tokenId];
        uint256 newXP = oldXP + _amount;
        _tokenXP[_tokenId] = newXP;

        uint256 oldLevel = _getLevelFromXP(oldXP);
        uint256 newLevel = _getLevelFromXP(newXP);

        emit XPAdded(_tokenId, _amount, newXP, newLevel);

        if (newLevel > oldLevel) {
            emit LevelUp(_tokenId, newLevel, oldLevel);
            // Optionally trigger automatic module unlocks or other level-up effects here
        }
    }

    /// @dev Calculates the level based on XP.
    function _getLevelFromXP(uint256 _xp) internal view returns (uint256) {
        uint256 level = 1;
        // Iterate through defined levels to find the highest level reached
        // This assumes xpRequiredForLevel mapping is populated for levels 1..N
        // A more efficient approach for many levels might use a formula or sorted array
        uint256 currentLevelXP = 0;
        while(xpRequiredForLevel[level + 1] > 0 && _xp >= xpRequiredForLevel[level + 1]) {
            level++;
            currentLevelXP = xpRequiredForLevel[level]; // Keep track of XP needed for the *current* level
        }
         if (_xp < currentLevelXP) return level; // Should not happen if logic is correct, but safety check


        // Find highest level below or equal to current XP
        uint256 currentMaxLevel = 1;
        for (uint i = 2; xpRequiredForLevel[i] > 0; i++) {
            if (_xp >= xpRequiredForLevel[i]) {
                currentMaxLevel = i;
            } else {
                break; // Levels are assumed to be sequential and increasing XP
            }
        }
        return currentMaxLevel;
    }

    /// @dev Checks if a module is unlocked for a token.
    function _isModuleUnlocked(uint256 _tokenId, bytes32 _moduleId) internal view returns (bool) {
        bytes32[] storage unlockedModules = _tokenUnlockedModules[_tokenId];
        for (uint i = 0; i < unlockedModules.length; i++) {
            if (unlockedModules[i] == _moduleId) {
                return true;
            }
        }
        return false;
    }

    /// @dev Helper to add reputation.
    function _addReputation(uint256 _tokenId, uint256 _amount) internal {
        uint256 newReputation = _tokenReputation[_tokenId] + _amount;
        _tokenReputation[_tokenId] = newReputation;
        emit ReputationGained(_tokenId, _amount, newReputation);
    }

    // --- Core ERC-721 Overrides ---

    /// @dev Returns the URI for a token. This is dynamic based on token state.
    ///      Assumes a base URI is set pointing to a service that can generate JSON metadata
    ///      given the token ID.
    function tokenURI(uint256 _tokenId) override public view returns (string memory) {
        require(_exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory base = _baseTokenURI;
        if (bytes(base).length == 0) {
            return ""; // Or revert, depending on desired behavior
        }
        // Append token ID to base URI
        return string(abi.encodePacked(base, Strings.toString(_tokenId)));
    }

    // --- Companion Management ---

    /// @dev Mints a new companion token. OwnerOnly.
    /// @param _to The address to mint the token to.
    /// @return The ID of the newly minted token.
    function mintCompanion(address _to) public onlyOwner returns (uint256) {
        _tokenIdCounter.increment();
        uint256 newTokenId = _tokenIdCounter.current();
        _safeMint(_to, newTokenId);

        // Initialize token state
        _tokenXP[newTokenId] = 0;
        _tokenCurrentEnergy[newTokenId] = maxEnergy; // Start with full energy
        _tokenLastEnergySync[newTokenId] = block.timestamp;
        _tokenReputation[newTokenId] = 0;
        // _tokenUnlockedModules will be an empty array by default
        // _tokenStakedAmounts will be empty mappings by default
        _tokenChallengeProgress[newTokenId] = 0;

        emit CompanionMinted(newTokenId, _to);
        return newTokenId;
    }

    /// @dev Allows the token owner to burn their companion.
    /// @param _tokenId The ID of the companion to burn.
    function burnCompanion(uint256 _tokenId) public whenCompanionExists(_tokenId) {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");

        // Clear token state before burning (gas optimization/cleanliness)
        delete _tokenXP[_tokenId];
        delete _tokenCurrentEnergy[_tokenId];
        delete _tokenLastEnergySync[_tokenId];
        delete _tokenReputation[_tokenId];
        delete _tokenUnlockedModules[_tokenId];
        // Note: Staked tokens would ideally be withdrawn *before* burning.
        // Or, implement a mechanism to reclaim them after burning.
        // For simplicity here, staked tokens become inaccessible unless a specific burn-and-redeem system is added.
        delete _tokenChallengeProgress[_tokenId];

        _burn(_tokenId);
        emit CompanionBurned(_tokenId);
    }


    // --- State Retrieval (View Functions) ---

    /// @dev Returns the current XP of a companion.
    function getTokenXP(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (uint256) {
        return _tokenXP[_tokenId];
    }

    /// @dev Returns the current level of a companion.
    function getTokenLevel(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (uint256) {
        return _getLevelFromXP(_tokenXP[_tokenId]);
    }

    /// @dev Calculates and returns the current energy of a companion (does not sync state).
    function getTokenEnergy(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (uint256) {
         uint256 currentEnergy = _tokenCurrentEnergy[_tokenId];
         uint256 lastSyncTime = _tokenLastEnergySync[_tokenId];
         uint256 currentTime = block.timestamp;
         uint256 timeElapsed = currentTime - lastSyncTime;
         uint256 energyGained = timeElapsed * energyRecoveryRatePerSecond;
         uint256 syncedEnergy = currentEnergy + energyGained;
         return syncedEnergy > maxEnergy ? maxEnergy : syncedEnergy;
    }

    /// @dev Returns the list of module IDs unlocked for a companion.
    function getTokenModules(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (bytes32[] memory) {
        return _tokenUnlockedModules[_tokenId];
    }

    /// @dev Returns the current reputation score of a companion.
    function getTokenReputation(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (uint256) {
        return _tokenReputation[_tokenId];
    }

    /// @dev Returns the amount of a specific ERC20 token staked within a companion.
    function getTokenStakedAmount(uint256 _tokenId, address _tokenAddress) public view whenCompanionExists(_tokenId) returns (uint256) {
        return _tokenStakedAmounts[_tokenId][_tokenAddress];
    }

    /// @dev Returns the list of all defined module types that can potentially be unlocked.
    function getAvailableModules() public view returns (bytes32[] memory) {
        return _availableModules;
    }

    /// @dev Returns the configuration details for a specific module type.
    function getModuleDetails(bytes32 _moduleId) public view whenModuleAvailable(_moduleId) returns (ModuleDetails memory) {
        return _moduleDetails[_moduleId];
    }

    /// @dev Returns the details of the currently active challenge.
    function getCurrentChallenge() public view returns (Challenge memory) {
        return currentChallenge;
    }

    /// @dev Returns the progress a specific companion has made on the current challenge.
    function getCompanionChallengeProgress(uint256 _tokenId) public view whenCompanionExists(_tokenId) returns (uint256) {
        return _tokenChallengeProgress[_tokenId];
    }


    // --- Module Management (Admin & User) ---

    /// @dev Admin: Defines a new module type that can be unlocked.
    /// @param _moduleId A unique identifier for the module (e.g., keccak256("staking_module")).
    /// @param _levelRequired The level needed to unlock.
    /// @param _energyCost The energy cost to use the module.
    /// @param _xpGainOnUse The XP gained when using the module.
    function addModuleType(bytes32 _moduleId, uint256 _levelRequired, uint256 _energyCost, uint256 _xpGainOnUse) public onlyOwner {
        require(!_moduleDetails[_moduleId].exists, "EDC: Module ID already exists");
        _moduleDetails[_moduleId] = ModuleDetails(_levelRequired, _energyCost, _xpGainOnUse, true);
        _availableModules.push(_moduleId); // Add to list of available modules
        emit ModuleTypeAdded(_moduleId, _levelRequired, _energyCost, _xpGainOnUse);
    }

    /// @dev Admin: Updates the details of an existing module type.
    function setModuleDetails(bytes32 _moduleId, uint256 _levelRequired, uint256 _energyCost, uint256 _xpGainOnUse) public onlyOwner whenModuleAvailable(_moduleId) {
        _moduleDetails[_moduleId] = ModuleDetails(_levelRequired, _energyCost, _xpGainOnUse, true);
         emit ModuleTypeAdded(_moduleId, _levelRequired, _energyCost, _xpGainOnUse); // Use the same event to signal update
    }

    /// @dev Admin: Removes a module type. Existing unlocked modules on tokens are unaffected but cannot be used.
    function removeModuleType(bytes32 _moduleId) public onlyOwner whenModuleAvailable(_moduleId) {
        // Cannot simply remove from _availableModules array efficiently. Mark as inactive instead.
        _moduleDetails[_moduleId].exists = false;
        // Optional: Could loop through _availableModules to remove, but expensive. Keeping it there is fine if 'exists' check is used.
        emit ModuleTypeRemoved(_moduleId);
    }

    /// @dev Allows a companion's owner to unlock a specific module.
    /// @param _tokenId The ID of the companion.
    /// @param _moduleId The ID of the module to unlock.
    function unlockModule(uint256 _tokenId, bytes32 _moduleId) public whenCompanionExists(_tokenId) whenModuleAvailable(_moduleId) {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");
        require(!_isModuleUnlocked(_tokenId, _moduleId), "EDC: Module already unlocked");

        ModuleDetails storage details = _moduleDetails[_moduleId];
        require(getTokenLevel(_tokenId) >= details.levelRequired, "EDC: Level requirement not met");

        // Energy cost to unlock? Or just level? Let's say just level for simplicity.
        // If energy cost were needed: _consumeEnergy(_tokenId, details.unlockEnergyCost);

        _tokenUnlockedModules[_tokenId].push(_moduleId);
        emit ModuleUnlocked(_tokenId, _moduleId);
    }

     /// @dev Admin: Temporarily pauses usage of a specific module type.
    function pauseModuleUse(bytes32 _moduleId) public onlyOwner whenModuleAvailable(_moduleId) {
        require(!_pausedModules[_moduleId], "EDC: Module is already paused");
        _pausedModules[_moduleId] = true;
        emit ModulePaused(_moduleId);
    }

    /// @dev Admin: Unpauses usage of a specific module type.
    function unpauseModuleUse(bytes32 _moduleId) public onlyOwner whenModuleAvailable(_moduleId) {
        require(_pausedModules[_moduleId], "EDC: Module is not paused");
        _pausedModules[_moduleId] = false;
        emit ModuleUnpaused(_moduleId);
    }

    /// @dev Returns a list of module IDs that are currently paused.
    function getPausedModules() public view returns (bytes32[] memory) {
        uint256 count = 0;
        // Count paused modules
        for (uint i = 0; i < _availableModules.length; i++) {
             bytes32 moduleId = _availableModules[i];
             // Check if the module type still exists and is paused
             if (_moduleDetails[moduleId].exists && _pausedModules[moduleId]) {
                count++;
             }
        }

        bytes32[] memory pausedList = new bytes32[](count);
        uint256 currentIndex = 0;
         for (uint i = 0; i < _availableModules.length; i++) {
             bytes32 moduleId = _availableModules[i];
              if (_moduleDetails[moduleId].exists && _pausedModules[moduleId]) {
                pausedList[currentIndex] = moduleId;
                currentIndex++;
             }
        }
        return pausedList;
    }


    // --- Module Usage ---
    // These functions represent specific actions enabled by modules.
    // Each requires: companion ownership, module unlocked, sufficient energy, module not paused.

    /// @dev Uses the 'staking' module to stake ERC20 tokens within the companion.
    ///      Module ID example: keccak256("staking_module")
    /// @param _tokenId The ID of the companion.
    /// @param _tokenAddress The address of the ERC20 token to stake.
    /// @param _amount The amount of ERC20 tokens to stake.
    function useModule_Staking(uint256 _tokenId, address _tokenAddress, uint256 _amount) public whenCompanionExists(_tokenId) {
        bytes32 stakingModuleId = keccak256("staking_module"); // Example Module ID
        whenModuleAvailable(stakingModuleId); // Check if module type exists
        whenModuleUnlocked(_tokenId, stakingModuleId); // Check if unlocked for token
        whenModuleNotPaused(stakingModuleId); // Check if module is paused

        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");
        require(_amount > 0, "EDC: Amount must be greater than 0");

        ModuleDetails storage details = _moduleDetails[stakingModuleId];
        _consumeEnergy(_tokenId, details.energyCost); // Consume energy

        // Transfer tokens from user to contract
        IERC20 erc20Token = IERC20(_tokenAddress);
        erc20Token.safeTransferFrom(msg.sender, address(this), _amount);

        // Record staked amount within the companion's state
        _tokenStakedAmounts[_tokenId][_tokenAddress] += _amount;

        _addXP(_tokenId, details.xpGainOnUse); // Add XP for using the module
        emit ModuleUsed(_tokenId, stakingModuleId, details.energyCost, details.xpGainOnUse);
        emit TokenStaked(_tokenId, _tokenAddress, _amount);
    }

    /// @dev Allows withdrawing staked tokens from the companion. Does NOT require energy or module use (withdrawal is a basic right).
    /// @param _tokenId The ID of the companion.
    /// @param _tokenAddress The address of the ERC20 token to withdraw.
    /// @param _amount The amount of ERC20 tokens to withdraw.
    function withdrawStaked(uint256 _tokenId, address _tokenAddress, uint256 _amount) public whenCompanionExists(_tokenId) {
        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");
        require(_amount > 0, "EDC: Amount must be greater than 0");
        require(_tokenStakedAmounts[_tokenId][_tokenAddress] >= _amount, "EDC: Not enough staked tokens");

        // Update staked amount within the companion's state
        _tokenStakedAmounts[_tokenId][_tokenAddress] -= _amount;

        // Transfer tokens from contract back to user
        IERC20 erc20Token = IERC20(_tokenAddress);
        erc20Token.safeTransfer(msg.sender, _amount);

        emit TokenWithdrawn(_tokenId, _tokenAddress, _amount);
    }

    /// @dev Uses the 'claim_yield' module to claim simulated yield from staked tokens.
    ///      Module ID example: keccak256("claim_yield_module")
    ///      NOTE: Yield simulation logic is highly simplified here (e.g., based on staked amount and time).
    ///            A real-world contract would need a more robust mechanism (oracle, external protocol interaction).
    /// @param _tokenId The ID of the companion.
    /// @param _tokenAddress The address of the ERC20 token to claim yield for.
    function useModule_ClaimYield(uint256 _tokenId, address _tokenAddress) public whenCompanionExists(_tokenId) {
        bytes32 claimYieldModuleId = keccak256("claim_yield_module"); // Example Module ID
        whenModuleAvailable(claimYieldModuleId);
        whenModuleUnlocked(_tokenId, claimYieldModuleId);
        whenModuleNotPaused(claimYieldModuleId);

        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");

        ModuleDetails storage details = _moduleDetails[claimYieldModuleId];
        _consumeEnergy(_tokenId, details.energyCost);

        _addXP(_tokenId, details.xpGainOnUse);
        emit ModuleUsed(_tokenId, claimYieldModuleId, details.energyCost, details.xpGainOnUse);

        // --- SIMPLIFIED YIELD CALCULATION ---
        // This is a placeholder. A real system needs more complex yield logic.
        // Example: Simple yield based on staked amount * a global yield factor per unit of time
        uint256 staked = _tokenStakedAmounts[_tokenId][_tokenAddress];
        // uint256 yieldAmount = (staked * getYieldFactor(_tokenAddress) * timeSinceLastClaim) / 1e18; // Needs more state
        // Let's make it simpler: a fixed small percentage or based on XP/Reputation?
        // Let's just claim a tiny percentage of staked amount as yield for demonstration.
        uint256 yieldAmount = staked / 100; // Claim 1% of staked amount as yield (super basic!)
        if (yieldAmount > 0) {
             // Transfer yield tokens from contract (assuming contract has them or can mint)
             // In a real scenario, contract might earn yield elsewhere or mint specific reward tokens.
             // For THIS example, we'll assume the contract holds tokens and can transfer.
             IERC20 erc20Token = IERC20(_tokenAddress);
             erc20Token.safeTransfer(msg.sender, yieldAmount);
             emit YieldClaimed(_tokenId, _tokenAddress, yieldAmount);
        }
        // --- END SIMPLIFIED YIELD ---
    }

    /// @dev Uses the 'social_boost' module to gain a small amount of reputation.
    ///      Module ID example: keccak256("social_boost_module")
    /// @param _tokenId The ID of the companion.
    function useModule_ReputationBoost(uint256 _tokenId) public whenCompanionExists(_tokenId) {
        bytes32 reputationModuleId = keccak256("social_boost_module"); // Example Module ID
        whenModuleAvailable(reputationModuleId);
        whenModuleUnlocked(_tokenId, reputationModuleId);
        whenModuleNotPaused(reputationModuleId);

        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");

        ModuleDetails storage details = _moduleDetails[reputationModuleId];
        _consumeEnergy(_tokenId, details.energyCost);

        _addXP(_tokenId, details.xpGainOnUse);
        _addReputation(_tokenId, 1); // Gain a fixed small reputation amount

        emit ModuleUsed(_tokenId, reputationModuleId, details.energyCost, details.xpGainOnUse);
    }

     /// @dev Uses the 'challenge_attempt' module to submit progress towards the current challenge.
    ///      Module ID example: keccak256("challenge_attempt_module")
    /// @param _tokenId The ID of the companion.
    /// @param _progressAmount The amount of progress to submit.
    function useModule_SubmitChallengeProgress(uint256 _tokenId, uint256 _progressAmount) public whenCompanionExists(_tokenId) {
        bytes32 challengeModuleId = keccak256("challenge_attempt_module"); // Example Module ID
        whenModuleAvailable(challengeModuleId);
        whenModuleUnlocked(_tokenId, challengeModuleId);
        whenModuleNotPaused(challengeModuleId);

        require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");
        require(currentChallenge.active, "EDC: No active challenge");
        require(_progressAmount > 0, "EDC: Progress amount must be greater than 0");

        ModuleDetails storage details = _moduleDetails[challengeModuleId];
        _consumeEnergy(_tokenId, details.energyCost);

        uint256 currentProgress = _tokenChallengeProgress[_tokenId];
        _tokenChallengeProgress[_tokenId] = currentProgress + _progressAmount;

        _addXP(_tokenId, details.xpGainOnUse);
        emit ModuleUsed(_tokenId, challengeModuleId, details.energyCost, details.xpGainOnUse);
        emit ChallengeProgressSubmitted(_tokenId, _progressAmount, _tokenChallengeProgress[_tokenId]);
    }


    // --- Challenge System ---

    /// @dev Admin: Creates a new global challenge. Deactivates the previous one.
    function createChallenge(bytes32 _challengeId, uint256 _targetProgress, uint256 _xpReward, uint256 _reputationReward) public onlyOwner {
        require(_challengeId != bytes32(0), "EDC: Challenge ID cannot be zero");
        require(_targetProgress > 0, "EDC: Challenge target must be greater than 0");

        // Deactivate previous challenge (optional, depending on desired behavior)
        if (currentChallenge.active) {
            // Logic to handle unfinished previous challenge participants? Reset progress? Leave it?
            // For simplicity, let's just reset all progress when a new challenge starts.
             // NOTE: This loop might be expensive with many tokens. Consider alternative designs.
             // A practical implementation might store tokens participating or reset progress only when a token attempts the *new* challenge.
             // For this example, we'll skip the global reset for gas reasons and assume progress auto-resets on first new submission OR is tied to a challenge ID.
             // Let's link progress to Challenge ID.
        }

        currentChallenge = Challenge({
            challengeId: _challengeId,
            targetProgress: _targetProgress,
            xpReward: _xpReward,
            reputationReward: _reputationReward,
            active: true
        });

        // Reset progress for all tokens? No, expensive. Let's use a mapping per challenge ID per token if needed, or reset implicitly.
        // A simpler approach is to use the single _tokenChallengeProgress and reset it here.
        // This means only one challenge can track progress at a time globally.
        // Let's reset progress for all tokens when a new challenge is created. This is gas heavy.
        // ALTERNATIVE: progress is tracked per token *for the current challenge ID*.
        // mapping(bytes32 => mapping(uint256 => uint256)) private _tokenChallengeProgressByChallenge;
        // This is safer but makes retrieval slightly more complex. Let's stick to the simpler single mapping for now but note the limitation/cost.

        // A better approach: When a token submits progress for the *currentChallenge.challengeId*, we use the single mapping.
        // If currentChallenge.challengeId is different from the one the token was tracking, reset its progress implicitly.

        emit ChallengeCreated(_challengeId, _targetProgress);
    }


    /// @dev Allows a companion's owner to complete the current challenge if their progress meets the target.
    /// @param _tokenId The ID of the companion.
    function completeChallenge(uint256 _tokenId) public whenCompanionExists(_tokenId) {
         require(_isApprovedOrOwner(msg.sender, _tokenId), "EDC: Caller is not owner or approved");
         require(currentChallenge.active, "EDC: No active challenge");

         // Check if companion progress meets target for the *current* challenge ID
         // We need to implicitly check if the stored progress is for the current challenge
         // How to do this with the single mapping? We can't reliably tell.
         // Let's modify the challenge progress storage slightly to include the challenge ID.
         mapping(uint256 => bytes32) private _tokenCurrentChallengeId; // Tracks which challenge the progress relates to

         // If the token's stored challenge ID doesn't match the current active challenge ID, their progress is considered 0 for the current one.
         uint256 companionProgress = (_tokenCurrentChallengeId[_tokenId] == currentChallenge.challengeId) ? _tokenChallengeProgress[_tokenId] : 0;

         require(companionProgress >= currentChallenge.targetProgress, "EDC: Challenge target not met");

         // Prevent double completion? A token can only complete a specific challenge ID once.
         // Need another mapping: mapping(bytes32 => mapping(uint256 => bool)) private _challengeCompletedByToken;
         mapping(bytes32 => mapping(uint256 => bool)) private _challengeCompletedByToken;

         require(!_challengeCompletedByToken[currentChallenge.challengeId][_tokenId], "EDC: Challenge already completed by this companion");

         // Mark as completed
         _challengeCompletedByToken[currentChallenge.challengeId][_tokenId] = true;

         // Award rewards
         _addXP(_tokenId, currentChallenge.xpReward);
         _addReputation(_tokenId, currentChallenge.reputationReward);

         // Reset progress for this token for this challenge
         delete _tokenChallengeProgress[_tokenId];
         delete _tokenCurrentChallengeId[_tokenId]; // Clear link to this challenge

         emit ChallengeCompleted(_tokenId, currentChallenge.challengeId, currentChallenge.xpReward, currentChallenge.reputationReward);

         // Optionally, deactivate the challenge globally after a certain number of completions or time
    }


    // --- Admin Functions ---

    /// @dev Admin: Sets the base URI for token metadata.
    function setBaseURI(string memory baseURI_) public onlyOwner {
        _baseTokenURI = baseURI_;
    }

    /// @dev Admin: Sets the rate at which energy recovers per second.
    function setEnergyRecoveryRate(uint256 _rate) public onlyOwner {
        energyRecoveryRatePerSecond = _rate;
    }

     /// @dev Admin: Sets the maximum energy a companion can hold.
    function setMaxEnergy(uint256 _maxEnergy) public onlyOwner {
        maxEnergy = _maxEnergy;
        // Note: Existing tokens' current energy might exceed the new max if it's lower.
        // A full implementation might iterate and cap energy, or handle it lazily on next sync.
    }

    /// @dev Admin: Sets the XP required to reach a specific level.
    /// @param _level The level number.
    /// @param _xpRequired The cumulative XP required for this level.
    function setXPRequiredForLevel(uint256 _level, uint256 _xpRequired) public onlyOwner {
        require(_level > 0, "EDC: Level must be positive");
        if (_level > 1) {
             // Ensure XP requirement is greater than the previous level
             require(_xpRequired > xpRequiredForLevel[_level - 1], "EDC: XP requirement must increase with level");
        }
        xpRequiredForLevel[_level] = _xpRequired;
    }

    /// @dev Admin: Updates details of the current challenge.
    function setChallengeDetails(uint256 _targetProgress, uint256 _xpReward, uint256 _reputationReward) public onlyOwner {
         require(currentChallenge.active, "EDC: No active challenge to update");
         require(_targetProgress > 0, "EDC: Challenge target must be greater than 0");

         currentChallenge.targetProgress = _targetProgress;
         currentChallenge.xpReward = _xpReward;
         currentChallenge.reputationReward = _reputationReward;
         // Note: Changing target mid-challenge might be unfair. Use with caution.
    }

    /// @dev Admin: Manually grants XP to a companion.
    function grantXP(uint256 _tokenId, uint256 _amount) public onlyOwner whenCompanionExists(_tokenId) {
        require(_amount > 0, "EDC: Amount must be > 0");
        _addXP(_tokenId, _amount);
    }

     /// @dev Admin: Manually grants Reputation to a companion.
    function grantReputation(uint256 _tokenId, uint256 _amount) public onlyOwner whenCompanionExists(_tokenId) {
        require(_amount > 0, "EDC: Amount must be > 0");
        _addReputation(_tokenId, _amount);
    }


    // --- Internal Implementations for inherited functions ---
    // Although inherited, sometimes need to override or ensure internal calls are handled.
    // ERC721Enumerable requires certain internal functions like _beforeTokenTransfer.
    // OpenZeppelin handles most of this, but adding relevant parts for completeness.

    /// @dev See {ERC721Enumerable-_beforeTokenTransfer}.
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize) internal override {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);

        // When transferring, sync energy state for the token being transferred
        // This ensures the new owner gets the token with up-to-date energy.
        if (_exists(tokenId)) { // Check exists in case of mint (from == address(0)) or burn (to == address(0))
             _syncEnergy(tokenId);
        }

        // Consider implications for staked tokens or challenge progress on transfer.
        // Default: Staked tokens and challenge progress transfer with the NFT.
        // Alternative: Staked tokens are auto-withdrawn to the old owner on transfer, or challenge progress resets.
        // Keeping state with NFT is simpler and often desired for game-like assets.
    }
}
```

**Explanation of Advanced/Creative Concepts:**

1.  **Evolving State per NFT:** Beyond static attributes, each NFT instance (`tokenId`) has unique, dynamic state variables that change over time and through interaction (`_tokenXP`, `_tokenCurrentEnergy`, `_tokenReputation`, `_tokenUnlockedModules`, `_tokenStakedAmounts`, `_tokenChallengeProgress`).
2.  **XP and Leveling System:** Implements a core gaming mechanic where accumulating `_tokenXP` leads to `LevelUp`, gating access to further features.
3.  **Energy System:** A time-gated resource (`_tokenCurrentEnergy`) that recovers over time (`energyRecoveryRatePerSecond`) and is consumed by actions (`_consumeEnergy`), creating a usage limit and encouraging return visits. Energy calculation involves syncing with `block.timestamp`.
4.  **Modular Functionality:** Features are encapsulated as "Modules" identified by `bytes32` IDs. Admin can define new `ModuleDetails` (`addModuleType`, `setModuleDetails`), and users must `unlockModule` based on level/other requirements. `_tokenUnlockedModules` tracks which modules are available per token.
5.  **Gated Module Usage:** Using a module requires ownership/approval, the module being unlocked, sufficient energy (`_consumeEnergy`), and the module not being paused (`whenModuleNotPaused`). Using a module also often grants XP (`_addXP`).
6.  **Internal Staking/Yield Simulation:** The contract tracks ERC20 tokens staked *within the NFT itself* (`_tokenStakedAmounts`). This is distinct from staking the NFT in a separate pool. It creates a micro-DeFi element where the NFT is a container. `useModule_Staking` and `useModule_ClaimYield` interact with this internal state (though the yield calculation here is a basic placeholder). `SafeERC20` is used for secure token interactions.
7.  **Reputation System:** Tokens have a `_tokenReputation` score, which can be gained through specific modules (`useModule_ReputationBoost`) or challenges. This adds a social/status layer.
8.  **Global Challenges:** An `Admin` can create a `currentChallenge` with targets and rewards. Tokens can submit `_tokenChallengeProgress` using a module (`useModule_SubmitChallengeProgress`) and `completeChallenge` when they meet the target, earning rewards (XP, Reputation). Progress tracking is linked to the challenge ID to handle new challenges.
9.  **Dynamic Metadata (`tokenURI`):** The token's URI is not static but points to an endpoint (`_baseTokenURI`) that should dynamically generate metadata (name, description, image, traits) based on the token's current state (Level, XP, Modules, Reputation, Staked Tokens). This makes the NFT's representation reflect its in-contract evolution.
10. **Admin Controls:** Comprehensive `onlyOwner` functions allow the administrator to configure core parameters (rates, XP requirements, module details, challenge details) and manage the system (add/remove modules, grant XP/Reputation, pause modules).
11. **State Sync on Transfer:** The `_beforeTokenTransfer` hook is used to ensure the `_tokenCurrentEnergy` state is synced immediately before a transfer, providing an up-to-date snapshot to the recipient.
12. **Pause Mechanism:** `pauseModuleUse` and `unpauseModuleUse` allow the admin to temporarily disable specific functionalities, useful for maintenance or mitigating issues without halting the entire contract.
13. **Structured State Management:** Using multiple mappings and structs to organize the complex state associated with each token ID and global configurations.
14. **Event Logging:** Comprehensive events are emitted for critical actions, allowing external services to track the evolution and interactions with companions.
15. **Modifier Usage:** Custom modifiers (`whenCompanionExists`, `whenModuleAvailable`, `whenModuleUnlocked`, `whenModuleNotPaused`) improve readability and enforce common checks.

This contract provides a foundation for a rich, interactive digital asset that evolves and gains utility over time, moving beyond the typical static NFT use case. Remember that a production implementation might require further considerations for gas costs (especially in loops like `getPausedModules` or if challenge reset was global), robust yield calculation, and potentially off-chain components (like the metadata service).