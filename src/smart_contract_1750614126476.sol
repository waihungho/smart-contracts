Okay, let's design a smart contract called `CreativeGeniusVault`. This contract will act as a decentralized platform for submitting, evaluating, funding, and even *evolving* creative ideas. It incorporates concepts like structured data storage on-chain, a decentralized evaluation process, a funding mechanism, a basic reputation system, and a novel concept: oracle-assisted 'idea mutation' requests to help generate variations or synergies.

We will aim for 20+ functions covering these areas.

---

**Smart Contract Outline & Function Summary**

**Contract Name:** `CreativeGeniusVault`

**Purpose:** A decentralized vault and platform for managing the lifecycle of creative ideas, from submission and evaluation to funding and potential 'mutation' via external data/oracles.

**Core Concepts:**
1.  **Idea Management:** Storing structured data representing creative ideas.
2.  **Decentralized Evaluation:** A system for designated evaluators to review and vote on ideas.
3.  **Funding Vault:** A mechanism to collect funds and allocate them to approved ideas.
4.  **Karma System:** A simple on-chain reputation for participants.
5.  **Idea Mutation (Oracle-assisted):** A novel feature allowing users to request variations or synergies of ideas, potentially triggered by external data or generative AI via oracles.
6.  **Staking for Priority:** Users can stake funds to prioritize idea evaluation.

**Function Categories:**

1.  **Admin & Setup:** Functions for owner to configure basic contract settings.
    *   `constructor`: Initializes the contract owner.
    *   `transferOwnership`: Transfers ownership to a new address.
    *   `renounceOwnership`: Renounces ownership (makes contract non-administrable).
    *   `pauseContract`: Pauses core functionality in emergencies.
    *   `unpauseContract`: Unpauses the contract.
    *   `addEvaluatorRole`: Grants evaluator permission.
    *   `removeEvaluatorRole`: Revokes evaluator permission.
    *   `setTrustedOracleAddress`: Sets the address allowed to submit mutation results.

2.  **Idea Submission & Management:** Functions for users to interact with their ideas.
    *   `submitIdea`: Creates a new idea entry in Draft status.
    *   `editIdeaDraft`: Allows the author to modify their idea while in Draft.
    *   `moveToEvaluation`: Submits a Draft idea for decentralized evaluation.
    *   `linkExternalDataToIdea`: Adds a hash reference (e.g., IPFS) to an idea.
    *   `stakeForEvaluationPriority`: Stakes ETH to increase idea's evaluation priority.
    *   `claimStakedFunds`: Allows author to claim staked ETH under certain conditions.
    *   `updateIdeaProgress`: Allows author (or delegate) to update progress of a funded idea.
    *   `signalIdeaCompletion`: Author marks a funded idea as potentially complete.

3.  **Evaluation Process:** Functions for evaluators and managing the process.
    *   `castEvaluationVote`: Evaluator submits a vote (Approve, Reject, NeedsRevision) and optionally a review hash.
    *   `finalizeEvaluationRound`: Tallies votes for an idea after its evaluation period, updates status, and awards karma.
    *   `verifyIdeaCompletion`: Evaluator/Admin verifies a signaled completion.

4.  **Funding & Vault:** Functions related to contributing and allocating funds.
    *   `depositFunds`: Users deposit funds into the general vault for sponsoring ideas.
    *   `allocateFundingToIdea`: Owner allocates funds from the vault to a specific Approved idea.
    *   `recordRevenueForIdea`: Owner records external revenue generated by a funded idea.
    *   `distributeIdeaRevenue`: Owner triggers distribution of recorded revenue based on contract rules (e.g., author, evaluators, stakers).
    *   `withdrawTreasuryFunds`: Owner withdraws general treasury funds from the vault.

5.  **Advanced & Creative Features:** Novel or complex functions.
    *   `proposeIdeaSynergy`: User suggests two existing ideas could be combined or are related. (Purely symbolic/karma based in this version).
    *   `requestIdeaMutation`: Initiates a request for an oracle to generate a variation or synergy based on an idea. Awards karma to requestor.
    *   `submitMutationResult`: Callable ONLY by the trusted oracle address to deliver a mutation result (e.g., a new idea hash/ID). Awards karma to oracle.

6.  **View & Utility Functions:** Functions to retrieve information.
    *   `getIdeaDetails`: Retrieves the full struct data for an idea.
    *   `getIdeasByAuthor`: Lists idea IDs submitted by an address.
    *   `getIdeasByStatus`: Lists idea IDs currently in a specific status.
    *   `getTotalIdeas`: Returns the total number of ideas submitted.
    *   `getVaultBalance`: Returns the current balance of the funding vault.
    *   `getKarmaScore`: Returns the karma score for an address.
    *   `getIdeaEvaluationResults`: Retrieves vote counts for an idea under evaluation.
    *   `getIdeaLinkedData`: Retrieves linked external data hashes for an idea.
    *   `getIdeaMutationRequests`: Retrieves mutation request details for an idea.
    *   `isEvaluator`: Checks if an address has the evaluator role.

**Total Functions:** 30 (This significantly exceeds the 20 function requirement and covers diverse functionalities).

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// ----------------------------------------------------------------------------
// CreativeGeniusVault Smart Contract
//
// Purpose: A decentralized platform for managing creative ideas. Users can
// submit, edit, and submit ideas for evaluation. Designated evaluators
// review and vote. Approved ideas can be funded from a community vault.
// Includes a karma system, staking for evaluation priority, and a novel
// oracle-assisted feature to request 'mutations' or variations of ideas.
//
// Features:
// - Idea Lifecycle Management (Draft, Submitted, Evaluating, Approved, Rejected, Funded, InProgress, PendingCompletion, Completed)
// - Decentralized Evaluation with Voting
// - Funding Vault and Allocation
// - Basic On-Chain Karma System
// - Staking for Evaluation Priority
// - Oracle-Assisted Idea Mutation Requests & Results (Conceptual)
// - Access Control (Owner, Evaluator, Trusted Oracle)
// - Pausable Emergency Mechanism
// - Link External Data (IPFS hashes, etc.)
//
// Outline:
// - Errors
// - Events
// - Enums (Idea Status, Evaluation Outcome, Progress Status)
// - Structs (Idea, EvaluationVote, MutationRequest)
// - State Variables (Mappings for ideas, users, roles, counters, vault)
// - Modifiers (Owner, Evaluator, Oracle, Pausable)
// - Admin & Setup Functions (constructor, ownership, pause, roles, oracle address)
// - Idea Submission & Management Functions (submit, edit, move to evaluation, link data, stake, claim, update progress, signal completion)
// - Evaluation Process Functions (cast vote, finalize evaluation, verify completion)
// - Funding & Vault Functions (deposit, allocate, record revenue, distribute revenue, withdraw treasury)
// - Advanced & Creative Functions (propose synergy, request mutation, submit mutation result)
// - View & Utility Functions (getters for details, lists, balances, karma, checks)
// ----------------------------------------------------------------------------

// --- Errors ---
error NotOwner();
error NotEvaluator();
error NotTrustedOracle();
error Paused();
error NotPaused();
error IdeaNotFound(uint256 ideaId);
error InvalidIdeaStatus();
error NotIdeaAuthor(uint256 ideaId, address caller);
error EvaluationPeriodActive(uint256 ideaId);
error EvaluationPeriodNotActive(uint256 ideaId);
error EvaluationPeriodNotEnded(uint256 ideaId);
error AlreadyVoted(uint256 ideaId, address evaluator);
error NoVotesRecorded(uint256 ideaId);
error InsufficientVaultBalance(uint256 ideaId, uint256 required);
error IdeaAlreadyFunded(uint256 ideaId);
error IdeaNotApprovedForFunding(uint256 ideaId);
error IdeaNotFunded(uint256 ideaId);
error MutationRequestNotFound(uint256 mutationId);
error MutationRequestAlreadyResulted(uint256 mutationId);
error InvalidStakeAmount();
error StakeClaimNotAllowed(uint256 ideaId);
error IdeaNotPendingCompletion(uint256 ideaId);
error IdeaNotCompleted(uint256 ideaId);
error NoRevenueRecorded(uint256 ideaId);
error InvalidRevenueDistributionRule(); // Placeholder if rules were complex

// --- Events ---
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
event PausedEvent(address account);
event UnpausedEvent(address account);
event EvaluatorRoleGranted(address indexed account);
event EvaluatorRoleRevoked(address indexed account);
event TrustedOracleAddressSet(address indexed oracleAddress);

event IdeaSubmitted(uint256 indexed ideaId, address indexed author, uint256 timestamp);
event IdeaMovedToEvaluation(uint256 indexed ideaId, uint256 evaluationDeadline);
event IdeaStatusUpdated(uint256 indexed ideaId, IdeaStatus newStatus);
event IdeaLinkedExternalData(uint256 indexed ideaId, bytes32 indexed dataHash);
event StakeForPriorityDeposited(uint256 indexed ideaId, address indexed staker, uint256 amount);
event StakeForPriorityClaimed(uint256 indexed ideaId, address indexed staker, uint256 amount);
event IdeaProgressUpdated(uint256 indexed ideaId, IdeaProgressStatus newProgress);
event IdeaSignaledCompletion(uint256 indexed ideaId, address indexed author);

event EvaluationVoteCast(uint256 indexed ideaId, address indexed evaluator, EvaluationOutcome outcome, bytes32 reviewHash);
event EvaluationFinalized(uint256 indexed ideaId, IdeaStatus finalStatus, uint256 approveVotes, uint256 rejectVotes);
event IdeaCompletionVerified(uint256 indexed ideaId, address indexed verifier);

event FundsDeposited(address indexed depositor, uint256 amount);
event FundsAllocated(uint256 indexed ideaId, uint256 amount, address indexed recipient);
event RevenueRecorded(uint256 indexed ideaId, uint256 amount);
event RevenueDistributed(uint256 indexed ideaId, uint256 totalDistributed);
event TreasuryFundsWithdrawn(address indexed recipient, uint256 amount);

event IdeaSynergyProposed(uint256 indexed ideaId1, uint256 indexed ideaId2, address indexed proposer);
event IdeaMutationRequested(uint256 indexed mutationId, uint256 indexed ideaId, address indexed requestor, bytes mutationParams);
event IdeaMutationResultSubmitted(uint256 indexed mutationId, bytes32 resultHash);

event KarmaAwarded(address indexed account, uint256 amount);

// --- Enums ---
enum IdeaStatus {
    Draft,              // Idea created by author, not yet submitted for review
    Submitted,          // Submitted for initial checks (e.g., uniqueness)
    Evaluating,         // Undergoing decentralized evaluation
    Approved,           // Approved by evaluators, eligible for funding
    Rejected,           // Rejected by evaluators
    NeedsRevision,      // Evaluators requested revisions
    Funded,             // Received funding, ready to be worked on
    InProgress,         // Author/team actively working on the idea
    PendingCompletion,  // Author signals the idea is finished
    Completed           // Verified as completed
}

enum EvaluationOutcome {
    None,
    Approve,
    Reject,
    NeedsRevision
}

enum IdeaProgressStatus {
    NotStarted,
    Planning,
    Development,
    Testing,
    Deployment,
    Launched,
    Maintenance,
    OnHold,
    Cancelled
}

// --- Structs ---
struct Idea {
    uint256 id;
    address author;
    string title; // Short title, maybe hash reference to full title/description
    bytes32 descriptionHash; // Hash of the full description (stored off-chain)
    IdeaStatus status;
    uint256 submittedTimestamp;
    uint256 evaluationDeadline; // Timestamp when evaluation period ends
    uint256 requestedBudget;
    address fundingRecipient; // Address to receive allocated funds if approved/funded
    uint256 stakedFunds; // ETH staked for priority
    IdeaProgressStatus progress;
    uint256 totalRevenueRecorded;
}

struct EvaluationVote {
    EvaluationOutcome outcome;
    bytes32 reviewHash; // Hash of the evaluator's review (stored off-chain)
    uint256 timestamp;
}

struct MutationRequest {
    uint256 id;
    uint256 ideaId;
    address requestor;
    uint256 requestTimestamp;
    bytes mutationParams; // Data passed to the oracle (e.g., generative seed, tags)
    bytes32 resultHash; // Hash of the result provided by the oracle
    bool resultSubmitted;
}

// --- State Variables ---
address private _owner;
bool private _paused;

mapping(address => bool) private _isEvaluator;
mapping(address => address) private _trustedOracles; // Map oracle name/ID (address) to its status (bool) - let's simplify to one trusted address
address private _trustedOracleAddress;

uint256 private _nextIdeaId;
mapping(uint256 => Idea) private _ideas;
mapping(address => uint256[]) private _ideasByAuthor;
// Note: Getting ideas by status requires iterating over all ideas or maintaining auxiliary lists - expensive!
// We'll provide a view function for getting total count, and expect clients to filter or use subgraph.

mapping(uint256 => mapping(address => EvaluationVote)) private _ideaEvaluatorVotes; // ideaId => evaluatorAddress => vote
mapping(uint256 => uint256) private _ideaApproveVotes;
mapping(uint256 => uint256) private _ideaRejectVotes;
mapping(uint256 => uint256) private _ideaNeedsRevisionVotes;

mapping(address => uint256) private _karmaScores; // Basic karma score

mapping(uint256 => bytes32[]) private _ideaLinkedExternalData; // ideaId => list of data hashes

uint256 private _vaultBalance; // Total funds deposited for ideas
mapping(uint256 => uint256) private _ideaAllocatedFunds; // Funds allocated to specific ideas

uint256 private _nextMutationRequestId;
mapping(uint256 => MutationRequest) private _mutationRequests;
mapping(uint256 => uint256[]) private _ideaMutationRequestIds; // ideaId => list of mutation request IDs

// --- Modifiers ---
modifier onlyOwner() {
    if (msg.sender != _owner) revert NotOwner();
    _;
}

modifier onlyEvaluator() {
    if (!_isEvaluator[msg.sender]) revert NotEvaluator();
    _;
}

modifier onlyTrustedOracle() {
    if (msg.sender != _trustedOracleAddress || msg.sender == address(0)) revert NotTrustedOracle();
    _;
}

modifier whenNotPaused() {
    if (_paused) revert Paused();
    _;
}

modifier whenPaused() {
    if (!_paused) revert NotPaused();
    _;
}

// --- Constructor ---
constructor() {
    _owner = msg.sender;
    _nextIdeaId = 1;
    _nextMutationRequestId = 1;
    _paused = false; // Start unpaused
    emit OwnershipTransferred(address(0), msg.sender);
}

// --- Admin & Setup Functions (7 functions) ---

function transferOwnership(address newOwner) external onlyOwner {
    if (newOwner == address(0)) revert NotOwner(); // Prevent transferring to zero address
    address oldOwner = _owner;
    _owner = newOwner;
    emit OwnershipTransferred(oldOwner, newOwner);
}

function renounceOwnership() external onlyOwner {
    address oldOwner = _owner;
    _owner = address(0);
    emit OwnershipTransferred(oldOwner, address(0));
}

function pauseContract() external onlyOwner whenNotPaused {
    _paused = true;
    emit PausedEvent(msg.sender);
}

function unpauseContract() external onlyOwner whenPaused {
    _paused = false;
    emit UnpausedEvent(msg.sender);
}

function addEvaluatorRole(address account) external onlyOwner {
    require(account != address(0), "Account cannot be zero address");
    _isEvaluator[account] = true;
    emit EvaluatorRoleGranted(account);
}

function removeEvaluatorRole(address account) external onlyOwner {
    require(account != address(0), "Account cannot be zero address");
    _isEvaluator[account] = false;
    emit EvaluatorRoleRevoked(account);
}

function setTrustedOracleAddress(address oracleAddress) external onlyOwner {
    _trustedOracleAddress = oracleAddress;
    emit TrustedOracleAddressSet(oracleAddress);
}

// --- Idea Submission & Management Functions (8 functions) ---

function submitIdea(string memory title, bytes32 descriptionHash, uint256 requestedBudget, address fundingRecipient) external whenNotPaused {
    uint256 ideaId = _nextIdeaId++;
    _ideas[ideaId] = Idea({
        id: ideaId,
        author: msg.sender,
        title: title,
        descriptionHash: descriptionHash,
        status: IdeaStatus.Draft,
        submittedTimestamp: block.timestamp,
        evaluationDeadline: 0, // Set when moved to evaluation
        requestedBudget: requestedBudget,
        fundingRecipient: fundingRecipient,
        stakedFunds: 0,
        progress: IdeaProgressStatus.NotStarted,
        totalRevenueRecorded: 0
    });
    _ideasByAuthor[msg.sender].push(ideaId);
    emit IdeaSubmitted(ideaId, msg.sender, block.timestamp);
}

function editIdeaDraft(uint256 ideaId, string memory title, bytes32 descriptionHash, uint256 requestedBudget, address fundingRecipient) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.author != msg.sender) revert NotIdeaAuthor(ideaId, msg.sender);
    if (idea.status != IdeaStatus.Draft) revert InvalidIdeaStatus();

    idea.title = title;
    idea.descriptionHash = descriptionHash;
    idea.requestedBudget = requestedBudget;
    idea.fundingRecipient = fundingRecipient;
    // Status remains Draft
    // No specific event for edit, IdeaSubmitted implies initial creation
}

function moveToEvaluation(uint256 ideaId, uint256 evaluationPeriodDuration) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.author != msg.sender) revert NotIdeaAuthor(ideaId, msg.sender);
    if (idea.status != IdeaStatus.Draft && idea.status != IdeaStatus.NeedsRevision) revert InvalidIdeaStatus();
    if (evaluationPeriodDuration == 0) revert ("Evaluation period duration must be > 0");

    idea.status = IdeaStatus.Evaluating;
    idea.evaluationDeadline = block.timestamp + evaluationPeriodDuration;

    // Reset evaluation votes if moved from NeedsRevision
    if (idea.status == IdeaStatus.NeedsRevision) {
         delete _ideaEvaluatorVotes[ideaId];
         _ideaApproveVotes[ideaId] = 0;
         _ideaRejectVotes[ideaId] = 0;
         _ideaNeedsRevisionVotes[ideaId] = 0;
    }

    emit IdeaMovedToEvaluation(ideaId, idea.evaluationDeadline);
    emit IdeaStatusUpdated(ideaId, IdeaStatus.Evaluating);
}

function linkExternalDataToIdea(uint256 ideaId, bytes32 dataHash) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    // Allow author to link data in any status except Completed/Rejected?
    // Let's allow in Draft, Submitted, Evaluating, Approved, Funded, InProgress, NeedsRevision
    if (idea.status == IdeaStatus.Completed || idea.status == IdeaStatus.Rejected) revert InvalidIdeaStatus();
    if (idea.author != msg.sender && idea.fundingRecipient != msg.sender) revert ("Only author or funding recipient can link data"); // Allow recipient if funded

    _ideaLinkedExternalData[ideaId].push(dataHash);
    emit IdeaLinkedExternalData(ideaId, dataHash);
}

function stakeForEvaluationPriority(uint256 ideaId) external payable whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.author != msg.sender) revert NotIdeaAuthor(ideaId, msg.sender);
    if (idea.status != IdeaStatus.Draft && idea.status != IdeaStatus.Submitted && idea.status != IdeaStatus.NeedsRevision) revert InvalidIdeaStatus();
    if (msg.value == 0) revert InvalidStakeAmount();

    idea.stakedFunds += msg.value;
    emit StakeForPriorityDeposited(ideaId, msg.sender, msg.value);
}

function claimStakedFunds(uint256 ideaId) external whenNotPaused {
     Idea storage idea = _ideas[ideaId];
     if (idea.author == address(0)) revert IdeaNotFound(ideaId);
     if (idea.author != msg.sender) revert NotIdeaAuthor(ideaId, msg.sender);
     if (idea.stakedFunds == 0) revert StakeClaimNotAllowed(ideaId);

     // Only allow claiming if the idea was rejected, or evaluation deadline passed and not Approved/Funded
     bool allowClaim = idea.status == IdeaStatus.Rejected ||
                       (idea.status != IdeaStatus.Approved && idea.status != IdeaStatus.Funded && idea.evaluationDeadline > 0 && block.timestamp >= idea.evaluationDeadline);

     if (!allowClaim) revert StakeClaimNotAllowed(ideaId);

     uint256 amount = idea.stakedFunds;
     idea.stakedFunds = 0;
     // Use low-level call for robustness against reentrancy by recipient contract
     (bool success, ) = payable(msg.sender).call{value: amount}("");
     require(success, "ETH transfer failed"); // Revert if transfer fails

     emit StakeForPriorityClaimed(ideaId, msg.sender, amount);
}


function updateIdeaProgress(uint256 ideaId, IdeaProgressStatus newProgress) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
     // Only allow author or funding recipient to update progress
    if (idea.author != msg.sender && idea.fundingRecipient != msg.sender) revert ("Only author or funding recipient can update progress");
    if (idea.status != IdeaStatus.Funded && idea.status != IdeaStatus.InProgress) revert InvalidIdeaStatus(); // Can only update progress if Funded or InProgress

    idea.progress = newProgress;
    if (idea.status == IdeaStatus.Funded && newProgress != IdeaProgressStatus.NotStarted) {
        idea.status = IdeaStatus.InProgress; // Auto-transition from Funded to InProgress
        emit IdeaStatusUpdated(ideaId, IdeaStatus.InProgress);
    }

    emit IdeaProgressUpdated(ideaId, newProgress);
}

function signalIdeaCompletion(uint256 ideaId) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.author != msg.sender) revert NotIdeaAuthor(ideaId, msg.sender);
    if (idea.status != IdeaStatus.InProgress) revert InvalidIdeaStatus();

    idea.status = IdeaStatus.PendingCompletion;
    emit IdeaStatusUpdated(ideaId, IdeaStatus.PendingCompletion);
    emit IdeaSignaledCompletion(ideaId, msg.sender);
}


// --- Evaluation Process Functions (3 functions) ---

function castEvaluationVote(uint256 ideaId, EvaluationOutcome outcome, bytes32 reviewHash) external onlyEvaluator whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.status != IdeaStatus.Evaluating) revert EvaluationPeriodNotActive(ideaId);
    if (block.timestamp > idea.evaluationDeadline) revert EvaluationPeriodNotActive(ideaId); // Period ended

    if (_ideaEvaluatorVotes[ideaId][msg.sender].outcome != EvaluationOutcome.None) revert AlreadyVoted(ideaId, msg.sender);
    if (outcome == EvaluationOutcome.None) revert ("Invalid vote outcome"); // Cannot vote None

    _ideaEvaluatorVotes[ideaId][msg.sender] = EvaluationVote({
        outcome: outcome,
        reviewHash: reviewHash,
        timestamp: block.timestamp
    });

    if (outcome == EvaluationOutcome.Approve) {
        _ideaApproveVotes[ideaId]++;
    } else if (outcome == EvaluationOutcome.Reject) {
        _ideaRejectVotes[ideaId]++;
    } else if (outcome == EvaluationOutcome.NeedsRevision) {
        _ideaNeedsRevisionVotes[ideaId]++;
    }

    // Award karma for participating in evaluation
    _awardKarma(msg.sender, 1); // Simple 1 karma per vote
    emit EvaluationVoteCast(ideaId, msg.sender, outcome, reviewHash);
}

// This function can be called by anyone after the deadline to finalize evaluation
function finalizeEvaluationRound(uint256 ideaId) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.status != IdeaStatus.Evaluating) revert EvaluationPeriodNotActive(ideaId);
    if (block.timestamp < idea.evaluationDeadline) revert EvaluationPeriodNotEnded(ideaId);

    // Determine outcome based on votes (simple majority wins, NeedsRevision is like a soft reject)
    IdeaStatus finalStatus;
    uint256 totalVotes = _ideaApproveVotes[ideaId] + _ideaRejectVotes[ideaId] + _ideaNeedsRevisionVotes[ideaId];

    if (totalVotes == 0) {
        // No votes cast, revert or auto-reject? Let's auto-reject.
        finalStatus = IdeaStatus.Rejected;
    } else if (_ideaApproveVotes[ideaId] > _ideaRejectVotes[ideaId] && _ideaApproveVotes[ideaId] > _ideaNeedsRevisionVotes[ideaId]) {
         finalStatus = IdeaStatus.Approved;
         // Award karma to author for approved idea
         _awardKarma(idea.author, 5);
    } else if (_ideaNeedsRevisionVotes[ideaId] > _ideaApproveVotes[ideaId] && _ideaNeedsRevisionVotes[ideaId] > _ideaRejectVotes[ideaId]) {
         finalStatus = IdeaStatus.NeedsRevision;
    }
    else {
         // Reject is majority, or ties (Approve vs Reject, Approve vs NeedsRevision tie, NeedsRevision vs Reject tie, or 3-way tie)
         finalStatus = IdeaStatus.Rejected;
    }

    idea.status = finalStatus;

    // Clean up evaluation data to save gas/storage *or* keep for history. Keeping for history is more informative.
    // If cleaning up, uncomment: delete _ideaEvaluatorVotes[ideaId]; delete _ideaApproveVotes[ideaId]; ...

    emit EvaluationFinalized(ideaId, finalStatus, _ideaApproveVotes[ideaId], _ideaRejectVotes[ideaId]);
    emit IdeaStatusUpdated(ideaId, finalStatus);
}

// Allows an evaluator or owner to verify completion of a PendingCompletion idea
function verifyIdeaCompletion(uint256 ideaId) external whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.status != IdeaStatus.PendingCompletion) revert IdeaNotPendingCompletion(ideaId);

    // Either owner or an evaluator can verify
    if (msg.sender != _owner && !_isEvaluator[msg.sender]) revert ("Only owner or evaluator can verify completion");

    idea.status = IdeaStatus.Completed;
    // Award karma to author and potentially funding recipient upon completion verification
    _awardKarma(idea.author, 10);
    if (idea.fundingRecipient != address(0) && idea.fundingRecipient != idea.author) {
         _awardKarma(idea.fundingRecipient, 5);
    }
    // Award karma to evaluators who approved or verified? Can be complex. Simple for now.

    emit IdeaCompletionVerified(ideaId, msg.sender);
    emit IdeaStatusUpdated(ideaId, IdeaStatus.Completed);
}


// --- Funding & Vault Functions (5 functions) ---

function depositFunds() external payable whenNotPaused {
    if (msg.value == 0) revert ("Cannot deposit zero value");
    _vaultBalance += msg.value;
    emit FundsDeposited(msg.sender, msg.value);
}

function allocateFundingToIdea(uint256 ideaId, uint256 amount) external onlyOwner whenNotPaused {
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.status != IdeaStatus.Approved) revert IdeaNotApprovedForFunding(ideaId);
    if (amount == 0 || amount > _vaultBalance) revert InsufficientVaultBalance(ideaId, amount);
    if (amount > idea.requestedBudget && idea.requestedBudget > 0) revert ("Cannot allocate more than requested budget"); // Optional: enforce budget limit

    _vaultBalance -= amount;
    _ideaAllocatedFunds[ideaId] += amount; // Track allocated funds per idea
    idea.status = IdeaStatus.Funded; // Transition status

    // Transfer funds to the idea's designated recipient
    address recipient = idea.fundingRecipient != address(0) ? idea.fundingRecipient : idea.author; // Default to author if no recipient set
     (bool success, ) = payable(recipient).call{value: amount}("");
     require(success, "Funding transfer failed"); // Revert if transfer fails

    emit FundsAllocated(ideaId, amount, recipient);
    emit IdeaStatusUpdated(ideaId, IdeaStatus.Funded);
}

// Allows owner to record revenue received off-chain for a funded idea
// This does NOT transfer funds into the contract, just records the amount for potential distribution
function recordRevenueForIdea(uint256 ideaId, uint256 amount) external onlyOwner {
     Idea storage idea = _ideas[ideaId];
     if (idea.author == address(0)) revert IdeaNotFound(ideaId);
     // Allow recording revenue for Funded, InProgress, PendingCompletion, Completed ideas
     if (idea.status < IdeaStatus.Funded) revert IdeaNotFunded(ideaId); // Must be Funded or later

     idea.totalRevenueRecorded += amount;
     emit RevenueRecorded(ideaId, amount);
}

// Placeholder for distributing recorded revenue.
// A real implementation would need detailed rules (e.g., % to author, % to stakers, % to evaluators, % to vault).
// This basic version just emits an event and doesn't handle complex transfers.
function distributeIdeaRevenue(uint256 ideaId) external onlyOwner {
     Idea storage idea = _ideas[ideaId];
     if (idea.author == address(0)) revert IdeaNotFound(ideaId);
     if (idea.totalRevenueRecorded == 0) revert NoRevenueRecorded(ideaId);

     // --- Distribution Logic Placeholder ---
     // Example: 70% to author, 30% to vault
     // uint256 authorShare = (idea.totalRevenueRecorded * 70) / 100;
     // uint256 vaultShare = idea.totalRevenueRecorded - authorShare;
     // Transfer to author/recipient (off-chain?) and update vault balance if sending there.
     // Complex revenue sharing requires careful design (pull vs push, gas, distribution rules).
     // For this example, we just acknowledge distribution happened for the total recorded.

     uint256 totalDistributed = idea.totalRevenueRecorded;
     idea.totalRevenueRecorded = 0; // Reset recorded revenue after distribution

     // In a real scenario, this would trigger actual ETH/token transfers
     // based on defined shares to author, stakers, evaluators, vault, etc.
     // For simplicity, we just log the event.
     emit RevenueDistributed(ideaId, totalDistributed);
}

function withdrawTreasuryFunds(address payable recipient, uint256 amount) external onlyOwner whenNotPaused {
    if (amount == 0 || amount > _vaultBalance) revert InsufficientVaultBalance(0, amount); // Using 0 for ideaId context not applicable
    _vaultBalance -= amount;
    (bool success, ) = recipient.call{value: amount}("");
    require(success, "ETH transfer failed"); // Revert if transfer fails
    emit TreasuryFundsWithdrawn(recipient, amount);
}


// --- Advanced & Creative Functions (3 functions) ---

// A symbolic function to propose synergy between ideas. Awards minor karma.
// Does not create a new idea or enforce anything, purely for tracking suggestions.
function proposeIdeaSynergy(uint256 ideaId1, uint256 ideaId2) external whenNotPaused {
    // Check if ideas exist (optional, could allow proposing synergy with non-existent ideas)
    if (_ideas[ideaId1].author == address(0)) revert IdeaNotFound(ideaId1);
    if (_ideas[ideaId2].author == address(0)) revert IdeaNotFound(ideaId2);

    // Award karma for suggesting connections
    _awardKarma(msg.sender, 1);
    emit IdeaSynergyProposed(ideaId1, ideaId2, msg.sender);

    // In a more complex version, you might store these suggestions in a mapping
    // mapping(uint256 => mapping(uint256 => address[])) ideaSynergySuggestions;
}

// Requests an oracle to perform a 'mutation' or generate a variation/synergy.
// The oracle is expected to call submitMutationResult later.
function requestIdeaMutation(uint256 ideaId, bytes memory mutationParams) external whenNotPaused {
    // Check if idea exists and is in a relevant state (e.g., Approved, Funded, Completed)
    Idea storage idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    if (idea.status < IdeaStatus.Approved && idea.status != IdeaStatus.NeedsRevision) revert InvalidIdeaStatus(); // Allow mutations on approved, funded, in progress, completed, or even needing revision

    uint256 mutationId = _nextMutationRequestId++;
    _mutationRequests[mutationId] = MutationRequest({
        id: mutationId,
        ideaId: ideaId,
        requestor: msg.sender,
        requestTimestamp: block.timestamp,
        mutationParams: mutationParams,
        resultHash: bytes32(0), // Placeholder for result
        resultSubmitted: false
    });
    _ideaMutationRequestIds[ideaId].push(mutationId);

    // Award karma for requesting a mutation
    _awardKarma(msg.sender, 2); // Slightly more karma for creative exploration

    // A real integration would likely emit an event the oracle is listening for
    // emit OracleMutationRequest(mutationId, ideaId, mutationParams); // Conceptual event

    emit IdeaMutationRequested(mutationId, ideaId, msg.sender, mutationParams);
}

// Callable ONLY by the trusted oracle address to submit the result of a mutation request.
// The result is a hash (e.g., hash of a new idea description, or reference to generated data).
function submitMutationResult(uint256 mutationId, bytes32 resultHash) external onlyTrustedOracle whenNotPaused {
    MutationRequest storage request = _mutationRequests[mutationId];
    if (request.ideaId == 0) revert MutationRequestNotFound(mutationId); // Check if request exists (ideaId is never 0 in our system)
    if (request.resultSubmitted) revert MutationRequestAlreadyResulted(mutationId);
    if (resultHash == bytes32(0)) revert ("Result hash cannot be zero");

    request.resultHash = resultHash;
    request.resultSubmitted = true;

    // Optional: Link the result hash to the original idea or create a new idea entry
    // For simplicity, we just store the hash in the mutation request struct.
    // If linking to original idea: _ideaLinkedExternalData[request.ideaId].push(resultHash);

    // Award karma to the oracle for providing a result
    _awardKarma(msg.sender, 3);

    // Award karma to the original requestor as their request was fulfilled
    _awardKarma(request.requestor, 1);

    emit IdeaMutationResultSubmitted(mutationId, resultHash);
}

// --- Utility Functions (Internal) ---

// Internal function to award karma
function _awardKarma(address account, uint256 amount) internal {
    if (account == address(0) || amount == 0) return;
    unchecked { // Karma is unlikely to overflow uint256
        _karmaScores[account] += amount;
    }
    emit KarmaAwarded(account, amount);
}


// --- View & Utility Functions (14 functions) ---

function getIdeaDetails(uint256 ideaId) external view returns (Idea memory) {
    Idea memory idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    return idea;
}

function getIdeasByAuthor(address author) external view returns (uint256[] memory) {
    return _ideasByAuthor[author];
}

// Note: This function is potentially very gas-expensive if there are many ideas
// and requires iterating through all idea IDs up to _nextIdeaId.
// In a real-world scenario, a subgraph or off-chain indexer is preferred for this.
function getIdeasByStatus(IdeaStatus status) external view returns (uint256[] memory) {
    uint256[] memory matchingIdeaIds = new uint256[](_nextIdeaId - 1); // Max possible size
    uint256 count = 0;
    // Loop from 1 up to the current number of ideas
    for (uint256 i = 1; i < _nextIdeaId; i++) {
        // Check if the idea exists before accessing its status
        if (_ideas[i].author != address(0) && _ideas[i].status == status) {
            matchingIdeaIds[count] = i;
            count++;
        }
    }
    // Resize array to actual count
    uint256[] memory result = new uint256[](count);
    for (uint256 i = 0; i < count; i++) {
        result[i] = matchingIdeaIds[i];
    }
    return result;
}

function getTotalIdeas() external view returns (uint256) {
    return _nextIdeaId - 1; // Subtract 1 because IDs start from 1
}

function getVaultBalance() external view returns (uint256) {
    return _vaultBalance;
}

function getKarmaScore(address account) external view returns (uint256) {
    return _karmaScores[account];
}

function getIdeaEvaluationResults(uint256 ideaId) external view returns (uint256 approve, uint256 reject, uint256 needsRevision, uint256 totalVotes) {
    if (_ideas[ideaId].author == address(0)) revert IdeaNotFound(ideaId);
    approve = _ideaApproveVotes[ideaId];
    reject = _ideaRejectVotes[ideaId];
    needsRevision = _ideaNeedsRevisionVotes[ideaId];
    totalVotes = approve + reject + needsRevision;
    return (approve, reject, needsRevision, totalVotes);
}

function getEvaluatorVoteForIdea(uint256 ideaId, address evaluator) external view returns (EvaluationVote memory) {
     if (_ideas[ideaId].author == address(0)) revert IdeaNotFound(ideaId);
     return _ideaEvaluatorVotes[ideaId][evaluator];
}

function getIdeaLinkedData(uint256 ideaId) external view returns (bytes32[] memory) {
     if (_ideas[ideaId].author == address(0)) revert IdeaNotFound(ideaId);
     return _ideaLinkedExternalData[ideaId];
}

function getIdeaStakedFunds(uint256 ideaId) external view returns (uint256) {
    Idea memory idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    return idea.stakedFunds;
}

function getIdeaAllocatedFunds(uint256 ideaId) external view returns (uint256) {
     if (_ideas[ideaId].author == address(0)) revert IdeaNotFound(ideaId);
     return _ideaAllocatedFunds[ideaId];
}

function getIdeaRevenue(uint256 ideaId) external view returns (uint256) {
    Idea memory idea = _ideas[ideaId];
    if (idea.author == address(0)) revert IdeaNotFound(ideaId);
    return idea.totalRevenueRecorded;
}

function getIdeaMutationRequests(uint256 ideaId) external view returns (uint256[] memory) {
     if (_ideas[ideaId].author == address(0)) revert IdeaNotFound(ideaId);
     return _ideaMutationRequestIds[ideaId];
}

function getMutationRequestDetails(uint256 mutationId) external view returns (MutationRequest memory) {
    MutationRequest memory request = _mutationRequests[mutationId];
    if (request.ideaId == 0) revert MutationRequestNotFound(mutationId); // Check if exists
    return request;
}

function isEvaluator(address account) external view returns (bool) {
     return _isEvaluator[account];
}

function getOwner() external view returns (address) {
    return _owner;
}

function paused() external view returns (bool) {
    return _paused;
}

function getTrustedOracleAddress() external view returns (address) {
     return _trustedOracleAddress;
}

// Total Functions: 30+ (Counted manually based on implementation: Admin=7, Idea Mgmt=8, Evaluation=3, Funding=5, Advanced=3, Views=14 -> 7+8+3+5+3+14 = 40 functions implemented or specified!)
```