This smart contract, named "AetherFlux DAO: Adaptive Sovereign Treasury Protocol," is designed to be a sophisticated decentralized autonomous organization focusing on dynamic treasury management, reputation-based governance, and integrating AI-driven insights for investment strategies, all while dedicating a portion of its resources to regenerative finance.

It avoids direct duplication of existing open-source projects by holistically combining and enhancing these concepts into a single, adaptive, and reputation-centric financial DAO.

---

### **AetherFlux DAO: Adaptive Sovereign Treasury Protocol**

*   **Vision:** To create a self-evolving decentralized autonomous organization that intelligently manages a community-owned treasury, adapts its investment strategies based on dynamic market conditions and AI-driven insights, fosters active participation through a unique reputation system, and contributes to public goods and sustainability initiatives.
*   **Core Concepts:**
    1.  **Adaptive Treasury Management:** The DAO's investment strategies are not static. They can be dynamically adjusted through governance proposals, informed by an external oracle providing AI-generated market sentiment.
    2.  **Reputation-Based Governance (AetherRep):** A non-transferable (Soul-Bound Token-like) score (`AetherRep`) that accrues from positive contributions (proposals, voting, staking) and decays with inactivity. This score directly boosts a user's voting power and determines eligibility for proposing.
    3.  **AI/Oracle Integration:** The contract relies on an external oracle to feed "Market Sentiment Index" data, generated by off-chain AI analysis. This sentiment data informs the community's decision-making process for treasury rebalancing.
    4.  **Regenerative Finance:** A dedicated mechanism allows the DAO to propose and fund public goods, environmental projects, or other impact initiatives, allocating a portion of its profits towards societal benefit.
    5.  **Modular Governance:** A flexible proposal and voting system enables the community to control all critical parameters, from investment strategies to protocol fees and reputation rules.
    6.  **Staking Mechanics:** Incentivizes long-term commitment to the protocol's native `AFT` (AetherFlux Token) by offering rewards and contributing to AetherRep.

*   **Tokenomics:**
    *   **AFT (AetherFlux Token):** The primary ERC-20 utility and governance token. Holders stake AFT to participate in governance and earn rewards.
    *   **AetherRep (Reputation Score):** A non-transferable integer score, conceptually similar to a Soul-Bound Token. It serves as a multiplier for AFT voting power and a gate for creating proposals. It dynamically adjusts based on user activity and contribution quality.

---

### **Outline & Function Summary**

**I. Core Setup & Access Control**
*   Manages contract ownership (initially deployer, conceptually transitioning to DAO), pausing mechanism for emergencies, and updates to critical external addresses.

1.  `constructor(address _aftToken, address _oracle, address _initialFeeRecipient)`: Initializes the core AFT token, the trusted market sentiment oracle, and the address for collecting protocol fees. Sets initial, configurable governance parameters like voting period and quorum.
2.  `updateOracleAddress(address _newOracle)`: Allows a privileged address (initially owner, eventually DAO-controlled via governance) to change the market sentiment oracle address.
3.  `setProtocolFeeRecipient(address _newRecipient)`: Sets the address designated to receive any protocol-level fees.
4.  `pauseContract()`: Activates an emergency pause, stopping all critical state-changing functions. Callable by a privileged address.
5.  `unpauseContract()`: Deactivates the emergency pause, restoring contract functionality. Callable by a privileged address.

**II. Treasury Management & Investment Strategies**
*   Functions for users to interact with the DAO's treasury, and for governance to propose and execute investment strategies, dynamically adjusting asset allocations.

6.  `depositAssets(address _asset, uint256 _amount)`: Allows users to deposit supported ERC-20 assets (and ETH via `receive()`) into the DAO's collective treasury. Deposits contribute to the user's AetherRep.
7.  `withdrawAssets(address _asset, uint256 _amount)`: Allows for withdrawal of assets from the treasury. In a full implementation, this would be subject to governance approval or specific deposit/withdrawal rules for individual users. Here, it represents the DAO releasing assets.
8.  `proposeInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages, string calldata _descriptionHash)`: Creates a new governance proposal for a specific asset allocation strategy. Proposers must meet minimum AFT staking and AetherRep requirements.
9.  `_applyInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages)`: An internal helper function executed by a successful governance proposal. It updates the DAO's target asset allocation percentages, conceptually triggering a rebalancing.
10. `getTreasuryValueUSD()`: Returns the estimated total USD value of all assets currently held by the DAO's treasury, using prices from the trusted oracle.
11. `getAssetAllocationPercentages()`: Retrieves the current target allocation percentages for each managed asset as set by the last approved investment strategy.

**III. AetherRep (Reputation System)**
*   Manages the non-transferable AetherRep score, which dynamically reflects a user's engagement, contribution, and reputation within the DAO. This score directly influences voting power and proposal eligibility.

12. `getAetherRep(address _user)`: Returns a user's current AetherRep score, which is calculated on-the-fly, accounting for any decay due to inactivity.
13. `_updateAetherRep(address _user, int256 _delta)`: An internal function used to adjust a user's AetherRep score. It's called automatically based on positive actions (e.g., successful proposals, active voting) or negative actions (e.g., failed proposals, inactivity).
14. `delegateAetherRepVote(address _delegatee)`: Allows a user to delegate their AetherRep-weighted voting power to another address, fostering liquid democracy.
15. `undelegateAetherRepVote()`: Revokes an active AetherRep delegation, restoring voting power to the original address.
16. `getAetherRepBoostMultiplier(address _user)`: Calculates the multiplier applied to a user's AFT votes based on their AetherRep score, enhancing the influence of reputable members.

**IV. Governance (Proposals & Voting)**
*   The core system for decentralized decision-making, enabling members to propose any changes to the protocol and collectively vote on them, with votes weighted by AFT and AetherRep.

17. `createProposal(bytes32 _proposalTypeHash, address _target, bytes calldata _callData, string calldata _descriptionHash)`: Initiates a new generic governance proposal. Requires a minimum AFT stake and AetherRep score. The `_callData` encodes the action to be executed if the proposal passes.
18. `voteOnProposal(uint256 _proposalId, bool _support)`: Allows AFT holders (with their AetherRep-boosted voting power) to cast a vote for or against an active proposal.
19. `executeProposal(uint256 _proposalId)`: Executes a proposal that has concluded its voting period, met the quorum requirements, and achieved majority approval. This function triggers the encoded `_callData` to enact the proposed changes.
20. `cancelProposal(uint256 _proposalId)`: Allows the original proposer or highly reputable members to cancel a pending proposal before its voting period ends.
21. `setVotingPeriod(uint256 _newPeriod)`: A governance function (executable via a successful proposal) to adjust the duration of proposal voting periods.
22. `setQuorumPercentage(uint256 _newPercentage)`: A governance function to adjust the minimum percentage of total weighted voting power required for a proposal to be valid and potentially pass.
23. `setMinRepForProposal(uint256 _newMinRep)`: A governance function to set the minimum AetherRep score required for a user to create a new proposal.

**V. Dynamic Adaptive Mechanism (Oracle/AI)**
*   Facilitates the integration of external AI-driven market sentiment data, which can inform or trigger new strategic proposals within the DAO, making its treasury management adaptive.

24. `submitMarketSentimentData(uint256 _sentimentIndex, uint256 _timestamp)`: Callable only by the trusted `IOracle` contract, this function updates the DAO's internal record of the latest AI-generated market sentiment index.
25. `getCurrentMarketSentiment()`: Returns the latest recorded market sentiment index.
26. `triggerStrategyReassessment()`: A public, view-only function that serves as a signal. It encourages off-chain agents (keepers, users) to review the current market sentiment and potentially propose new investment strategies if conditions warrant a change.

**VI. Impact Initiatives & Regenerative Finance**
*   A dedicated mechanism to allocate a portion of the DAO's treasury towards public goods, social impact projects, or other regenerative finance initiatives, reflecting the DAO's commitment to broader societal benefit.

27. `proposeImpactInitiative(string calldata _descriptionHash, uint256 _amount, address _recipient)`: Creates a governance proposal to fund a specific impact project with a designated amount of a chosen asset from the treasury.
28. `_fundImpactInitiativeInternal(uint256 _amount, address _recipient, string calldata _descriptionHash)`: An internal helper function executed by a successful governance proposal. It transfers the specified amount of assets from the treasury to the impact initiative recipient.
29. `getImpactFundBalanceUSD()`: Returns the estimated total USD value of assets currently earmarked or allocated for impact initiatives.

**VII. Staking & Rewards**
*   Allows users to stake their AFT tokens, earning rewards and strengthening their AetherRep, contributing to the protocol's security and governance participation.

30. `stakeAFT(uint256 _amount)`: Allows users to stake their AFT tokens, contributing to the protocol's liquidity/security and starting to accrue staking rewards and AetherRep.
31. `unstakeAFT(uint256 _amount)`: Allows users to unstake their AFT tokens, stopping reward accrual and potentially incurring a small AetherRep reduction.
32. `claimStakingRewards()`: Allows users to claim their accumulated staking rewards based on their staked AFT balance and duration.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/*
* @title AetherFlux DAO: Adaptive Sovereign Treasury Protocol
* @author [Your Name/Alias]
* @notice A decentralized autonomous organization designed for adaptive treasury management,
*         governed by a dynamic reputation system (AetherRep) and influenced by AI-driven
*         market sentiment. It incorporates regenerative finance principles by dedicating
*         a portion of its treasury to impact initiatives.
*
* @dev This contract demonstrates advanced concepts including:
*      1.  **Adaptive Treasury Management:** Dynamic asset allocation based on market sentiment
*          and governance proposals.
*      2.  **Reputation-Based Governance (AetherRep):** A non-transferable (SBT-like) score that
*          boosts voting power, grants access, and decays over inactivity, encouraging active participation.
*      3.  **AI/Oracle Integration:** Relies on an external oracle to feed AI-generated market sentiment,
*          influencing strategic decisions via governance.
*      4.  **Regenerative Finance:** A dedicated fund for community-proposed public goods and impact initiatives.
*      5.  **Modular Governance:** Flexible proposal and voting mechanisms with adjustable parameters.
*      6.  **Staking Mechanics:** Incentivizes long-term commitment to the protocol.
*
* @custom:concept Non-Duplication Statement: While individual components like DAOs, staking,
*                  or reputation systems exist, this contract aims for uniqueness by holistically
*                  integrating an adaptive, AI-sentiment-driven treasury with a decaying, SBT-like
*                  reputation system that *directly influences* voting power and access, alongside
*                  a built-in regenerative finance mandate. The interplay of these dynamic elements
*                  creates a novel governance and treasury management paradigm.
*/

// --- OUTLINE & FUNCTION SUMMARY ---

// I. Core Setup & Access Control
//    - Manages contract ownership (initial deployment, eventually DAO-controlled), pausing mechanism,
//      and crucial address updates.
//    1.  `constructor(address _aftToken, address _oracle, address _initialFeeRecipient)`: Initializes the core token, oracle, and fee recipient addresses. Sets initial governance parameters.
//    2.  `updateOracleAddress(address _newOracle)`: Allows a privileged address (initially owner, then DAO) to update the market sentiment oracle address.
//    3.  `setProtocolFeeRecipient(address _newRecipient)`: Sets the address designated to receive protocol fees.
//    4.  `pauseContract()`: Pauses all critical state-changing functions in an emergency. Callable by privileged address.
//    5.  `unpauseContract()`: Unpauses the contract. Callable by privileged address.

// II. Treasury Management & Investment Strategies
//     - Functions for managing the DAO's collective assets, proposing new investment strategies,
//       and executing approved strategies.
//    6.  `depositAssets(address _asset, uint256 _amount)`: Allows users to deposit supported ERC20 assets into the DAO's treasury.
//    7.  `withdrawAssets(address _asset, uint256 _amount)`: Allows users to withdraw their previously deposited assets, subject to rules/lock-ups (simplified for this example).
//    8.  `proposeInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages, string calldata _descriptionHash)`: Creates a new governance proposal for a specific asset allocation strategy. Requires sufficient AetherRep.
//    9.  `_applyInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages)`: Internal function executed by a successful governance proposal to update the DAO's target asset allocation.
//    10. `getTreasuryValueUSD()`: Returns the estimated total USD value of all assets held by the treasury using oracle price feeds.
//    11. `getAssetAllocationPercentages()`: Returns the current target allocation percentages for each managed asset.

// III. AetherRep (Reputation System)
//     - Manages the non-transferable "AetherRep" score, which reflects a user's engagement and reputation.
//       This score directly influences voting power and proposal eligibility.
//    12. `getAetherRep(address _user)`: Returns a user's calculated AetherRep score, accounting for decay.
//    13. `_updateAetherRep(address _user, int256 _delta)`: Internal function to adjust a user's AetherRep based on actions (e.g., successful proposals, active voting, inactivity).
//    14. `delegateAetherRepVote(address _delegatee)`: Allows a user to delegate their AetherRep-weighted voting power to another address.
//    15. `undelegateAetherRepVote()`: Revokes any existing AetherRep delegation.
//    16. `getAetherRepBoostMultiplier(address _user)`: Calculates the multiplier applied to AFT votes based on the user's AetherRep.

// IV. Governance (Proposals & Voting)
//     - The core system for decentralized decision-making, enabling members to propose changes
//       and vote on them.
//    17. `createProposal(bytes32 _proposalTypeHash, address _target, bytes calldata _callData, string calldata _descriptionHash)`: Initiates a new governance proposal. Requires minimum AFT stake and AetherRep.
//    18. `voteOnProposal(uint256 _proposalId, bool _support)`: Allows AFT holders (with AetherRep boost) to vote for or against a proposal.
//    19. `executeProposal(uint256 _proposalId)`: Executes a proposal that has met quorum and passed the voting threshold.
//    20. `cancelProposal(uint256 _proposalId)`: Allows the proposal creator or high-rep member to cancel a pending proposal.
//    21. `setVotingPeriod(uint256 _newPeriod)`: DAO governance function to adjust the duration of proposal voting periods.
//    22. `setQuorumPercentage(uint256 _newPercentage)`: DAO governance function to adjust the minimum percentage of total voting power required for a proposal to be valid.
//    23. `setMinRepForProposal(uint256 _newMinRep)`: DAO governance function to set the minimum AetherRep required to create a new proposal.

// V. Dynamic Adaptive Mechanism (Oracle/AI)
//    - Facilitates the integration of external AI-driven market sentiment data, which can inform
//      or trigger new strategic proposals within the DAO.
//    24. `submitMarketSentimentData(uint256 _sentimentIndex, uint256 _timestamp)`: Callable only by the trusted oracle, submits the latest AI-generated market sentiment index.
//    25. `getCurrentMarketSentiment()`: Returns the latest recorded market sentiment index.
//    26. `triggerStrategyReassessment()`: A public function that can be called to signal the DAO
//        to review its current investment strategies in light of new market sentiment data.

// VI. Impact Initiatives & Regenerative Finance
//     - A mechanism to allocate a portion of the DAO's treasury towards public goods and
//       socially impactful projects.
//    27. `proposeImpactInitiative(string calldata _descriptionHash, uint256 _amount, address _recipient)`: Creates a proposal to fund a specific impact project.
//    28. `_fundImpactInitiativeInternal(uint256 _amount, address _recipient, string calldata _descriptionHash)`: Internal function executed by a successful governance proposal to transfer funds for an impact initiative.
//    29. `getImpactFundBalanceUSD()`: Returns the current USD value of assets specifically earmarked or allocated for impact initiatives.

// VII. Staking & Rewards
//     - Allows users to stake AFT tokens to earn rewards and contribute to the protocol's
//       security and governance. Staking is a primary way to earn AetherRep.
//    30. `stakeAFT(uint256 _amount)`: Allows users to stake their AFT tokens, earning rewards and potentially increasing AetherRep.
//    31. `unstakeAFT(uint256 _amount)`: Allows users to unstake their AFT tokens, subject to any lock-up periods.
//    32. `claimStakingRewards()`: Allows users to claim their accumulated staking rewards.

// --- END OF OUTLINE & FUNCTION SUMMARY ---

interface IOracle {
    // getLatestPrice returns price scaled with 18 decimals, for direct calculation with 18-decimal ERC20s
    function getLatestPrice(address _asset) external view returns (int256);
    function getMarketSentiment() external view returns (uint256); // 0-100, 50 neutral
}

contract AetherFluxDAO is Ownable, Pausable {
    using SafeERC20 for IERC20;
    using Address for address;

    IERC20 public immutable aftToken; // AetherFlux Token - Governance Token
    IOracle public oracle;

    // --- Core State Variables ---

    // Treasury Management
    mapping(address => uint256) public assetBalances; // Balances of various ERC20 assets held by the DAO
    address[] public supportedAssets; // List of assets the DAO can hold/manage
    mapping(address => uint256) public assetTargetAllocations; // Target percentage allocations for investment strategies (e.g., 1000 for 10%) - these sum to 10000 (100%)
    uint256 public totalAllocationPercentage; // Sum of all target allocation percentages, should be 10000 (100%)

    // AetherRep (Reputation System)
    mapping(address => uint256) public aetherRepScores; // Raw reputation score
    mapping(address => uint256) public lastAetherRepActivity; // Timestamp of last reputation-earning activity for decay calculation
    mapping(address => address) public aetherRepDelegates; // Delegate mapping for reputation votes
    uint256 public constant AETHER_REP_DECAY_RATE_PER_DAY = 1; // Example: 1 point per day of inactivity
    uint256 public constant AETHER_REP_MAX_BOOST = 1000; // Max AetherRep score for calculating full vote boost (e.g., 1000 rep gives 2x vote)
    uint256 public constant AETHER_REP_BOOST_FACTOR = 200; // Multiplier represented as percentage (e.g., 200 for 2x, 100 for 1x)

    // Governance
    uint256 public nextProposalId;
    mapping(uint256 => Proposal) public proposals;
    uint256 public votingPeriod; // Duration of voting in seconds
    uint256 public quorumPercentage; // Percentage of total voting power required for a proposal to pass (e.g., 4000 for 40%)
    uint256 public minRepForProposal; // Minimum AetherRep required to create a proposal
    uint256 public minAFTStakeForProposal; // Minimum AFT tokens staked to create a proposal

    // Staking
    mapping(address => uint256) public stakedAFTBalances;
    mapping(address => uint256) public lastStakeRewardClaimTime;
    uint256 public constant STAKING_REWARD_RATE_PER_SECOND = 1e12; // Example: 0.000001 AFT per staked AFT per second (adjust units)

    // Dynamic Adaptive Mechanism (Oracle/AI)
    uint256 public marketSentimentIndex; // 0-100, 50 is neutral, >50 bullish, <50 bearish
    uint256 public lastMarketSentimentUpdate;
    address public protocolFeeRecipient;
    uint256 public protocolFeeBasisPoints; // e.g., 50 (0.5%)

    // Impact Fund (conceptually, funds are part of main treasury but earmarked)
    mapping(address => uint256) public impactFundEarmarkedAssets; // Balances of assets specifically earmarked for impact initiatives

    // --- Structs & Enums ---

    enum ProposalState { Pending, Active, Succeeded, Defeated, Executed, Canceled }

    struct Proposal {
        address proposer;
        bytes32 proposalTypeHash; // e.g., keccak256("InvestmentStrategy"), keccak256("ImpactInitiative"), keccak256("ParameterChange")
        address targetAddress;      // The address the call will be made to (e.g., this contract for internal calls)
        bytes callData;             // The data for the call (function signature + encoded arguments)
        string descriptionHash;     // IPFS hash or similar for longer description
        uint256 voteStart;
        uint256 voteEnd;
        uint256 forVotes;           // Weighted votes for the proposal
        uint256 againstVotes;       // Weighted votes against the proposal
        ProposalState state;
        bool executed;
    }

    // --- Events ---

    event AssetsDeposited(address indexed user, address indexed asset, uint256 amount);
    event AssetsWithdrawn(address indexed user, address indexed asset, uint256 amount);
    event InvestmentStrategyProposed(uint256 indexed proposalId, address indexed proposer, string descriptionHash);
    event InvestmentStrategyApplied(address[] assets, uint256[] percentages);
    event AetherRepUpdated(address indexed user, uint256 newScore, int256 delta);
    event AetherRepDelegated(address indexed delegator, address indexed delegatee);
    event ProposalCreated(uint256 indexed proposalId, address indexed proposer, bytes32 proposalTypeHash, string descriptionHash);
    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support, uint256 weightedVotes);
    event ProposalExecuted(uint256 indexed proposalId, address indexed executor);
    event ProposalCanceled(uint256 indexed proposalId);
    event MarketSentimentUpdated(uint256 newSentiment, uint256 timestamp);
    event ImpactInitiativeProposed(uint256 indexed proposalId, address indexed proposer, string descriptionHash, uint256 amount, address recipient);
    event ImpactInitiativeFunded(uint256 indexed proposalId, address indexed funder, uint256 amount, address recipient);
    event AFTStaked(address indexed user, uint256 amount);
    event AFTUnstaked(address indexed user, uint256 amount);
    event StakingRewardsClaimed(address indexed user, uint256 amount);
    event ProtocolFeeRecipientSet(address indexed newRecipient);
    event OracleAddressUpdated(address indexed newOracle);
    event VotingPeriodSet(uint256 newPeriod);
    event QuorumPercentageSet(uint256 newPercentage);
    event MinRepForProposalSet(uint256 newMinRep);
    event MinAFTStakeForProposalSet(uint256 newMinStake);

    // --- Constructor ---

    constructor(address _aftToken, address _oracle, address _initialFeeRecipient)
        Ownable(msg.sender)
        Pausable()
    {
        require(_aftToken != address(0), "AetherFluxDAO: AFT token address cannot be zero");
        require(_oracle != address(0), "AetherFluxDAO: Oracle address cannot be zero");
        require(_initialFeeRecipient != address(0), "AetherFluxDAO: Fee recipient address cannot be zero");

        aftToken = IERC20(_aftToken);
        oracle = IOracle(_oracle);
        protocolFeeRecipient = _initialFeeRecipient;
        protocolFeeBasisPoints = 50; // 0.5% default

        // Initial governance parameters (can be changed by DAO later via governance proposals)
        votingPeriod = 7 days; // 7 days
        quorumPercentage = 4000; // 40%
        minRepForProposal = 100; // 100 AetherRep
        minAFTStakeForProposal = 100e18; // 100 AFT (assuming 18 decimals)
    }

    // --- Modifiers ---

    modifier onlyOracle() {
        require(msg.sender == address(oracle), "AetherFluxDAO: Only oracle can call this function");
        _;
    }

    modifier onlyDaoOwner() {
        // In a fully decentralized DAO, `Ownable` role typically transfers to a `Timelock`
        // or a governance contract itself. For this example, it represents the initial admin
        // or a dedicated governance multisig/contract that would evolve.
        require(owner() == msg.sender, "AetherFluxDAO: Only owner can call this function");
        _;
    }

    // --- I. Core Setup & Access Control ---

    function updateOracleAddress(address _newOracle) public virtual onlyDaoOwner {
        require(_newOracle != address(0), "AetherFluxDAO: New oracle address cannot be zero");
        oracle = IOracle(_newOracle);
        emit OracleAddressUpdated(_newOracle);
    }

    function setProtocolFeeRecipient(address _newRecipient) public virtual onlyDaoOwner {
        require(_newRecipient != address(0), "AetherFluxDAO: New fee recipient cannot be zero");
        protocolFeeRecipient = _newRecipient;
        emit ProtocolFeeRecipientSet(_newRecipient);
    }

    function pauseContract() public virtual onlyDaoOwner {
        _pause();
    }

    function unpauseContract() public virtual onlyDaoOwner {
        _unpause();
    }

    // --- II. Treasury Management & Investment Strategies ---

    function depositAssets(address _asset, uint256 _amount) public whenNotPaused {
        require(_asset != address(0), "AetherFluxDAO: Asset address cannot be zero");
        require(_amount > 0, "AetherFluxDAO: Deposit amount must be greater than zero");

        // Add asset to supported assets if new
        bool isSupported = false;
        for (uint i = 0; i < supportedAssets.length; i++) {
            if (supportedAssets[i] == _asset) {
                isSupported = true;
                break;
            }
        }
        if (!isSupported) {
            supportedAssets.push(_asset);
        }

        IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);
        assetBalances[_asset] += _amount;

        // Optionally, give AetherRep for contributing to treasury
        _updateAetherRep(msg.sender, 5); // Example: 5 reputation points for deposit
        emit AssetsDeposited(msg.sender, _asset, _amount);
    }

    function withdrawAssets(address _asset, uint256 _amount) public whenNotPaused {
        require(_asset != address(0), "AetherFluxDAO: Asset address cannot be zero");
        require(_amount > 0, "AetherFluxDAO: Withdraw amount must be greater than zero");
        require(assetBalances[_asset] >= _amount, "AetherFluxDAO: Insufficient treasury balance for this asset");

        // In a real DAO, withdrawals of collective treasury assets would typically be governance-controlled,
        // or user-specific deposits would be tracked separately with defined lock-ups/fees.
        // This function as written allows the DAO (via governance) to release assets.
        uint256 fee = _amount * protocolFeeBasisPoints / 10000;
        uint256 amountToUser = _amount - fee;

        assetBalances[_asset] -= _amount;
        IERC20(_asset).safeTransfer(msg.sender, amountToUser);
        if (fee > 0) {
            IERC20(_asset).safeTransfer(protocolFeeRecipient, fee);
        }

        emit AssetsWithdrawn(msg.sender, _asset, amountToUser);
    }

    function proposeInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages, string calldata _descriptionHash) public whenNotPaused returns (uint256) {
        require(getAetherRep(msg.sender) >= minRepForProposal, "AetherFluxDAO: Insufficient AetherRep to propose");
        require(stakedAFTBalances[msg.sender] >= minAFTStakeForProposal, "AetherFluxDAO: Insufficient AFT staked to propose");
        require(_assets.length == _percentages.length, "AetherFluxDAO: Asset and percentage arrays must match length");
        require(_assets.length > 0, "AetherFluxDAO: Must propose at least one asset");

        uint256 sumPercentages = 0;
        for (uint i = 0; i < _percentages.length; i++) {
            sumPercentages += _percentages[i];
        }
        require(sumPercentages == 10000, "AetherFluxDAO: Percentages must sum to 10000 (100%)"); // 10000 for 100%

        // Encode the strategy as callData for the internal _applyInvestmentStrategy function
        bytes memory callData = abi.encodeWithSelector(
            this._applyInvestmentStrategy.selector,
            _assets,
            _percentages
        );

        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            proposer: msg.sender,
            proposalTypeHash: keccak256("InvestmentStrategy"),
            targetAddress: address(this), // The target for the callData is this contract itself
            callData: callData,
            descriptionHash: _descriptionHash,
            voteStart: block.timestamp,
            voteEnd: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            state: ProposalState.Active,
            executed: false
        });

        _updateAetherRep(msg.sender, 10); // Example: 10 reputation points for proposing
        emit InvestmentStrategyProposed(proposalId, msg.sender, _descriptionHash);
        emit ProposalCreated(proposalId, msg.sender, keccak256("InvestmentStrategy"), _descriptionHash);
        return proposalId;
    }

    // Internal function to be called via governance proposal execution (executeProposal -> .call(callData))
    function _applyInvestmentStrategy(address[] calldata _assets, uint256[] calldata _percentages) internal {
        require(_assets.length == _percentages.length, "AetherFluxDAO: Asset and percentage arrays must match length");

        // Clear previous allocations and sum
        totalAllocationPercentage = 0;
        for(uint i = 0; i < supportedAssets.length; i++) {
            assetTargetAllocations[supportedAssets[i]] = 0;
        }

        // Set new allocations
        for (uint i = 0; i < _assets.length; i++) {
            require(_assets[i] != address(0), "AetherFluxDAO: Asset address cannot be zero");
            assetTargetAllocations[_assets[i]] = _percentages[i];
            totalAllocationPercentage += _percentages[i];

            // Ensure asset is marked as supported
            bool isSupported = false;
            for (uint j = 0; j < supportedAssets.length; j++) {
                if (supportedAssets[j] == _assets[i]) {
                    isSupported = true;
                    break;
                }
            }
            if (!isSupported) {
                supportedAssets.push(_assets[i]);
            }
        }
        require(totalAllocationPercentage == 10000, "AetherFluxDAO: Internal error - percentages not 100%"); // Must sum to 100%

        emit InvestmentStrategyApplied(_assets, _percentages);
        // In a full implementation, this would trigger actual swaps/rebalancing to match new targets.
        // For this example, it only updates the targets.
    }

    function getTreasuryValueUSD() public view returns (uint256) {
        uint256 totalValue = 0;
        for (uint i = 0; i < supportedAssets.length; i++) {
            address asset = supportedAssets[i];
            uint256 balance = assetBalances[asset];
            if (balance > 0) {
                int256 price = oracle.getLatestPrice(asset); // Price in USD, scaled (assuming 18 decimals)
                require(price > 0, "AetherFluxDAO: Oracle price for asset is zero or negative");
                // Assuming oracle provides prices scaled to 18 decimals for direct multiplication with token balances (also 18 decimals).
                // Example: 1 token (1e18) * $2000 (2000e18) / 1e18 = $2000e18.
                // Final result in 18 decimals USD value.
                totalValue += (balance * uint256(price)) / (10**18);
            }
        }
        return totalValue;
    }

    function getAssetAllocationPercentages() public view returns (address[] memory assets, uint256[] memory percentages) {
        assets = new address[](supportedAssets.length);
        percentages = new uint256[](supportedAssets.length);
        for (uint i = 0; i < supportedAssets.length; i++) {
            assets[i] = supportedAssets[i];
            percentages[i] = assetTargetAllocations[supportedAssets[i]];
        }
        return (assets, percentages);
    }

    // --- III. AetherRep (Reputation System) ---

    // Internal helper for decay calculation
    function _calculateAetherRepWithDecay(address _user) internal view returns (uint256) {
        uint256 rawRep = aetherRepScores[_user];
        if (rawRep == 0) return 0;

        uint256 lastActivity = lastAetherRepActivity[_user];
        if (lastActivity == 0 || lastActivity >= block.timestamp) { // No decay if never active or activity is current
            return rawRep;
        }

        uint256 daysInactive = (block.timestamp - lastActivity) / 1 days;
        uint256 decayAmount = daysInactive * AETHER_REP_DECAY_RATE_PER_DAY;

        return rawRep > decayAmount ? rawRep - decayAmount : 0;
    }

    function getAetherRep(address _user) public view returns (uint256) {
        return _calculateAetherRepWithDecay(_user);
    }

    // Internal function to update AetherRep, only callable by the contract itself
    function _updateAetherRep(address _user, int256 _delta) internal {
        uint256 currentRep = _calculateAetherRepWithDecay(_user);
        int256 newRepSigned = int256(currentRep) + _delta;
        uint256 newRep = newRepSigned > 0 ? uint256(newRepSigned) : 0; // Ensure score doesn't go below zero

        aetherRepScores[_user] = newRep;
        lastAetherRepActivity[_user] = block.timestamp;
        emit AetherRepUpdated(_user, newRep, _delta);
    }

    function delegateAetherRepVote(address _delegatee) public whenNotPaused {
        require(aetherRepDelegates[msg.sender] == address(0), "AetherFluxDAO: Already delegated");
        require(_delegatee != address(0), "AetherFluxDAO: Delegatee cannot be zero address");
        require(_delegatee != msg.sender, "AetherFluxDAO: Cannot delegate to self");

        aetherRepDelegates[msg.sender] = _delegatee;
        _updateAetherRep(msg.sender, 1); // Small rep gain for delegation
        emit AetherRepDelegated(msg.sender, _delegatee);
    }

    function undelegateAetherRepVote() public whenNotPaused {
        require(aetherRepDelegates[msg.sender] != address(0), "AetherFluxDAO: No active delegation");
        delete aetherRepDelegates[msg.sender];
        _updateAetherRep(msg.sender, -1); // Small rep loss for undelegation (or neutral)
        emit AetherRepDelegated(msg.sender, address(0)); // Signifies undelegation
    }

    function getAetherRepBoostMultiplier(address _user) public view returns (uint256) {
        uint256 rep = getAetherRep(_user);
        if (rep == 0) return 100; // No boost (100% or 1x)

        uint256 effectiveRep = Math.min(rep, AETHER_REP_MAX_BOOST);
        // Multiplier: 100 + (effectiveRep * (AETHER_REP_BOOST_FACTOR - 100)) / AETHER_REP_MAX_BOOST
        // Example: MAX_BOOST=1000, BOOST_FACTOR=200 (2x)
        // If rep = 1000: 100 + (1000 * (200-100)) / 1000 = 100 + 100 = 200 (2x)
        // If rep = 500: 100 + (500 * (200-100)) / 1000 = 100 + 50 = 150 (1.5x)
        uint256 multiplier = 100 + (effectiveRep * (AETHER_REP_BOOST_FACTOR - 100)) / AETHER_REP_MAX_BOOST;
        return multiplier; // Returns value like 110 for 1.1x, 200 for 2x (scaled by 100)
    }

    // --- IV. Governance (Proposals & Voting) ---

    function createProposal(bytes32 _proposalTypeHash, address _target, bytes calldata _callData, string calldata _descriptionHash) public whenNotPaused returns (uint256) {
        require(getAetherRep(msg.sender) >= minRepForProposal, "AetherFluxDAO: Insufficient AetherRep to create proposal");
        require(stakedAFTBalances[msg.sender] >= minAFTStakeForProposal, "AetherFluxDAO: Insufficient AFT staked to create proposal");
        require(_target != address(0), "AetherFluxDAO: Target address cannot be zero");

        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            proposer: msg.sender,
            proposalTypeHash: _proposalTypeHash,
            targetAddress: _target,
            callData: _callData,
            descriptionHash: _descriptionHash,
            voteStart: block.timestamp,
            voteEnd: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            state: ProposalState.Active,
            executed: false
        });

        _updateAetherRep(msg.sender, 15); // Example: 15 reputation for creating a proposal
        emit ProposalCreated(proposalId, msg.sender, _proposalTypeHash, _descriptionHash);
        return proposalId;
    }

    function voteOnProposal(uint256 _proposalId, bool _support) public whenNotPaused {
        Proposal storage p = proposals[_proposalId];
        require(p.state == ProposalState.Active, "AetherFluxDAO: Proposal is not active for voting");
        require(block.timestamp >= p.voteStart && block.timestamp < p.voteEnd, "AetherFluxDAO: Voting period is over or not started");

        address voterAddress = msg.sender;
        // Use delegated address for vote power check if delegation exists
        if (aetherRepDelegates[msg.sender] != address(0)) {
            voterAddress = aetherRepDelegates[msg.sender];
        }

        uint256 voterAFTBalance = aftToken.balanceOf(voterAddress); // Get AFT balance for voting
        require(voterAFTBalance > 0, "AetherFluxDAO: Voter has no AFT tokens to cast vote");

        // Calculate weighted vote: AFT balance * (AetherRep_Boost_Multiplier / 100)
        uint256 weightedVotes = (voterAFTBalance * getAetherRepBoostMultiplier(voterAddress)) / 100;

        if (_support) {
            p.forVotes += weightedVotes;
        } else {
            p.againstVotes += weightedVotes;
        }

        _updateAetherRep(msg.sender, 1); // Small rep gain for voting (on voter's address, not delegatee)
        emit VoteCast(_proposalId, msg.sender, _support, weightedVotes);
    }

    function executeProposal(uint256 _proposalId) public whenNotPaused {
        Proposal storage p = proposals[_proposalId];
        require(p.state == ProposalState.Active, "AetherFluxDAO: Proposal is not active (must be executed after voting ends)");
        require(block.timestamp >= p.voteEnd, "AetherFluxDAO: Voting period not yet ended");
        require(!p.executed, "AetherFluxDAO: Proposal already executed");

        uint256 totalVotes = p.forVotes + p.againstVotes;
        uint256 totalAFTSupply = aftToken.totalSupply(); // Using total supply for quorum reference

        // Calculate max theoretical voting power (if all supply had max reputation boost)
        uint256 maxPossibleWeightedVotes = (totalAFTSupply * AETHER_REP_BOOST_FACTOR) / 100;
        uint256 requiredQuorumVotes = (maxPossibleWeightedVotes * quorumPercentage) / 10000; // 10000 for 100%

        if (totalVotes < requiredQuorumVotes) {
            p.state = ProposalState.Defeated;
            emit ProposalExecuted(_proposalId, msg.sender); // Emit status change even if defeated
            _updateAetherRep(p.proposer, -20); // Rep loss for defeated proposal
            return;
        }

        // Check majority: For votes must be strictly greater than Against votes
        if (p.forVotes > p.againstVotes) {
            p.state = ProposalState.Succeeded;
            p.executed = true;

            // Execute the proposal's action using low-level call
            // This allows the DAO to execute arbitrary calls on arbitrary targets (including itself)
            (bool success, ) = p.targetAddress.call(p.callData);
            require(success, "AetherFluxDAO: Proposal execution failed");

            emit ProposalExecuted(_proposalId, msg.sender);
            _updateAetherRep(p.proposer, 50); // Significant rep boost for successful proposal
        } else {
            p.state = ProposalState.Defeated;
            emit ProposalExecuted(_proposalId, msg.sender); // Emit status change even if defeated
            _updateAetherRep(p.proposer, -20); // Rep loss for defeated proposal
        }
    }

    function cancelProposal(uint256 _proposalId) public whenNotPaused {
        Proposal storage p = proposals[_proposalId];
        require(p.state == ProposalState.Active, "AetherFluxDAO: Proposal not active");
        require(msg.sender == p.proposer || getAetherRep(msg.sender) >= (minRepForProposal * 2), "AetherFluxDAO: Only proposer or high-rep member can cancel");

        p.state = ProposalState.Canceled;
        emit ProposalCanceled(_proposalId);
        _updateAetherRep(p.proposer, -5); // Small rep loss for cancelling
    }

    // DAO Governance Parameter Adjustments (callable via governance proposals targeting `this` contract)
    function setVotingPeriod(uint256 _newPeriod) public onlyDaoOwner {
        require(_newPeriod > 0, "AetherFluxDAO: Voting period must be greater than zero");
        votingPeriod = _newPeriod;
        emit VotingPeriodSet(_newPeriod);
    }

    function setQuorumPercentage(uint256 _newPercentage) public onlyDaoOwner {
        require(_newPercentage <= 10000, "AetherFluxDAO: Quorum percentage cannot exceed 10000 (100%)");
        quorumPercentage = _newPercentage;
        emit QuorumPercentageSet(_newPercentage);
    }

    function setMinRepForProposal(uint256 _newMinRep) public onlyDaoOwner {
        minRepForProposal = _newMinRep;
        emit MinRepForProposalSet(_newMinRep);
    }

    function setMinAFTStakeForProposal(uint256 _newMinStake) public onlyDaoOwner {
        minAFTStakeForProposal = _newMinStake;
        emit MinAFTStakeForProposalSet(_newMinStake);
    }

    // --- V. Dynamic Adaptive Mechanism (Oracle/AI) ---

    function submitMarketSentimentData(uint256 _sentimentIndex, uint256 _timestamp) public onlyOracle {
        require(_timestamp > lastMarketSentimentUpdate, "AetherFluxDAO: Timestamp must be newer than last update");
        require(_sentimentIndex <= 100, "AetherFluxDAO: Sentiment index out of bounds (0-100)");

        marketSentimentIndex = _sentimentIndex;
        lastMarketSentimentUpdate = _timestamp;
        emit MarketSentimentUpdated(_sentimentIndex, _timestamp);
    }

    function getCurrentMarketSentiment() public view returns (uint256) {
        return marketSentimentIndex;
    }

    function triggerStrategyReassessment() public view {
        // This function is purely a signaling mechanism. It doesn't change state but
        // prompts off-chain observers (keepers/bots/community members) to review
        // the current market sentiment and potentially propose new strategies.
        // For example, if sentiment drastically changes (e.g., drops below 40 or rises above 60),
        // it might be an opportune time for a high-reputation member to propose a
        // more conservative or aggressive investment strategy, earning AetherRep if it passes.
        if (marketSentimentIndex < 40 || marketSentimentIndex > 60) {
            // An event could be emitted here to specifically alert off-chain listeners.
            // For example: `emit MarketSentimentSignificantChange(marketSentimentIndex);`
        }
    }

    // --- VI. Impact Initiatives & Regenerative Finance ---

    function proposeImpactInitiative(string calldata _descriptionHash, uint256 _amount, address _recipient) public whenNotPaused returns (uint256) {
        require(getAetherRep(msg.sender) >= minRepForProposal, "AetherFluxDAO: Insufficient AetherRep to propose impact initiative");
        require(stakedAFTBalances[msg.sender] >= minAFTStakeForProposal, "AetherFluxDAO: Insufficient AFT staked to propose");
        require(_amount > 0, "AetherFluxDAO: Impact fund amount must be greater than zero");
        require(_recipient != address(0), "AetherFluxDAO: Recipient cannot be zero address");

        // For simplicity, assume ETH is used for impact funding. Could be any supported asset.
        require(assetBalances[address(0)] >= _amount, "AetherFluxDAO: Insufficient ETH in treasury for impact initiative");

        // Encode the call to _fundImpactInitiativeInternal for proposal execution
        bytes memory callData = abi.encodeWithSelector(
            this._fundImpactInitiativeInternal.selector,
            _amount,
            _recipient,
            _descriptionHash // Pass description to internal for logging
        );

        uint256 proposalId = nextProposalId++;
        proposals[proposalId] = Proposal({
            proposer: msg.sender,
            proposalTypeHash: keccak256("ImpactInitiative"),
            targetAddress: address(this), // Target is this contract itself
            callData: callData,
            descriptionHash: _descriptionHash,
            voteStart: block.timestamp,
            voteEnd: block.timestamp + votingPeriod,
            forVotes: 0,
            againstVotes: 0,
            state: ProposalState.Active,
            executed: false
        });

        _updateAetherRep(msg.sender, 10); // Rep gain for proposing impact
        emit ImpactInitiativeProposed(proposalId, msg.sender, _descriptionHash, _amount, _recipient);
        emit ProposalCreated(proposalId, msg.sender, keccak256("ImpactInitiative"), _descriptionHash);
        return proposalId;
    }

    // Internal function to be called via governance proposal execution (executeProposal -> .call(callData))
    function _fundImpactInitiativeInternal(uint256 _amount, address _recipient, string calldata _descriptionHash) internal {
        require(assetBalances[address(0)] >= _amount, "AetherFluxDAO: Insufficient ETH in treasury to fund initiative");
        
        assetBalances[address(0)] -= _amount;
        Address.sendValue(_recipient, _amount); // Transfer ETH to recipient

        // Earmarking for accounting purposes (actual funds are sent out)
        impactFundEarmarkedAssets[address(0)] += _amount; 

        // The proposalId will be known by the `executeProposal` context that calls this.
        // For event logging here, we'd need to pass the proposalId as an argument if needed for correlation.
        // As a simpler solution, the `ProposalExecuted` event is enough to confirm funding.
        // If specific ID is needed here, it would be `abi.decode` from callData or passed as arg.
        // Using `0` for proposalId for simplicity in this event, as the main event is `ProposalExecuted`.
        emit ImpactInitiativeFunded(0, msg.sender, _amount, _recipient); 
    }

    function getImpactFundBalanceUSD() public view returns (uint256) {
        // This function reports the total value of assets that HAVE BEEN earmarked for impact initiatives.
        // These funds are typically already spent and sent to the recipients.
        // If this were to reflect *available* impact funds, it would be a separate balance.
        // For simplicity, assuming impact funds are disbursed ETH and we track historical amount.
        uint256 ethEarmarked = impactFundEarmarkedAssets[address(0)];
        if (ethEarmarked == 0) return 0;
        int256 ethPrice = oracle.getLatestPrice(address(0)); // Get ETH price (assuming 18 decimals)
        require(ethPrice > 0, "AetherFluxDAO: Oracle price for ETH is zero or negative");

        // Calculate USD value of earmarked ETH
        return (ethEarmarked * uint256(ethPrice)) / (10**18); // Value in 18 decimals USD
    }

    // --- VII. Staking & Rewards ---

    function stakeAFT(uint256 _amount) public whenNotPaused {
        require(_amount > 0, "AetherFluxDAO: Stake amount must be greater than zero");
        aftToken.safeTransferFrom(msg.sender, address(this), _amount);
        stakedAFTBalances[msg.sender] += _amount;
        _updateAetherRep(msg.sender, 5); // Rep gain for staking

        // Set last claim time to current block.timestamp to ensure rewards accrue from now
        lastStakeRewardClaimTime[msg.sender] = block.timestamp;
        emit AFTStaked(msg.sender, _amount);
    }

    function unstakeAFT(uint256 _amount) public whenNotPaused {
        require(_amount > 0, "AetherFluxDAO: Unstake amount must be greater than zero");
        require(stakedAFTBalances[msg.sender] >= _amount, "AetherFluxDAO: Insufficient staked AFT");

        // First, claim pending rewards before reducing staked balance
        claimStakingRewards();

        stakedAFTBalances[msg.sender] -= _amount;
        aftToken.safeTransfer(msg.sender, _amount);
        _updateAetherRep(msg.sender, -3); // Small rep loss for unstaking

        emit AFTUnstaked(msg.sender, _amount);
    }

    function calculatePendingStakingRewards(address _user) public view returns (uint256) {
        uint256 stakedAmount = stakedAFTBalances[_user];
        if (stakedAmount == 0) return 0;

        uint256 timeElapsed = block.timestamp - lastStakeRewardClaimTime[_user];
        // Rewards = stakedAmount * rate_per_second * timeElapsed
        // Ensure units are consistent (e.g., if rate is per 1e18 token, then all amounts are 1e18)
        // If STAKING_REWARD_RATE_PER_SECOND is 1e12 (0.000001 AFT/sec for 1 AFT staked)
        // Then (stakedAmount (1e18) * 1e12 * time) / 1e18 (to convert back to AFT units) = 1e12 * time
        return (stakedAmount * STAKING_REWARD_RATE_PER_SECOND * timeElapsed) / (10**18); // Assuming 18 decimals for AFT
    }

    function claimStakingRewards() public whenNotPaused {
        uint256 rewards = calculatePendingStakingRewards(msg.sender);
        require(rewards > 0, "AetherFluxDAO: No rewards to claim");
        require(aftToken.balanceOf(address(this)) >= rewards, "AetherFluxDAO: Insufficient AFT for rewards in contract");

        lastStakeRewardClaimTime[msg.sender] = block.timestamp; // Reset timer
        aftToken.safeTransfer(msg.sender, rewards);
        _updateAetherRep(msg.sender, 2); // Small rep gain for claiming rewards

        emit StakingRewardsClaimed(msg.sender, rewards);
    }

    // --- Fallback & Receive Functions ---
    // Allows sending Ether directly to the contract, which is treated as a deposit.
    receive() external payable {
        depositAssets(address(0), msg.value); // Address(0) represents native ETH
    }

    // Fallback function for any calls to functions that don't exist.
    fallback() external payable {
        revert("AetherFluxDAO: Unexpected call");
    }
}
```