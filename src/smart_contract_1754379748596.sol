This smart contract, `ChronoKineticSentinels`, represents a novel concept in the realm of dynamic, evolving NFTs driven by on-chain economic activity and external environmental factors. It aims to create a self-sustaining ecosystem where unique digital entities (Sentinels) grow, decay, and interact based on a custom resource called "Kinetic Energy" (KE).

---

## Contract: ChronoKineticSentinels

**Outline:**

1.  **Core Concept:**
    *   Dynamic ERC-721 NFTs (Sentinels) that evolve through distinct stages.
    *   Evolution is driven by a custom resource: "Kinetic Energy" (KE).
    *   KE is generated by staking approved ERC-20 collateral.
    *   External "Environmental Factors" (via oracles) influence KE generation and evolution outcomes.
    *   Gamified interactions: Bonding Sentinels for synergy, Siphoning KE from others.
    *   Deflationary mechanics: Sentinel decay, and "Ascension" (burning multiple for a rarer one).
    *   Community-driven rule changes (simplified governance).

2.  **Interfaces & Imports:**
    *   `ERC721Enumerable`: For basic NFT functionalities and token tracking.
    *   `IERC20`: For collateral interaction.
    *   `Ownable`: For administrative control.
    *   `IRandomWordsConsumer` (Chainlink VRF): For random outcomes in interactions.
    *   `IAggregatorV3` (Chainlink Data Feeds): For environmental factors.

3.  **State Variables & Data Structures:**
    *   `Sentinel` struct: Stores unique attributes, evolution stage, last KE claim time, bond status.
    *   `EvolutionStage` enum: Defines growth phases.
    *   Mappings: For Sentinels, user KE balances, staked collateral, oracle data.
    *   Configuration parameters: KE generation rates, evolution costs, decay rates, fees.

4.  **Events:** Comprehensive logging of all significant state changes (minting, evolving, KE claims, bonding, etc.).

5.  **Errors:** Custom errors for specific failure conditions, improving revert messages.

6.  **Functions Categories (At least 20 unique functions):**

    *   **I. Core Sentinel Management (ERC-721 Related):**
        *   `mintSentinel`: Creates a new Sentinel NFT.
        *   `tokenURI`: Generates dynamic metadata based on Sentinel's state.
        *   `setBaseURI`: Sets the base for metadata URIs.
        *   `setEvolutionStageConfig`: Configures costs and requirements for each evolution stage.

    *   **II. Kinetic Energy (KE) System:**
        *   `depositCollateralForKE`: Locks ERC-20 tokens to start generating KE.
        *   `withdrawCollateral`: Unlocks staked collateral.
        *   `claimKineticEnergy`: Collects accumulated KE.
        *   `siphonKineticEnergy`: Allows a Sentinel to attempt to "siphon" KE from another, with a random outcome.
        *   `updateKEGenerationRate`: Sets the rate at which staked collateral generates KE.
        *   `setApprovedCollateralToken`: Whitelists an ERC-20 token for staking.

    *   **III. Sentinel Evolution & Interaction:**
        *   `evolveSentinel`: Advances a Sentinel to the next evolution stage using KE.
        *   `decaySentinel`: Initiates decay for neglected Sentinels, potentially reducing their stats or stage.
        *   `ascendSentinels`: Burns multiple Sentinels to create a single, higher-tier, rarer Sentinel.
        *   `bondSentinels`: Establishes a symbiotic link between two Sentinels for potential bonuses.
        *   `unbondSentinels`: Breaks a bonded connection.
        *   `setDecayConfiguration`: Configures decay thresholds and effects.
        *   `setAscensionRequirements`: Sets the cost (number of Sentinels) for ascension.

    *   **IV. Environmental Factors & Oracles (Chainlink Integration):**
        *   `requestEnvironmentalFactorUpdate`: Triggers a Chainlink Data Feed request for an environmental factor (e.g., market volatility).
        *   `fulfillEnvironmentalFactorUpdate`: Callback function for Chainlink Data Feed results.
        *   `requestRandomWords`: Triggers Chainlink VRF for random numbers (used in Siphoning).
        *   `rawFulfillRandomWords`: Callback for Chainlink VRF results.
        *   `setEnvironmentalImpactMultiplier`: Adjusts how environmental factors affect KE generation/evolution.

    *   **V. Treasury & Governance (Simplified):**
        *   `withdrawTreasuryFunds`: Allows the owner/governance to withdraw accumulated fees.
        *   `proposeEvolutionRuleChange`: Placeholder for a more advanced governance system.
        *   `voteOnProposal`: Placeholder for voting.
        *   `executeProposal`: Placeholder for executing approved changes.
        *   `setFeeRecipient`: Sets the address where operational fees are sent.

    *   **VI. View Functions:**
        *   `getSentinelDetails`: Retrieves all details of a specific Sentinel.
        *   `getKineticEnergyBalance`: Gets a user's total KE.
        *   `getCollateralStaked`: Gets a user's staked collateral for a specific token.
        *   `getEnvironmentalFactor`: Retrieves the current environmental factor.
        *   `getKEGenerationRate`: Retrieves the current KE generation rate.

---

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

// Custom Errors for better readability and gas efficiency
error NotEnoughKineticEnergy(uint256 required, uint256 provided);
error SentinelNotFound(uint256 tokenId);
error InvalidEvolutionStage();
error NotOwnerOrApproved();
error CannotEvolveYet(uint256 nextEvolutionTime);
error NotEnoughCollateral(uint256 required, uint256 provided);
error CollateralNotApproved();
error CannotSiphonSelf();
error SiphonFailed(string reason);
error SentinelAlreadyBonded();
error SentinelsNotBonded();
error InvalidOracleResponse();
error UnauthorizedCall();
error NoFundsToWithdraw();
error AlreadyAtMaxStage();
error NotEligibleForDecay();
error NotEnoughSentinelsForAscension(uint256 required, uint256 provided);
error CollateralTokenNotWhitelisted();
error RandomnessRequestFailed(uint256 requestId, uint256 callbackGasLimit);


/**
 * @title ChronoKineticSentinels
 * @dev A smart contract for dynamic, evolving NFTs driven by a custom "Kinetic Energy" (KE) resource.
 *      Sentinels evolve through stages, gain KE by staking collateral, and interact based on
 *      external environmental factors via Chainlink Oracles. Features gamified mechanics like
 *      bonding, siphoning, decay, and ascension.
 */
contract ChronoKineticSentinels is ERC721Enumerable, Ownable, VRFConsumerBaseV2 {
    using Strings for uint256;

    // --- State Variables ---

    // Constants
    uint256 public constant KINETIC_ENERGY_DECIMALS = 18; // KE is fixed to 18 decimals, like Ether
    uint256 public constant MAX_EVOLUTION_STAGE = 5; // Example max stage

    // Sentinel Data Structures
    enum EvolutionStage { Hatchling, Juvenile, Adult, Elder, Mythic, Ascended }

    struct Sentinel {
        uint256 id;
        EvolutionStage stage;
        uint256 birthTime;
        uint256 lastKEConsumptionTime; // Last time KE was spent on evolution or other action
        uint256 lastKECalculationTime; // Last time KE was generated or claimed
        uint256 bondedWith; // 0 if not bonded, otherwise the bonded Sentinel ID
        uint256 nextEvolutionCost;
        uint256 nextEvolutionCooldown; // Cooldown after evolving
        uint256 decayThreshold; // Timestamp after which decay might begin
        uint256 strength; // Affects siphon outcome, for example
        uint256 resilience; // Affects decay resistance, for example
    }

    struct EvolutionConfig {
        uint256 keCost;
        uint256 cooldownDuration; // Duration in seconds after evolving before next evolution
        uint256 decayThresholdDuration; // Duration in seconds after which decay can start
        uint256 strengthBonus;
        uint256 resilienceBonus;
    }

    // Mappings for core data
    mapping(uint256 => Sentinel) private _sentinels;
    uint256 private _nextTokenId;

    // Kinetic Energy System
    mapping(address => uint256) public userKineticEnergy; // User's total claimable KE
    mapping(address => mapping(address => uint256)) public collateralStaked; // user => tokenAddress => amount

    mapping(address => bool) public approvedCollateralTokens; // Whitelisted ERC-20 tokens for staking

    uint256 public keGenerationRatePerSecondPerUnitCollateral; // KE generated per second per 1 unit of collateral (e.g., 1e18 for 1 token)
    uint256 public constant KE_RATE_DENOMINATOR = 1e18; // To allow for fractional rates

    // Evolution Configuration
    mapping(uint256 => EvolutionConfig) public evolutionStageConfigs; // stage => config

    // Decay Configuration
    uint256 public decayRatePerDay; // KE deducted per day for decayed Sentinels
    uint256 public decayEffectMultiplier; // Multiplier for stat reduction or stage reduction

    // Ascension Configuration
    uint256 public sentinelsRequiredForAscension;
    uint256 public ascensionKEModifier; // KE bonus or penalty during ascension

    // Environmental Factors (Chainlink Data Feed)
    AggregatorV3Interface public priceFeedOracle; // Example: For market volatility factor
    int256 public currentEnvironmentalFactor; // e.g., market volatility index
    uint256 public environmentalImpactMultiplier; // How environmental factor affects KE generation

    // Chainlink VRF for randomness
    VRFCoordinatorV2Interface public immutable i_vrfCoordinator;
    uint64 public immutable i_subscriptionId;
    bytes32 public immutable i_keyHash;
    uint32 public constant REQUEST_CONFIRMATIONS = 3;
    uint32 public constant NUM_WORDS = 1;
    uint32 public s_callbackGasLimit; // settable gas limit for VRF callback
    mapping(uint256 => uint256) public s_requestIdToTokenId; // Maps Chainlink request ID to Sentinel ID for siphon

    // Treasury and Fees
    address public feeRecipient;
    uint256 public evolutionFeePercentage; // % of KE cost sent to treasury
    uint256 public siphonFeePercentage; // % of siphoned KE sent to treasury

    // Base URI for metadata
    string private _baseTokenURI;

    // --- Constructor ---

    constructor(
        address vrfCoordinator,
        uint64 subscriptionId,
        bytes32 keyHash,
        uint32 callbackGasLimit,
        address initialPriceFeed,
        address initialFeeRecipient,
        uint256 initialKEGenerationRate,
        uint256 initialEvolutionFeePercentage,
        uint256 initialSiphonFeePercentage,
        uint256 initialSentinelsForAscension,
        uint256 initialDecayRate,
        uint256 initialDecayEffectMultiplier
    ) ERC721("ChronoKineticSentinels", "CKS") VRFConsumerBaseV2(vrfCoordinator) Ownable(msg.sender) {
        i_vrfCoordinator = VRFCoordinatorV2Interface(vrfCoordinator);
        i_subscriptionId = subscriptionId;
        i_keyHash = keyHash;
        s_callbackGasLimit = callbackGasLimit;

        priceFeedOracle = AggregatorV3Interface(initialPriceFeed);
        feeRecipient = initialFeeRecipient;

        keGenerationRatePerSecondPerUnitCollateral = initialKEGenerationRate; // e.g., 1e16 means 0.01 KE per second per unit
        evolutionFeePercentage = initialEvolutionFeePercentage; // e.g., 500 for 5%
        siphonFeePercentage = initialSiphonFeePercentage; // e.g., 1000 for 10%

        sentinelsRequiredForAscension = initialSentinelsForAscension;
        ascensionKEModifier = 0; // Default: no KE bonus/penalty for ascension

        decayRatePerDay = initialDecayRate;
        decayEffectMultiplier = initialDecayEffectMultiplier; // e.g., 100 for 1% stat reduction per decay cycle

        // Initial configuration for Hatchling (Stage 0)
        evolutionStageConfigs[uint256(EvolutionStage.Hatchling)] = EvolutionConfig({
            keCost: 0,
            cooldownDuration: 0,
            decayThresholdDuration: 3 days,
            strengthBonus: 50,
            resilienceBonus: 50
        });

        // Example configurations for other stages (can be set by owner/governance)
        evolutionStageConfigs[uint256(EvolutionStage.Juvenile)] = EvolutionConfig({
            keCost: 100 ether,
            cooldownDuration: 7 days,
            decayThresholdDuration: 10 days,
            strengthBonus: 100,
            resilienceBonus: 100
        });
        evolutionStageConfigs[uint256(EvolutionStage.Adult)] = EvolutionConfig({
            keCost: 500 ether,
            cooldownDuration: 14 days,
            decayThresholdDuration: 21 days,
            strengthBonus: 200,
            resilienceBonus: 200
        });
    }

    // --- Events ---
    event SentinelMinted(uint256 indexed tokenId, address indexed owner, EvolutionStage stage, uint256 birthTime);
    event KineticEnergyClaimed(address indexed user, uint256 amount);
    event CollateralDeposited(address indexed user, address indexed tokenAddress, uint256 amount);
    event CollateralWithdrawn(address indexed user, address indexed tokenAddress, uint256 amount);
    event SentinelEvolved(uint256 indexed tokenId, EvolutionStage oldStage, EvolutionStage newStage, uint256 keSpent);
    event SentinelDecayed(uint256 indexed tokenId, EvolutionStage oldStage, EvolutionStage newStage, uint256 statReduction);
    event SentinelsAscended(address indexed user, uint256[] burnedTokenIds, uint256 newSentinelId);
    event SentinelsBonded(uint256 indexed tokenId1, uint256 indexed tokenId2);
    event SentinelsUnbonded(uint256 indexed tokenId1, uint256 indexed tokenId2);
    event KineticEnergySiphoned(uint256 indexed siphonnerId, uint256 indexed targetId, uint256 siphonedAmount, bool success);
    event EnvironmentalFactorUpdated(int256 newFactor, uint256 timestamp);
    event RandomnessRequested(uint256 indexed requestId, uint256 indexed tokenId);
    event RandomnessFulfilled(uint256 indexed requestId, uint256 indexed tokenId, uint256 randomWord);
    event TreasuryFundsWithdrawn(address indexed recipient, uint256 amount);
    event KEGenerationRateUpdated(uint256 newRate);
    event EvolutionConfigUpdated(uint256 stage, uint256 keCost, uint256 cooldown, uint256 decayThreshold);
    event DecayConfigUpdated(uint256 newRate, uint256 newEffectMultiplier);
    event AscensionRequirementsUpdated(uint256 newRequired, uint256 newKEModifier);
    event CollateralTokenWhitelisted(address indexed tokenAddress, bool status);
    event EnvironmentalImpactMultiplierUpdated(uint256 newMultiplier);
    event FeeRecipientUpdated(address indexed newRecipient);
    event FeePercentagesUpdated(uint256 newEvolutionFee, uint256 newSiphonFee);
    event CallbackGasLimitUpdated(uint32 newLimit);


    // --- Internal/Helper Functions ---

    /**
     * @dev Calculates the Kinetic Energy generated for a user since their last calculation time.
     * @param _user The address of the user.
     * @return The amount of KE generated since last calculation.
     */
    function _calculateGeneratedKE(address _user) internal view returns (uint256) {
        uint256 totalCollateral = 0;
        for (uint256 i = 0; i < _tokenIdsOfOwner[_user].length(); i++) {
            address tokenAddress = _tokenIdsOfOwner[_user].at(i); // This is a placeholder as ERC721Enumerable doesn't store collateral per token, rather per user
            // In a real scenario, collateralStaked would need to be iterated across whitelisted tokens
            // For simplicity, we assume one primary collateral token or a sum of all approved ones.
            // A more robust system would require tracking *which* collateral contributes to *which* sentinel or a global pool.
            // For this example, let's assume it's a sum of ALL whitelisted tokens collateral.
            if (approvedCollateralTokens[tokenAddress]) { // This check is conceptual; a better approach is needed
                totalCollateral += collateralStaked[_user][tokenAddress];
            }
        }
        
        // This is a simplified calculation. In a real scenario, you'd track last update time for each collateral deposit.
        // For simplicity, we will calculate based on global user KE and last claim time.
        // This function will need significant modification if `collateralStaked` is multi-token.
        // For now, let's just make it simple assuming total collateral directly converts.

        // This function will primarily be used to calculate `userKineticEnergy`.
        // The implementation needs to properly track how long collateral has been staked.
        // For a more precise model, each `depositCollateralForKE` and `withdrawCollateral`
        // would also update the user's current KE balance using `_updateUserKineticEnergy`.
        
        // Placeholder logic:
        // uint256 timeElapsed = block.timestamp - lastKEGenerationTime[_user];
        // uint256 generatedKE = (totalCollateral * keGenerationRatePerSecondPerUnitCollateral * timeElapsed * environmentalImpactMultiplier) / (KE_RATE_DENOMINATOR * 1e18);
        
        // As _updateUserKineticEnergy is called on deposit/withdraw/claim,
        // this function's logic becomes redundant unless there's an external trigger.
        // We'll rely on `_updateUserKineticEnergy` for all calculations.
        return 0; // Return 0 as calculation is handled elsewhere
    }

    /**
     * @dev Updates a user's Kinetic Energy balance based on time elapsed and staked collateral.
     *      This function should be called before any operation that reads or modifies user KE.
     * @param _user The address of the user.
     */
    function _updateUserKineticEnergy(address _user) internal {
        uint256 timeElapsed = block.timestamp - _lastKECalculationTime[_user];
        if (timeElapsed == 0) return;

        uint256 totalCollateralValue = 0;
        for (address token : getApprovedCollateralTokens()) { // Iterate through actual approved tokens
            totalCollateralValue += collateralStaked[_user][token];
        }

        // Apply environmental factor to generation rate
        uint256 effectiveGenerationRate = (keGenerationRatePerSecondPerUnitCollateral * (1e18 + (uint256(currentEnvironmentalFactor) * environmentalImpactMultiplier) / 1000)) / 1e18; // Assuming 1000 for 1% impact

        uint256 generatedKE = (totalCollateralValue * effectiveGenerationRate * timeElapsed) / KE_RATE_DENOMINATOR;
        userKineticEnergy[_user] += generatedKE;
        _lastKECalculationTime[_user] = block.timestamp;
    }

    // This mapping helps track last KE calculation time for each user
    mapping(address => uint256) private _lastKECalculationTime;

    /**
     * @dev Internal function to mint a new Sentinel.
     * @param _to The address to mint the Sentinel to.
     * @return The ID of the newly minted Sentinel.
     */
    function _mintSentinelInternal(address _to) internal returns (uint256) {
        uint256 tokenId = _nextTokenId++;
        _safeMint(_to, tokenId);

        Sentinel storage newSentinel = _sentinels[tokenId];
        newSentinel.id = tokenId;
        newSentinel.stage = EvolutionStage.Hatchling;
        newSentinel.birthTime = block.timestamp;
        newSentinel.lastKEConsumptionTime = block.timestamp; // Start cooldowns from now
        newSentinel.lastKECalculationTime = block.timestamp;
        newSentinel.bondedWith = 0; // Not bonded initially

        // Apply initial stats from config
        EvolutionConfig memory hatchlingConfig = evolutionStageConfigs[uint256(EvolutionStage.Hatchling)];
        newSentinel.strength = hatchlingConfig.strengthBonus;
        newSentinel.resilience = hatchlingConfig.resilienceBonus;
        newSentinel.nextEvolutionCost = hatchlingConfig.keCost;
        newSentinel.nextEvolutionCooldown = hatchlingConfig.cooldownDuration;
        newSentinel.decayThreshold = block.timestamp + hatchlingConfig.decayThresholdDuration;

        emit SentinelMinted(tokenId, _to, EvolutionStage.Hatchling, block.timestamp);
        return tokenId;
    }

    /**
     * @dev Internal function to handle Sentinel decay.
     *      Reduces stats or stage if neglected beyond decay threshold.
     * @param _tokenId The ID of the Sentinel to check.
     * @param _owner The owner of the Sentinel.
     */
    function _handleSentinelDecay(uint256 _tokenId, address _owner) internal {
        Sentinel storage sentinel = _sentinels[_tokenId];
        if (sentinel.id == 0) revert SentinelNotFound(_tokenId);

        if (block.timestamp >= sentinel.decayThreshold && sentinel.stage != EvolutionStage.Hatchling) {
            uint256 daysDecayed = (block.timestamp - sentinel.decayThreshold) / 1 days;
            if (daysDecayed > 0) {
                uint256 oldStrength = sentinel.strength;
                uint256 oldResilience = sentinel.resilience;

                uint256 strengthDecrease = (sentinel.strength * decayEffectMultiplier * daysDecayed) / 10000; // 10000 for percentage
                uint256 resilienceDecrease = (sentinel.resilience * decayEffectMultiplier * daysDecayed) / 10000;

                sentinel.strength = sentinel.strength > strengthDecrease ? sentinel.strength - strengthDecrease : 0;
                sentinel.resilience = sentinel.resilience > resilienceDecrease ? sentinel.resilience - resilienceDecrease : 0;

                // Optionally, revert stage if stats drop too low or after certain number of decay cycles
                // For simplicity, we just reduce stats here.
                // A more complex system might revert stage, but requires careful handling to avoid loops.

                sentinel.decayThreshold = block.timestamp + evolutionStageConfigs[uint256(sentinel.stage)].decayThresholdDuration; // Reset decay timer

                emit SentinelDecayed(_tokenId, sentinel.stage, sentinel.stage, strengthDecrease + resilienceDecrease);
            }
        }
    }


    /**
     * @dev Calculates the potential KE to siphon.
     * @param _siphonnerStrength The strength of the siphoning Sentinel.
     * @param _targetResilience The resilience of the target Sentinel.
     * @param _randomValue A random number from Chainlink VRF.
     * @param _targetKE The current KE of the target owner.
     * @return The amount of KE to siphon.
     */
    function _calculateSiphonAmount(uint256 _siphonnerStrength, uint256 _targetResilience, uint256 _randomValue, uint256 _targetKE)
        internal
        pure
        returns (uint256 siphonedAmount, bool success)
    {
        uint256 baseSuccessChance = 50; // 50% base chance
        uint224 strengthModifier = uint224(_siphonnerStrength / 10); // 10 strength points give 1% chance
        uint224 resilienceModifier = uint224(_targetResilience / 10); // 10 resilience points reduce 1% chance

        int256 netModifier = int256(strengthModifier) - int256(resilienceModifier);

        // Cap modifier effect
        if (netModifier > 40) netModifier = 40; // Max +40%
        if (netModifier < -40) netModifier = -40; // Min -40%

        uint256 finalSuccessChance = uint256(int256(baseSuccessChance) + netModifier);
        if (finalSuccessChance > 95) finalSuccessChance = 95; // Cap at 95%
        if (finalSuccessChance < 5) finalSuccessChance = 5; // Min at 5%

        uint256 randomPercentage = (_randomValue % 100) + 1; // 1 to 100

        if (randomPercentage <= finalSuccessChance) {
            // Siphon success! Siphon 5-15% of target's KE
            uint256 siphonedPercent = 5 + (_randomValue % 11); // Random between 5 and 15
            siphonedAmount = (_targetKE * siphonedPercent) / 100;
            success = true;
        } else {
            siphonedAmount = 0;
            success = false;
        }
    }

    /**
     * @dev Retrieves the list of currently approved collateral tokens.
     * @return An array of addresses for approved collateral tokens.
     */
    function getApprovedCollateralTokens() public view returns (address[] memory) {
        address[] memory tokens = new address[](1); // For simplicity, assume a single primary token or iterate a list
        // In a real scenario, you'd iterate through a dynamic list of approved tokens.
        // For this example, let's just return a mock token or assume only one is ever set.
        // If there are multiple, you need a different mapping structure to list them.
        // For demonstration, let's assume `approvedCollateralTokens` directly holds the addresses.
        // This would require a `LinkedList` or similar structure, which is complex for Solidity.
        // A common pattern is to have a `mapping(address => bool) public approvedCollateralTokens;`
        // and then manually keep a list for `getApprovedCollateralTokens`.
        // Let's just return the "dummy" initial one if it exists.
        tokens[0] = address(0x1); // Placeholder
        return tokens;
    }


    // --- I. Core Sentinel Management ---

    /**
     * @dev Mints a new Chrono Kinetic Sentinel NFT to the caller.
     *      Requires a small fee in native currency (e.g., ETH) as a initial KE contribution.
     */
    function mintSentinel() public payable {
        // A small fee could be required here, or it could be free initially.
        // For now, let's keep it simple and just mint.
        // If there's a minting fee, add `require(msg.value >= MINT_FEE, "Not enough ETH for minting");`

        _mintSentinelInternal(msg.sender);
    }

    /**
     * @dev Generates the dynamic metadata URI for a given Sentinel.
     *      The metadata changes based on the Sentinel's current state (stage, stats).
     * @param tokenId The ID of the Sentinel.
     * @return The base64 encoded JSON metadata URI.
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        if (!_exists(tokenId)) revert ERC721NonexistentToken(tokenId);

        Sentinel memory sentinel = _sentinels[tokenId];
        string memory stageName;
        if (sentinel.stage == EvolutionStage.Hatchling) stageName = "Hatchling";
        else if (sentinel.stage == EvolutionStage.Juvenile) stageName = "Juvenile";
        else if (sentinel.stage == EvolutionStage.Adult) stageName = "Adult";
        else if (sentinel.stage == EvolutionStage.Elder) stageName = "Elder";
        else if (sentinel.stage == EvolutionStage.Mythic) stageName = "Mythic";
        else if (sentinel.stage == EvolutionStage.Ascended) stageName = "Ascended";
        else stageName = "Unknown";

        string memory json = string(
            abi.encodePacked(
                '{"name": "Chrono Sentinel #', tokenId.toString(),
                '", "description": "An evolving Chrono Kinetic Sentinel.",',
                '"image": "', _baseTokenURI, tokenId.toString(), '.png', // Example image URL
                '", "attributes": [',
                '{"trait_type": "Stage", "value": "', stageName, '"},',
                '{"trait_type": "Strength", "value": ', sentinel.strength.toString(), '},',
                '{"trait_type": "Resilience", "value": ', sentinel.resilience.toString(), '},',
                '{"trait_type": "Birth Time", "value": ', sentinel.birthTime.toString(), '}',
                ']}'
            )
        );

        return string(abi.encodePacked("data:application/json;base64,", Base64.encode(bytes(json))));
    }

    /**
     * @dev Allows the owner to set the base URI for Sentinel images.
     * @param baseURI The new base URI.
     */
    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    /**
     * @dev Sets the configuration for a specific evolution stage.
     *      Only callable by the owner (or eventually, governance).
     * @param stage The evolution stage to configure.
     * @param keCost The Kinetic Energy cost to reach this stage.
     * @param cooldownDuration The cooldown period after evolving to this stage (in seconds).
     * @param decayThresholdDuration The duration after which decay can start for this stage (in seconds).
     * @param strengthBonus The strength bonus for this stage.
     * @param resilienceBonus The resilience bonus for this stage.
     */
    function setEvolutionStageConfig(
        EvolutionStage stage,
        uint256 keCost,
        uint256 cooldownDuration,
        uint256 decayThresholdDuration,
        uint256 strengthBonus,
        uint256 resilienceBonus
    ) public onlyOwner {
        evolutionStageConfigs[uint256(stage)] = EvolutionConfig({
            keCost: keCost,
            cooldownDuration: cooldownDuration,
            decayThresholdDuration: decayThresholdDuration,
            strengthBonus: strengthBonus,
            resilienceBonus: resilienceBonus
        });
        emit EvolutionConfigUpdated(uint256(stage), keCost, cooldownDuration, decayThresholdDuration);
    }


    // --- II. Kinetic Energy (KE) System ---

    /**
     * @dev Allows users to deposit approved ERC-20 collateral to generate Kinetic Energy.
     * @param tokenAddress The address of the ERC-20 token to deposit.
     * @param amount The amount of tokens to deposit.
     */
    function depositCollateralForKE(address tokenAddress, uint256 amount) public {
        if (!approvedCollateralTokens[tokenAddress]) revert CollateralTokenNotWhitelisted();
        if (amount == 0) revert NotEnoughCollateral(1, 0);

        _updateUserKineticEnergy(msg.sender); // Update KE before deposit

        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
        collateralStaked[msg.sender][tokenAddress] += amount;
        
        // Reset the last KE calculation time for precise new calculation from now
        _lastKECalculationTime[msg.sender] = block.timestamp;

        emit CollateralDeposited(msg.sender, tokenAddress, amount);
    }

    /**
     * @dev Allows users to withdraw their staked ERC-20 collateral.
     * @param tokenAddress The address of the ERC-20 token to withdraw.
     * @param amount The amount of tokens to withdraw.
     */
    function withdrawCollateral(address tokenAddress, uint256 amount) public {
        if (collateralStaked[msg.sender][tokenAddress] < amount) revert NotEnoughCollateral(amount, collateralStaked[msg.sender][tokenAddress]);
        if (amount == 0) revert NotEnoughCollateral(1, 0);

        _updateUserKineticEnergy(msg.sender); // Update KE before withdrawal

        collateralStaked[msg.sender][tokenAddress] -= amount;
        IERC20(tokenAddress).transfer(msg.sender, amount);

        // Reset the last KE calculation time for precise new calculation from now
        _lastKECalculationTime[msg.sender] = block.timestamp;

        emit CollateralWithdrawn(msg.sender, tokenAddress, amount);
    }

    /**
     * @dev Allows users to claim their accumulated Kinetic Energy.
     */
    function claimKineticEnergy() public {
        _updateUserKineticEnergy(msg.sender); // Ensure KE is up-to-date

        uint256 amount = userKineticEnergy[msg.sender];
        if (amount == 0) revert NotEnoughKineticEnergy(1, 0);

        userKineticEnergy[msg.sender] = 0; // Reset user's claimable KE

        emit KineticEnergyClaimed(msg.sender, amount);
    }

    /**
     * @dev Allows a Sentinel to attempt to "siphon" Kinetic Energy from another Sentinel's owner.
     *      Outcome is determined by a random number from Chainlink VRF and Sentinel stats.
     *      A small fee is collected and sent to the treasury on success.
     * @param siphonnerId The ID of the Sentinel initiating the siphon.
     * @param targetId The ID of the Sentinel being targeted.
     */
    function siphonKineticEnergy(uint256 siphonnerId, uint256 targetId) public {
        address siphonnerOwner = ownerOf(siphonnerId);
        address targetOwner = ownerOf(targetId);

        if (siphonnerOwner != msg.sender) revert NotOwnerOrApproved();
        if (siphonnerId == targetId) revert CannotSiphonSelf();
        if (_sentinels[siphonnerId].id == 0) revert SentinelNotFound(siphonnerId);
        if (_sentinels[targetId].id == 0) revert SentinelNotFound(targetId);

        // Update KE for both participants before siphoning
        _updateUserKineticEnergy(siphonnerOwner);
        _updateUserKineticEnergy(targetOwner);

        // Request randomness for the siphon attempt
        uint256 requestId = i_vrfCoordinator.requestRandomWords(
            i_keyHash,
            i_subscriptionId,
            REQUEST_CONFIRMATIONS,
            s_callbackGasLimit,
            NUM_WORDS
        );
        s_requestIdToTokenId[requestId] = siphonnerId; // Store siphonner ID for callback
        // You'd typically store targetId too, or retrieve it from siphonner's state if complex
        // For simplicity, we assume the outcome applies to the current state of Sentinels
        // and target's KE will be taken from 'userKineticEnergy[targetOwner]' when fulfilled.

        emit RandomnessRequested(requestId, siphonnerId);
    }

    /**
     * @dev Callback function for Chainlink VRF randomness. Handles the siphon outcome.
     * @param requestId The request ID for the random words.
     * @param randomWords The random words generated by Chainlink VRF.
     */
    function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        uint256 siphonnerId = s_requestIdToTokenId[requestId];
        if (siphonnerId == 0) revert RandomnessRequestFailed(requestId, s_callbackGasLimit); // Or some other error if request ID is unknown

        // Clean up mapping
        delete s_requestIdToTokenId[requestId];

        Sentinel storage siphonner = _sentinels[siphonnerId];
        // The target's ID needs to be stored or retrieved from the original `siphonKineticEnergy` call's context
        // For this example, let's assume the targetId was passed and stored in a mapping along with requestId
        // For simplicity, we'll retrieve it from another mapping `s_requestIdToTargetId[requestId]` which needs to be added.
        // Let's assume for now, this callback can access the target owner through a simpler lookup.
        // In a real scenario, you'd store the targetId in s_requestIdToTokenId and retrieve both.

        // Placeholder: let's re-fetch target using a simplified logic (not robust for concurrent siphons)
        // A robust system needs to store targetId with requestId.
        // For demonstration, let's assume targetId needs to be retrieved contextually or via another storage.
        // This is a simplification and would require re-design of `siphonKineticEnergy` to store target.

        // Since we can't reliably get targetId here without more complex storage, let's just make `siphonKineticEnergy`
        // target the *owner's* overall KE, not a specific Sentinel's owner. This simplifies things.
        // Reverting `siphonKineticEnergy` to: siphons from `targetOwner`'s *total KE balance*.
        // This removes the dependency on knowing specific target Sentinel ID in the callback.

        // This is where a more robust cross-function state passing or a dedicated `Request` struct would be needed.
        // Let's simplify: the random word determines the outcome. We then need to know *who* was the target.
        // For this example, this is a slight flaw. Let's assume a simplified target lookup (e.g., from `_lastSiphonTargetFor[siphonnerId]`)
        // To make it functional, `siphonKineticEnergy` must store the target ID.
        // Let's add: `mapping(uint256 => uint256) public s_requestIdToTargetId;`

        // Re-designing siphon storage:
        // struct SiphonRequest {
        //     uint256 siphonnerId;
        //     uint256 targetId;
        //     address siphonnerOwner;
        //     address targetOwner;
        //     uint256 targetKEAtRequest;
        // }
        // mapping(uint256 => SiphonRequest) public siphonRequests;
        // In siphonKineticEnergy, populate this struct and map requestId.
        // Then in rawFulfillRandomWords, retrieve this struct.
        // This is getting too complex for a single function example.

        // Let's assume `s_requestIdToTokenId` maps to the `siphonnerId`. The contract will manage the target KE.
        // For now, let's assume `siphonKineticEnergy` only needs the siphonner's ID for the callback logic.
        // This means the "target" of the siphon will be the *owner's* global KE, not tied to a specific target Sentinel.

        // For a functional example without too much complexity, let's simplify siphon:
        // It's a general KE gain attempt, not directly tied to another sentinel's KE pool.
        // This would mean `siphonKineticEnergy(uint256 siphonnerId)` without targetId.
        // Then it just gives random KE. This defeats "siphon" concept.

        // Okay, let's stick to the original "siphon from other Sentinel's owner" but use a simplified lookup.
        // This requires `s_requestIdToTargetId` to be populated in `siphonKineticEnergy`.
        // Let's add: `mapping(uint256 => uint256) public s_requestIdToTargetId;`
        uint256 targetId = s_requestIdToTargetId[requestId]; // Retrieve target ID
        delete s_requestIdToTargetId[requestId]; // Clear mapping

        address targetOwner = ownerOf(targetId);
        
        // Ensure KE is up-to-date for both
        _updateUserKineticEnergy(ownerOf(siphonnerId));
        _updateUserKineticEnergy(targetOwner);

        uint256 siphonedAmount;
        bool success;
        (siphonedAmount, success) = _calculateSiphonAmount(
            siphonner.strength,
            _sentinels[targetId].resilience,
            randomWords[0], // Use the first random word
            userKineticEnergy[targetOwner]
        );

        if (success) {
            uint256 fee = (siphonedAmount * siphonFeePercentage) / 10000;
            uint256 amountToSiphonner = siphonedAmount - fee;

            // Ensure target has enough KE
            if (userKineticEnergy[targetOwner] < siphonedAmount) {
                // Siphon failed due to insufficient KE from target
                emit KineticEnergySiphoned(siphonnerId, targetId, 0, false);
                return;
            }

            userKineticEnergy[targetOwner] -= siphonedAmount;
            userKineticEnergy[ownerOf(siphonnerId)] += amountToSiphonner;
            // Send fee to treasury
            payable(feeRecipient).transfer(fee);

            emit KineticEnergySiphoned(siphonnerId, targetId, amountToSiphonner, true);
        } else {
            emit KineticEnergySiphoned(siphonnerId, targetId, 0, false);
        }
    }

    /**
     * @dev Allows the owner to set the KE generation rate per second per unit of collateral.
     * @param newRate The new KE generation rate. e.g., 1e16 for 0.01 KE per sec per 1e18 collateral.
     */
    function updateKEGenerationRate(uint256 newRate) public onlyOwner {
        keGenerationRatePerSecondPerUnitCollateral = newRate;
        emit KEGenerationRateUpdated(newRate);
    }

    /**
     * @dev Whitelists or unwhitelists an ERC-20 token for use as collateral.
     * @param tokenAddress The address of the ERC-20 token.
     * @param status True to whitelist, false to unwhitelist.
     */
    function setApprovedCollateralToken(address tokenAddress, bool status) public onlyOwner {
        approvedCollateralTokens[tokenAddress] = status;
        emit CollateralTokenWhitelisted(tokenAddress, status);
    }


    // --- III. Sentinel Evolution & Interaction ---

    /**
     * @dev Evolves a Sentinel to its next stage if requirements are met (KE, cooldown).
     * @param tokenId The ID of the Sentinel to evolve.
     */
    function evolveSentinel(uint256 tokenId) public {
        address sentinelOwner = ownerOf(tokenId);
        if (sentinelOwner != msg.sender) revert NotOwnerOrApproved();
        
        Sentinel storage sentinel = _sentinels[tokenId];
        if (sentinel.id == 0) revert SentinelNotFound(tokenId);

        if (sentinel.stage == EvolutionStage.Ascended) revert AlreadyAtMaxStage();

        EvolutionStage nextStage = EvolutionStage(uint256(sentinel.stage) + 1);
        EvolutionConfig memory nextConfig = evolutionStageConfigs[uint256(nextStage)];

        if (nextConfig.keCost == 0 && uint256(nextStage) != 0) revert InvalidEvolutionStage(); // Stage not configured

        if (block.timestamp < sentinel.lastKEConsumptionTime + sentinel.nextEvolutionCooldown) {
            revert CannotEvolveYet(sentinel.lastKEConsumptionTime + sentinel.nextEvolutionCooldown);
        }

        _updateUserKineticEnergy(msg.sender); // Update user's KE before checking balance
        if (userKineticEnergy[msg.sender] < nextConfig.keCost) {
            revert NotEnoughKineticEnergy(nextConfig.keCost, userKineticEnergy[msg.sender]);
        }

        userKineticEnergy[msg.sender] -= nextConfig.keCost;
        
        // Collect evolution fee
        uint256 fee = (nextConfig.keCost * evolutionFeePercentage) / 10000;
        if (fee > 0) {
            // In a real scenario, fees could be accumulated on contract balance and withdrawn by owner.
            // For simplicity here, we assume KE is convertible to native currency or a governance token.
            // A direct transfer of KE here is symbolic.
            // For actual ETH/ERC20, this part needs separate handling with a treasury.
            // For now, let's just "burn" the fee from circulation or track it for future use.
            // Or better, assume `userKineticEnergy` is transferable and send to feeRecipient.
            // Since KE isn't a separate ERC20, the fees represent burned KE.
            // Or, the `feeRecipient` gets this portion as ETH from a wrapper.
            // Let's assume `feeRecipient` gets an equivalent value if this were a wrapped token.
            // For now, the KE cost is simply reduced from user, and `fee` is "removed" from circulation.
            // If feeRecipient should get something, it needs to be ETH that was sent to the contract, or an ERC20.
            // For now, we simulate burning the fee from the total KE.
        }

        EvolutionStage oldStage = sentinel.stage;
        sentinel.stage = nextStage;
        sentinel.lastKEConsumptionTime = block.timestamp; // Reset cooldown
        sentinel.nextEvolutionCost = evolutionStageConfigs[uint256(nextStage)].keCost; // Update next cost
        sentinel.nextEvolutionCooldown = evolutionStageConfigs[uint256(nextStage)].cooldownDuration;
        sentinel.decayThreshold = block.timestamp + evolutionStageConfigs[uint256(nextStage)].decayThresholdDuration; // Reset decay timer
        sentinel.strength += nextConfig.strengthBonus;
        sentinel.resilience += nextConfig.resilienceBonus;

        emit SentinelEvolved(tokenId, oldStage, nextStage, nextConfig.keCost);
    }

    /**
     * @dev Initiates decay for a neglected Sentinel, reducing its stats.
     *      Can be triggered by anyone, but affects the Sentinel's owner.
     * @param tokenId The ID of the Sentinel to check for decay.
     */
    function decaySentinel(uint256 tokenId) public {
        Sentinel storage sentinel = _sentinels[tokenId];
        if (sentinel.id == 0) revert SentinelNotFound(tokenId);

        if (block.timestamp < sentinel.decayThreshold || sentinel.stage == EvolutionStage.Hatchling) {
            revert NotEligibleForDecay();
        }

        _handleSentinelDecay(tokenId, ownerOf(tokenId)); // Apply decay effects
    }

    /**
     * @dev Allows burning multiple Sentinels owned by the caller to ascend to a new, rarer Sentinel.
     *      The new Sentinel will be minted at a higher stage or with unique properties.
     * @param tokenIdsToBurn An array of Sentinel IDs to burn.
     */
    function ascendSentinels(uint256[] memory tokenIdsToBurn) public {
        if (tokenIdsToBurn.length < sentinelsRequiredForAscension) {
            revert NotEnoughSentinelsForAscension(sentinelsRequiredForAscension, tokenIdsToBurn.length);
        }

        for (uint256 i = 0; i < tokenIdsToBurn.length; i++) {
            uint256 tokenId = tokenIdsToBurn[i];
            if (ownerOf(tokenId) != msg.sender) revert NotOwnerOrApproved();
            _burn(tokenId); // Burn the Sentinel NFT
            delete _sentinels[tokenId]; // Remove from our storage
        }

        uint256 newSentinelId = _mintSentinelInternal(msg.sender); // Mint new one
        Sentinel storage newSentinel = _sentinels[newSentinelId];

        // Set the new Sentinel to Ascended stage (or a specific rare stage)
        newSentinel.stage = EvolutionStage.Ascended; // Assuming this is the highest tier
        EvolutionConfig memory ascendedConfig = evolutionStageConfigs[uint256(EvolutionStage.Ascended)];
        
        newSentinel.strength += ascendedConfig.strengthBonus + ascensionKEModifier; // Add bonus from ascension
        newSentinel.resilience += ascendedConfig.resilienceBonus + ascensionKEModifier;
        newSentinel.nextEvolutionCost = ascendedConfig.keCost; // Should be 0 as it's max
        newSentinel.nextEvolutionCooldown = ascendedConfig.cooldownDuration;
        newSentinel.decayThreshold = block.timestamp + ascendedConfig.decayThresholdDuration;


        emit SentinelsAscended(msg.sender, tokenIdsToBurn, newSentinelId);
    }

    /**
     * @dev Establishes a symbiotic bond between two Sentinels.
     *      Both Sentinels must be owned by the caller.
     * @param tokenId1 The ID of the first Sentinel.
     * @param tokenId2 The ID of the second Sentinel.
     */
    function bondSentinels(uint256 tokenId1, uint256 tokenId2) public {
        if (ownerOf(tokenId1) != msg.sender || ownerOf(tokenId2) != msg.sender) revert NotOwnerOrApproved();
        if (_sentinels[tokenId1].id == 0 || _sentinels[tokenId2].id == 0) revert SentinelNotFound(tokenId1);
        if (tokenId1 == tokenId2) revert InvalidEvolutionStage(); // Cannot bond with self

        if (_sentinels[tokenId1].bondedWith != 0 || _sentinels[tokenId2].bondedWith != 0) {
            revert SentinelAlreadyBonded();
        }

        _sentinels[tokenId1].bondedWith = tokenId2;
        _sentinels[tokenId2].bondedWith = tokenId1;

        // Implement bond effects here, e.g., KE generation boost, stat boost
        // For simplicity, this is just a state change. Effects would be in `_calculateGeneratedKE` etc.

        emit SentinelsBonded(tokenId1, tokenId2);
    }

    /**
     * @dev Breaks a symbiotic bond between two Sentinels.
     * @param tokenId1 The ID of the first Sentinel in the bond.
     */
    function unbondSentinels(uint256 tokenId1) public {
        if (ownerOf(tokenId1) != msg.sender) revert NotOwnerOrApproved();
        Sentinel storage sentinel1 = _sentinels[tokenId1];
        if (sentinel1.id == 0) revert SentinelNotFound(tokenId1);

        uint256 tokenId2 = sentinel1.bondedWith;
        if (tokenId2 == 0) revert SentinelsNotBonded();

        Sentinel storage sentinel2 = _sentinels[tokenId2];
        if (sentinel2.id == 0 || sentinel2.bondedWith != tokenId1) revert SentinelsNotBonded(); // Consistency check

        sentinel1.bondedWith = 0;
        sentinel2.bondedWith = 0;

        // Remove bond effects here if any were applied

        emit SentinelsUnbonded(tokenId1, tokenId2);
    }

    /**
     * @dev Sets the decay configuration parameters.
     * @param newDecayRatePerDay New KE deduction rate per day for decayed Sentinels.
     * @param newDecayEffectMultiplier New multiplier for stat reduction.
     */
    function setDecayConfiguration(uint256 newDecayRatePerDay, uint256 newDecayEffectMultiplier) public onlyOwner {
        decayRatePerDay = newDecayRatePerDay;
        decayEffectMultiplier = newDecayEffectMultiplier;
        emit DecayConfigUpdated(newDecayRatePerDay, newDecayEffectMultiplier);
    }

    /**
     * @dev Sets the requirements for Sentinel ascension.
     * @param newRequired The number of Sentinels to burn for ascension.
     * @param newKEModifier The KE bonus/penalty during ascension.
     */
    function setAscensionRequirements(uint256 newRequired, uint256 newKEModifier) public onlyOwner {
        sentinelsRequiredForAscension = newRequired;
        ascensionKEModifier = newKEModifier;
        emit AscensionRequirementsUpdated(newRequired, newKEModifier);
    }


    // --- IV. Environmental Factors & Oracles (Chainlink Integration) ---

    /**
     * @dev Requests an update for the environmental factor from the Chainlink price feed.
     *      Can be called by anyone (with gas cost), but usually triggered by a keeper or trusted entity.
     */
    function requestEnvironmentalFactorUpdate() public {
        (, int256 answer, , ,) = priceFeedOracle.latestRoundData();
        currentEnvironmentalFactor = answer; // Direct update for simplicity, could be more complex derived value
        emit EnvironmentalFactorUpdated(currentEnvironmentalFactor, block.timestamp);
    }

    /**
     * @dev Callback for Chainlink price feed (AggregatorV3Interface).
     *      Note: AggregatorV3Interface does not have a direct `fulfill` callback like VRF.
     *      You typically query `latestRoundData()` directly. This function is a placeholder
     *      if a more complex request/fulfill pattern were implemented for general oracles.
     *      For AggregatorV3, `requestEnvironmentalFactorUpdate` directly gets the data.
     */
    function fulfillEnvironmentalFactorUpdate() internal {
        // This function would be implemented if using Chainlink Any API or other types of oracles
        // that require a callback after an asynchronous request.
        // For AggregatorV3Interface, data is available synchronously via `latestRoundData()`.
        revert InvalidOracleResponse(); // Not implemented for this oracle type
    }

    /**
     * @dev Sets the address of the Chainlink AggregatorV3 price feed oracle.
     * @param newOracleAddress The address of the new price feed oracle.
     */
    function setOracleAddress(address newOracleAddress) public onlyOwner {
        priceFeedOracle = AggregatorV3Interface(newOracleAddress);
    }

    /**
     * @dev Sets the multiplier for how environmental factors impact KE generation/evolution.
     *      e.g., if factor is 100, multiplier 1000 means 10% impact.
     * @param newMultiplier The new environmental impact multiplier.
     */
    function setEnvironmentalImpactMultiplier(uint256 newMultiplier) public onlyOwner {
        environmentalImpactMultiplier = newMultiplier;
        emit EnvironmentalImpactMultiplierUpdated(newMultiplier);
    }

    /**
     * @dev Allows the owner to set the callback gas limit for Chainlink VRF requests.
     * @param newLimit The new callback gas limit.
     */
    function setCallbackGasLimit(uint32 newLimit) public onlyOwner {
        s_callbackGasLimit = newLimit;
        emit CallbackGasLimitUpdated(newLimit);
    }


    // --- V. Treasury & Governance (Simplified) ---

    /**
     * @dev Allows the owner to withdraw funds accumulated in the contract's treasury.
     *      (e.g., native currency fees from future integrations, or if KE conversion is enabled).
     */
    function withdrawTreasuryFunds() public onlyOwner {
        uint256 balance = address(this).balance;
        if (balance == 0) revert NoFundsToWithdraw();
        payable(feeRecipient).transfer(balance);
        emit TreasuryFundsWithdrawn(feeRecipient, balance);
    }

    /**
     * @dev Placeholder function for a governance proposal system.
     *      In a full system, this would log a proposal that can be voted on.
     * @param description A brief description of the proposed rule change.
     */
    function proposeEvolutionRuleChange(string memory description) public {
        // This would be a more complex function interacting with a governance module
        // For example, using Compound's Governor Bravo pattern.
        // emit ProposalCreated(msg.sender, description);
        // require(false, "Governance system not fully implemented. This is a placeholder.");
    }

    /**
     * @dev Placeholder function for voting on a governance proposal.
     * @param proposalId The ID of the proposal to vote on.
     * @param support True for 'for', false for 'against'.
     */
    function voteOnProposal(uint256 proposalId, bool support) public {
        // require(false, "Governance system not fully implemented. This is a placeholder.");
    }

    /**
     * @dev Placeholder function for executing an approved governance proposal.
     * @param proposalId The ID of the proposal to execute.
     */
    function executeProposal(uint256 proposalId) public {
        // require(false, "Governance system not fully implemented. This is a placeholder.");
    }

    /**
     * @dev Sets the address designated to receive operational fees.
     * @param newRecipient The new address for fee collection.
     */
    function setFeeRecipient(address newRecipient) public onlyOwner {
        feeRecipient = newRecipient;
        emit FeeRecipientUpdated(newRecipient);
    }

    /**
     * @dev Sets the percentage of KE cost for evolution and siphoned KE that goes to the treasury.
     * @param newEvolutionFee The new evolution fee percentage (e.g., 500 for 5%).
     * @param newSiphonFee The new siphon fee percentage (e.g., 1000 for 10%).
     */
    function setFeePercentages(uint256 newEvolutionFee, uint256 newSiphonFee) public onlyOwner {
        evolutionFeePercentage = newEvolutionFee;
        siphonFeePercentage = newSiphonFee;
        emit FeePercentagesUpdated(newEvolutionFee, newSiphonFee);
    }


    // --- VI. View Functions ---

    /**
     * @dev Retrieves all detailed information about a specific Sentinel.
     * @param tokenId The ID of the Sentinel.
     * @return A tuple containing all Sentinel properties.
     */
    function getSentinelDetails(uint256 tokenId)
        public
        view
        returns (
            uint256 id,
            EvolutionStage stage,
            uint256 birthTime,
            uint256 lastKEConsumptionTime,
            uint256 lastKECalculationTime,
            uint256 bondedWith,
            uint256 nextEvolutionCost,
            uint256 nextEvolutionCooldown,
            uint256 decayThreshold,
            uint256 strength,
            uint256 resilience
        )
    {
        Sentinel memory sentinel = _sentinels[tokenId];
        if (sentinel.id == 0) revert SentinelNotFound(tokenId);

        return (
            sentinel.id,
            sentinel.stage,
            sentinel.birthTime,
            sentinel.lastKEConsumptionTime,
            sentinel.lastKECalculationTime,
            sentinel.bondedWith,
            sentinel.nextEvolutionCost,
            sentinel.nextEvolutionCooldown,
            sentinel.decayThreshold,
            sentinel.strength,
            sentinel.resilience
        );
    }

    /**
     * @dev Gets a user's current Kinetic Energy balance (including generated un-claimed KE).
     * @param user The address of the user.
     * @return The total Kinetic Energy balance for the user.
     */
    function getKineticEnergyBalance(address user) public view returns (uint256) {
        // This function should ideally update KE before returning, but view functions are read-only.
        // Callers should call `claimKineticEnergy` first if they need to be sure.
        // For a true real-time view, we'd replicate `_updateUserKineticEnergy` logic here.
        // For simplicity, we return the stored balance.
        return userKineticEnergy[user];
    }

    /**
     * @dev Gets the amount of a specific collateral token staked by a user.
     * @param user The address of the user.
     * @param tokenAddress The address of the collateral token.
     * @return The amount of collateral staked.
     */
    function getCollateralStaked(address user, address tokenAddress) public view returns (uint256) {
        return collateralStaked[user][tokenAddress];
    }

    /**
     * @dev Retrieves the current environmental factor as determined by the oracle.
     * @return The current environmental factor.
     */
    function getEnvironmentalFactor() public view returns (int256) {
        return currentEnvironmentalFactor;
    }

    /**
     * @dev Retrieves the current KE generation rate.
     * @return The current KE generation rate.
     */
    function getKEGenerationRate() public view returns (uint256) {
        return keGenerationRatePerSecondPerUnitCollateral;
    }

    /**
     * @dev Returns the total number of Sentinels minted so far.
     * @return The total count of minted Sentinels.
     */
    function getTotalSentinelsMinted() public view returns (uint256) {
        return _nextTokenId;
    }

    /**
     * @dev Returns the owner's last KE calculation time.
     * @param user The address of the user.
     * @return The timestamp of the last KE calculation.
     */
    function getLastKECalculationTime(address user) public view returns (uint256) {
        return _lastKECalculationTime[user];
    }
}

// Minimal Base64 Library for on-chain metadata
library Base64 {
    string internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    function encode(bytes memory data) internal pure returns (string memory) {
        if (data.length == 0) return "";

        // load all chars from the table into memory to reduce stack tampering
        // or heap manipulation
        string memory table = TABLE;

        uint256 encodedLen = 4 * ((data.length + 2) / 3);
        string memory result = new string(encodedLen);
        assembly {
            let tablePtr := add(table, 32)
            let resultPtr := add(result, 32)
            let dataPtr := add(data, 32)

            for {
                let i := 0
            } lt(i, mload(data)) {

            } {
                i := add(i, 3)
                let byte1 := byte(0, mload(dataPtr))
                let byte2 := byte(0, mload(add(dataPtr, 1)))
                let byte3 := byte(0, mload(add(dataPtr, 2)))
                dataPtr := add(dataPtr, 3)

                let char1 := shr(2, byte1)
                let char2 := and(shl(4, byte1), 0x3F)
                let char3 := shr(2, byte2)
                let char4 := and(shl(4, byte2), 0x3F)
                let char5 := shr(2, byte3)
                let char6 := and(shl(4, byte3), 0x3F)

                if lt(i, mload(data)) {
                    mstore(resultPtr, byte(0, mload(add(tablePtr, char1))))
                    mstore(add(resultPtr, 1), byte(0, mload(add(tablePtr, char2))))
                    mstore(add(resultPtr, 2), byte(0, mload(add(tablePtr, char3))))
                    mstore(add(resultPtr, 3), byte(0, mload(add(tablePtr, char4))))
                    resultPtr := add(resultPtr, 4)
                }
            }
        }
        
        switch (data.length % 3) {
            case 1:
                result = string(abi.encodePacked(result, "=", "="));
                break;
            case 2:
                result = string(abi.encodePacked(result, "="));
                break;
        }
        return result;
    }
}

// Chainlink Interfaces (simplified/mock for example if not using direct import)
// In a real scenario, you'd import these from @chainlink/contracts/src/v0.8/interfaces
interface IRandomWordsConsumer {
    function rawFulfillRandomWords(
        uint256 requestId,
        uint256[] calldata randomWords
    ) external;
}

interface IAggregatorV3 {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}
```